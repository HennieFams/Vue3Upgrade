/*!
*  filename: ej.diagram.js
*  version : 18.1.0.42
*  Copyright Syncfusion Inc. 2001 - 2020. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
*/
(function (fn) {
    typeof define === 'function' && define.amd ? define(["./../common/ej.core","jsrender","./../common/ej.data","./../common/ej.touch","./../common/ej.draggable","./../common/ej.scroller","./../web/ej.menu"], fn) : fn();
})
(function () {
	
/**
* @fileOverview Plugin to style the Html Diagram elements
* @copyright Copyright Syncfusion Inc. 2001 - 2020. All rights reserved.
* Use of this code is subject to the terms of our license.
* A copy of the current license can be obtained at any time by e-mailing
* licensing@syncfusion.com. Any infringement will be prosecuted under
* applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej, undefined) {
    "use strict";
    //#region ej.Diagram widget
    ej.widget("ejDiagram", "ej.datavisualization.Diagram", {
        element: null,
        model: null,
        _requiresID: true,
        validTags: ["div"],
        //#region defaults
        defaults: {
            width: "",
            height: "",
            nodes: [],
            connectors: [],
            labelRenderingMode: "html",
            defaultSettings: {
                connector: null,
                node: null,
                group: null
            },
            nodeTemplate: null,
            connectorTemplate: null,
            dataSourceSettings: {
                dataSource: null,
                query: null,
                tableName: null,
                id: "",
                parent: "",
                nodes: null,
                connectors: null,
                root: "",
                crudAction: {
                    create: "",
                    update: "",
                    destroy: "",
                    read: ""
                },
                customFields: [],
                connectionDataSource: {
                    dataSource: null,
                    id: "",
                    sourceNode: "",
                    targetNode: "",
                    sourcePointX: "",
                    sourcePointY: "",
                    targetPointX: "",
                    targetPointY: "",
                    crudAction: {
                        create: "",
                        update: "",
                        destroy: "",
                        read: ""
                    },
                    customFields: []
                }
            },
            serializationSettings: {
                preventDefaultValues: false
            },
            rulerSettings: {
                showRulers: false,
                horizontalRuler: {
                    interval: 5,
                    segmentWidth: 100,
                    arrangeTick: null,
                    tickAlignment: "rightorbottom",
                    markerColor: "red",
                    length: null,
                    thickness: 25
                },
                verticalRuler: {
                    interval: 5,
                    segmentWidth: 100,
                    arrangeTick: null,
                    tickAlignment: "rightorbottom",
                    markerColor: "red",
                    length: null,
                    thickness: 25
                }
            },
            snapSettings: {
                horizontalGridLines: {
                    linesInterval: null,
                    snapInterval: [20],
                    lineDashArray: "",
                    lineColor: "lightgray"
                },
                verticalGridLines: {
                    linesInterval: null,
                    snapInterval: [20],
                    lineDashArray: "",
                    lineColor: "lightgray"
                },
                snapConstraints: 1 | 2 | 4 | 8,
                enableSnapToObject: true,
                snapAngle: 5,
                snapObjectDistance: 5
            },
            scrollSettings: {
                horizontalOffset: 0,
                verticalOffset: 0,
                currentZoom: 1,
                viewPortHeight: 0,
                viewPortWidth: 0,
                minZoom: 0.25,
                maxZoom: 30,
                zoomFactor: 0.2,
                padding: {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }
            },
            pageSettings: {
                pageWidth: null,
                pageHeight: null,
                multiplePage: false,
                pageBorderWidth: 0,
                pageBackgroundColor: "#ffffff",
                pageBorderColor: "#565656",
                pageMargin: 24,
                showPageBreak: false,
                pageOrientation: "portrait",
                scrollLimit: "diagram",
                scrollableArea: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY, width: Number.POSITIVE_INFINITY, height: Number.POSITIVE_INFINITY },
                autoScrollBorder: { left: 15, top: 15, right: 15, bottom: 15 },
                boundaryConstraints: "infinity"
            },
            locale: "en-US",
            contextMenu: {
                items: [],
                showCustomMenuItemsOnly: false
            },
            enableContextMenu: true,
            enableAutoScroll: true,
            tooltip: {
                templateId: "",
                relativeMode: "object",
                alignment: {
                    horizontal: "center",
                    vertical: "bottom",
                },
                margin: { left: 5, right: 5, top: 5, bottom: 5 }
            },
            showTooltip: true,
            layout: {
                avoidSegmentOverlapping: false,
                bounds: null,
                type: "none",
                horizontalAlignment: "center",
                verticalAlignment: "top",
                orientation: "toptobottom",
                horizontalSpacing: 30,
                verticalSpacing: 30,
                margin: { left: 0, right: 0, top: 0, bottom: 0 },
                marginX: 0,
                marginY: 0,
                fixedNode: "",
                getLayoutInfo: null,
                getConnectorSegments: null,
                root: "",
                springLength: 100,
                springFactor: 0.442,
                maxIteration: 1000
            },
            drawingTools: {},
            backgroundImage: {
                source: "",
                scale: "meet",
                alignment: "xmidymid"
            },
            backgroundColor: "transparent",
            bridgeDirection: "top",
            version: "13.1",
            constraints: 1 << 1 | 1 << 2 | 1 << 4 | 1 << 5 | 1 << 6 | 1 << 7 | 1 << 8,
            tool: null,
            drawType: {},
            selectedItems: {
                offsetX: 0,
                offsetY: 0,
                width: 0,
                height: 0,
                rotateAngle: 0,
                children: [],
                constraints: 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4,
                userHandles: [],
                tooltip: {
                    templateId: "",
                    alignment: { horizontal: "center", vertical: "bottom" },
                    margin: { top: 10 }
                },
                getConstraints: null
            },
            commandManager: {
                commands: {}
            },
            historyManager: {
                push: null,
                pop: null,
                canPop: null,
                canLog: null,
                undo: null,
                redo: null,
                startGroupAction: null,
                closeGroupAction: null,
                stackLimit: null,
                undoStack: [],
                redoStack: []
            },
            layers: [],
            connectorType: "straightLine",
            editorFocusChange: null,
            nodeCollectionChange: null,
            templateNodeRendering: null,
            historyChange: null,
            autoScrollChange: null,
            itemClick: null,
            connectorCollectionChange: null,
            selectionChange: null,
            mouseLeave: null,
            mouseEnter: null,
            mouseOver: null,
            click: null,
            doubleClick: null,
            dragEnter: null,
            dragOver: null,
            dragLeave: null,
            drop: null,
            drag: null,
            textChange: null,
            sizeChange: null,
            connectionChange: null,
            rotationChange: null,
            contextMenuClick: null,
            contextMenuBeforeOpen: null,
            contextMenuClose: null,
            connectorSourceChange: null,
            connectorTargetChange: null,
            scrollChange: null,
            segmentChange: null,
            propertyChange: null,
            groupChange: null,
            create: null,
            destroy: null
        },
        observables: [
            "nodes",
            "connectors",
            "locale",
            "enableContextMenu",
            "backgroundColor",
            "backgroundImage",
            "enableAutoScroll",
            "showTooltip",
            "bridgeDirection",
            "tool",
            "pageSettings.pageHeight",
            "pageSettings.pageWidth",
            "pageSettings.multiplePage",
            "pageSettings.pageBorderWidth",
            "pageSettings.pageBackgroundColor",
            "pageSettings.pageBorderColor",
            "pageSettings.pageMargin",
            "pageSettings.showPageBreak",
            "pageSettings.pageOrientation",
            "pageSettings.scrollLimit",
            "snapSettings.enableSnapToObject",
            "snapSettings.snapAngle",
            "snapSettings.snapObjectDistance",
            "snapSettings.snapConstraints",
            "dataSourceSettings.id",
            "dataSourceSettings.parent",
            "dataSourceSettings.root",
            "dataSourceSettings.dataSource",
            "dataSourceSettings.tableName",
            "dataSourceSettings.query",
            "layout.type",
            "layout.orientation",
            "layout.horizontalSpacing",
            "layout.avoidSegmentOverlapping ",
            "layout.verticalSpacing",
            "layout.marginX",
            "layout.marginY",
            "layout.fixedNode",
            "selectedItems.offsetX",
            "selectedItems.offsetY",
            "selectedItems.width",
            "selectedItems.height",
            "selectedItems.rotateAngle",
            "scrollSettings.horizontalOffset",
            "scrollSettings.verticalOffset",
            "scrollSettings.zoomFactor",
            "tooltip.templateId",
            "tooltip.relativeMode",
            "tooltip.alignment.horizontal",
            "tooltip.alignment.vertical",
            "contextMenu.items",
            "contextMenu.showCustomMenuItemsOnly"
        ],
        nodes: ej.util.valueFunction("nodes"),
        connectors: ej.util.valueFunction("connectors"),
        locale: ej.util.valueFunction("locale"),
        enableContextMenu: ej.util.valueFunction("enableContextMenu"),
        enableAutoScroll: ej.util.valueFunction("enableAutoScroll"),
        showTooltip: ej.util.valueFunction("showTooltip"),
        bridgeDirection: ej.util.valueFunction("bridgeDirection"),
        tool: ej.util.valueFunction("tool"),
        _backgroundColor: ej.util.valueFunction("backgroundColor"),
        _backgroundImage: ej.util.valueFunction("backgroundImage"),
        _pageHeight: ej.util.valueFunction("pageSettings.pageHeight"),
        _pageWidth: ej.util.valueFunction("pageSettings.pageWidth"),
        _multiplePage: ej.util.valueFunction("pageSettings.multiplePage"),
        _pageBorderWidth: ej.util.valueFunction("pageSettings.pageBorderWidth"),
        _pageBackgroundColor: ej.util.valueFunction("pageSettings.pageBackgroundColor"),
        _pageBorderColor: ej.util.valueFunction("pageSettings.pageBorderColor"),
        _pageMargin: ej.util.valueFunction("pageSettings.pageMargin"),
        _showPageBreak: ej.util.valueFunction("pageSettings.showPageBreak"),
        _pageOrientation: ej.util.valueFunction("pageSettings.pageOrientation"),
        _scrollLimit: ej.util.valueFunction("pageSettings.scrollLimit"),
        _enableSnapToObject: ej.util.valueFunction("snapSettings.enableSnapToObject"),
        _snapConstraints: ej.util.valueFunction("snapSettings.snapConstraints"),
        _snapAngle: ej.util.valueFunction("snapSettings.snapAngle"),
        _snapObjectDistance: ej.util.valueFunction("snapSettings.snapObjectDistance"),
        _selectorOffsetX: ej.util.valueFunction("selectedItems.offsetX"),
        _selectorOffsetY: ej.util.valueFunction("selectedItems.offsetY"),
        _selectorWidth: ej.util.valueFunction("selectedItems.width"),
        _selectorHeight: ej.util.valueFunction("selectedItems.height"),
        _selectorRotateAngle: ej.util.valueFunction("selectedItems.rotateAngle"),
        _horizontalOffset: ej.util.valueFunction("scrollSettings.horizontalOffset"),
        _verticalOffset: ej.util.valueFunction("scrollSettings.verticalOffset"),
        zoomFactor: ej.util.valueFunction("scrollSettings.zoomFactor"),
        _layoutType: ej.util.valueFunction("layout.type"),
        _layoutOrientation: ej.util.valueFunction("layout.orientation"),
        _horizontalSpacing: ej.util.valueFunction("layout.horizontalSpacing"),
        _avoidSegmentOverlapping: ej.util.valueFunction("layout.avoidSegmentOverlapping "),
        _verticalSpacing: ej.util.valueFunction("layout.verticalSpacing"),
        _layoutMarginX: ej.util.valueFunction("layout.marginX"),
        _layoutMarginY: ej.util.valueFunction("layout.marginY"),
        _fixedNode: ej.util.valueFunction("layout.fixedNode"),
        _dataSourceUniqueId: ej.util.valueFunction("dataSourceSettings.id"),
        _dataSourceParentId: ej.util.valueFunction("dataSourceSettings.parent"),
        _dataSource: ej.util.valueFunction("dataSourceSettings.dataSource"),
        _dataSourceTableName: ej.util.valueFunction("dataSourceSettings.tableName"),
        _dataSourceQueryString: ej.util.valueFunction("dataSourceSettings.query"),
        _dataSourceRoot: ej.util.valueFunction("dataSourceSettings.root"),
        _tooltipTemplateId: ej.util.valueFunction("tooltip.templateId"),
        _horizontalTooltipAlignment: ej.util.valueFunction("tooltip.alignment.horizontal"),
        _verticalTooltipAlignment: ej.util.valueFunction("tooltip.alignment.vertical"),
        _tooltipMode: ej.util.valueFunction("tooltip.relativeMode"),
        _showCustomContextMenuItems: ej.util.valueFunction("contextMenu.showCustomMenuItemsOnly"),
        _contextMenuItems: ej.util.valueFunction("contextMenu.items"),
        dataTypes: {
            nodes: "data",
            connectors: "data",
            contextMenu: {
                items: "array"
            },
            dataSourceSettings: {
                dataSource: "data"
            },
            defaultSettings: {
                connector: {
                    segments: "data",
                    labels: "data"
                },
                node: {
                    children: "data",
                    gradient: {
                        stops: "data"
                    },
                    labels: "data",
                    lanes: "data",
                    phases: "data",
                    points: "data",
                    ports: "data",
                },
                group: {
                    children: "data",
                    gradient: {
                        stops: "data"
                    },
                    labels: "data",
                    lanes: "data",
                    phases: "data",
                    points: "data",
                    ports: "data",
                }
            },
            snapSettings: {
                horizontalGridLines: {
                    linesInterval: "data",
                    snapInterval: "data",
                },
                verticalGridLines: {
                    linesInterval: "data",
                    snapInterval: "data",
                }
            },
            selectedItems: {
                children: "data",
                userHandles: "data"
            }
        },
        //#endregion
        //#region Local members
        _doubleClickEvent: false,
        _nodes: [],
        _connectors: [],
        _canvas: null,
        _svg: null,
        _toolToActivate: null,
        _inAction: false,
        _isPinching: false,
        _isEditing: false,
        _nodeToHit: null,
        _enableAPIMethods: true,
        _currentCursor: null,
        _pasteIndex: null,
        _page: null,
        _view: null,
        _currentLabel: null,
        _zOrder: 0,
        _clipboardData: null,
        _currZoom: 1,
        _UndoRedo: false,
        _mouseEventTriggered: false,
        _selectedItem: "",
        _historyList: {
            currentEntry: {
                next: null,
                previous: null
            },
            canUndo: false,
            canRedo: false
        },
        _historyCount: 0,
        _lastbefore: null,
        _defaultContextMenuItems: [
            { name: "cut", text: "Cut" },
            { name: "copy", text: "Copy" },
            { name: "paste", text: "Paste" },
            { name: "undo", text: "Undo" },
            { name: "redo", text: "Redo" },
            { name: "selectAll", text: "Select All" },
            {
                name: "grouping",
                text: "Grouping",
                subItems: [
                    { name: "group", text: "Group" },
                    { name: "ungroup", text: "Ungroup" }
                ]
            },
            {
                name: "order",
                text: "Order",
                subItems: [
                    { name: "bringToFront", text: "Bring To Front" },
                    { name: "moveForward", text: "Move Forward" },
                    { name: "sendToBack", text: "Send To Back" },
                    { name: "sendBackward", text: "Send Backward" }
                ]
            }
        ],
        _hScrollOffset: 0,
        _vScrollOffset: 0,
        _hScrollbar: null,
        _vScrollbar: null,
        _scrollPixel: 30,
        _previousSelectedItems: [],
        _eventCause: {},
        _crudDeleteNodes: [],
        _isMobile: false,
        _labelHashTable: {},
        //#endregion
        //#region public members
        activeTool: null,
        selectionList: [],
        tools: null,
        nameTable: {},
        boundaryTable: {},
        //#endregion
        //#region Initialization
        _init: function () {
            this.boundaryTable = {};
            this.nameTable = {};
            this.selectionList = [];
            this._isInit = true;
            this.nameTable = {};
            this.boundaryTable = {};
            var svgSupport = (window.SVGSVGElement) ? true : false;
            if (svgSupport) {
                if (this.model.version === "NewVersion") {
                    this.model.version = ej.version;
                }
                if (!this.model.height)
                    this.model.height = "18px";
                if (ej.widget.unobtrusive !== undefined) {
                    if (this.model.snapSettings.horizontalGridLines && this.model.snapSettings.horizontalGridLines.linesInterval && typeof (this.model.snapSettings.horizontalGridLines.linesInterval) === "string")
                        this.model.snapSettings.horizontalGridLines.linesInterval = JSON.parse(this.model.snapSettings.horizontalGridLines.linesInterval);
                    if (this.model.snapSettings.verticalGridLines && this.model.snapSettings.verticalGridLines.linesInterval && typeof (this.model.snapSettings.verticalGridLines.linesInterval) === "string")
                        this.model.snapSettings.verticalGridLines.linesInterval = JSON.parse(this.model.snapSettings.verticalGridLines.linesInterval);
                    if (this.model.defaultSettings.connector) {
                        var connector = ej.datavisualization.Diagram.Connector({});
                        this.model.defaultSettings.connector = this._equivalentPropMap(connector, this.model.defaultSettings.connector);
                    }
                    if (this.model.defaultSettings.node) {
                        var node = ej.datavisualization.Diagram.Node({});
                        this.model.defaultSettings.node = this._equivalentPropMap(node, this.model.defaultSettings.node);
                    }
                }
                if (this.model.snapSettings.horizontalGridLines && this.model.snapSettings.horizontalGridLines.linesInterval == null)
                    this.model.snapSettings.horizontalGridLines.linesInterval = [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75];
                if (this.model.snapSettings.verticalGridLines && this.model.snapSettings.verticalGridLines.linesInterval == null)
                    this.model.snapSettings.verticalGridLines.linesInterval = [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75];

                var tempObj = this;
                if (tempObj.model.dataSourceSettings.crudAction.read) {
                    var callback = $.ajax({
                        type: 'GET',
                        url: tempObj.model.dataSourceSettings.crudAction.read,
                        async: false,
                        success: function (data, textStatus, xhr) {
                            tempObj.model.dataSourceSettings.dataSource = data;
                        },
                        error: function (xhr, textStatus, errorThrown) {
                        }
                    });
                    this._isWebAPI = true;
                }
                if (tempObj.model.dataSourceSettings.connectionDataSource.crudAction.read) {
                    var callback = $.ajax({
                        type: 'GET',
                        url: tempObj.model.dataSourceSettings.connectionDataSource.crudAction.read,
                        async: false,
                        success: function (data) {
                            tempObj.model.dataSourceSettings.connectionDataSource.dataSource = data;
                        },
                        error: function (errData) {

                        }
                    });
                    this._isWebAPI = true;
                }
                if (this.model.backgroundImage) {
                    var imagePath;
                    if (typeof this.model.backgroundImage === "string")
                        imagePath = this.model.backgroundImage;
                    if (typeof this.model.backgroundImage === "function")
                        imagePath = this.model.backgroundImage();
                    if (imagePath)
                        this.model.backgroundImage = ej.datavisualization.Diagram.BackgroundImage({ source: imagePath });
                }
                if (this._layoutMarginX()) {
                    this.model.layout.margin.left = this.model.layout.margin.right = this._layoutMarginX();
                }
                if (this._layoutMarginY()) {
                    this.model.layout.margin.top = this.model.layout.margin.bottom = this._layoutMarginY();
                }
                this._cloneGlobalVariables();
                this._spatialSearch = ej.datavisualization.Diagram.SpatialSearch(this);
                this._initDefaults();
                this._initViews();
                this._initLineRouting();
                this._initData();
                this._initCanvas();
                this._initDiagramTool();
                this._initVisualGuide();
                this._wireEvents();
                this._initHandles();
                this._initContextMenu();
                this._drawingTool = false;
                this._isDropped = false;
                this._initCommands();
                this._initHistoryManager();
                if (this.model.zoomFactor && this.model.zoomFactor !== .2)
                    this.model.scrollSettings.zoomFactor = this.model.zoomFactor;
                this._updateScrollSettings(this.model.scrollSettings);
                delete this._viewPort;
                this._cloneModel = $.extend(true, {}, this.model);
            }
            delete this._isInit;
        },

        _initLineRouting: function () {
            if (ej.datavisualization.Diagram.Util.canRouteDiagram(this)) {
                this.lineRouting = new LineRouting();
                this.lineRouting.firstLoad = true;
                this.lineRouting.Init(this.model);
                this.lineRouting.SetLineRoutingSettings();
            }
        },
        _resetConnectorPoints: function (edge, diagram) {
            if (edge._undoSegments || edge._redoSegments) {
                var segments = edge._undoSegments ? edge._undoSegments : edge._redoSegments;
                this.updateConnector(edge.name, { segments: segments });
            }
            else {
                if (edge._points && edge._points.size() > 0) {
                    var connector = diagram.nameTable[edge.name];
                    if (!this._isUndo && (this.activeTool.name == "move" || this.activeTool.name === "resize" || this.activateTool.name === "rotatetool"))
                        this.tools[this.activeTool.name].undoObject.connectors[connector.name] = { name: connector.name, segments: connector.segments };
                    connector.segments = [];
                    connector.sourcePoint = edge._points.get(0);
                    connector.targetPoint = edge._points.get(edge._points.size() - 1);
                    connector._sourcePortLocation = $.extend(true, {}, edge._points.get(0));
                    connector._targetPortLocation = $.extend(true, {}, edge._points.get(edge._points.size() - 1));
                    var points = [];
                    var segments = [];
                    for (var i = 0; i < edge._points.size() - 1; i++) {
                        var point1 = edge._points.get(i);
                        var point2 = edge._points.get(i + 1);
                        if (point1.x == point2.x && point1.y == point2.y) {
                            edge._points.RemoveAt(i + 1);
                            if (i + 1 == edge._points.size())
                                break;
                            point2 = edge._points.get(i + 1);
                        }
                        var length = Point.findLength(point1, point2);
                        var direction = ej.datavisualization.Diagram.Util._getBezierDirection(point1, point2);
                        segments.push({ length: length, direction: direction, type: "orthogonal" });
                    }
                    this.updateConnector(connector.name, { segments: segments });
                    if (!this._isUndo && (this.activeTool.name == "move" || this.activeTool.name === "resize" || this.activateTool.name === "rotate"))
                        this.tools[this.activeTool.name]._redoConnectors[connector.name] = { name: connector.name, segments: connector.segments };
                    delete connector._sourcePortLocation;
                    delete connector._targetPortLocation;
                } else {
                    var connector = diagram.nameTable[edge.name];
                    connector.segments = [];
                    var segments = [{ type: "orthogonal" }];
                    this.updateConnector(connector.name, { segments: segments });
                }
            }
        },
        _equivalentPropMap: function (obj, sourceObj) {
            var obj1 = {}, field;
            for (var prop in obj) {
                field = prop.toLowerCase();
                if (ej.isPlainObject(sourceObj[field]) || ej.isPlainObject(sourceObj[prop])) {
                    obj1[prop] = this._equivalentPropMap(obj[prop], sourceObj[field] ? sourceObj[field] : sourceObj[prop]);
                }
                else if (sourceObj[field] || sourceObj[prop])
                    obj1[prop] = sourceObj[field] ? sourceObj[field] : sourceObj[prop];
            }
            return obj1;
        },

        getDiagramBounds: function () {

            var bounds = this._getDigramBounds();
            bounds.width = bounds.width > this.model.scrollSettings.viewPortWidth ? bounds.width + (bounds.x > 0 ? bounds.x : 0) : this.model.scrollSettings.viewPortWidth;
            bounds.height = bounds.height > this.model.scrollSettings.viewPortHeight ? bounds.height + (bounds.y > 0 ? bounds.y : 0) : this.model.scrollSettings.viewPortHeight;

            bounds.x = bounds.x > 0 ? 0 : bounds.x;
            bounds.y = bounds.y > 0 ? 0 : bounds.y;

            return bounds;
        },

        getDiagramContent: function (styleSheets) {
            var margin = {};
            margin = {
                top: !isNaN(margin.top) ? margin.top : 0,
                bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
                left: !isNaN(margin.left) ? margin.left : 0,
                right: !isNaN(margin.right) ? margin.right : 0
            };
            var oldZoom = this._currZoom, oldHorizontalOffset = this._hScrollOffset, oldVerticalOffset = this._vScrollOffset,
                hScrollVisibility, vScrollVisibility;
            var minHorOffset = 0, minVerOffset = 0;

            var oldWidth = this.model.width, oldHeight = this.model.height;

            var bounds = this.getDiagramBounds();

            if (this._hScrollbar && this._hScrollbar._scrollData) {
                minHorOffset = this._hScrollbar.model.minimum / oldZoom;
            }

            if (this._vScrollbar && this._vScrollbar._scrollData) {
                minVerOffset = this._vScrollbar.model.minimum / oldZoom;
            }

            this._preventZoomEvent = true;

            if (this._currZoom !== 1) {
                var zoomAction = new ej.datavisualization.Diagram.Zoom();
                zoomAction.zoomFactor = (1 / oldZoom) - 1;
                this.zoomTo(zoomAction);
            }

            var scrollSettings = {};
            if (bounds.x !== this._hScrollOffset / oldZoom) {
                scrollSettings.horizontalOffset = bounds.x;
            }
            if (bounds.y !== this._vScrollOffset / oldZoom) {
                scrollSettings.verticalOffset = bounds.y;
            }

            if (Object.keys(scrollSettings).length > 0)
                this.update({ scrollSettings: scrollSettings });


            $("#" + this.element[0].id).ejDiagram({
                width: bounds.width + "px",
                height: bounds.height + "px"
            });

            hScrollVisibility = this._hScrollbar.element[0].style.visibility;
            this._hScrollbar.element[0].style.visibility = "hidden";

            vScrollVisibility = this._vScrollbar.element[0].style.visibility;
            this._vScrollbar.element[0].style.visibility = "hidden";


            var snapConstraints = this.model.snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.ShowLines;

            if (snapConstraints) {
                $("#" + this.element[0].id).ejDiagram({
                    snapSettings: {
                        snapConstraints: this.model.snapSettings.snapConstraints
                            & ~ej.datavisualization.Diagram.SnapConstraints.ShowLines
                    }
                })
            }

            this._clearSelection(true);
            styleSheets = styleSheets || document.styleSheets;
            var styleSheetRef = "";
            for (var i = 0; i < styleSheets.length; i++) {
                if (styleSheets[i].href || typeof styleSheets[i] === "string")
                    styleSheetRef += "<link href=\"" + (styleSheets[i].href || styleSheets[i]) + "\" rel=\"stylesheet\" />";
            }

            var htmlData = $(this.element).html();
            var marginStyle = "margin-left:" + margin.left + "px;margin-top:" + margin.top + "px;margin-right:" + margin.right + "px;margin-bottom:" + margin.bottom + "px;";
            htmlData = styleSheetRef + "<body style='margin:0px;padding:0px'><div style=\"" + marginStyle + "\">" + htmlData + "</div></body>";

            htmlData = htmlData.replace(/ transform: t/g, " -webkit-transform: t");

            $("#" + this.element[0].id).ejDiagram({
                width: oldWidth,
                height: oldHeight
            });

            if (oldZoom) {
                var zoomAction = new ej.datavisualization.Diagram.Zoom();
                zoomAction.zoomFactor = (oldZoom / this._currZoom) - 1;
                this.zoomTo(zoomAction);
            }


            this.update({ scrollSettings: { horizontalOffset: oldHorizontalOffset, verticalOffset: oldVerticalOffset } });

            delete this._preventZoomEvent;

            if (this._hScrollbar) {
                this._hScrollbar.element[0].style.visibility = hScrollVisibility;
            }

            if (this._vScrollbar) {
                this._vScrollbar.element[0].style.visibility = vScrollVisibility;
            }

            if (snapConstraints) {
                $("#" + this.element[0].id).ejDiagram({
                    snapSettings: {
                        snapConstraints: this.model.snapSettings.snapConstraints
                            | ej.datavisualization.Diagram.SnapConstraints.ShowLines
                    }
                });
            }
            return htmlData;
        },

        refresh: function () {
            this._updateTableNodes();
            this._updateGroupChildren(this.model);
            if (this._isSwimlaneExist) {
                var connectors = this.connectors();
                for (var i = 0; i < connectors.length; i++) {
                    connectors[i].zOrder = -1;
                }
                delete this._isSwimlaneExist;
            }
            this._updateScrollOffset(0, 0);
            this._destroy();
            this.element.addClass("e-datavisualization-diagram");
            this._currZoom = 1;
            this._hScrollbar = null;
            this._vScrollbar = null;
            this._view = null;
            this._svg = null;
            this._page = null;
            this._pageBackgroundLayer = null;
            this._diagramLayer = null;
            this._htmlLayer = null;
            this.clearHistory();
            this._spatialSearch = ej.datavisualization.Diagram.SpatialSearch(this);
            if ((this.model.dataSourceSettings && this.model.dataSourceSettings.dataSource)) {
                this.nodes([]);
                this.connectors([]);
                this._nodes = [];
                this._connectors = [];
            }
            this._init();
        },

        _initCommands: function (newCommands) {
            var modifiers = ej.datavisualization.Diagram.KeyModifiers;
            var keys = ej.datavisualization.Diagram.Keys;
            var commands;
            if (newCommands) {
                commands = this.model.commandManager.commands;
            } else {
                newCommands = this.model.commandManager.commands;
                commands = {
                    "copy":
                    {
                        gesture: { key: keys.C, keyModifiers: modifiers.Control },
                        _isDefault: true
                    },
                    "paste":
                    {
                        gesture: { key: keys.V, keyModifiers: modifiers.Control },
                        _isDefault: true
                    },
                    "cut":
                    {
                        gesture: { key: keys.X, keyModifiers: modifiers.Control },
                        _isDefault: true
                    },
                    "delete":
                    {
                        gesture: { key: keys.Delete },
                        _isDefault: true
                    },
                    "undo":
                    {
                        gesture: { key: keys.Z, keyModifiers: modifiers.Control },
                        _isDefault: true
                    },
                    "redo":
                    {
                        gesture: { key: keys.Y, keyModifiers: modifiers.Control },
                        _isDefault: true
                    },
                    "selectAll":
                    {
                        gesture: { key: keys.A, keyModifiers: modifiers.Control },
                        _isDefault: true
                    },
                    "nudgeUp":
                    {
                        parameter: "up",
                        gesture: { key: keys.Up },
                        _isDefault: true
                    },
                    "nudgeRight":
                    {
                        parameter: "right",
                        gesture: { key: keys.Right },
                        _isDefault: true
                    },
                    "nudgeDown":
                    {
                        parameter: "down",
                        gesture: { key: keys.Down },
                        _isDefault: true
                    },
                    "nudgeLeft":
                    {
                        parameter: "left",
                        gesture: { key: keys.Left },
                        _isDefault: true
                    },
                    "startEdit":
                    {
                        gesture: { key: 113 },
                        _isDefault: true
                    },
                    "endEdit":
                    {
                        gesture: { key: keys.Escape },
                        _isDefault: true
                    },
                    "focusToNextItem":
                    {
                        gesture: { key: keys.Tab },
                        _isDefault: true
                    },
                    "focusToPreviousItem":
                    {
                        gesture: { key: keys.Tab, keyModifiers: modifiers.Control },
                        _isDefault: true
                    },
                    "selectFocusedItem":
                    {
                        gesture: { key: keys.Enter },
                        _isDefault: true
                    },
                };
                for (var j in commands)
                    this._initCommandValues(j, commands[j]);

            }
            var i;
            for (i in newCommands) {
                if (commands[i]) {
                    if (newCommands[i]) {
                        if (newCommands[i] && commands[i].gesture && newCommands[i].gesture) {
                            if (!this._isLoad) {
                                if (commands[i]._isDefault)
                                    delete commands[i]._isDefault;
                            }
                            newCommands[i].gesture = ej.datavisualization.Diagram.Gesture($.extend({}, true, commands[i].gesture, newCommands[i].gesture));
                            if (this._tempCommandManager && this._tempCommandManager.commands && this._tempCommandManager.commands[i]._isDefault) {
                                this._initCommandValues(i, newCommands[i]);
                            }
                        }
                        $.extend(commands[i], true, newCommands[i]);
                    } else commands[i] = null;
                } else {
                    if (newCommands[i]) {
                        var cmd = ej.datavisualization.Diagram.Command(newCommands[i]);
                        commands[i] = cmd;
                    }
                }
            }
            this.model.commandManager.commands = commands;
        },
        _initCommandValues: function (command, newCommands) {
            switch (command) {
                case "copy":
                    newCommands.execute = $.proxy(this.copy, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "paste":
                    newCommands.execute = $.proxy(this._commandPaste, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "cut":
                    newCommands.execute = $.proxy(this.cut, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "delete":
                    newCommands.execute = $.proxy(this.remove, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "undo":
                    newCommands.execute = $.proxy(this.undo, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "redo":
                    newCommands.execute = $.proxy(this.redo, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "selectAll":
                    newCommands.execute = $.proxy(this._selectCommand, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "nudgeUp":
                case "nudgeRight":
                case "nudgeDown":
                case "nudgeLeft":
                    newCommands.execute = $.proxy(this._nudgeCommand, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "startEdit":
                    newCommands.execute = $.proxy(this._startEditCommand, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "endEdit":
                    newCommands.execute = $.proxy(this._endEdit, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "focusToNextItem":
                case "focusToPreviousItem":
                    newCommands.execute = $.proxy(this._focusToItem, this);
                    newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
                case "selectFocusedItem":
                    newCommands.execute = $.proxy(this._selectFocusedItem, this),
                        newCommands.canExecute = $.proxy(this._canExecute, this);
                    break;
            }
        },
        _initViews: function (isLoad) {
            if (!isLoad) {
                this._views = [];
                this._views.push(this._id);
            }
            this._views[this._id] = {
                "type": "mainview",
                "context": ej.datavisualization.Diagram.SvgContext,
                "style": "position:relative; height:" + this.model.height + "; width:" + this.model.width + ";"
            };
        },
        _initDefaults: function () {
            if (!(this.tool())) {
                if (ej.isMobile()) {
                    this.tool(ej.datavisualization.Diagram.Tool.ZoomPan);
                    this._isMobile = true;
                }
                else {
                    this.tool(ej.datavisualization.Diagram.Tool.SingleSelect | ej.datavisualization.Diagram.Tool.MultipleSelect);
                }
            }
            this._initTools();
        },
        _initCanvas: function (isload) {
            this._renderCanvas(isload);
        },
        _initVisualGuide: function () {
            if (this.model.tooltip) {
                this.model.tooltip = ej.datavisualization.Diagram.Tooltip(this.model.tooltip);
            }
            if (this.model.selectedItems) {
                if (this.model.selectorConstraints) {
                    this.model.selectedItems.constraints = this.model.selectorConstraints;
                }
                if (!ej.datavisualization.Diagram.Util.canEnableTooltip(this) || !this.showTooltip()) {
                    this.model.selectedItems.tooltip = null;
                }
                else {
                    if (this.model.selectedItems.tooltip) {
                        this.model.selectedItems.tooltip = ej.datavisualization.Diagram.Tooltip(this.model.selectedItems.tooltip);
                    }
                    else {
                        this.model.selectedItems.tooltip = ej.datavisualization.Diagram.Tooltip({ margin: { top: 10 } });
                    }

                }
                if (this.model.selectedItems.tooltip && this.model.tooltipTemplateId) {
                    this.model.selectedItems.tooltip.templateId = this.model.selectedItems.tooltip.templateId || this.model.tooltipTemplateId;
                }
            }
        },
        _initTools: function () {
            this.tools = {
                "select": new ej.datavisualization.Diagram.SelectTool(this),
                "move": new ej.datavisualization.Diagram.MoveTool(this),
                "resize": new ej.datavisualization.Diagram.ResizeTool(this),
                "rotate": new ej.datavisualization.Diagram.RotateTool(this),
                //"pivot": new ej.datavisualization.Diagram.PivotTool(this),
                "endPoint": new ej.datavisualization.Diagram.ConnectionEditTool(this),
                "panTool": new ej.datavisualization.Diagram.PanTool(this),
                "portTool": new ej.datavisualization.Diagram.PortTool(this),
                "straightLine": new ej.datavisualization.Diagram.StraightLineTool(this),
                "orthogonalLine": new ej.datavisualization.Diagram.OrthogonalLineTool(this),
                "bezierLine": new ej.datavisualization.Diagram.BezierLineTool(this),
                "phase": new ej.datavisualization.Diagram.PhaseTool(this),
                "shapeTool": new ej.datavisualization.Diagram.ShapeTool(this),
                "text": new ej.datavisualization.Diagram.TextTool(this),
                "labelMove": new ej.datavisualization.Diagram.LabelMoveTool(this),
                "labelResize": new ej.datavisualization.Diagram.LabelResizeTool(this),
                "labelRotate": new ej.datavisualization.Diagram.LabelRotateTool(this),
            };
            this._toolToActivate = "select";
            this.activeTool = this.tools[this._toolToActivate];
            this._registerDrawingTools();
        },
        _initDiagramTool: function () {
            var tool = this.tool();
            var shape;
            if (tool & ej.datavisualization.Diagram.Tool.ContinuesDraw) {
                if (this.model.drawType) {
                    shape = this.model.drawType.shape ? this.model.drawType.shape : this.model.drawType.type;
                    this._drawToolShape(shape, false);
                }
            } else if (tool & ej.datavisualization.Diagram.Tool.DrawOnce) {
                if (this.model.drawType) {
                    shape = this.model.drawType.shape ? this.model.drawType.shape : this.model.drawType.type;
                    this._drawToolShape(shape, true);
                }
            } else if (tool & ej.datavisualization.Diagram.Tool.ZoomPan) {
                if (ej.datavisualization.Diagram.Util.canPanning(this)) {
                    this._toolToActivate = "panTool";
                    this.activeTool = this.tools[this._toolToActivate];
                    this.activeTool._isMouseDown = false;
                    this._currentCursor = "pointer";
                }
            } else if (tool & ej.datavisualization.Diagram.Tool.MultipleSelect) {
                this.activateTool("select");
                this.activeTool.singleAction = false;
            }
        },
        _initHandles: function () {
            var userHandles = this.model.selectedItems.userHandles;
            if (userHandles) {
                for (var i = 0; i < userHandles.length; i++) {
                    userHandles[i] = ej.datavisualization.Diagram.UserHandle(userHandles[i]);
                    if (userHandles[i].tool) {
                        userHandles[i].tool.diagram = this;
                        this.tools[userHandles[i].name] = userHandles[i].tool;
                    }
                }
            }
        },
        _initHistoryManager: function () {
            this.model.historyManager.push = $.proxy(this.addHistoryEntry, this);
            this.model.historyManager.pop = $.proxy(this.removeHistoryEntry, this);
            this.model.historyManager.canPop = $.proxy(this.canRemoveHistoryEntry, this);
            this.model.historyManager.startGroupAction = $.proxy(this._startGroupAction, this);
            this.model.historyManager.closeGroupAction = $.proxy(this._closeGroupAction, this);
        },

        _cloneGlobalVariables: function () {
            this._historyList = $.extend(true, {}, this._historyList);
        },
        _setNodesConnectors: function (options, isLoad) {
            var nodes = [], sNodes = false, sConnectors = false;
            var nLength = options.nodes ? (typeof options.nodes === 'function' ? options.nodes().length : options.nodes.length) : 0;
            var cLength = options.connectors ? (options.connectors && typeof options.connectors === 'function' ? options.connectors().length : options.connectors.length) : 0;
            if (options.nodes && nLength != this._nodes.length) {
                for (var i = 0; i < this.nodes().length; i++)
                    this._removeElementFromCollection(this.nameTable[this.nodes()[i].name]);
                this._isPreventModelChange = true;
                this.nodes(typeof options.nodes === 'function' ? options.nodes() : options['nodes']);
                this._isPreventModelChange = false;
                this._initNodeCollection(isLoad);
                sNodes = true;
            }
            if (options.connectors && cLength != this._connectors.length) {
                for (var i = 0; i < this.connectors().length; i++)
                    this._removeElementFromCollection(this.nameTable[this.connectors()[i].name]);
                this._isPreventModelChange = true;
                this.connectors(typeof options.connectors === 'function' ? options.connectors() : options['connectors']);
                this._isPreventModelChange = false;
                this._initConnectorCollection(); sConnectors = true;
            }
            nodes = this.nodes();
            nodes = nodes.length > 0 ? this.nodes().concat(this.connectors()) : this.connectors();
            if (nodes.length > 0 || options.nodes.length == 0 || options.connectors.length == 0) {
                this._resetObjectCollection(nodes, isLoad, sNodes, sConnectors);
            }
            return true;
        },
        _removeElementFromCollection: function (item) {
            if (item) {
                if (item.children) {
                    for (var i = 0; i < item.children.length; i++)
                        this._removeElementFromCollection(this.nameTable[this._getChild(item.children[i])]);
                }
                if (item.segments)
                    this._removeEdges(item);
                else {
                    this._disConnect(item, {});
                    item.inEdges = item.outEdges = [];
                }
                ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[item.name], item);
                ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, item);
                this._removeElement(item);
                delete this.nameTable[item.name];
            }
        },
        _updateCloneModel: function (arg) {
            if (arg) {
                this._cloneModel[arg] = typeof (this.model[arg]) === "string" ? this.model[arg] : $.extend(true, {}, this.model[arg]);
            }
        },
        _compareModelProperty: function (arg, interaction, root) {
            if (arg) {
                if (this._cloneModel[arg] !== this.model[arg]) {
                    var args = {};
                    args[arg] = this.model[arg];
                    this._comparePropertyValues(this._cloneModel, arg, args, interaction, root);
                    this._updateCloneModel(arg);
                }
            }
        },

        _setModel: function (options) {
            var initObject = false;
            var diagram, object;
            for (var option in options) {
                switch (option) {
                    case "height":
                    case "width":
                        this._svgParentDimention = null;
                        if (options["dataSourceSettings"]) {
                            this._layoutUpdate = true;
                        }
                        this._initViews(true);
                        this._initCanvas(true);
                        delete this._layoutUpdate;
                        break;
                    case "nodes":
                    case "connectors":
                        var flag = false;
						if(window.angular && option ==="nodes" && options.nodes&& options.nodes()&& this.nodes()&& options.nodes() === this.nodes())	
						{
							flag = true;
						}	
						if(!flag){
							if (!initObject && !this._isPreventModelChange && (!(this._isRefreshTriggered && typeof this.model.nodes === "function"))) {
								this._initLineRouting();
								initObject = this._setNodesConnectors(options, this._isLoad);
								this._trigger("refresh");
								this._iiii = 1;
							}
							delete this._isRefreshTriggered;
						}
                        break;
                    case "enableContextMenu":
                        this.model.enableContextMenu = options[option];
                        this._initContextMenu(this._isLoad);
                        break;
                    case "contextMenu":
                        this.model.contextMenu = $.extend({}, this.model.contextMenu, options[option]);
                        this._initContextMenu(this._isLoad);
                        break;
                    case "rulerSettings":
                        this._updateRulerSettings(options[option]);
                        break;
                    case "snapSettings":
                        object = options[option];
                        if (object && Object.keys(object).length > 0) {
                            this._updateSnapSettings(options[option]);
                            ej.datavisualization.Diagram.SvgContext._renderGrid(this._canvas, this._svg, this._page, this);
                        }
                        break;
                    case "selectorConstraints":
                        this._setSelectorConstraints(options[option]);
                        break;
                    case "constraints":
                        this.model.constraints = options[option];
                        if (this._hasSelection() && !ej.datavisualization.Diagram.Util.isPageEditable(this))
                            this._clearSelection();
                        var totalConnectors = this._getConnectors();
                        if (totalConnectors.length > 0) {
                            for (var i = 0; i < totalConnectors.length; i++) {
                                ej.datavisualization.Diagram.Util.updateBridging(this.model.connectors[i], this);
                                ej.datavisualization.Diagram.DiagramContext.update(this.model.connectors[i], this);
                            }
                        }

                        break;
                    case "drawingTools":
                        this.model.drawingTools = options[option];
                        this._registerDrawingTools();
                        break;
                    case "backgroundImage":
                        if (this.model.backgroundImage && typeof this.model.backgroundImage == "string") {
                            this.model.backgroundImage = ej.datavisualization.Diagram.BackgroundImage({ source: this.model.backgroundImage });
                        }
                        else
                            this.model.backgroundImage = $.extend(true, {}, this.model.backgroundImage, options[option]);
                        ej.datavisualization.Diagram.SvgContext._renderBackground(this, this._canvas, this._svg, this._page, this.model);
                        break;
                    case "backgroundColor":
                        this.model.backgroundColor = options[option];
                        ej.datavisualization.Diagram.SvgContext._renderBackground(this, this._canvas, this._svg, this._page, this.model);
                        break;
                    case "enableAutoScroll":
                        this.enableAutoScroll(options[option]);
                        break;
                    case "autoScrollMargin":
                        this.model.autoScrollMargin = options[option];
                        break;
                    case "layout":
                        if (!this._isLoad) {
                            if (options[option].marginX)
                                this.model.layout.margin.left = this.model.layout.margin.right = Number(typeof options[option].marginX === 'function' ? this._layoutMarginX() : options[option].marginX);
                            if (options[option].marginY)
                                this.model.layout.margin.top = this.model.layout.margin.bottom = Number(typeof options[option].marginY === 'function' ? this._layoutMarginY() : options[option].marginY);
                            this.model.layout = $.extend(true, {}, this.model.layout, options[option]);
                            this._setLayout(options[option]);
                        }
                        break;
                    case "selectedItems":
                        this.updateSelector(options[option]);
                        break;
                    case "pageSettings":
                        this.updatePageSettings(options[option]);
                        break;
                    case "scrollSettings":
                        this._updateScrollSettings(options[option]);
                        break;
                    case "locale":
                        this.locale(options[option]);
                        var contextmenu = document.getElementById(this.element[0].id + "_contextMenu");
                        contextmenu.parentNode.removeChild(contextmenu);
                        if (this.model.contextMenu && this.model.contextMenu.items && this.model.contextMenu.items.length > 0)
                            this.model.contextMenu.items = [];
                        this._renderContextMenu();
                        break;
                    case "nodeTemplate":
                        if (!this._isLoad) {
                            if (!options["dataSourceSettings"] && !options["nodes"]) {
                                this._clearElementCollection();
                                this._initData();
                                diagram = this;
                                this._views.forEach(function (viewid) {
                                    var view = diagram._views[viewid];
                                    var nodes = diagram._setNodeZOrder(view);
                                    diagram._renderDiagramObjects(nodes, view);
                                });
                                this.layout();
                            }
                        }
                        break;
                    case "bridgeDirection":
                    case "tool":
                        this.update(options);
                        break;
                    case "connectorTemplate":
                        this._updateConnectors();
                        break;
                    case "commandManager":
                        var commands = options[option] && options[option]["commands"] ? options[option]["commands"] : undefined;
                        this._initCommands(commands);
                        break;
                    case "historyManager":
                        this.model.historyManager = $.extend(true, this.model.historyManager, {}, options[option]);
                        var stackLimit = this.model.historyManager.stackLimit;
                        var rLength = this.model.historyManager.redoStack.length
                        var uLength = this.model.historyManager.undoStack.length
                        if (rLength > 0) {
                            if (rLength > stackLimit) {
                                var sliceEnd = rLength - stackLimit;
                                this.model.historyManager.redoStack.splice(0, sliceEnd);
                                this.model.historyManager.undoStack = [];
                            }
                            else {
                                var remaiRemove = stackLimit - rLength;
                                var sliceEnd = uLength - remaiRemove;
                                this.model.historyManager.undoStack.splice(0, sliceEnd);
                            }
                        }
                        if (uLength > 0) {
                            var sliceEnd = uLength - stackLimit;
                            if (sliceEnd > 0) {
                                this.model.historyManager.undoStack.splice(0, sliceEnd);
                            }
                        }
                        this._initHistoryManager();
                        break;
                    case "showTooltip":
                        this.model.showTooltip = options[option];
                        if (this.showTooltip())
                            this.model.selectedItems.tooltip = ej.datavisualization.Diagram.Tooltip({ margin: { top: 10 } });
                        else
                            this.model.selectedItems.tooltip = null;
                        break;
                    case "toolTipTemplateId":
                        if (!this.model.selectedItems.tooltip)
                            this.model.selectedItems.tooltip = ej.datavisualization.Diagram.Tooltip({ margin: { top: 10 } });
                        this.model.selectedItems.tooltip.templateId = options[option];
                        break;
                    case "tooltip":
                        if (options[option] === null) this.model.tooltip = null;
                        else
                            this.model.tooltip = ej.datavisualization.Diagram.Tooltip($.extend(true, this.model.tooltip, {}, options[option]));
                        break;
                    case "dataSourceSettings":
                        if (!this._isLoad) {
                            object = options[option];
                            if (object && Object.keys(object).length > 0 && object.dataSource) {
                                this.clear();
                                $.extend(this.model.dataSourceSettings, options[option]);
                                this._initLineRouting();
                                this._initData();
                                diagram = this;
                                this._views.forEach(function (viewid) {
                                    var view = diagram._views[viewid];
                                    var nodes = diagram._setNodeZOrder(view);
                                    diagram._renderDiagramObjects(nodes, view);
                                });
                                this.layout();
                                var nodes = diagram.connectors();
                                if (nodes.length > 1 && (ej.datavisualization.Diagram.Util.canRouteDiagram(this))) {
                                    diagram.lineRouting.GenerateVisibilityGraph(diagram, nodes.length);
                                    for (var i = 0; i < nodes.length; i++)
                                        diagram._routeEdge(nodes[i]);
                                }
                            }
                        }
                        break;
                }
                if (!(option === "nodes" || option === "connectors" || option === "selectorConstraints" || option === "selectedItems" || option === "bridgeDirection" || option === "tool" || option === "dataSourceSettings"))
                    this._compareModelProperty(option);
            }
        },
        _resetObjectCollection: function (nodes, isLoad, sNode, sConnectors) {
            if (sNode) {
                $(this.element).find(".ej-d-node").remove();
                $(this.element).find(".ej-d-group").remove();
                $(this.element).find(".ej-d-seperator").remove();
            }
            if (sConnectors) {
                var children = $(this.element).find(".ej-d-connector");
                for (var i = children.length - 1; i >= 0; i--) {
                    var child = this.nameTable[children[i].id];
                    if (child && child.parent == "")
                        $(children[i]).remove();
                }
            }
            if (this._hasSelection())
                this._clearSelection();
            var diagram = this;
            this._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                var nodes = diagram._setNodeZOrder(view);
                diagram._renderDiagramObjects(nodes, view);
            });

        },
        _getConnectors: function () {
            var connectors = [];
            for (var prop in this.nameTable) {
                var connector = this.nameTable[prop];
                if (connector._type === "connector" || connector.segments)
                    connectors.push(connector);
            }
            return connectors;
        },

        _generateNodes: function (dataSource) {
            var nodes = [];
            for (var i = 0; i < dataSource.length; i++) {
                var row = dataSource[i];
                var node = this._makeNode(row);
                if (node != null && node.name && !this._findNodeByName(nodes, node.name)) {
                    nodes.push(node);
                }
            }
            return nodes;
        },

        _generateConnectors: function (dataSource) {
            var connectors = [];
            for (var i = 0; i < dataSource.length; i++) {
                var row = dataSource[i];
                var conn = this._makeLine(row);
                if (conn && conn.name && !this._findNodeByName(connectors, conn.name))
                    connectors.push(conn);
            }
            return connectors;
        },

        _findNodeByName: function (nodes, name) {
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].name === name)
                    return true;
            }
            return false;
        },

        _makeNode: function (row) {
            var fields = this.model.dataSourceSettings;
            var node = {};
            var nodeName = row[fields.id];
            if (nodeName) {
                node.name = nodeName;
                if (fields.customFields && fields.customFields.length > 0) {
                    for (var i = 0; i < fields.customFields.length; i++)
                        node[fields.customFields[i]] = row[fields.customFields[i]];
                }
                return node;
            }
            else
                return null;
        },

        _makeLine: function (row) {
            var fields = this.model.dataSourceSettings.connectionDataSource;
            var conn = {};
            conn.name = row[fields.id] ? row[fields.id] : "connector_" + ej.datavisualization.Diagram.Util.randomId();
            conn.sourceNode = row[fields.sourceNode];
            conn.targetNode = row[fields.targetNode];
            if (row[fields.sourcePointX] && row[fields.sourcePointY])
                conn.sourcePoint = { "x": Number(row[fields.sourcePointX]), "y": Number(row[fields.sourcePointY]) };
            if (row[fields.targetPointX] && row[fields.targetPointY])
                conn.targetPoint = { "x": Number(row[fields.targetPointX]), "y": Number(row[fields.targetPointY]) };
            if (fields.customFields && fields.customFields.length > 0) {
                for (var i = 0; i < fields.customFields.length; i++)
                    conn[fields.customFields[i]] = row[fields.customFields[i]];
            }
            return conn;
        },

        insertData: function (node) {
            var mappingData;
            if (node) {
                var data, url;
                data = this._parameterMap(node);
                if (node.type === "connector")
                    url = this.model.dataSourceSettings.connectionDataSource.crudAction.create;
                else
                    url = this.model.dataSourceSettings.crudAction.create;
                if (data) {
                    this._raiseAjaxPost(JSON.stringify({ "data": [data] }), url);
                }
            }
            else {
                var newObjects = this._getNewNodes();
                if (newObjects.nodes) {
                    var mappingData, data = [];
                    for (var i = 0; i < newObjects.nodes.length; i++) {
                        data.push(this._parameterMap(newObjects.nodes[i]));
                    }
                    if (data && data.length > 0)
                        this._raiseAjaxPost(JSON.stringify({ "data": data }), this.model.dataSourceSettings.crudAction.create);
                }
                if (newObjects.connectors) {
                    var mappingData, data = [];
                    for (var i = 0; i < newObjects.connectors.length; i++) {
                        data.push(this._parameterMap(newObjects.connectors[i]));
                    }
                    if (data && data.length > 0)
                        this._raiseAjaxPost(JSON.stringify({ "data": data }), this.model.dataSourceSettings.connectionDataSource.crudAction.create);
                }
            }

        },

        updateData: function (node) {
            var mappingData;
            if (node) {
                var data, url;
                data = this._parameterMap(node);
                if (node.type === "connector")
                    url = this.model.dataSourceSettings.connectionDataSource.crudAction.update;
                else
                    url = this.model.dataSourceSettings.crudAction.update;
                if (data) {
                    this._raiseAjaxPost(JSON.stringify({ "data": [data] }), url);
                }
            }
            else {
                var newObjects = this._getUpdatedNodes();
                if (newObjects.nodes) {
                    var mappingData, data = [];
                    for (var i = 0; i < newObjects.nodes.length; i++) {
                        data.push(this._parameterMap(newObjects.nodes[i]));
                    }
                    if (data && data.length > 0)
                        this._raiseAjaxPost(JSON.stringify({ "data": data }), this.model.dataSourceSettings.crudAction.update);
                }
                if (newObjects.connectors) {
                    var mappingData, data = [];
                    for (var i = 0; i < newObjects.connectors.length; i++) {
                        data.push(this._parameterMap(newObjects.connectors[i]));
                    }
                    if (data && data.length > 0)
                        this._raiseAjaxPost(JSON.stringify({ "data": data }), this.model.dataSourceSettings.connectionDataSource.crudAction.update);
                }
            }
        },

        removeData: function (node) {
            var mappingData;
            if (node) {
                var data, url;
                data = this._parameterMap(node);
                if (node.type === "connector")
                    url = this.model.dataSourceSettings.connectionDataSource.crudAction.destroy;
                else
                    url = this.model.dataSourceSettings.crudAction.destroy;
                if (data) {
                    this._raiseAjaxPost(JSON.stringify({ "data": [data] }), url);
                }
            }
            else {
                var newObjects = this._getDeletedNodes();
                if (newObjects.nodes) {
                    var mappingData, data = [];
                    for (var i = 0; i < newObjects.nodes.length; i++) {
                        data.push(this._parameterMap(newObjects.nodes[i]));
                    }
                    if (data && data.length > 0)
                        this._raiseAjaxPost(JSON.stringify({ "data": data }), this.model.dataSourceSettings.crudAction.destroy);
                }
                if (newObjects.connectors) {
                    var mappingData, data = [];
                    for (var i = 0; i < newObjects.connectors.length; i++) {
                        data.push(this._parameterMap(newObjects.connectors[i]));
                    }
                    if (data && data.length > 0)
                        this._raiseAjaxPost(JSON.stringify({ "data": data }), this.model.dataSourceSettings.connectionDataSource.crudAction.destroy);
                }
            }
        },

        _parameterMap: function (object, url) {
            var mappingObj = {};
            if (object.type === "connector") {
                var fields = this.model.dataSourceSettings.connectionDataSource;
                if (fields.id)
                    mappingObj[fields.id] = object.name;
                if (fields.sourcePointX && fields.sourcePointY) {
                    mappingObj[fields.sourcePointX] = object.sourcePoint.X;
                    mappingObj[fields.sourcePointY] = object.sourcePoint.Y;
                }
                if (fields.targetPointX && fields.targetPointY) {
                    mappingObj[fields.targetPointX] = object.targetPoint.X;
                    mappingObj[fields.targetPointY] = object.targetPoint.Y;
                }
                if (fields.sourceNode)
                    mappingObj[fields.sourceNode] = object.sourceNode;
                if (fields.targetNode)
                    mappingObj[fields.targetNode] = object.targetNode;
                if (fields.customFields && fields.customFields.length > 0) {
                    for (var i = 0; i < fields.customFields.length; i++)
                        mappingObj[fields.customFields[i]] = object[fields.customFields[i]];
                }
            }
            else {
                var fields = this.model.dataSourceSettings;
                if (fields.id)
                    mappingObj[fields.id] = object.name;
                if (fields.width)
                    mappingObj[fields.width] = object.width;
                if (fields.height)
                    mappingObj[fields.height] = object.height;
                if (fields.offsetX)
                    mappingObj[fields.offsetX] = object.offsetX;
                if (fields.offsetY)
                    mappingObj[fields.offsetY] = object.offsetY;
                if (fields.customFields && fields.customFields.length > 0) {
                    for (var i = 0; i < fields.customFields.length; i++)
                        mappingObj[fields.customFields[i]] = object[fields.customFields[i]];
                }
            }
            return mappingObj;
        },

        _raiseAjaxPost: function (data, url) {
            var tempObj = this;
            var callback = $.ajax({
                contentType: 'application/json',
                type: 'POST',
                url: url,
                data: this._isWebAPI ? JSON.stringify(JSON.parse(data).data) : JSON.stringify(JSON.parse(data)),
                dataType: "json",
                error: function (errData) {
                    if (errData.status === 404) {
                        console.log("Method not found");
                    }
                }
            });
        },

        _initData: function () {
            if (this.model.dataSourceSettings) {
                var dataSourceSettings = {};
                if (this.model.dataSourceSettings.dataSource && this.model.dataSourceSettings.connectionDataSource.dataSource) {
                    dataSourceSettings.dataSource = this.model.dataSourceSettings.dataSource;
                    dataSourceSettings.isBinding = true;
                    dataSourceSettings.nodes = this._generateNodes(this.model.dataSourceSettings.dataSource);
                    dataSourceSettings.connectors = this._generateConnectors(this.model.dataSourceSettings.connectionDataSource.dataSource);
                }
                else if (this.model.dataSourceSettings.dataSource) {
                    dataSourceSettings.id = this._dataSourceUniqueId();
                    dataSourceSettings.parent = this._dataSourceParentId();
                    dataSourceSettings.root = this._dataSourceRoot();
                    dataSourceSettings.dataSource = this._dataSource();
                    dataSourceSettings.tableName = this._dataSourceTableName();
                    dataSourceSettings.query = this._dataSourceQueryString();
                }
                var dataSource = dataSourceSettings.dataSource || this.model.dataSourceSettings.nodes || this.model.dataSourceSettings.connectors;
            }
            if (dataSource) {
                var nodes = [];
                var connectors = [];
                var dataSourceApplied;
                if (dataSourceSettings && dataSourceSettings.isBinding) {
                    if (dataSourceSettings.nodes && dataSourceSettings.nodes.length > 0) {
                        this._applyTemplate(this.model.dataSourceSettings, dataSourceSettings.nodes, nodes, "nodes");
                    }
                    if (dataSourceSettings.connectors && dataSourceSettings.connectors.length > 0) {
                        this._applyTemplate(this.model.dataSourceSettings, dataSourceSettings.connectors, connectors, "connectors");
                    }
                    //dataSourceApplied = true;
                }
                else if (this.model.dataSourceSettings.nodes || this.model.dataSourceSettings.connectors) {
                    if (this.model.dataSourceSettings.nodes) {
                        dataSource = this.model.dataSourceSettings.nodes || this.model.dataSourceSettings.dataSource;
                        if (dataSource) {
                            if (dataSource instanceof ej.DataManager) {
                                $.ajaxSetup({
                                    async: false
                                });
                                var query = this._findQuery(this.model.dataSourceSettings.nodes, this.model.dataSourceSettings.nodeBinding);
                                var queryPromise = dataSource.executeQuery(eval(query));
                                var diagram = this;
                                queryPromise.done(function (e) {
                                    diagram.retriveData = e.result;
                                    diagram._applyTemplate(diagram.model.dataSourceSettings, e.result, nodes, "nodes");
                                });
                            } else
                                this._applyTemplate(this.model.dataSourceSettings, dataSource, nodes, "nodes");
                        }
                        if (this.model.dataSourceSettings.connectors) {
                            dataSource = this.model.dataSourceSettings.connectors || this.model.dataSourceSettings.dataSource;
                            if (dataSource) {
                                if (dataSource instanceof ej.DataManager) {
                                    $.ajaxSetup({
                                        async: false
                                    });
                                    query = this._findQuery(this.model.dataSourceSettings.connectors, this.model.dataSourceSettings.connectorBinding);
                                    queryPromise = dataSource.executeQuery(eval(query));
                                    queryPromise.done(function (e) {
                                        diagram.retriveData = e.result;
                                        diagram._applyTemplate(diagram.model.dataSourceSettings, e.result, connectors, "connectors");
                                    });
                                } else {
                                    this._applyTemplate(this.model.dataSourceSettings, dataSource, connectors, "connectors");
                                }
                            }
                        }
                    }
                } else if (dataSource instanceof ej.DataManager) {
                    this._initDataSource(dataSourceSettings, nodes, connectors);
                    if (dataSourceSettings.parent)
                        dataSourceApplied = true;
                }
                else if (typeof dataSource != "string" && dataSource.length) {
                    this._applyDataSource(dataSourceSettings, dataSource, nodes, connectors);
                    if (this.model.dataSourceSettings.parent)
                        dataSourceApplied = true;
                }
                var tempNodes = [], tempconnectors = [];
                if (this.nodes().length > 0)
                    tempNodes = this.nodes();
                if (this.connectors().length > 0)
                    tempconnectors = this.connectors();
                this.nodes(nodes);
                this.connectors(connectors);
                var i;
                for (i = 0; i < tempNodes.length; i++) {
                    this.nodes().push(tempNodes[i]);
                    this._nodes = $.extend(true, [], this.nodes());
                }
                for (i = 0; i < tempconnectors.length; i++) {
                    this.connectors().push(tempconnectors[i]);
                    this._connectors = $.extend(true, [], this.connectors());
                }
            }
            var collapsedNodes = this._initNodeCollection(false, dataSourceApplied);
            this._initConnectorCollection(dataSourceApplied);
            if (collapsedNodes.length > 0) {
                this._collapseNodes(collapsedNodes);
            }
            this._cloneModel = $.extend(true, {}, this.model);
        },

        _getSetTool: function () {
            var setTool;
            if (this.model.setTool) {
                if (typeof this.model.setTool === "string") {
                    setTool = ej.util.getObject(this.model.setTool, window);
                }

                if ($.isFunction(this.model.setTool)) {
                    setTool = this.model.setTool;
                }
            }
            return setTool;
        },

        _getNodeTemplate: function () {
            var nodeTemplate;
            if (this.model.nodeTemplate) {
                if (typeof this.model.nodeTemplate === "string") {
                    nodeTemplate = ej.util.getObject(this.model.nodeTemplate, window);
                }
                if ($.isFunction(this.model.nodeTemplate)) {
                    nodeTemplate = this.model.nodeTemplate;
                }
            }
            return nodeTemplate;
        },

        _getConnectorTemplate: function () {
            var connectorTemplate;
            if (this.model.connectorTemplate) {
                if (typeof this.model.connectorTemplate === "string") {
                    this.model.connectorTemplate = ej.util.getObject(this.model.connectorTemplate, window);
                }
                if ($.isFunction(this.model.connectorTemplate)) {
                    connectorTemplate = this.model.connectorTemplate;
                }
            }
            return connectorTemplate;
        },

        _initNodeCollection: function (isLoad, dataSourceApplied) {
            var collapsedNodes = [];
            var nodes = this.nodes();
            var nodeTemplate;
            if (!this.model.dataSourceSettings.dataSource || this._isLoad)
                nodeTemplate = this._getNodeTemplate();
            this._isNodeInitializing = true;
            for (var i = 0; i < nodes.length; i++) {
                if ((nodes[i].container && !$.isEmptyObject(nodes[i].container)) || nodes[i].isSwimlane || nodes[i].type === "swimlane") {
                    i = this._convertGroupChild(nodes[i], nodes);
                    nodes[i] = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, nodes[i]);
                }
                else if (typeof nodes[i].shape !== "object") {
                    nodes[i] = ej.datavisualization.Diagram.NodeType(nodes[i], this);
                }
                if (nodes[i].name == "") {
                    nodes[i].name = "node_" + ej.datavisualization.Diagram.Util.randomId();
                }
                if (nodes[i].type === "swimlane" || nodes[i].isSwimlane) {
                    this.nameTable[nodes[i].name] = ej.datavisualization.Diagram.Group(nodes[i]);

                } else if (nodes[i]._type === "group" || (nodes[i].children && nodes[i].children.length > 0)) {
                    if (nodes[i].type == "bpmn" && nodes[i].container)
                        nodes[i] = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, nodes[i]);
                    else {
                        i = this._convertGroupChild(nodes[i], nodes);
                        nodes[i] = this._getNewGroup(nodes[i]);
                    }
                    nodes[i]._type = "group";
                    this.nameTable[nodes[i].name] = nodes[i];
                    this._initGroupNode(nodes[i]);
                    if (!isLoad && nodes[i].type !== "bpmn")
                        this._udpateChildRotateAngle(nodes[i]);
                } else {
                    if (!dataSourceApplied) {
                        nodes[i] = this._getNewNode(nodes[i]); //ej.datavisualization.Diagram.Node(nodes[i]);
                        this.nameTable[nodes[i].name] = nodes[i];
                    } else if (nodes[i].shape && typeof nodes[i].shape === "object")
                        ej.datavisualization.Diagram.Util._updateShapeProperties(nodes[i]);
                }
                if (!dataSourceApplied && nodeTemplate) {
                    nodeTemplate(this, nodes[i]);
                    if (typeof nodes[i].shape !== "object") {
                        nodes[i] = ej.datavisualization.Diagram.NodeType(nodes[i], this);
                    }
                    if (nodes[i]._type === "group" || (nodes[i].children && nodes[i].children.length > 0)) {
                        if (nodes[i].type == "bpmn" && nodes[i].container)
                            nodes[i] = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, nodes[i]);
                        else
                            nodes[i] = this._getNewGroup(nodes[i]);
                        this._initGroupNode(nodes[i]);
                    }
                }
                if (nodes[i]._type === "node" && nodes[i].labels.length && (nodes[i].width == 0 || nodes[i].height == 0))
                    this._getNodeDimension(nodes[i]);
                this.nameTable[nodes[i].name] = nodes[i];
                this._updateQuad(nodes[i]);
                if (!nodes[i].isExpanded) {
                    collapsedNodes.push(nodes[i]);
                }
                this._setBounds(nodes[i]);
            }
            delete this._isNodeInitializing;
            this._nodes = $.extend(false, [], nodes);
            if (ej.datavisualization.Diagram.Util.canRouteDiagram(this)) {
                this.lineRouting.GenerateVisibilityGraph(this, nodes.length);
                for (var i = 0; i < this._nodes.length; i++) {
                    this._resetValues(this._nodes[i]);
                }
            }
            return collapsedNodes;
        },

        _convertGroupChild: function (group, nodesCollection) {
            if (group.children && group.children.length > 0) {
                for (var i = 0; i < group.children.length; i++) {
                    var child = group.children[i];
                    if (child && typeof child === "string") {
                        child = this.nameTable[child];
                        group.children[i] = child;
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[child.name], child);
                        ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, child, false);
                        if (child.type === "group") {
                            i = this._convertGroupChild(child, group.children);
                        }
                        if (child.type === "connector")
                            ej.datavisualization.Diagram.Util.removeItem(this.connectors(), child);
                        else
                            ej.datavisualization.Diagram.Util.removeItem(this.nodes(), child);
                    }
                }
            }
            var index = nodesCollection.indexOf(group);
            return index;
        },
        _checkFromSwimlane: function (node) {
            if (node) {
                if (node.isSwimlane || node.isLane || node.isLaneStack || node.isPhaseStack || node.isPhase || node.type == "phase")
                    return true;
                if (node.parent) {
                    var parent = this.nameTable[node.parent];
                    if (parent) {
                        return this._checkFromSwimlane(parent);
                    }
                }
            }
            return false
        },
        _setBounds: function (node) {
            if (!this._selectedSymbol && ej.datavisualization.Diagram.Util.canRouteDiagram(this)) {
                if (!node.segments) {
                    if (!this._checkFromSwimlane(node)) {
                        if (this.nodes().length == 1 && !this.lineRouting.router && !this.lineRouting.router.graph)
                            this.lineRouting.GenerateVisibilityGraph(this, this.nodes().length == 1);
                        this.lineRouting.RemoveNode(node);
                        if (!this._isInit) {
                            //this.renderGraph();
                            this._setObstacle();
                            this.lineRouting.AddNode(node);
                        }
                    }
                }
            }
        },
        _setObstacle: function () {
            this.lineRouting.IsDirt = true
        },

        _initConnectorCollection: function (dataSourceApplied) {
            var connectors = this.connectors();
            var connector;
            var connectorTemplate = this._getConnectorTemplate();
            for (var i = 0, len = connectors.length; i < len; i++) {
                connector = dataSourceApplied ? connectors[i] : this._getNewConnector(connectors[i]);
                this.nameTable[connector.name] = connector;
                if (!dataSourceApplied) {
                    if ((this.model.layout && this._layoutType() === ej.datavisualization.Diagram.LayoutTypes.None) || this._isLoad)
                        this._dock(connector, this.nameTable);
                }
                this._updateEdges(connector);
                if (connectorTemplate && !dataSourceApplied) connectorTemplate(this, connector);
                connectors[i] = connector;
                if (this.model.layout && this._layoutType() === ej.datavisualization.Diagram.LayoutTypes.None) {
                    this._isUndo = true;
                    this._routeEdge(connectors[i]);
                    this._isUndo = false;
                }
            }
            this._connectors = $.extend(true, [], connectors);
        },

        //#region Data Source
        _initDataSource: function (dataSourceSettings, nodes, connectors) {
            var dataSource = dataSourceSettings.dataSource;
            var diagram = this;
            if (dataSource.dataSource.json && dataSource.dataSource.json.length > 0) {
                diagram._applyDataSource(dataSourceSettings, dataSource.dataSource.json, nodes, connectors);
            }
            else if (!dataSource.dataSource.table) {
                var mapper = dataSourceSettings;
                if (dataSource instanceof ej.DataManager) {
                    $.ajaxSetup({
                        async: false
                    });
                    var query = this._findQuery(mapper, dataSourceSettings.nodeBinding);
                    var queryPromise = dataSourceSettings["dataSource"].executeQuery(eval(query));
                    queryPromise.done(function (e) {
                        diagram.retriveData = e.result;
                        diagram._applyDataSource(dataSourceSettings, e.result, nodes, connectors);
                    });
                }
            }
        },
        _findQuery: function (mapper, binding) {
            var column = [], queryManager = ej.Query();
            var query = mapper.query || this.model.dataSourceSettings.query;

            if (ej.isNullOrUndefined(query)) {
                var dataSource = mapper.dataSource || this.model.dataSourceSettings.dataSource;
                var tableName = mapper.tableName || this.model.dataSourceSettings.tableName;;
                for (var col in mapper) {
                    if (col !== "tableName" && col !== "dataSource" && col !== "designTemplate" && !col.match("Binding"))
                        if (mapper[col]) column.push(mapper[col]);
                }
                for (var tempcol in binding) {
                    if (tempcol === "labels") {
                        var labels = binding[tempcol];
                        for (var i = 0; i < labels.length; i++) {
                            if (labels[i].text) column.push(labels[i].text);
                        }
                    } else if (tempcol == "shape" || tempcol == "line") {
                        if (binding[tempcol][type]) col.push(binding[tempcol][type]);
                    } else
                        if (binding[tempcol]) column.push(binding[tempcol]);
                }
                if (column.length > 0)
                    queryManager.select(column);
                if (!dataSource["dataSource"].url.match(tableName + "$"))
                    !ej.isNullOrUndefined(tableName) && queryManager.from(tableName);
            } else
                queryManager = query;
            return queryManager;
        },
        _updateMultipleRootNodes: function (obj, rootNodes, mapper, data) {
            var parents = obj[mapper.parent], parent;
            if (parents && parents.length > 0) {
                for (var i = 0; i < parents.length; i++) {
                    parent = parents[i];
                    if (rootNodes[parent])
                        rootNodes[parent].items.push(obj);
                    else
                        rootNodes[parent] = { items: [obj] };
                }
            }
            return rootNodes;
        },

        _applyDataSource: function (mapper, data, nodes, connectors) {
            var rootNodes = [];
            var firstNode, r, i, j, item, node, n, obj, firstLvel, nextLevel, nodeTemplate, connectorTemplate;
            for (r = 0; r < data.length; r++) {
                obj = data[r];
                if (!(Array.isArray(obj[mapper.parent]))) {
                    if (rootNodes[obj[mapper.parent]])
                        rootNodes[obj[mapper.parent]].items.push(obj);
                    else
                        rootNodes[obj[mapper.parent]] = { items: [obj] };
                }
                else
                    rootNodes = this._updateMultipleRootNodes(obj, rootNodes, mapper, data);
                if (mapper.root === obj[mapper.id])
                    firstNode = { items: [obj] };
            }
            firstLvel = [];
            if (mapper.parent) {
                if (firstNode)
                    firstLvel.push(firstNode);
                else {
                    for (n in rootNodes) {
                        if ((!n && n !== 0) || n == "undefined" || n == "\"\"" || n == "null") {
                            firstLvel.push(rootNodes[n]);
                        }
                    }
                }
            }
            else firstLvel.push(rootNodes[undefined]);
            if (this.model.nodeTemplate)
                nodeTemplate = this._getNodeTemplate();
            if (this.model.connectorTemplate)
                connectorTemplate = this._getConnectorTemplate();
            for (i = 0; i < firstLvel.length; i++) {
                for (j = 0; j < firstLvel[i].items.length; j++) {
                    item = firstLvel[i].items[j];
                    node = this._applyNodeTemplate(mapper, item, nodeTemplate);
                    nodes.push(node);
                    if (mapper.parent) {
                        nextLevel = rootNodes[node[mapper.id]];
                        if (nextLevel && nextLevel.items)
                            this._renderChildNodes(mapper, nextLevel, node.name, nodes, connectors, rootNodes, nodeTemplate, connectorTemplate);
                    }
                }
            }
        },

        _getNewNodes: function () {
            var nodes = [], connectors = [];
            for (var name in this.nameTable) {
                var node = this.nameTable[name];
                if (node && node.type === "connector" && node._status === "new") {
                    node._status = "";
                    connectors.push(node);
                }
                else if (node && node._status === "new") {
                    node._status = "";
                    nodes.push(node);
                }
            }
            return { nodes: nodes, connectors: connectors };
        },

        _getUpdatedNodes: function () {
            var nodes = [], connectors = [];
            for (var name in this.nameTable) {
                var node = this.nameTable[name];
                if (node && node.type === "connector" && node._status === "update") {
                    node._status = "";
                    connectors.push(node);
                }
                else if (node && node._status === "update") {
                    node._status = "";
                    nodes.push(node);
                }
            }
            return { nodes: nodes, connectors: connectors };
        },

        _getDeletedNodes: function () {
            var nodes = [], connectors = [];
            for (var i = 0; i < this._crudDeleteNodes.length; i++) {
                var node = this._crudDeleteNodes[i];
                if (node && node.type === "connector")
                    connectors.push(node);
                else if (node) {
                    nodes.push(node);
                }
            }
            this._crudDeleteNodes = [];
            return { nodes: nodes, connectors: connectors };
        },

        _isContainsSameConnector: function (connectors, sourceNode, targetNode) {
            if (sourceNode && targetNode) {
                for (var i = 0; i < connectors.length; i++) {
                    var connector = connectors[i];
                    if (connector && (connector.sourceNode === sourceNode && connector.targetNode === targetNode)) {
                        return true;
                    }
                }
            }
            return false;
        },
        _renderChildNodes: function (mapper, parent, ancestor, nodes, connectors, rootNodes, nodeTemplate, connectorTemplate) {
            var j, child, node, nextLevel;
            for (j = 0; j < parent.items.length; j++) {
                child = parent.items[j];
                node = this._applyNodeTemplate(mapper, child, nodeTemplate);
                var canBreak = false;
                if (!this._collectionContains(node.name, nodes))
                    nodes.push(node);
                else
                    canBreak = true;
                if (!this._isContainsSameConnector(connectors, ancestor, node.name))
                    connectors.push(this._applyConnectorTemplate(mapper, null, ancestor, node.name, connectorTemplate));
                if (!canBreak) {
                    nextLevel = rootNodes[child[mapper.id]]
                    if (nextLevel)
                        this._renderChildNodes(mapper, nextLevel, node.name, nodes, connectors, rootNodes, nodeTemplate, connectorTemplate);
                }
            }
        },
        _applyTemplate: function (mapper, data, collection, collname) {
            var nodeTemplate, i, node, conn, connectorTemplate;
            if (this.model.nodeTemplate)
                nodeTemplate = this._getNodeTemplate();
            if (this.model.connectorTemplate)
                connectorTemplate = this._getConnectorTemplate();
            if (collname == "nodes") {
                for (i = 0; i < data.length; i++) {
                    node = this._applyNodeTemplate(mapper, data[i], nodeTemplate);
                    collection.push(node);
                }
            }
            if (collname == "connectors") {
                for (i = 0; i < data.length; i++) {
                    conn = this._applyConnectorTemplate(mapper, data[i], data[i].sourceNode, data[i].targetNode, connectorTemplate);
                    collection.push(conn);
                }
            }
        },

        _applyNodeTemplate: function (mapper, item, nodeTemplate) {
            var root = item;
            if (root.name === "" || !root.name)
                root.name = ej.datavisualization.Diagram.Util.randomId();
            if (root.type != "group")
                root = this._getNewNode(root);
            else
                root = this._getNewGroup(root);
            if (nodeTemplate) {
                nodeTemplate(this, root);
            }
            if (root._type === "group") {
                //root = this._getNewGroup(root);
                this._initGroupNode(root);
            }
            return root;
        },
        _applyConnectorTemplate: function (mapper, item, sourceNode, targetNode, connectorTemplate) {
            var connector = {};
            connector.name = item && item.name ? item.name : ej.datavisualization.Diagram.Util.randomId();
            connector.sourceNode = sourceNode;
            connector.targetNode = targetNode;
            connector = this._getNewConnector(connector);
            if (connectorTemplate) {
                connectorTemplate(this, connector);
            }
            return connector;
        },
        _collapseNodes: function (nodes) {
            var node;
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                this._collapseChildren(node);
            }
        },
        //#endregion
        //#region Get elements
        _getNewNode: function (options) {
            if (options.shape && typeof options.shape === "object")
                ej.datavisualization.Diagram.Util._updateShapeProperties(options);
            return ej.datavisualization.Diagram.Node($.extend(true, {}, this.model.defaultSettings.node, options));
        },
        _getNewGroup: function (options) {
            var child = null, index = 0;
            if (options.type == "bpmn") options = ej.datavisualization.Diagram.Util._updateBpmnChild(ej.datavisualization.Diagram.Node(options), this);
            if (options.children && options.children.length > 0) {
                for (var i = 0; i < options.children.length; i++) {
                    child = this.nameTable[this._getChild(options.children[i])];
                    if (child) {
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[child.name], child);
                        ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, child);
                        if (child.segments) {
                            index = this.connectors().indexOf(child);
                            delete this.nameTable[child.name];
                            this.nameTable[child.name] = this._getNewConnector(child);
                            if (index >= 0) this.connectors()[index] = this.nameTable[child.name];
                            this._dock(this.nameTable[child.name], this.nameTable);
                            ej.datavisualization.Diagram.Util.updateBridging(this.nameTable[child.name], this);
                        } else if (child._type === "node") {
                            index = this.nodes().indexOf(child);
                            delete this.nameTable[child.name];
                            this.nameTable[child.name] = this._getNewNode(child);
                            if (index >= 0) this.nodes()[index] = this.nameTable[child.name];
                        } else if (child._type === "group") {
                            index = this.nodes().indexOf(child);
                            delete this.nameTable[child.name];
                            this.nameTable[child.name] = this._getNewGroup(child);
                            if (index >= 0) this.nodes()[index] = this.nameTable[child.name];
                        }
                    }
                }
            }
            return ej.datavisualization.Diagram.Group($.extend(false, {}, this.model.defaultSettings.group, options));
        },
        _isEmptyDiagramObject: function (obj) {
            if ($.isEmptyObject(obj))
                return true;
            else {
                for (var prop in obj) {
                    if (typeof obj[prop] === "object")
                        return this._isEmptyDiagramObject(obj[prop]);
                }
            }
            return false;

        },
        _getNewConnector: function (options) {
            var obj = $.extend(true, {}, this.model.defaultSettings.connector, options);
            if (this.model.layout && this.model.layout.type == "organizationalchart")
                obj = $.extend(true, {}, { segments: [{ type: "orthogonal" }] }, obj);
            if (this.model.defaultSettings.connector && (this.model.defaultSettings.connector.segments && this.model.defaultSettings.connector.segments[0])) {
                obj.defaultType = this.model.defaultSettings.connector.segments[0].type;
            }
            if (obj.shape && !this._isEmptyDiagramObject(obj.shape)) {
                if (obj.shape.type == "umlactivity") {
                    obj = ej.datavisualization.Diagram.UMLConnectorShape(obj);
                    if (obj.sourceNode)
                        var sourceNode = this.nameTable[obj.sourceNode];
                    if (obj.targetNode)
                        var targetNode = this.nameTable[obj.targetNode];
                    var node = ej.datavisualization.Diagram.ClassifierHelper.EnableorDisableConnection(targetNode, sourceNode, obj, this);
                    if (node)
                        obj.targetNode = node.name;
                    else
                        obj.targetNode = null;
                }
                if (obj.shape.type == "umlclassifier") {
                    obj = ej.datavisualization.Diagram.UMLConnectorShape(obj);
                    if (obj.sourceNode)
                        var sourceNode = this.nameTable[obj.sourceNode];
                    if (obj.targetNode)
                        var targetNode = this.nameTable[obj.targetNode];
                    var node = ej.datavisualization.Diagram.ClassifierHelper.EnableorDisableConnection(targetNode, sourceNode, obj, this);
                    if (node)
                        obj.targetNode = node.name;
                    else
                        obj.targetNode = null;
                }
                else {
                    obj.shape = $.extend(true, {}, ej.datavisualization.Diagram.ConnectorShapeDefaults, obj.shape);
                    if (obj.shape.flow == "sequence") {
                        if (obj.shape.sequence == "normal")
                            obj = $.extend(true, {}, { segments: [{ type: "straight" }], targetDecorator: { shape: "arrow" }, lineWidth: 2 }, obj);
                        if (obj.shape.sequence == "conditional") {
                            obj = $.extend(true, {}, { segments: [{ type: "straight" }], targetDecorator: { shape: "arrow" }, lineWidth: 2 }, obj);
                            obj.sourceDecorator = { shape: "diamond", fillColor: "white", width: 20, height: 10 };
                        }
                        if (obj.shape.sequence == "default")
                            obj = $.extend(true, { segments: [{ type: "straight" }], targetDecorator: { shape: "arrow" }, lineWidth: 2 }, obj);
                    }
                    if (obj.shape.flow == "association") {
                        if (obj.shape.association == "directional")
                            obj = $.extend(true, {}, { segments: [{ type: "straight" }], lineWidth: 2, lineDashArray: "2 2", targetDecorator: { shape: "openarrow", width: 5, height: 10 } }, obj);
                        if (obj.shape.association == "nondirectional")
                            obj = $.extend(true, {}, { segments: [{ type: "straight" }], lineWidth: 2, lineDashArray: "2 2", targetDecorator: { shape: "none" } }, obj);
                        if (obj.shape.association == "bidirectional") {
                            obj = $.extend(true, {}, { segments: [{ type: "straight" }], lineWidth: 2, lineDashArray: "2 2", targetDecorator: { shape: "openarrow", width: 5, height: 10 } }, obj);
                            obj.sourceDecorator = { shape: "openarrow", width: 5, height: 10 };
                        }
                    }
                    if (obj.shape.flow == "message") {
                        obj = $.extend(true, {}, { segments: [{ type: "straight" }], sourceDecorator: { shape: "circle", fillColor: "white" }, targetDecorator: { shape: "arrow", fillColor: "white" }, lineWidth: 2, lineDashArray: "4 4" }, obj);
                    }
                }

            }

            ej.datavisualization.Diagram.Util._initConnectionEnds(obj, this);
            return ej.datavisualization.Diagram.Connector(obj);
        },
        //#endregion
        _setOverview: function (overview, id) {
            if (overview) {
                this._overview = overview;
                this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
                if (!this._views[overview._id]) {
                    this._views.push(overview._id);
                    this._views[overview._id] = { "context": ej.datavisualization.Diagram.SvgContext, "type": "overview" };
                    overview._renderDocument(this._views[overview._id]);
                    var view = this._views[overview._id];
                    var nodes = this._setNodeZOrder(view);
                    this._renderDiagramObjects(nodes, view, null, true);
                    overview._updateOverview(view);
                }
                delete this._viewPort;
            } else {
                overview = $("#" + id).ejOverview("instance");
                overview._removeDocument(this._views[id]);
                this._views[id] = undefined;
                var index = this._views.indexOf(id);
                this._views.splice(index, 1);
                //this._overview = null;
            }
        },
        _updateScrollOffset: function (hScrollOffset, vScrollOffset, canScale) {
            this._hScrollOffset = Number(hScrollOffset);
            this._vScrollOffset = Number(vScrollOffset);
            this._verticalOffset(Number(vScrollOffset));
            this._horizontalOffset(Number(hScrollOffset));
            this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            ej.datavisualization.Diagram.ScrollUtil._transform(this, hScrollOffset, vScrollOffset, canScale);
            var diagram = this;
            this._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                if (view.type == "overview") {
                    var ovw = $("#" + viewid).ejOverview("instance");
                    if (ovw)
                        ovw._scrollOverviewRect(hScrollOffset, vScrollOffset, diagram._currZoom);
                }
            });
            this.model.scrollSettings.viewPortHeight = this._viewPort.height;
            this.model.scrollSettings.viewPortWidth = this._viewPort.width;
            this.model.scrollSettings.currentZoom = this._currZoom;
        },
        _getChild: function (child) {
            return ej.datavisualization.Diagram.Util.getChild(child);
        },
        _getChildren: function (children) {
            if (children) {
                var children1 = [];
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child) {
                        if (typeof (child) == "object") {
                            children1.push(child.name);
                        } else {
                            children1.push(child);
                        }
                    }
                }
                return children1;
            }
        },
        _initGroupNode: function (group, childTable) {
            var child = null, childNode;
            for (var i = 0; group.children && i < group.children.length; i++) {
                childNode = childTable ? $.extend(true, {}, childTable[this._getChild(group.children[i])]) : group.children[i];
                child = typeof childNode == "string" ? this.nameTable[childNode] : childNode;
                if (child) {
                    if (!child._type && child.type == "umlclassifier")
                        child._type = "group";
                    if (child.container) {
                        child._type = "group"
                        child.labels = child.labels || [];
                    }
                    if (childNode && typeof (childNode) == "object") {
                        if (typeof child.shape !== "object" && group.type != "bpmn")
                            child = ej.datavisualization.Diagram.NodeType(child, this);
                        if (child._type != "group" && !child.children && !child.segments && child.type != "connector") {
                            if (group.type != "bpmn" && group.type != "umlclassifier") {
                                var extendChild = false;
                                if (group.parent) {
                                    var parent1 = this.getNode(group.parent);
                                    if (parent1 && ((parent1.subProcess && parent1.subProcess.events.length > 0) || (parent1.task && parent1.task.events.length > 0))) {
                                        extendChild = true;
                                    }
                                }
                                if (!extendChild) {
                                    child = this._getNewNode(child);
                                }
                            }
                            if (child.name == "")
                                child.name = ej.datavisualization.Diagram.Util.randomId();
                            if (child._type == "node" && child.labels.length && (child.width == 0 || child.height == 0))
                                this._getNodeDimension(child);
                        }
                        else if (child.segments || child.type == "connector") {
                            child = this._getNewConnector(child);
                            if (child.name == "") {
                                child.name = ej.datavisualization.Diagram.Util.randomId();
                            }
                        }
                        else {
                            child = this._getNewGroup(child);
                            if (child.name == "") {
                                child.name = ej.datavisualization.Diagram.Util.randomId();
                            }
                            this._initGroupNode(child);
                        }
                        group.children[i] = child;
                        child.parent = group.name;
                        this.nameTable[child.name] = child;
                        if (child.segments)
                            this._dock(child, this.nameTable);
                    }
                    this._updateQuad(this.nameTable[this._getChild(group.children[i])]);
                }
            }
            if (!this._isLoad) {
                ej.datavisualization.Diagram.Util._updateGroupBounds(group, this);
            }
            if (group._type === "group") {
                this._updateFlipOffset(group, group.flip, this._isLoad && this.model.serializationSettings.preventDefaultValues ? true : false);
            }
            else if (group.parent) {
                var parentNode = this.findNode(group.parent);
                if (parentNode && ((parentNode.subProcess && parentNode.subProcess.events.length > 0) || (parentNode.task && parentNode.task.events.length > 0))) {
                    ej.datavisualization.Diagram.Util._updateGroupBounds(group, this);
                }
            }
        },
        _udpateChildRotateAngle: function (group) {
            var pinx, piny, child;
            if (group.rotateAngle) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, group.rotateAngle, group.offsetX, group.offsetY);
                for (var i = 0; i < group.children.length; i++) {
                    child = this.nameTable[this._getChild(group.children[i])];
                    child.rotateAngle = child.rotateAngle ? child.rotateAngle + group.rotateAngle : group.rotateAngle;
                    child.rotateAngle %= 360;
                    if (child.rotateAngle < 0) child.rotateAngle += 360;
                    if (!(child.segments)) {
                        if (child.type == "group") this._udpateChildRotateAngle(child);
                        var pinx = child.offsetX;
                        piny = child.offsetY;
                        var actualpt = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(pinx, piny));
                        this._translate(child, actualpt.x - pinx, actualpt.y - piny, this.nameTable);
                        this._updateAssociatedConnectorEnds(child, this.nameTable);
                    } else {
                        if (!child.sourceNode)
                            this._setEndPoint(child, ej.Matrix.transform(matrix, child.sourcePoint), false);
                        if (!child.targetNode)
                            this._setEndPoint(child, ej.Matrix.transform(matrix, child.targetPoint), true);
                    }
                }
            }
        },
        _getNodeDimension: function (node) {
            var prevWidth = node._width, prevHeight = node._height;
            var width = node.width ? node.width : (node.maxWidth ? node.maxWidth : node.minWidth);
            var text = document.createElement("span");
            var w = 0, h = 0, label, i;
            if (node.labels.length) {
                ej.datavisualization.Diagram.Util.attr(text, { "id": node.name + "_label", "class": "ej-d-label", "style": "display: inline-block; position: absolute; pointer-events: all; line-height: normal;" });
                this.element[0].appendChild(text);
                for (i = 0; i < node.labels.length; i++) {
                    label = node.labels[i];
                    if (label.bold) text.style.fontWeight = "bold";
                    if (label.italic) text.style.fontStyle = "italic";
                    text.style.textDecoration = label.textDecoration;
                    text.style.fontFamily = label.fontFamily;
                    text.style.fontSize = label.fontSize + "px";
                    text.style.color = label.fontColor;
                    text.style.backgroundColor = label.fillColor;
                    text.style.borderColor = label.borderColor;
                    text.style.borderWidth = label.borderWidth + "px";
                    text.textContent = label.text;
                    if (label.wrapping == "nowrap") {
                        text.style.whiteSpace = "nowrap";
                        text.style.wordWrap = "normal";
                    } else {
                        if (label.wrapping == "wrap") {
                            text.style.wordBreak = "break-all";
                        }
                        text.style.wordWrap = "break-word";
                        text.style.whiteSpace = "pre";

                    }
                    if (node.maxWidth) text.style.maxWidth = width - (label.margin.left + label.margin.right) - label.fontSize + "px";
                    if (node.minWidth) text.style.minWidth = width - (label.margin.left + label.margin.right) - label.fontSize + "px";
                    w += text.offsetWidth + label.margin.left + label.margin.right + 5;
                    h += text.offsetHeight + label.margin.top + label.margin.bottom;
                }
                var type = node.name.match("_attribute") ? "attribute" : (node.name.match("_method") ? "method" : (node.name.match("_member") ? "member" : "header"));
                node._width = Math.max(node.minWidth || 0, w || 0);
                if (node.maxWidth) node._width = Math.min(node.maxWidth, node._width);
                node._height = Math.max(node.minHeight || 0, h || 0);
                if (node.maxHeight) node._height = Math.min(node.maxHeight, node._height);
                if (!node.width && node.labels[0].horizontalAlignment == "left" && type != "attribute" && type != "method" && type != "member") node.offsetX += (node._width - prevWidth) / 2;
                if (!node.width && node.labels[0].horizontalAlignment == "right") node.offsetX -= (node._width - prevWidth) / 2;
                if (!node.height && node.labels[0].verticalAlignment == "top") node.offsetY += (node._height - prevHeight) / 2;
                if (!node.height && node.labels[0].verticalAlignment == "bottom") node.offsetY -= (node._height - prevHeight) / 2;
                if (node.parent) var parent = this.nameTable[node.parent];
                this.element[0].removeChild(text);
            }
        },
        _getMinMaxSize: function (node, width, height, stretch, isExeed) {
            var nw = null, nh = null;
            if (width >= node.minWidth && width <= node.maxWidth) {
                nw = width;
            } else {
                if (node.horizontalAlign == "stretch" && node.parent && !stretch && !isExeed) {
                    var group = this.nameTable[node.parent];
                    if (group) {
                        var rSize = ej.datavisualization.Diagram.Util.bounds(group); // ej.datavisualization.Diagram.SvgContext._measureCanvasSize(group, this);
                        if (rSize.width == 0 && rSize.height == 0) {
                            rSize.width = width;
                            rSize.height = height;
                        }
                        var newSize = this._getMinMaxSize(group, rSize.width, rSize.height);
                        if (group.isSwimlane && group.orientation == "vertical") {
                            var head = this.nameTable[this._getChild(group.children[0])];
                            if (head)
                                newSize.height -= head.height;
                        }
                        newSize.width -= (group.paddingLeft + group.paddingRight + group.marginLeft + group.marginRight);
                        newSize.height -= (group.paddingTop + group.paddingBottom + group.marginTop + group.marginBottom);
                        nw = newSize.width ? newSize.width : width;
                    }
                }
                else if (isExeed) {
                    var group = this.nameTable[node.parent];
                    if (group) {
                        var rSize = ej.datavisualization.Diagram.Util.bounds(group); // ej.datavisualization.Diagram.SvgContext._measureCanvasSize(group, this);
                        var newSize = this._getMinMaxSize(group, rSize.width, rSize.height);
                        nw = newSize.width ? newSize.width : width;
                    }
                }
                else if (width < node.minWidth && node.minWidth != 0)
                    nw = node.minWidth;
                else if (width > node.maxWidth && node.maxWidth != 0 && !node.isSwimlane)
                    nw = node.maxWidth;
                else
                    nw = width;
            }
            if (height >= node.minHeight && height <= node.maxHeight) {
                nh = height;
            } else {
                var group = this.nameTable[node.parent];
                if (node.verticalAlign == "stretch" && node.parent && !stretch && !node.isLane) {
                    var rSize = ej.datavisualization.Diagram.Util.bounds(group);
                    if (rSize.width == 0 && rSize.height == 0) {
                        //rSize.width = width;
                        //rSize.height = height;
                        var status = null;
                        var state = false;
                        rSize.width = node.minWidth;
                        rSize.height = node.minHeight;
                        if (node.minWidth == 0 || node.minHeight == 0) {
                            rSize.width = width;
                            rSize.height = height;
                            status = false;
                            state = true;
                        }
                        if (!state)
                            status = true;
                    }
                    var newSize = this._getMinMaxSize(group, rSize.width, rSize.height);
                    newSize.width -= (group.paddingLeft + group.paddingRight + group.marginLeft + group.marginRight);
                    newSize.height -= (group.paddingTop + group.paddingBottom + group.marginTop + group.marginBottom);
                    if (status) {
                        newSize.height -= node.marginTop;

                    }
                    nh = newSize.height ? newSize.height : height;
                } else if (height < node.minHeight && node.minHeight != 0)
                    nh = node.minHeight;
                else if (height > node.maxHeight && node.maxHeight != 0)
                    nh = node.maxHeight;
                else
                    nh = height;
            }
            return { width: nw, height: nh };
        },
        _updateConnectorBridging: function (baseConnector) {
            var intersectingConnectors = [];
            this.boundaryTable[baseConnector.name] = ej.datavisualization.Diagram.Util.bounds(baseConnector);
            if (baseConnector._intersects && baseConnector._intersects.length)
                intersectingConnectors = baseConnector._intersects;
            for (var q = 0; q < intersectingConnectors.length; q++) {
                var connector = this.nameTable[intersectingConnectors[q]];
                if (connector && connector.visible) {
                    if (connector.segments) {
                        if (connector != baseConnector && ej.datavisualization.Diagram.Util.canBridge(connector, this)) {
                            ej.datavisualization.Diagram.Util.updateBridging(connector, this, [baseConnector]);
                            if (!this._disableSegmentChange)
                                ej.datavisualization.Diagram.DiagramContext._refreshOnlySegments(connector, this);
                        }
                    }
                }
            }
        },
        _drawToolShape: function (type, args) {
            if (type == "image" || type == "native" || type == "html" || type === "text" || type === "basic" || type === "flow" || type === "arrow" || type === "bpmn" || this.activeTool._isPolyline()) {
                this.activateTool("shapeTool", args);
            }
            else if (type == "straightLine") {
                this.activateTool("straightLine", args);
            }
            else if (type == "orthogonalLine") {
                this.activateTool("orthogonalLine", args);
            }
            else if (type == "bezierLine") {
                this.activateTool("bezierLine", args);
            }
        },
        _destroy: function () {
            this.element.empty().removeClass("e-datavisualization-diagram");
            if (this.enableContextMenu()) {
                var menuObj = $("#" + this.element[0].id + "_contextMenu").data("ejMenu");
                menuObj.destroy();
            }
            $("#" + this.element[0].id + "_contextMenu").remove();
        },
        //#endregion      
        _updateRuler: function (option, ruler) {
            var object = {}
            if (option.interval)
                object.interval = option.interval;
            if (option.segmentWidth)
                object.segmentWidth = option.segmentWidth;
            if (option.tickAlignment)
                object.tickAlignment = option.tickAlignment;
            if (option.markerColor)
                object.markerColor = option.markerColor;
            if (option.thickness)
                object.thickness = option.thickness;
            if (option.arrangeTick)
                object.arrangeTick = option.arrangeTick;
            if (!$.isEmptyObject(object))
                $("#" + ruler[0].id).ejRuler(object)
        },
        _updateRulerSettings: function (option) {
            this.updateViewPort();
            if (option.showRulers != undefined ||
                ((option.horizontalRuler && option.horizontalRuler.thickness) || (option.verticalRuler && option.verticalRuler.thickness))) {
                this._svgParentDimention = null;
                this._initViews(true);
                this._initCanvas(true);
            } if (option.horizontalRuler)
                this._updateRuler(option.horizontalRuler, this._hRuler);
            if (option.verticalRuler)
                this._updateRuler(option.verticalRuler, this._vRuler);
            ej.datavisualization.Diagram.SvgContext._updateGrid(this._hScrollOffset, this._vScrollOffset, this._currZoom, this);
            ej.datavisualization.Diagram.ScrollUtil._updateRuler(this, this._hScrollOffset, this._vScrollOffset);
        },
        _updateScrollSettings: function (option) {
            var isLimited = this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Limited ? true : false;
            var scrollableArea = this.model.pageSettings.scrollableArea;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            if (option.horizontalOffset !== undefined || option.verticalOffset !== undefined) {
                var oVal = {
                    zoom: this._getCurrentZoom(), horizontalOffset: this._hScrollOffset,
                    verticalOffset: this._vScrollOffset, viewPort: viewPort
                };
                if ((option.horizontalOffset !== undefined)) {
                    var hValue = Number((typeof option.horizontalOffset === 'function' ? option.horizontalOffset() : option.horizontalOffset));
                    if (!isLimited || (hValue >= scrollableArea.x && hValue <= scrollableArea.x + scrollableArea.width)) {
                        if (this._scrollLimit() == "diagram") {
                            hValue = Math.max(this._hScrollbar.model.minimum, hValue);
                            hValue = Math.min(this._hScrollbar.model.maximum, hValue);
                        }
                        this._updateScrollOffset(hValue, this._verticalOffset());
                    }
                }
                if ((option.verticalOffset !== undefined)) {
                    var vValue = Number((typeof option.verticalOffset === 'function' ? option.verticalOffset() : option.verticalOffset));
                    if (!isLimited || (vValue >= scrollableArea.y && vValue <= scrollableArea.y + scrollableArea.height)) {
                        if (this._scrollLimit() == "diagram") {
                            vValue = Math.max(this._vScrollbar.model.minimum, vValue);
                            vValue = Math.min(this._vScrollbar.model.maximum, vValue);
                        }
                        this._updateScrollOffset(this._horizontalOffset(), vValue);
                    }
                }
                var nVal = {
                    zoom: this._getCurrentZoom(), horizontalOffset: this._hScrollOffset,
                    verticalOffset: this._vScrollOffset, viewPort: viewPort
                };
                this._raiseEvent("scrollChange", { newValues: nVal, oldValues: oVal });
            }
            if (option.zoomFactor)
                this.zoomFactor((typeof option.zoomFactor === 'function' ? option.zoomFactor() : option.zoomFactor));
            if (option.padding) {
                $.extend(this.model.scrollSettings.padding, option.padding);
                this._updateScrollOffset(this._horizontalOffset(), this._verticalOffset());
            }

        },
        updatePageSettings: function (option) {
            if (option) {
                var oldValue = $.extend(true, {}, this.model.pageSettings);
                if (option.pageHeight) {
                    this._pageHeight(Number(typeof option.pageHeight === 'function' ? option.pageHeight() : option.pageHeight));
                }
                if (option.pageWidth) {
                    this._pageWidth(Number(typeof option.pageWidth === 'function' ? option.pageWidth() : option.pageWidth));
                }
                if (typeof option.multiplePage === 'function' || typeof option.multiplePage === "boolean") {
                    this._multiplePage(typeof option.multiplePage === 'function' ? option.multiplePage() : option.multiplePage);
                }
                if (typeof option.showPageBreak === 'function' || typeof option.showPageBreak === "boolean") {
                    this._showPageBreak(typeof option.showPageBreak === 'function' ? option.showPageBreak() : option.showPageBreak);
                }
                if (option.pageBorderColor || option.pageBorderColor === "") {
                    this._pageOrientation(typeof option.pageOrientation === 'function' ? option.pageOrientation() : option.pageOrientation);
                }
                if (option.pageBorderWidth || option.pageBorderWidth === 0) {
                    this._pageBorderWidth(Number(typeof option.pageBorderWidth === 'function' ? option.pageBorderWidth() : option.pageBorderWidth));
                }
                if (option.pageMargin || option.pageMargin === 0) {
                    this._pageMargin(Number(typeof option.pageMargin === 'function' ? option.pageMargin() : option.pageMargin));
                }
                if (option.pageBackgroundColor || option.pageBackgroundColor === "") {
                    this._pageBackgroundColor(typeof option.pageBackgroundColor === 'function' ? option.pageBackgroundColor() : option.pageBackgroundColor);
                }
                if (option.scrollLimit) {
                    this._scrollLimit(typeof option.scrollLimit === 'function' ? option.scrollLimit() : option.scrollLimit);
                }
                if (option.scrollableArea) {
                    this.model.pageSettings.scrollableArea = option.scrollableArea;
                }
                if (option.pageBorderColor || option.pageBorderColor === "") {
                    this._pageBorderColor(typeof option.pageBorderColor === 'function' ? option.pageBorderColor() : option.pageBorderColor);
                }
                this._compareModelProperty("pageSettings");
                if (!this._isUndo)
                    this.addHistoryEntry({ type: "pagesettingschanged", undoObject: oldValue, category: "internal", redoObject: $.extend(true, {}, this.model.pageSettings) });
                ej.datavisualization.Diagram.PageUtil._updatePageSize(this);
                ej.datavisualization.Diagram.SvgContext._updateBackground(this._hScrollOffset, this._vScrollOffset, this._currZoom, this);
                ej.datavisualization.Diagram.SvgContext._updateGrid(this._hScrollOffset, this._vScrollOffset, this._currZoom, this);
            }
        },
        _updateSnapSettings: function (option) {
            if (option) {
                if (option.horizontalGridLines && option.horizontalGridLines.linesInterval)
                    this.model.snapSettings.horizontalGridLines.linesInterval = option.horizontalGridLines.linesInterval;
                if (option.verticalGridLines && option.verticalGridLines.linesInterval)
                    this.model.snapSettings.verticalGridLines.linesInterval = option.verticalGridLines.linesInterval;
                if (option.snapAngle) {
                    this._snapAngle(Number(typeof option.snapAngle === 'function' ? option.snapAngle() : option.snapAngle));
                }
                if (option.snapObjectDistance) {
                    this._snapObjectDistance(Number(typeof option.snapObjectDistance === 'function' ? option.snapObjectDistance() : option.snapObjectDistance));
                }
            }
        },
        //#region Public methods
        _cloneObject: function (node) {
            if ((this.getObjectType(node) === "node" || this.getObjectType(node) === "connector") && node.type != "bpmn") {
                node = $.extend(true, {}, node);
                return node;
            }
            else if ((this.getObjectType(node) === "group" || node.type === "bpmn") && !node.isSwimlane) {
                var group = ($.extend(true, {}, node));
                for (var i = 0; group.children && group.children.length > 0 && i < group.children.length; i++) {
                    group.children[i] = this._cloneObject(this.nameTable[this._getChild(group.children[i])]);
                    group.children[i].parent = group.name;
                }
                return group;
            }
            else if (this.getObjectType(node) === "group" && node.isSwimlane) {
                var swmlnObj = this.getNode(node);
                return swmlnObj;
            }
        },
        _cloneSelectionList: function () {
            var obj = [];
            for (var i = 0 && this.selectionList && this.selectionList.length > 0; i < this.selectionList.length; i++) {
                if (this.getObjectType(this.selectionList[i]) === "pseudoGroup") {
                    var pGroup = this.selectionList[0];
                    for (var j = 0; pGroup.children && pGroup.children.length > 0 && j < pGroup.children.length; j++) {
                        obj.push(this._cloneObject(this.nameTable[this._getChild(pGroup.children[j])]));
                    }
                }
                else {
                    obj.push(this._cloneObject(this.selectionList[i]));
                }
            }
            return obj;
        },
        getNode: function (name, childTable) {
            if (name) {
                return this._getNode(name, childTable);
            }
        },
        addPhase: function (name, options) {
            this._addPhase(name, options);
        },
        stopEvents: function (evt) {
            if (this.activeTool.inAction) {
                if (!evt.originalEvent.target && evt.target) {
                    evt.originalEvent.target = evt.target;
                    this._mouseup(evt);
                }
            }
        },
        _updateSwimlanePhase: function (phase, options, selupdate, updateChildren) {
            if (phase && options) {
                if (options.label) {
                    var psStkNode = this.nameTable[phase.name];
                    if (psStkNode) {
                        this._comparePropertyValues(phase, "label", options);
                        options.label = $.extend(true, {}, options.label);
                        options.label.rotateAngle = (options.orientation === "vertical") ? 270 : 0;
                        options.label.name = psStkNode.labels[0].name;
                        options.label.mode = ej.datavisualization.Diagram.LabelEditMode.View
                        phase.label = options.label;
                        this.updateLabel(psStkNode.name, psStkNode.labels[0], phase.label);
                    }
                }
                if (options.lineColor || options.lineDashArray || options.lineWidth) {
                    var attr = {}
                    if (options.lineColor) {
                        this._comparePropertyValues(phase, "lineColor", options);
                        phase.lineColor = options.lineColor;
                        attr["stroke"] = options.lineColor;
                    }
                    if (options.lineDashArray) {
                        this._comparePropertyValues(phase, "lineDashArray", options);
                        phase.lineDashArray = options.lineDashArray;
                        attr["stroke-dasharray"] = options.lineDashArray;
                    }
                    if (options.lineWidth) {
                        this._comparePropertyValues(phase, "lineWidth", options);
                        phase.lineWidth = options.lineWidth;
                        attr["stroke-width"] = options.lineWidth;
                    }

                    ej.datavisualization.Diagram.SvgContext._updatePhaseStyle(phase, attr, this);
                }
                if (options.fillColor) {
                    this._comparePropertyValues(phase, "fillColor", options);
                    phase.fillColor = options.fillColor;
                    ej.datavisualization.Diagram.DiagramContext.updateNodeStyle(phase, this);
                }
            }
        },
        _updateNodeVisibility: function (node, options) {
            if (node) {
                if (node.type === "group") {
                    for (var i = 0; i < node.children.length; i++) {
                        var child = this.nameTable[this._getChild(node.children[i])];
                        if (child)
                            this._updateNodeVisibility(child, options);
                    }
                }
                if (node.isSwimlane) {
                    var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(this, node);
                    if (phases) {
                        for (var i = 0; i < phases.length; i++) {
                            var phase = this.nameTable[this._getChild(phases[i])];
                            phase.visible = options.visible;
                            ej.datavisualization.Diagram.SvgContext._updatePhaseStyle(phase, options, this);
                        }
                    }
                }
                node.visible = options.visible;
            }
        },

        _compareInnerProperties: function (sElement, tElement) {
            var state = true;
            if (sElement && tElement)
                for (var k in tElement) {
                    if (typeof (sElement[k]) === "object") {
                        state = this._compareInnerProperties(sElement[k], tElement[k]);
                        if (!state)
                            return false;
                    }
                    else if (sElement[k] !== tElement[k])
                        return false
                }
            return true;
        },
        _comparePropertyValues: function (element, property, options, interaction, root) {
            if (element) {
                var resource = null;
                var srobject = element;
                var trobject = options;
                var prCol = property.split(".");
                var prlength = prCol.length;
                if (prlength > 1) {
                    var i = 0;
                    while (prlength > i) {
                        srobject = srobject[prCol[i]]
                        trobject = trobject[prCol[i]]
                        i++;
                        if (srobject && trobject) {
                            if (i == (prlength - 1)) {
                                if (srobject[prCol[i]] != trobject[prCol[i]]) {
                                    resource = {
                                        element: element,
                                        cause: root ? root : (interaction ? ej.datavisualization.Diagram.ActionType.Mouse : ej.datavisualization.Diagram.ActionType.Unknown),
                                        propertyName: prCol[0],
                                        oldValue: srobject,
                                        newValue: trobject
                                    };
                                    this._raisePropertyChange(resource);
                                }
                            }
                        }
                        else
                            break;
                    }
                }
                else {
                    resource = {
                        cause: root ? root : (interaction ? ej.datavisualization.Diagram.ActionType.Mouse : ej.datavisualization.Diagram.ActionType.Unknown),
                        propertyName: property,
                        oldValue: element[property],
                        newValue: options[property]
                    };
                    if ((property !== "labels" && property !== "ports" && property !== "segments") && ((typeof (element[property]) === "object" && !this._compareInnerProperties(element[property], options[property])) || !element[property] || (typeof (element[property]) !== "object" && element[property] != options[property]))) {
                        resource.element = element;
                    }
                    else if (property === "segments") {
                        if (element[property] != options[property]) {
                            resource.element = element;
                        }
                    }
                    else if (property === "labels" || property === "ports") {
                        if (element[property].length > 0) {
                            if (property === "ports")
                                var obj = this._findPort(element, options.name);
                            else
                                obj = this._findLabel(element, options.name);
                            if (!this._compareInnerProperties(obj, options)) {
                                resource.element = obj;
                                resource.oldValue = obj,
                                    resource.newValue = options

                            }
                        }
                    }
                    if (resource.element)
                        this._raisePropertyChange(resource);
                }
            }
        },
        updateNode: function (name, options) {
            if (name) {
                var node = this._findNode(name);
                var matrix = ej.Matrix.identity();
                var bounds, dx, dy, pt;
                var groupAction = false;
                var nodeConstraints = ej.datavisualization.Diagram.NodeConstraints;
                var cont = (node && (node.isSwimlane || node.isLane || node.isPhase || node.type === "phase"));
                if ((cont) || !cont) { // if ((cont && this._needUpdate) || !cont) {
                    this._needUpdate = false;
                    var resource = null;
                    if (node) {
                        if ((node.isSwimlane || node.isLane) && options.header) {
                            var headerObject = options.header;
                            delete options.header;
                            this.model.historyManager.startGroupAction();
                            groupAction = true;
                        }
                        if (!this._isUndo && !this._isSizingCommand)
                            this._recordPropertiesChanged(node, options, "node");
                        if (options.pivot != undefined) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                            ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                            if (options.pivot.x !== undefined) {
                                this._comparePropertyValues(node, "pivot.x", options);
                                var difx = options.pivot.x - node.pivot.x;
                                node.pivot.x = options.pivot.x;
                                node.offsetX += difx * (node.width || node._width || 0);
                            }
                            if (options.pivot.y !== undefined) {
                                this._comparePropertyValues(node, "pivot.y", options);
                                var dify = options.pivot.y - node.pivot.y;
                                node.pivot.y = options.pivot.y;
                                node.offsetY += dify * (node.height || node._height || 0);
                            }
                            pt = ej.Matrix.transform(matrix, { x: node.offsetX, y: node.offsetY });
                            node.offsetX = pt.x;
                            node.offsetY = pt.y;
                        }
                        if (options.offsetX != undefined) {
                            dx = options.offsetX - node.offsetX;
                            if (this._outOfBoundsOnNudge(node, dx, 0)) {
                                resource = { element: node, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "offsetX", oldValue: node.offsetX, newValue: node.offsetX + dx };
                                this._raisePropertyChange(resource);
                                this._translate(node, dx, 0, this.nameTable);
                                if (node.marginLeft != 0) node.marginLeft += dx;
                            }
                        }
                        if (options.offsetY != undefined) {
                            dy = options.offsetY - node.offsetY;
                            if (this._outOfBoundsOnNudge(node, 0, dy)) {
                                resource = { element: node, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "offsetY", oldValue: node.offsetY, newValue: node.offsetY + dy }
                                this._raisePropertyChange(resource);
                                this._translate(node, 0, dy, this.nameTable);
                                if (node.marginTop != 0) node.marginTop += dy;
                            }
                        }
                        if (options.rotateAngle != undefined) {
                            this._comparePropertyValues(node, "rotateAngle", options);
                            this._rotate(node, options.rotateAngle - node.rotateAngle, this.nameTable);
                        }
                        if (!node.isSwimlane && !node.isLane) {
                            var tool = this.tools["resize"];

                            if (options.width != undefined) {
                                node.width = node.width ? node.width : 1;
                                resource = { element: node, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "width", oldValue: node.width, newValue: options.width };
                                this._raisePropertyChange(resource);
                                var swimchild = false;
                                var parsemin = !node.isLane ? false : true;
                                if (tool._outOfBoundsDrag(node, options.width / node.width, 1, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY))) {
                                    this.scale(node, options.width / node.width, 1, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable, swimchild, parsemin);
                                    if (node.type === "bpmn" && node._type === "group")
                                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                                }
                            }
                            if (options.height != undefined) {
                                node.height = node.height ? node.height : 1;
                                resource = { element: node, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "height", oldValue: node.height, newValue: options.height };
                                this._raisePropertyChange(resource);
                                var swimchild = false;
                                var parsemin = !node.isLane ? false : true;
                                if (tool._outOfBoundsDrag(node, 1, options.height / node.height, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY))) {
                                    this.scale(node, 1, options.height / node.height, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable, swimchild, parsemin);
                                    if (node.type === "bpmn" && node._type === "group")
                                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                                }
                            }
                        }
                        else
                            this._updateSwimlaneSize(node, options);
                        if (options.connectorPadding != undefined) {
                            this._comparePropertyValues(node, "connectorPadding", options);
                            node.connectorPadding = options.connectorPadding;
                            this.scale(node, 1, 1, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable);
                        }
                        if (options.visible != undefined) {
                            this._comparePropertyValues(node, "visible", options);
                            this._updateNodeVisibility(node, options);
                            if (!options.visible)
                                this._clearSelection();
                        }
                        if (options.constraints != undefined) {
                            this._comparePropertyValues(node, "constraints", options);
                            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                                if (node._type != "group" || node.type === "bpmn") {
                                    if (node.constraints & nodeConstraints.Shadow || options.constraints & nodeConstraints.Shadow) {
                                        if (!(node.constraints & nodeConstraints.Shadow) && (options.constraints & nodeConstraints.Shadow)) {
                                            node.constraints = options.constraints;
                                            if (node.type === "bpmn" && node.children && (node.shape != "group")) {
                                                ej.datavisualization.Diagram.DiagramContext.updateBPMNNodeStyle(node, this);
                                                ej.datavisualization.Diagram.DiagramContext.renderShadow(this.nameTable[this._getChild(node.children[0])], this);
                                            }
                                            else
                                                ej.datavisualization.Diagram.DiagramContext.renderShadow(node, this);
                                        }
                                        else if ((node.constraints & nodeConstraints.Shadow) && !(options.constraints & nodeConstraints.Shadow)) {
                                            node.constraints = options.constraints;
                                            ej.datavisualization.Diagram.DiagramContext.removeShadow(node, this);
                                        }
                                    }
                                }
                                node.constraints = options.constraints;
                                if (this.selectionList[0] && this.selectionList[0].name === node.name) {
                                    if (ej.datavisualization.Diagram.Util.canSelect(this.selectionList[0])) {
                                        ej.datavisualization.Diagram.SvgContext.clearSelector(this._adornerSvg, this._adornerLayer, this);

                                        ej.datavisualization.Diagram.SvgContext.renderSelector(this.selectionList[0], this._adornerSvg, this._adornerLayer, this._currZoom, this.model.selectedItems.constraints, undefined, this);
                                        if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                                            ej.datavisualization.Diagram.SvgContext.renderUserHandles(this.model.selectedItems.userHandles, this.selectionList[0], this._adornerSvg, this.selectionList[0].type === "pseudoGroup",
                                                this._currZoom, this._adornerLayer, this);
                                    }
                                    else this._clearSelection(true);
                                }
                            }
                        }
                        if (options.fillColor != undefined) {
                            this._comparePropertyValues(node, "fillColor", options);
                            node.fillColor = options.fillColor;
                        }
                        if (options.cssClass != undefined) {
                            this._comparePropertyValues(node, "cssClass", options);
                            node.cssClass = options.cssClass;
                        }
                        if (options.opacity != undefined) {
                            this._comparePropertyValues(node, "opacity", options);
                            node.opacity = options.opacity;
                        }
                        if (options.borderColor != undefined) {
                            this._comparePropertyValues(node, "borderColor", options);
                            node.borderColor = options.borderColor;
                        }
                        if (options.borderWidth != undefined) {
                            this._comparePropertyValues(node, "borderWidth", options);
                            node.borderWidth = options.borderWidth;
                        }
                        if (options.borderDashArray != undefined) {
                            this._comparePropertyValues(node, "borderDashArray", options);
                            node.borderDashArray = options.borderDashArray;
                        }
                        if (options.shadow != undefined) {
                            this._comparePropertyValues(node, "shadow", options);
                            if (node.type === "bpmn" && node.children && (node.shape != "group")) {
                                node.children[0].shadow = ej.datavisualization.Diagram.Shadow($.extend(true, node.children[0].shadow, {}, options.shadow));
                                ej.datavisualization.Diagram.DiagramContext.updateShadow(node.children[0], this);
                            }
                            else {
                                node.shadow = ej.datavisualization.Diagram.Shadow($.extend(true, node.shadow, {}, options.shadow));
                                ej.datavisualization.Diagram.DiagramContext.updateShadow(node, this);
                            }
                        }
                        if (options.gradient !== undefined) {
                            this._comparePropertyValues(node, "gradient", options);
                            if (options.gradient === null)
                                node.gradient = options.gradient;
                            else if (options.gradient && options.gradient.type === "radial")
                                node.gradient = ej.datavisualization.Diagram.RadialGradient(options.gradient);
                            else
                                node.gradient = ej.datavisualization.Diagram.LinearGradient(options.gradient);
                        }
                        if (options.borderGradient !== undefined) {
                            this._comparePropertyValues(node, "borderGradient", options);
                            if (options.borderGradient === null)
                                node.borderGradient = options.borderGradient;
                            else if (options.borderGradient && options.borderGradient.type === "radial")
                                node.borderGradient = ej.datavisualization.Diagram.RadialGradient(options.borderGradient);
                            else
                                node.borderGradient = ej.datavisualization.Diagram.LinearGradient(options.borderGradient);
                        }
                        if (options.isExpanded !== undefined) {
                            this._comparePropertyValues(node, "isExpanded", options);
                            node._updateExpander = true;
                            if (options.isExpanded) {
                                node.isExpanded = true;
                                this._expandChildren(node);
                            }
                            else {
                                node.isExpanded = false;
                                this._collapseChildren(node);
                            }
                            var select;
                            if (this._selectionContains(node)) {
                                select = true;
                                this._clearSelection(true);
                            }
                            this.layout();
                            if (select)
                                this._addSelection(node, true);
                        }
                        if (options.tooltip !== undefined) {
                            this._comparePropertyValues(node, "tooltip", options);
                            node.tooltip = ej.datavisualization.Diagram.Tooltip($.extend(true, node.tooltip, {}, options.tooltip));
                        }
                        if (options.excludeFromLayout != undefined) {
                            this._comparePropertyValues(node, "excludeFromLayout", options);
                            node.excludeFromLayout = options.excludeFromLayout;
                            this.layout();
                        }
                        if (options.flip != undefined) {
                            node.flip = options.flip;
                            if (node._type === "group") {
                                this._updateFlipOffset(node, options.flip);
                            }

                            this._updateAssociatedConnectorEnds(node, this.nameTable);
                        }
                        if (options.addInfo != undefined) {
                            this._comparePropertyValues(node, "addInfo", options);
                            node.addInfo = options.addInfo;
                        }
                        if (options.maxWidth != undefined) {
                            this._comparePropertyValues(node, "maxWidth", options);
                            node.maxWidth = options.maxWidth;
                        }
                        if (options.maxHeight != undefined) {
                            this._comparePropertyValues(node, "maxHeight", options);
                            node.maxHeight = options.maxHeight;
                        }
                        node = this._findNode(name);
                        if (options.shape) {
                            if (typeof options.shape == "object") {
                                this._comparePropertyValues(node, "shape", options);
                                ej.datavisualization.Diagram.Util._updateShapeProperties(options);
                                if (node.type == "html") {
                                    var htmlelement = document.getElementById(node.name + "_parentdiv");
                                    htmlelement.parentNode.removeChild(htmlelement);
                                }
                                ej.datavisualization.Diagram.DiagramContext.setNodeShape(node, this);
                            }

                        }
                        if (this.getObjectType(node) == "node" || node.type == "bpmn")
                            node = this._updateShape(node, options);

                        if (node && node.type != "phase") {
                            ej.datavisualization.Diagram.DiagramContext.update(node, this);
                            if (node.type == "bpmn")
                                ej.datavisualization.Diagram.DiagramContext.updateBPMNNodeStyle(node, this);
                            else
                                ej.datavisualization.Diagram.DiagramContext.updateNodeStyle(node, this);
                        }
                        if (this.selectionList[0] && this.selectionList[0].name === node.name)
                            ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
                    }
                }
                if (name) {
                    var oldabsolutepath;
                    if (options && options.pathData) {
                        oldabsolutepath = node._absolutePath;
                    }
                    var node = this._findNode(name);
                    if (oldabsolutepath) {
                        node._absolutePath = oldabsolutepath;
                        node._absoluteBounds = null;
                    }
                    if (node && node._type === "node" && options && options.type === "group" && options.children && options.children.length > 0) {
                        var isRendered = false;
                        if (this._svg.document.getElementById(node.name))
                            isRendered = true;
                        this.remove(node);
                        node.borderColor = "transparent";
                        node.borderDashArray = "";
                        node.borderWidth = 1;
                        node.fillColor = "#1BA0E2";
                        node.labels = [];
                        node.fillColor = "";
                        node.type = options.type;
                        node.children = options.children;
                        node = ej.datavisualization.Diagram.Group(node);
                        this._initGroupNode(node);
                        if (isRendered) {
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                            this.add(node);
                        }
                    }
                }
                if (node && (node.isLane || node.isSwimlane || node.type === "phase" || node.isPhase)) {
                    this._needUpdate = true;
                    options.header = headerObject;
                    if (node.isLane)
                        this._updateLane(node, options);
                    else if (node.isSwimlane) {
                        this._needUpdate = false;
                        this._updateSwimlane(node, options, true);
                    }
                    else if (node.type === "phase" || node.phase) {
                        this._needUpdate = false;
                        if (options.offset) {
                            this._updatePhase({ name: node.name, offset: options.offset });
                        }
                        this._updateSwimlanePhase(node, options);
                    }
                }
                if (groupAction) {
                    this.model.historyManager.closeGroupAction();
                }
            }
        },

        _updateFlipOffset: function (group, flip, isLoad) {
            if (group && group.children && !group.isSwimlane && !group.lane && group.type !== "bpmn") {
                var nodes = this._getChildren(group.children);
                if (isLoad && flip && flip !== "none" && flip !== "both") {
                    group._flipRotateAngle = true;
                }
                if (group._flipRotateAngle) {
                    group.rotateAngle = 360 - group.rotateAngle;
                    delete group._flipRotateAngle;
                }
                if (flip && flip !== "none" && flip !== "both") {
                    group.rotateAngle = 360 - group.rotateAngle;
                    group._flipRotateAngle = true;
                }
                for (var i = 0; i < nodes.length; i++) {
                    var child = this.nameTable[this._getChild(nodes[i])];
                    child._flip = flip;
                    if (isLoad && flip && flip !== "none" && flip !== "both") {
                        child._flipRotateAngle = true;
                    }
                    if (child._flipRotateAngle) {
                        child.rotateAngle = 360 - child.rotateAngle;
                        delete child._flipRotateAngle;
                    }
                    if (flip && flip !== "none" && flip !== "both") {
                        child.rotateAngle = 360 - child.rotateAngle;
                        child._flipRotateAngle = true;
                    }
                    if (child._type !== "Group") {
                        if (isLoad && (flip === ej.datavisualization.Diagram.FlipDirection.Horizontal || flip === ej.datavisualization.Diagram.FlipDirection.Both)) {
                            child._flipOffsetX = true;
                        }
                        if (isLoad && (flip === ej.datavisualization.Diagram.FlipDirection.Vertical || flip === ej.datavisualization.Diagram.FlipDirection.Both)) {
                            child._flipOffsetY = true;
                        }
                        if (child._flipOffsetX) {
                            child.offsetX = (group.offsetX - child.offsetX) + group.offsetX;
                            delete child._flipOffsetX;
                        }
                        if (child._flipOffsetY) {
                            child.offsetY = (group.offsetY - child.offsetY) + group.offsetY;
                            delete child._flipOffsetY;
                        }
                        if (flip === ej.datavisualization.Diagram.FlipDirection.Horizontal || flip === ej.datavisualization.Diagram.FlipDirection.Both) {
                            child._flipOffsetX = true;
                        }
                        if (flip === ej.datavisualization.Diagram.FlipDirection.Vertical || flip === ej.datavisualization.Diagram.FlipDirection.Both) {
                            child._flipOffsetY = true;
                        }
                        if (child._flipOffsetX)
                            child.offsetX = (group.offsetX - child.offsetX) + group.offsetX;
                        if (child._flipOffsetY)
                            child.offsetY = (group.offsetY - child.offsetY) + group.offsetY;
                        if (flip === ej.datavisualization.Diagram.FlipDirection.None)
                            delete child._flip;
                    }
                    else {
                        this._updateFlipOffset(child, flip);
                    }
                    this._updateAssociatedConnectorEnds(child, this.nameTable);
                }
            }
        },
       
        _updateSwimlaneSize: function (object, options) {
            if (object) {
                if (options.height) {
                    this._comparePropertyValues(object, "height", options);
                    var dif = options.height - object.height;
                    this._comparePropertyValues(object, "offsetY", { offsetY: object.offsetY + (dif / 2) });
                }
                if (options.width) {
                    this._comparePropertyValues(object, "width", options);
                    var dif = options.width - object.width;
                    this._comparePropertyValues(object, "offsetX", { offsetX: object.offsetX + (dif / 2) });
                }
                if (object.isSwimlane && (options.height || options.width)) {
                    var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(this, object);
                    if (lanes.length > 0) {
                        var lastLane = this.nameTable[this._getChild(lanes[lanes.length - 1])];
                        if (lastLane) {
                            if (object.orientation === "vertical") {
                                if (options.width) {
                                    if (options.width > object.width) {
                                        lastLane.minWidth = lastLane.width + options.width - object.width;
                                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, lastLane, true);
                                    }
                                }
                                if (options.height) {
                                    for (var i = 0; i < lanes.length; i++) {
                                        var lane = this.nameTable[this._getChild(lanes[i])];
                                        if (options.height >= object.height)
                                            lane.minHeight = options.height;
                                    }
                                }
                            }
                            else {
                                if (options.width) {
                                    for (var i = 0; i < lanes.length; i++) {
                                        var lane = this.nameTable[this._getChild(lanes[i])];
                                        if (options.width >= object.width)
                                            lane.minWidth = options.width;
                                    }
                                }
                                if (options.height) {
                                    if (options.height > object.height) {
                                        lastLane.minHeight = lastLane.height + options.height - object.height;
                                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, lastLane, true);
                                    }
                                }
                            }
                            ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, object, true);
                            ej.datavisualization.Diagram.canvasHelper._updateLastPhase(this, object);

                        }
                    }
                }
                else if (object.isLane && (options.height || options.width)) {
                    var swimlane = this.nameTable[object.parent.split("laneStack")[0]];
                    var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(this, swimlane);
                    ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                    if (swimlane && swimlane.orientation === "vertical") {
                        if (options.width) {
                            options.minWidth = options.width;
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, object, true);
                        }
                        if (options.height) {
                            for (var i = 0; i < lanes.length; i++) {
                                var lane = this.nameTable[this._getChild(lanes[i])];
                                if (options.height >= lane.height) {
                                    lane.minHeight = options.height;
                                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, lane, true);
                                }
                            }
                        }
                    }
                    else {
                        if (options.width) {
                            for (var i = 0; i < lanes.length; i++) {
                                var lane = this.nameTable[this._getChild(lanes[i])];
                                if (options.width >= lane.width) {
                                    lane.minWidth = options.width;
                                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, lane, true);
                                }
                            }
                        }
                        if (options.height) {
                            options.minHeight = options.height;
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, object, true);
                        }
                    }
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, swimlane, true);
                    ej.datavisualization.Diagram.canvasHelper._updateLastPhase(this, swimlane);
                }
            }
        },

        _updateShape: function (node, options) {
            var isShapeModified = false;
            if (options.type) {
                this._comparePropertyValues(node, "type", options);
                node.type = node._shape = options.type;
                isShapeModified = true;
            }
            if (options.shape) {
                this._comparePropertyValues(node, "shape", options);
                node.shape = node._shape = options.shape;
                isShapeModified = true;
            }
            if (node.type != "bpmn") {
                if (options.cornerRadius != undefined) {
                    this._comparePropertyValues(node, "cornerRadius", options);
                    node.cornerRadius = options.cornerRadius;
                    isShapeModified = true;
                }
                if (options.pathData) {
                    this._comparePropertyValues(node, "pathData", options);
                    node.pathData = options.pathData;
                    isShapeModified = true;
                }
                if (options.templateId !== undefined) {
                    node.templateId = options.templateId;
                    isShapeModified = true;
                }
                if (options.html !== undefined) {
                    this._comparePropertyValues(node, "html", options);
                    node.html = options.html;
                    isShapeModified = true;
                }
                if (options.contentId !== undefined) {
                    this._comparePropertyValues(node, "contentId", options);
                    node.contentId = options.contentId;
                    isShapeModified = true;
                }
                if (options.source) {
                    this._comparePropertyValues(node, "source", options);
                    node.source = options.source;
                    isShapeModified = true;
                }
                if (options.textBlock) {
                    this._comparePropertyValues(node, "textBlock", options);
                    node.textBlock = options.textBlock;
                    isShapeModified = true;
                }
                if (options.points) {
                    this._comparePropertyValues(node, "points", options);
                    node.points = options.points;
                    isShapeModified = true;
                }
                if (isShapeModified) {
                    if (node.children) delete node.children;
                    node = ej.datavisualization.Diagram.NodeType(node, this);
                    var htmlelement = document.getElementById(node.name + "_parentdiv");
                    if (htmlelement)
                        htmlelement.parentNode.removeChild(htmlelement);
                    ej.datavisualization.Diagram.DiagramContext.setNodeShape(node, this);
                    this._clearSelection(true);
                    this._addSelection(node, true);
                }
            }
            else {
                var shape = $.extend(true, {}, this.nameTable[node.name]);
                if (options.event) {
                    this._comparePropertyValues(node, "event", options);
                    shape.event = options.event;
                    isShapeModified = true;
                }
                if (options.trigger) {
                    this._comparePropertyValues(node, "trigger", options);
                    shape.trigger = options.trigger;
                    isShapeModified = true;
                }
                if (options.gateway) {
                    this._comparePropertyValues(node, "gateway", options);
                    shape.gateway = options.gateway;
                    isShapeModified = true;
                }
                if (options.data) {
                    this._comparePropertyValues(node, "data", options);
                    shape.data = $.extend(shape.data, options.data);;
                    isShapeModified = true;
                }
                if (options.activity) {
                    this._comparePropertyValues(node, "activity", options);
                    shape.activity = options.activity;
                    isShapeModified = true;
                }
                if (options.task !== undefined) {
                    this._comparePropertyValues(node, "task", options);
                    shape.task = $.extend(shape.task, options.task);
                    isShapeModified = true;
                }
                if (options.annotation !== undefined) {
                    this._comparePropertyValues(node, "annotation", options);
                    shape.annotation = $.extend(shape.annotation, options.annotation);
                    isShapeModified = true;
                }
                if (options.subProcess !== undefined) {
                    this._comparePropertyValues(node, "subProcess", options);
                    shape.subProcess = $.extend(shape.subProcess, options.subProcess);
                    isShapeModified = true;
                }
                if (options.direction) {
                    this._comparePropertyValues(node, "direction", options);
                    shape.direction = options.direction;
                    isShapeModified = true;
                }
                if (isShapeModified) {
                    var nextNode = this._svg.getElementById(node.name).nextSibling;
                    this._removeElement(node);
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[node.name], node);
                    ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.nameTable[node.name]);
                    this._nodes = $.extend(true, [], this.nodes());
                    node = ej.datavisualization.Diagram.NodeType(shape, this);
                    if (node.type == "bpmn" && node.container)
                        node = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, node);
                    else
                        node = this._getNewGroup(node);
                    this._initGroupNode(node);
                    this.nameTable[node.name] = node;
                    this.nodes().push(node);
                    if (node.parent) {
                        var parentNode = this.nameTable[node.parent];
                        if (parentNode) {
                            var index1 = this._getChildIndexFromParent(parentNode, node.name);
                            parentNode.children[index1] = node;
                        }
                    }
                    this._nodes = $.extend(true, [], this.nodes());
                    this._updateQuad(node);
                    ej.datavisualization.Diagram.DiagramContext.renderGroup(node, this);
                    if (nextNode) this._svg.getElementById(node.name).parentNode.insertBefore(this._svg.getElementById(node.name), this._svg.getElementById(nextNode.id));
                    this._clearSelection(true);
                    this._addSelection(node, true);
                }
            }
            return node;
        },

        _getChildIndexFromParent: function (parentNode, childName) {
            for (var i = 0; i < parentNode.children.length; i++) {
                var child = parentNode.children[i];
                child = typeof child === "object" ? child.name : child;
                if (child === childName) {
                    return i;
                }
            }
            return null;
        },

        _updateObject: function (node) {
            if (node) {
                if (node.type == "pseudoGroup") {
                    var child;
                    var children = this._getChildren(node.children);
                    for (var i = 0, len = children.length; i < len; i++) {
                        child = this.nameTable[this._getChild(children[i])];
                        ej.datavisualization.Diagram.DiagramContext.update(child, this);
                    }
                }
                else {
                    if (node.parent) {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(this.nameTable[node.parent], this);
                    }
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                }
            }
        },
        _udatePhaseSize: function (node, options) {
            var phsStack = this.nameTable[this._getChild(node.children[1])];
            if (node.orientation === "vertical") {
                if (phsStack.minWidth != options.phaseSize) {
                    phsStack.width = phsStack.maxWidth;
                    phsStack.minWidth = options.phaseSize;
                    var xdif = phsStack.maxWidth - options.phaseSize;
                    var xVar = (options.phaseSize / phsStack.maxWidth)
                    phsStack.maxWidth = options.phaseSize;
                    this.scale(phsStack, xVar, .0001, ej.datavisualization.Diagram.Point(phsStack.offsetX, phsStack.offsetY), this.nameTable);
                    if (phsStack.children && phsStack.children.length > 0) {
                        for (var i = 0; i < phsStack.children.length; i++) {
                            var child = this.nameTable[this._getChild(phsStack.children[i])];
                            if (child) {
                                this.scale(child, xVar, .0001, ej.datavisualization.Diagram.Point(child.offsetX, child.offsetY), this.nameTable);
                            }
                        }
                    }
                    var laneStack = this.nameTable[this._getChild(node.children[2])];
                    laneStack.marginLeft -= xdif;
                }
            }
            else if (node.orientation === "horizontal") {
                if (phsStack.minHeight != options.phaseSize) {
                    phsStack.height = phsStack.maxHeight;
                    phsStack.minHeight = options.phaseSize;
                    var ydif = phsStack.maxHeight - options.phaseSize;
                    var yVar = (options.phaseSize / phsStack.maxHeight)
                    yVar = (yVar === Infinity) ? 0 : yVar;
                    phsStack.maxHeight = options.phaseSize;
                    this.scale(phsStack, .0001, yVar, ej.datavisualization.Diagram.Point(phsStack.offsetX, phsStack.offsetY), this.nameTable);
                    if (phsStack.children && phsStack.children.length > 0) {
                        for (var i = 0; i < phsStack.children.length; i++) {
                            var child = this.nameTable[this._getChild(phsStack.children[i])];
                            if (child) {
                                this.scale(child, .0001, yVar, ej.datavisualization.Diagram.Point(child.offsetX, child.offsetY), this.nameTable);
                            }
                        }
                    }
                    var laneStack = this.nameTable[this._getChild(node.children[2])];
                    laneStack.marginTop -= ydif;
                }
            }
        },

        _updateLane: function (node, options) {
            if (node && options) {
                //#region updateHeader 
                if (options.header) {
                    this._comparePropertyValues(this.getNode(node.name), "header", options);
                    if (node.children && node.children.length > 0) {
                        var hdname, head;
                        hdname = this._getChild(node.children[0]);
                        if (hdname) {
                            head = this.nameTable[hdname];
                        }
                        if (head) {
                            this.updateLabel(head.name, head.labels[0], options.header);
                            if (options.header.fillColor && options.header.fillColor != head.fillColor) {
                                this.updateNode(head.name, { fillColor: options.header.fillColor })
                            }
                        }
                    }
                }
                //#endregion
                if (options.fillColor && options.fillColor != node.fillColor) {
                    this._comparePropertyValues(node, "fillColor", options);
                    this.updateNode(node.name, { fillColor: options.fillColor })
                }
                if ((options.minHeight && options.minHeight != node.minHeight) || (options.minWidth && options.minWidth != node.minWidth)) {
                    if (options.minHeight) {
                        this._comparePropertyValues(node, "minHeight", options);
                        node.minHeight = options.minHeight;
                    }
                    if (options.minWidth) {
                        this._comparePropertyValues(node, "minWidth", options);
                        node.minWidth = options.minWidth;
                    }
                    var laneStack = this.nameTable[node.parent];
                    if (laneStack) {
                        var swimlane = this.nameTable[laneStack.parent];
                        if (swimlane)
                            ej.datavisualization.Diagram.SwimLaneContainerHelper._updateSwimlane(this, swimlane);
                    }
                    ej.datavisualization.Diagram.canvasHelper._updateLastPhase(this, swimlane);
                    ej.datavisualization.Diagram.SvgContext.updateSelector(swimlane, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
                }

                if (options.constraints && options.constraints != node.constraints) {
                    this._comparePropertyValues(node, "constraints", options);
                    node.constraints = options.constraints;
                }
            }
        },
        _updateLastPhase: function (node, options, needUpdate) {
            if (node.isSwimlane) {
                if (node.phases && node.phases.length == 1) {
                    var df = 0;
                    var phase = this.nameTable[this._getChild(node.phases[0])];
                    if (node.orientation === "horizontal") {
                        phase.offset = node.minWidth - df;
                        this.updateNode(this.nameTable["phaseStack" + this._getChild(node.phases[0])].name, { width: node.minWidth - df });
                        if (needUpdate) {
                            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                            this.updateNode(this.nameTable["phaseStack" + this._getChild(node.phases[0])].name, { offsetX: bounds.x + node.width / 2 });
                        }
                    } else if (node.orientation === "vertical") {
                        phase.offset = node.minHeight - df
                        var height = phase.offset - df;
                        height = height - (options.header ? options.header.height : 50);
                        this.updateNode(this.nameTable["phaseStack" + this._getChild(node.phases[0])].name, { height: height });

                        if (needUpdate) {
                            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                            this.updateNode(this.nameTable["phaseStack" + this._getChild(node.phases[0])].name, { offsetY: (options.header ? options.header.height : 50) / 2 + bounds.y + node.height / 2 });
                        }
                    }
                }
            }
        },
        _updateSwimlane: function (node, options, update) {
            //#region updateHeader 
            if (options.header) {
                if (node.children && node.children.length > 0) {
                    var hdname, head;
                    hdname = this._getChild(node.children[0]);
                    if (hdname) {
                        head = this.nameTable[hdname];
                    }
                    if (head) {
                        this._comparePropertyValues(this.getNode(node.name), "header", options);
                        this.updateLabel(head.name, head.labels[0], options.header);
                        if (options.header.fillColor && options.header.fillColor != head.fillColor) {
                            this.updateNode(head.name, { fillColor: options.header.fillColor })
                        }
                    }
                }
            }
            for (var item in options) {
                if (node[item]) {
                    if (options[item] !== node[item]) {
                        if (item === "offsetX") {
                            this._comparePropertyValues(this.getNode(node.name), "offsetX", options);
                            var dx = options.offsetX - node.offsetX;
                            if (this._outOfBoundsOnNudge(node, dx, 0))
                                this._translate(node, dx, 0, this.nameTable);
                        }
                        else if (item === "offsetY") {
                            this._comparePropertyValues(this.getNode(node.name), "offsetY", options);
                            var dy = options.offsetY - node.offsetY;
                            if (this._outOfBoundsOnNudge(node, 0, dy))
                                this._translate(node, 0, dy, this.nameTable);
                        }
                        else if (item !== "minWidth" && item !== "minHeight" && item !== "maxwidth" && item !== "maxHeight" && item != "width" && item != "height" && item != "phaseSize")
                            node[item] = options[item];
                    }
                }
            }
            //#region phases
            if (options.phases && options.phases.length > 0) {
                var phase;
                for (var i = 0; i < options.phases.length; i++) {
                    phase = this.nameTable[this._getChild(options.phases[i])];
                    if (phase)
                        this._updateSwimlanePhase(phase, options.phases[i], true);
                }
            }
            if (update) {
                if ((options.phaseSize || options.phaseSize === 0) && (options.phaseSize !== node.phaseSize)) {
                    this._comparePropertyValues(this.getNode(node.name), "phaseSize", options);
                    if (options.phaseSize != node.phaseSize)
                        var lastPhase = true;
                    var phaseStack = this.nameTable[node.name + "phaseStack"];
                    var laneStack = this.nameTable[node.name + "laneStack"];
                    var phase;
                    var d = options.phaseSize - node.phaseSize;
                    for (var i = 0; i < phaseStack.children.length; i++) {
                        phase = this.nameTable[this._getChild(phaseStack.children[i])];
                        if (phase) {
                            options.phaseSize = options.phaseSize === 0 ? .0001 : options.phaseSize;
                            node.orientation === "horizontal" ? phase.height = options.phaseSize : phase.width = options.phaseSize;
                        }
                    }
                    node.phaseSize += d;
                    node.orientation === "horizontal" ? laneStack.marginTop += d : laneStack.marginLeft += d;
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, phaseStack, null, node);
                }
            }
            //#endregion
            //#region lanes
            if (options.lanes && options.lanes.length > 0) {
                var lane;
                for (var i = 0; i < options.lanes.length; i++) {
                    lane = this.nameTable[this._getChild(options.lanes[i])];
                    if (lane) {
                        this._updateLane(lane, options.lanes[i]);
                    }
                }
            }
            //#endregion
            if (!update) {
                if (options && options.phaseSize)
                    var isPhaseUpdate = false;

                if (options.minHeight && options.minHeight != node.minHeight) {
                    this._comparePropertyValues(this.getNode(node.name), "minHeight", options);
                    node.minHeight = options.minHeight;
                    isPhaseUpdate = true;
                }
                if (options.minWidth && options.minWidth != node.minWidth) {
                    this._comparePropertyValues(this.getNode(node.name), "minWidth", options);
                    node.minWidth = options.minWidth;
                    isPhaseUpdate = true;
                }
                if (options.maxHeight && options.maxHeight != node.maxHeight) {
                    this._comparePropertyValues(this.getNode(node.name), "maxHeight", options);
                    node.minHeight = options.maxHeight;
                    isPhaseUpdate = true;
                }
                if (options.maxWidth && options.maxWidth != node.maxWidth) {
                    this._comparePropertyValues(this.getNode(node.name), "maxWidth", options);
                    node.minWidth = options.maxWidth;
                    isPhaseUpdate = true;
                }
                if (isPhaseUpdate && !this._isUndo) {
                    this._updateLastPhase(node, options);
                };
                if ((options.phaseSize || (options.phaseSize === 0)) && options.phaseSize != node.phaseSize) {
                    this._comparePropertyValues(this.getNode(node.name), "phaseSize", options);
                    this._udatePhaseSize(node, options);
                    if (options.phaseSize === 0)
                        node.phaseSize = 0;
                }
            }
            ej.datavisualization.Diagram.DiagramContext.update(node, this);
            if (this.selectionList[0] && this.selectionList[0].name === node.name)
                ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
        },

        updateConnector: function (name, options) {
            if (name) {
                var connector = this._findConnector(name);
                if (connector) {
                    if (!this._isUndo && !ej.datavisualization.Diagram.Util.canRouteDiagram(this))
                        this._recordPropertiesChanged(connector, options, "connector");
                    if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                        if (options.constraints !== undefined) {
                            this._comparePropertyValues(connector, "constraints", options);
                            connector.constraints = options.constraints;
                            if (!ej.datavisualization.Diagram.Util.canSelect(connector) && ej.datavisualization.Diagram.Util.enableLayerOption(connector, "lock", this))
                                this._clearSelection(true);
                        }
                    }
                    if (options.lineColor) {
                        this._comparePropertyValues(connector, "lineColor", options);
                        connector.lineColor = options.lineColor;
                    }
                    if (options.cssClass || options.cssClass === "") {
                        this._comparePropertyValues(connector, "cssClass", options);
                        connector.cssClass = options.cssClass;
                    }
                    if (options.lineWidth || options.lineWidth === 0) {
                        this._comparePropertyValues(connector, "lineWidth", options);
                        connector.lineWidth = options.lineWidth;
                    }
                    if (options.lineDashArray !== undefined) {
                        this._comparePropertyValues(connector, "lineDashArray", options);
                        connector.lineDashArray = options.lineDashArray;
                    }
                    if (connector.shape && connector.shape.type == "umlclassifier") {
                        if (options.shape && options.shape.multiplicity != undefined) {
                            connector.shape.multiplicity = options.shape.multiplicity;
                            connector.shape.multiplicity = ej.datavisualization.Diagram.UMLConnectorMultiplicity(connector.shape.multiplicity);
                            var labels = ej.datavisualization.Diagram.ClassifierHelper.umlConnectorMultiplicity(connector)
                            for (var i = 0; i < connector.labels.length; i++) {
                                if (connector.labels[i].name == connector.name + "_sourcelabel")
                                    connector.labels[i].text = labels[0].text;
                                else if (connector.labels[i].name == connector.name + "_targetlabel")
                                    connector.labels[i].text = labels[1].text;
                            }
                        }
                    }
                    if (options.opacity !== undefined) {
                        this._comparePropertyValues(connector, "opacity", options);
                        connector.opacity = options.opacity;
                    }
                    if (options.cornerRadius !== undefined) {
                        this._comparePropertyValues(connector, "cornerRadius", options);
                        connector.cornerRadius = options.cornerRadius;
                    }
                    if (options.lineHitPadding !== undefined) {
                        this._comparePropertyValues(connector, "lineHitPadding", options);
                        connector.lineHitPadding = options.lineHitPadding;
                    }
                    if (options.sourcePadding != undefined) {
                        this._comparePropertyValues(connector, "sourcePadding", options);
                        connector.sourcePadding = options.sourcePadding;
                        this._dock(connector, this.nameTable);
                    }
                    if (options.targetPadding != undefined) {
                        this._comparePropertyValues(connector, "targetPadding", options);
                        connector.targetPadding = options.targetPadding;
                        this._dock(connector, this.nameTable);
                    }
                    if (options.visible != undefined) {
                        this._comparePropertyValues(connector, "visible", options);
                        connector.visible = options.visible;
                        if (!options.visible)
                            this._clearSelection();
                    }
                    if (options.flip !== undefined) {
                        connector.flip = options.flip;
                        ej.datavisualization.Diagram.Util.flipConnector(connector, connector.flip);

                    }
                    if (options.bridgeSpace != undefined) {
                        this._comparePropertyValues(connector, "bridgeSpace", options);
                        connector.bridgeSpace = options.bridgeSpace;
                    }
                    if (options.tooltip !== undefined) {
                        this._comparePropertyValues(connector, "tooltip", options);
                        connector.tooltip = ej.datavisualization.Diagram.Tooltip($.extend(true, connector.tooltip, {}, options.tooltip));
                    }
                    if (options.segments) {
                        this._comparePropertyValues(connector, "segments", options);
                        if (options.segments.length > 1) {
                            var newarray = $.extend(true, [], options.segments);
                            connector.segments = newarray;
                        }
                        else {
                            connector.segments = options.segments;
                        }
                        ej.datavisualization.Diagram.Util._initConnectionEnds(connector, this);
                        if (this.model.defaultSettings.connector && this.model.defaultSettings.connector.segments && this.model.defaultSettings.connector.segments.length) {
                            var defaultType = this.model.defaultSettings.connector.segments[0].type;
                        }
                        ej.datavisualization.Diagram.Util._initializeSegments(connector, defaultType);
                        this._dock(connector, this.nameTable);
                        ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                        //this._updateQuad(this, connector);
                        if (connector == this.selectionList[0]) {
                            ej.datavisualization.Diagram.SvgContext.clearSegments(this._adornerSvg);
                            ej.datavisualization.Diagram.SvgContext.addSegments(this._adornerSvg, this.selectionList[0], this._currZoom);

                        }
                    }
                    var decorator;
                    if (options.targetDecorator) {
                        this._comparePropertyValues(connector, "targetDecorator", options);
                        if (connector.targetDecorator) {
                            decorator = $.extend(true, {}, connector.targetDecorator, options.targetDecorator);
                        } else {
                            decorator = ej.datavisualization.Diagram.Decorator(options.targetDecorator);
                        }

                        connector.targetDecorator = decorator;
                    }
                    if (options.sourceDecorator) {
                        this._comparePropertyValues(connector, "sourceDecorator", options);
                        if (connector.sourceDecorator) {
                            decorator = $.extend(true, {}, connector.sourceDecorator, options.sourceDecorator);
                        } else {
                            decorator = ej.datavisualization.Diagram.Decorator(options.sourceDecorator);
                        }
                        connector.sourceDecorator = decorator;
                    }
                    if (options.sourceDecorator || options.targetDecorator) {
                        ej.datavisualization.Diagram.DiagramContext.clearDecorators(connector, this);
                        ej.datavisualization.Diagram.DiagramContext.renderDecorators(connector, this);
                    }
                    if (options.hasOwnProperty("sourceNode") || options.hasOwnProperty("targetNode") || options.hasOwnProperty("targetPort") || options.hasOwnProperty("sourcePort") || options.hasOwnProperty("targetPoint") || options.hasOwnProperty("sourcePoint")) {
                        if (options.sourceNode !== undefined) {
                            this._comparePropertyValues(connector, "sourceNode", options);
                            var node = this.nameTable[connector.sourceNode];
                            var sourceNode = this.nameTable[options.sourceNode];
                            var targetNode = this.nameTable[connector.targetNode];
                            var node1 = ej.datavisualization.Diagram.ClassifierHelper.EnableorDisableConnection(sourceNode, targetNode, connector, this);
                            if (node1)
                                options.sourceNode = node1.name;
                            else
                                options.sourceNode = null;
                            if (node && node.outEdges.indexOf(connector.name) != -1)
                                ej.datavisualization.Diagram.Util.removeItem(node.outEdges, connector.name);
                            connector.sourceNode = options.sourceNode;
                        }
                        if (options.targetNode !== undefined) {
                            this._comparePropertyValues(connector, "targetNode", options);
                            var sourceNode = this.nameTable[connector.sourceNode];
                            var targetNode = this.nameTable[options.targetNode];
                            var node = this.nameTable[connector.targetNode];
                            var node1 = ej.datavisualization.Diagram.ClassifierHelper.EnableorDisableConnection(targetNode, sourceNode, connector, this);
                            if (node1)
                                options.targetNode = node1.name;
                            else
                                options.targetNode = null;
                            if (node && node.inEdges.indexOf(connector.name) != -1)
                                ej.datavisualization.Diagram.Util.removeItem(node.inEdges, connector.name);
                            connector.targetNode = options.targetNode;
                        }
                        if (options.targetPort !== undefined) {
                            this._comparePropertyValues(connector, "targetPort", options);
                            connector.targetPort = options.targetPort;
                        }
                        if (options.sourcePort !== undefined) {
                            this._comparePropertyValues(connector, "sourcePort", options);
                            connector.sourcePort = options.sourcePort;
                        }
                        if (options.targetPoint !== undefined) {
                            this._comparePropertyValues(connector, "targetPoint", options);
                            ej.datavisualization.Diagram.Util._setLineEndPoint(connector, options.targetPoint, true);
                        }
                        if (options.sourcePoint !== undefined) {
                            this._comparePropertyValues(connector, "sourcePoint", options);
                            ej.datavisualization.Diagram.Util._setLineEndPoint(connector, options.sourcePoint, false);
                        }
                        this._updateEdges(connector);
                        this._dock(connector, this.nameTable);
                    }
                    ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                    if (this._svg) {
                        this._updateConnectorBridging(connector);
                        ej.datavisualization.Diagram.DiagramContext.update(connector, this);
                        ej.datavisualization.Diagram.DiagramContext.updateConnectorStyle(connector, this);
                    }
                    if (this.selectionList[0] && this.selectionList[0].name === connector.name)
                        ej.datavisualization.Diagram.SvgContext.updateSelector(connector, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
                }
            }
        },
        _updateDrawType: function (option) {
            var shape, singleAction = false, shapes;
            var tool = option.tool;
            if (tool & ej.datavisualization.Diagram.Tool.ContinuesDraw)
                singleAction = false;
            else if (tool & ej.datavisualization.Diagram.Tool.DrawOnce)
                singleAction = true;
            var drawType = option.drawType ? option.drawType : this.model.drawType;
            if (drawType) {
                if (drawType.type === "connector" && !this.activeTool._isPolyline()) {
                    var defaultconnectorsettings = this.model.defaultSettings.connector;
                    var defaultType = defaultconnectorsettings && defaultconnectorsettings.segments && defaultconnectorsettings.segments.length ? defaultconnectorsettings.segments[0].type : "";
                    var type = drawType.segments && drawType.segments.length && drawType.segments[0].type ? drawType.segments[0].type : defaultType;
                    if (type === "bezier" || this.model.connectorType === "bezierLine")
                        this.activateTool("bezierLine", singleAction);
                    else if (type === "orthogonal" || this.model.connectorType === "orthogonalLine")
                        this.activateTool("orthogonalLine", singleAction);
                    else if (type === "straight" || this.model.connectorType === "straightLine")
                        this.activateTool("straightLine", singleAction);
                }
                else if (drawType.type === "text")
                    this.activateTool("text", singleAction);
                else if (drawType.type || drawType.shape) {
                    shape = drawType.shape ? drawType.shape : drawType.type;
                    if (drawType.type == "basic")
                        shapes = ej.datavisualization.Diagram.BasicShapes;
                    else if (drawType.type == "flow")
                        shapes = ej.datavisualization.Diagram.FlowShapes;
                    else if (drawType.type == "arrow")
                        shapes = ej.datavisualization.Diagram.ArrowShapes;
                    else if (drawType.type == "bpmn")
                        shapes = ej.datavisualization.Diagram.BPMNShapes;
                    for (var key in shapes) {
                        if (shapes[key] == drawType.shape) {
                            shape = drawType.type;
                            break;
                        }
                    }
                    if (shape)
                        this._drawToolShape(shape, singleAction);
                }
            }
        },
        update: function (option) {
            if (option.scrollSettings) {
                this._eventCause["scrollChange"] = ej.datavisualization.Diagram.ScrollChangeCause.Unknown;
                this._setModel({ scrollSettings: option.scrollSettings });
            }
            if (option.backgroundColor) {
                this._setModel({ backgroundColor: option.backgroundColor });
            }
            if (option.tool) {
                this.activeTool._showAllPorts(true);
                var tool = option.tool;
                this.tool(tool);
                this._compareModelProperty("tool");
                if (tool & ej.datavisualization.Diagram.Tool.ContinuesDraw || tool & ej.datavisualization.Diagram.Tool.DrawOnce) {
                    this._updateDrawType(option);
                }
                else if (tool & ej.datavisualization.Diagram.Tool.ZoomPan) {
                    if (ej.datavisualization.Diagram.Util.canPanning(this)) {
                        this._toolToActivate = "panTool";
                        this.activeTool = this.tools[this._toolToActivate];
                        this.activeTool._isMouseDown = false;
                        this._currentCursor = "pointer";
                    }
                }
                else if (tool & ej.datavisualization.Diagram.Tool.MultipleSelect) {
                    this.activateTool("select", false);
                }
            }
            if (option.bridgeDirection) {
                this.bridgeDirection(typeof option.bridgeDirection === 'function' ? option.bridgeDirection() : option.bridgeDirection);
                this._compareModelProperty("bridgeDirection");
                var connectors = this.connectors();
                for (var i = 0, len = connectors.length; i < len; i++) {
                    var connector = connectors[i];
                    if (connector && ej.datavisualization.Diagram.Util.canBridge(connector, this)) {
                        ej.datavisualization.Diagram.Util.updateBridging(connector, this);
                        ej.datavisualization.Diagram.DiagramContext.update(connector, this);
                    }
                }
            }
            if (option.rulerSettings) {
                this._setModel({ scrollSettings: option.scrollSettings });
            }
        },
        bringToCenter: function (rect) {
            var scale = this._currZoom;
            var viewPort = this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            var actualbounds = { x: rect.x * scale, y: rect.y * scale, width: rect.width * scale, height: rect.height * scale };
            var hoffset = actualbounds.x + actualbounds.width / 2 - viewPort.width / 2;
            var voffset = actualbounds.y + actualbounds.height / 2 - viewPort.height / 2;
            ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, 1, this._hScrollOffset - hoffset, this._vScrollOffset - voffset, null, false);
        },
        bringIntoView: function (bounds) {
            var x = 0, y = 0;
            var scale = this._currZoom;
            bounds.right = bounds.right ? bounds.right : bounds.x + bounds.width;
            bounds.bottom = bounds.bottom ? bounds.bottom : bounds.y + bounds.height;
            var hoffset = this._hScrollOffset;
            var voffset = this._vScrollOffset;
            var viewPort = this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            bounds = { x: bounds.x * scale, y: bounds.y * scale, width: bounds.width * scale, height: bounds.height * scale, right: bounds.right * scale, bottom: bounds.bottom * scale };
            var view = { x: this._hScrollOffset, y: this._vScrollOffset, width: viewPort.width, height: viewPort.height };
            if (!(ej.datavisualization.Diagram.Geometry.containsRect(view, bounds))) {
                if (bounds.right > (-hoffset + viewPort.width)) {
                    x = bounds.right - viewPort.width;
                }
                if (bounds.x < -hoffset) {
                    x = bounds.x;
                }
                if (bounds.bottom > (-voffset + viewPort.height)) {
                    y = bounds.bottom - viewPort.height;
                }
                if (bounds.y < -voffset) {
                    y = bounds.y;
                }
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, 1, this._hScrollOffset - x, this._vScrollOffset - y, null, false);
            }
        },
        getBridgeSegment: function (startPt, endPt, angle, bridgeSpace, sweep) {
            var path = "A " + bridgeSpace / 2 + " " + bridgeSpace / 2 + "  " + angle + " , 1 " + sweep + " " + endPt.x + "," + endPt.y;
            return path;
        },
        fitToPage: function (mode, region, margin, canZoomIn) {
            var zoomFactor, factor, scale = {}, bounds;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            //margin
            margin = margin || {};
            margin = {
                top: !isNaN(margin.top) ? margin.top : 25,
                bottom: !isNaN(margin.bottom) ? margin.bottom : 25,
                left: !isNaN(margin.left) ? margin.left : 25,
                right: !isNaN(margin.right) ? margin.right : 25
            };
            //region
            region = region ? region : "pageSettings";
            //fit mode
            if ((region == "pageSettings" && this.model.pageSettings.pageWidth && this.model.pageSettings.pageHeight) || (this.nodes().length > 0 || this.connectors().length > 0)) {
                mode = mode ? mode : "page";
                if (region != "custom") {
                    bounds = this._getDigramBounds(region);
                    bounds.x -= this.model.scrollSettings.padding.left;
                    bounds.y -= this.model.scrollSettings.padding.top;
                    bounds.width += (this.model.scrollSettings.padding.left + this.model.scrollSettings.padding.right);
                    bounds.height += (this.model.scrollSettings.padding.top + this.model.scrollSettings.padding.bottom);
                }
                var width = bounds.width;
                var height = bounds.height;
                scale.x = (viewPort.width - (margin.left + margin.right)) / width;
                scale.y = (viewPort.height - (margin.top + margin.bottom)) / height;
                if (!canZoomIn && (!(this._vScrollbar && this._vScrollbar._scrollData) && !(this._hScrollbar && this._hScrollbar._scrollData))) {
                    scale.x = Math.min(1, scale.x);
                    scale.y = Math.min(1, scale.y);
                }
                var deltaX = this._hScrollOffset;
                var deltaY = this._vScrollOffset;
                var centerX, centerY;
                switch (mode) {
                    case "width":
                        zoomFactor = scale.x;
                        factor = zoomFactor / this._getCurrentZoom();
                        centerX = (viewPort.width - (region != "content" ? bounds.width : width) * zoomFactor) / 2 - bounds.x * zoomFactor;
                        deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                        //deltaX -= bounds.x * zoomFactor;
                        deltaY -= this._vScrollOffset * factor;
                        deltaY = region != "custom" ? deltaY : deltaY + this._vScrollOffset * factor;
                        break;
                    case "height":
                        zoomFactor = scale.y;
                        factor = zoomFactor / this._getCurrentZoom();
                        //var centerX = (viewPort.width - (bounds.x > 0 ? bounds.width : width) * zoomFactor - bounds.x * zoomFactor) / 2;
                        //deltaX += centerX - (bounds.x * zoomFactor) / 4 + margin.left;
                        //deltaY -= bounds.y * zoomFactor - margin.top;
                        centerX = (viewPort.width - (region != "content" ? bounds.width : width) * zoomFactor) / 2 - bounds.x * zoomFactor;
                        centerY = (viewPort.height - (region != "content" ? bounds.height : height) * zoomFactor) / 2 - bounds.y * zoomFactor;
                        deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                        deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;
                        break;
                    case "page":
                        zoomFactor = Math.min(scale.x, scale.y);
                        factor = zoomFactor / this._getCurrentZoom();
                        centerX = (viewPort.width - (region != "content" ? bounds.width : width) * zoomFactor) / 2 - bounds.x * zoomFactor;
                        centerY = (viewPort.height - (region != "content" ? bounds.height : height) * zoomFactor) / 2 - bounds.y * zoomFactor;
                        deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                        deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;
                        break;
                }
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, factor, deltaX, deltaY, new ej.datavisualization.Diagram.Point(0, 0), true);
            } else {
                factor = 1 / this._getCurrentZoom();
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, factor, this._hScrollOffset, this._vScrollOffset, new ej.datavisualization.Diagram.Point(0, 0), true);
            }
        },

        _convertImagesToBuffer: function (images) {
            var buffers = [];
            for (var g = 0; g < images.length; g++) {
                var image = images[g];
                image = image.replace(/^data:[a-z]*;,/, '');
                var image1 = image.split(',');
                var byteString = atob(image1[1]);
                var buffer = new ArrayBuffer(byteString.length);
                var intArray = new Uint8Array(buffer);
                for (var i = 0; i < byteString.length; i++) {
                    intArray[i] = byteString.charCodeAt(i);
                }
                buffers.push(buffer);
            }
            return buffers;
        },

        _downloadImage: function (buffers, fileName, fileType, content) {
            var browserInfo = ej.browserInfo();
            if (browserInfo.name === "msie" && parseFloat(browserInfo.version) < 10 || browserInfo.name == "webkit") {
                var info = browserInfo.name == "webkit" ? "Safari" : "IE-9";
                alert("Downloading option is not supported in " + info + ", Please use the returned data");
                return content;
            }
            else {
                for (var b = 0; b < buffers.length; b++) {
                    var blob = new Blob([buffers[b]], { type: 'application/octet-stream' });
                    if (browserInfo.name === "msie" || browserInfo.name === "edge")
                        window.navigator.msSaveOrOpenBlob(blob, fileName + '.' + fileType);
                    else {
                        var pom = document.createElement('a');
                        var url = URL.createObjectURL(blob);
                        pom.href = url;
                        pom.setAttribute('download', fileName + '.' + fileType);
                        if (document.createEvent) {
                            var e = document.createEvent("MouseEvents");
                            e.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                            pom.dispatchEvent(e);
                        } else if (pom.fireEvent) {
                            pom.fireEvent("onclick");
                        }
                    }
                }
            }
        },

        exportImage: function (image, options) {
            options = ej.datavisualization.Diagram.ExportSettings(options);
            var region = options && options.region ? options.region : "content";
            var margin = options.margin || {};
            margin = {
                top: !isNaN(margin.top) ? margin.top : 25,
                bottom: !isNaN(margin.bottom) ? margin.bottom : 25,
                left: !isNaN(margin.left) ? margin.left : 25,
                right: !isNaN(margin.right) ? margin.right : 25
            };

            var bounds = this._getDigramBounds(region);

            if (options.bounds) {
                bounds = {
                    x: (!isNaN(options.bounds.x) ? options.bounds.x : bounds.x),
                    y: (!isNaN(options.bounds.y) ? options.bounds.y : bounds.y),
                    width: (options.bounds.width || bounds.width),
                    height: (options.bounds.height || bounds.height)
                };
            }

            var img = document.createElement('img');
            var attr = {
                "src": image
            };
            ej.datavisualization.Diagram.Util.attr(img, attr);
            var context = this;
            img.onload = function () {
                var canvas = new ej.datavisualization.Diagram.Canvas({ "width": bounds.width + (margin.left + margin.right), "height": bounds.height + (margin.top + margin.bottom) });
                var ctx = canvas.document.getContext("2d");
                ctx.fillStyle = context._pageBackgroundColor();
                ctx.fillRect(0, 0, bounds.width + (margin.left + margin.right), bounds.height + (margin.top + margin.bottom));
                ctx.drawImage(this, bounds.x, bounds.y, bounds.width, bounds.height, margin.left, margin.top, bounds.width, bounds.height);
                image = canvas.document.toDataURL();
                if (options.printOptions) {
                    context._raisePrintAction(image, options.printOptions);
                    return;
                }
                ctx.restore();
                var fileName = options.fileName || "diagram", fileType = options.format || "jpg";
                if (options.multiplePage) {
                    options.pageHeight = options.pageHeight ? options.pageHeight : context.model.pageSettings.pageHeight;
                    options.pageWidth = options.pageWidth ? options.pageWidth : context.model.pageSettings.pageWidth;
                    options.pageHeight = options.pageHeight ? options.pageHeight : canvas.width;
                    options.pageWidth = options.pageWidth ? options.pageWidth : canvas.height;
                    options.pageOrientation = context.model.pageSettings.pageOrientation || options.pageOrientation;
                    margin = options.margin || {};
                    var swap = false;
                    if (options.pageOrientation == ej.datavisualization.Diagram.PageOrientations.Landscape) {
                        if (options.pageHeight > options.pageWidth) {
                            swap = true;
                        }
                    }
                    else {
                        if (options.pageWidth > options.pageHeight) {
                            swap = true;
                        }
                    }
                    if (swap) {
                        var temp = options.pageWidth;
                        options.pageWidth = options.pageHeight;
                        options.pageHeight = temp;
                    }

                    options.margin = {
                        top: !isNaN(margin.top) ? margin.top : 0,
                        bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
                        left: !isNaN(margin.left) ? margin.left : 0,
                        right: !isNaN(margin.right) ? margin.right : 0
                    }

                    var img = document.createElement('img');
                    var attr = {
                        "id": context.element[0].id + "_printImage",
                        "src": image,
                    };
                    ej.datavisualization.Diagram.Util.attr(img, attr);
                    img.onload = function () {
                        var images = context._getMultipleImage(img, options, true);
                        var buffers = context._convertImagesToBuffer(images);
                        context._downloadImage(buffers, fileName, fileType, images);
                    }
                }
                else {
                    var images = [image];
                    var buffers = context._convertImagesToBuffer(images);
                    context._downloadImage(buffers, fileName, fileType, images);
                }
            }
        },

        exportDiagram: function (options) {
            options = ej.datavisualization.Diagram.ExportSettings(options);
            var fileType, customBounds, content, buffers = [];
            if (!options) options = {};
            //region
            var region = options && options.region ? options.region : "content";
            //mode
            var mode = options && options.mode ? options.mode : "download";
            //margin
            var margin = options.margin || {};
            margin = {
                top: !isNaN(margin.top) ? margin.top : 25,
                bottom: !isNaN(margin.bottom) ? margin.bottom : 25,
                left: !isNaN(margin.left) ? margin.left : 25,
                right: !isNaN(margin.right) ? margin.right : 25
            };
            //region
            var bounds = this._getDigramBounds(region);
            if (options.bounds) {
                customBounds = true;
                bounds = {
                    x: (!isNaN(options.bounds.x) ? options.bounds.x : bounds.x),
                    y: (!isNaN(options.bounds.y) ? options.bounds.y : bounds.y),
                    width: (options.bounds.width || bounds.width),
                    height: (options.bounds.height || bounds.height)
                };
            }
            if (!options.bounds) {
                var nodes = this.nodes();
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    var labels = node.labels;
                    for (var j = 0; j < labels.length; j++) {
                        var label = labels[j];
                        if (label.visible)
                            var labelbounds = ej.datavisualization.Diagram.Util.getLabelbounds(this, node, label, true);
                        if (labelbounds) {
                            bounds = this._union(labelbounds, bounds);
                        }
                    }

                }
            }
            bounds.x -= margin.left;
            bounds.y -= margin.top;
            bounds.width += margin.left + margin.right;
            bounds.height += margin.top + margin.bottom;
            //Target file name
            var fileName = options.fileName || "diagram";
            if (options.format != "svg") {
                this._setScaleValueforCanvas(options, bounds);
                var canvas = this._diagramAsCanvas({ bounds: bounds, margin: margin, region: region, scaleX: options._scaleX, scaleY: options._scaleY }, customBounds);
                fileType = options.format || "jpg";
                var image = content = canvas.toDataURL();
                if (mode == "data") return content;
                if (!(ej.browserInfo().name === "msie" && parseFloat(ej.browserInfo().version) < 10)) {
                    if (options.multiplePage) {
                        options.pageHeight = options.pageHeight ? options.pageHeight : this.model.pageSettings.pageHeight;
                        options.pageWidth = options.pageWidth ? options.pageWidth : this.model.pageSettings.pageWidth;
                        options.pageHeight = options.pageHeight ? options.pageHeight : canvas.width;
                        options.pageWidth = options.pageWidth ? options.pageWidth : canvas.height;
                        options.pageOrientation = this.model.pageSettings.pageOrientation || options.pageOrientation;
                        margin = options.margin || {};
                        var swap = false;
                        if (options.pageOrientation == ej.datavisualization.Diagram.PageOrientations.Landscape) {
                            if (options.pageHeight > options.pageWidth) {
                                swap = true;
                            }
                        }
                        else {
                            if (options.pageWidth > options.pageHeight) {
                                swap = true;
                            }
                        }
                        if (swap) {
                            var temp = options.pageWidth;
                            options.pageWidth = options.pageHeight;
                            options.pageHeight = temp;
                        }

                        options.margin = {
                            top: !isNaN(margin.top) ? margin.top : 0,
                            bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
                            left: !isNaN(margin.left) ? margin.left : 0,
                            right: !isNaN(margin.right) ? margin.right : 0
                        }
                        var img = document.createElement('img');
                        var attr = {
                            "id": this.element[0].id + "_printImage",
                            "src": image,
                        };
                        ej.datavisualization.Diagram.Util.attr(img, attr);
                        var context = this;
                        img.onload = function () {
                            var images = context._getMultipleImage(img, options, true);
                            buffers = context._convertImagesToBuffer(images);
                            context._downloadImage(buffers, fileName, fileType, content);
                        }
                    }
                    else {
                        var images = [image];
                        buffers = this._convertImagesToBuffer(images);
                    }

                }

            } else {
                fileType = options.format || "svg";
                var svg = content = this._diagramAsSvg({ bounds: bounds, margin: margin });
                if (mode == "data") return content;
                if (!(ej.browserInfo().name === "msie" && parseFloat(ej.browserInfo().version) < 10)) {
                    var buffer = new XMLSerializer().serializeToString(svg);
                    buffers.push(buffer);
                }
            }
            if (mode == "download") {
                this._downloadImage(buffers, fileName, fileType, content);
            }
        },
        _diagramAsSvg: function (options) {
            var svg = new ej.datavisualization.Diagram.Svg({ "id": "diagram_svg", "width": options.bounds.width, "height": options.bounds.height });
            document.body.appendChild(svg.document);
            var g = this._svg.document.getElementById(this._canvas.id + "_pageBackground");
            g = $(g).find("#pageback")[0];
            g = g.cloneNode(true);
            var bounds = this._getDigramBounds();
            var left = bounds.x;
            var top = bounds.y;
            var width = bounds.width;
            var height = bounds.height;
            svg.appendChild(g);
            g.setAttribute("transform", "translate(" + (-options.bounds.x) + ", " + (-options.bounds.y) + ")");
            g.setAttribute("x", left);
            g.setAttribute("y", top);
            g.setAttribute("width", width);
            g.setAttribute("height", height);
            g = this._svg.document.getElementById(this._canvas.id + "_diagramLayer");
            g = g.cloneNode(true);
            svg.appendChild(g);
            g.setAttribute("transform", "translate(" + (-options.bounds.x) + ", " + (-options.bounds.y) + ")");

            var nodes = this.nodes();
            //renderLabels
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if (node._type == "group")
                    ej.datavisualization.Diagram.SvgContext._renderLabelGroup(node, svg, this);
                else
                    ej.datavisualization.Diagram.SvgContext._renderLabelsAsSvg(node, svg, this);
                if (node.annotation) {
                    if (node._annotation && node._annotation.length) {
                        for (var n = 0; n < node._annotation.length; n++) {
                            if (diagram.nameTable[node._annotation[n]]) {
                                var element = diagram.nameTable[node._annotation[n]];
                                ej.datavisualization.Diagram.SvgContext._renderLabelsAsSvg(element, svg, this);
                            }
                        }
                    }
                }
            }
            var connectors = this.connectors();
            for (var i = 0; i < connectors.length; i++) {
                var connector = connectors[i];
                ej.datavisualization.Diagram.SvgContext._renderLabelsAsSvg(connector, svg, this);
            }
            document.body.removeChild(svg.document);
            svg.appendChild(this._svg.document.getElementById(this._canvas.id + "patterndefinition").cloneNode(true));
            return svg.document;
        },

        _setScaleValueforCanvas: function (options, bounds) {
            options._scaleX = 1;
            options._scaleY = 1;
            options.pageHeight = options.pageHeight ? options.pageHeight : this.model.pageSettings.pageHeight;
            options.pageWidth = options.pageWidth ? options.pageWidth : this.model.pageSettings.pageWidth;
            var height = options.pageHeight ? options.pageHeight : bounds.height;
            var width = options.pageWidth ? options.pageWidth : bounds.width;
            if (options.stretch === "fill" || options.stretch === "uniform" || options.stretch === "uniformtofill") {
                options._scaleX = width / bounds.width;
                options._scaleY = height / bounds.height;
                if (options.stretch === "uniform")
                    options._scaleX = options._scaleY = Math.min(options._scaleX, options._scaleY);
                else if (options.stretch === "uniformtofill")
                    options._scaleX = options._scaleY = Math.max(options._scaleX, options._scaleY);
                bounds.width = width;
                bounds.height = height;
            }
            bounds.x *= options._scaleX;
            bounds.y *= options._scaleY;
        },
        _diagramAsCanvas: function (options, customBounds) {
            var elements, element, pageBounds;
            var margin = options.margin;
            var region = pageBounds = options.bounds;
            var bgColor = this._pageBackgroundColor();
            var canvas = new ej.datavisualization.Diagram.Canvas({ "id": "mycanvas", "width": region.width, "height": region.height });
            canvas._diagram = this;
            canvas._scaleX = options.scaleX;
            canvas._scaleY = options.scaleY;
            var context = canvas.document.getContext("2d");
            context.fillStyle = this._backgroundColor();
            context.translate(-region.x, -region.y);
            context.fillRect(region.x, region.y, region.width, region.height);
            var bgImg = this._backgroundImage();
            if (bgImg && bgImg.source) {
                var image = new Image();
                image.src = bgImg.source;
                var proportionX = pageBounds.width / image.width;
                var proportionY = pageBounds.height / image.height;
                var x = pageBounds.x;
                var y = pageBounds.y;
                var width = pageBounds.width;
                var height = pageBounds.height;
                var exportable = ej.datavisualization.Diagram.CanvasContext._isImageExportable(bgImg);
                if (bgImg.scale != "none" && bgImg.alignment != "none") {
                    var proportion = bgImg.scale == "meet" ? Math.min(proportionX, proportionY) : Math.max(proportionX, proportionY);
                    width = proportion * image.width;
                    height = proportion * image.height;
                    if (bgImg.alignment.indexOf("xmid") > -1) {
                        x += (pageBounds.width - width) / 2;
                    }
                    else if (bgImg.alignment.indexOf("xmax") > -1) {
                        x = x + pageBounds.width - width;
                    }
                    if (bgImg.alignment.indexOf("ymid") > -1) {
                        y += (pageBounds.height - height) / 2;
                    }
                    else if (bgImg.alignment.indexOf("ymax") > -1) {
                        y = y + pageBounds.height - height;
                    }
                    if (this._backgroundColor() == "none" || this._backgroundColor() == "transparent") {
                        context.fillStyle = "white";
                        context.fillRect(pageBounds.x * options.scaleX, pageBounds.y * options.scaleY, pageBounds.width * options.scaleX, pageBounds.height * options.scaleY);
                    }
                    if (exportable)
                        context.drawImage(image, x, y, proportion * image.width, proportion * image.height);
                }
                else if (exportable) context.drawImage(image, x, y, pageBounds.width, pageBounds.height);
            }
            else {
                context.fillStyle = bgColor;
                context.fillRect((pageBounds.x * options.scaleX) - margin.left, (pageBounds.y * options.scaleY) - margin.top, (pageBounds.width * options.scaleX) + margin.left + margin.right, (options.scaleY * pageBounds.height) + margin.top + margin.bottom);
            }
            var brColor = this._pageBorderColor();
            var brWidth = this._pageBorderWidth();
            if (brWidth) {
                context.strokeStyle = brColor == "none" ? "transparent" : brColor;
                context.lineWidth = brWidth;
                context.strokeRect(pageBounds.x * options.scaleX, pageBounds.y * options.scaleY, pageBounds.width * options.scaleX, pageBounds.height * options.scaleY);
            }
            elements = this.nodes().concat(this.connectors());
            elements = this._sortByZIndex(elements, true);
            this._sortByGroupChildrenZIndex(true);
            for (var i = 0; i < elements.length; i++) {
                element = elements[i];
                if (ej.datavisualization.Diagram.Util.enableLayerOption(element, "print", this)) {
                    if (element.segments)
                        ej.datavisualization.Diagram.CanvasContext.renderConnector(element, canvas);
                    else if (element._type === "group" && !element.parent) {
                        ej.datavisualization.Diagram.CanvasContext.renderGroup(element, canvas, this);
                    }
                    else if (element._type === "node" && !element.isPhase && !element.parent)
                        ej.datavisualization.Diagram.CanvasContext.renderNode(element, canvas, this);
                }
            }
            /*canvas.line({ x: region.x + margin.left / 2, y: region.y }, { x: region.x + margin.left / 2, y: region.y + region.height }, { lineWidth: margin.left, stroke: bgColor });
        var y = region.y + region.height - margin.bottom / 2;
        canvas.line({ x: region.x, y: y }, { x: region.x + region.width, y: y }, { lineWidth: margin.bottom, stroke: bgColor });
        var x = region.x + region.width - margin.right / 2;
        canvas.line({ x: x, y: region.y + region.height }, { x: x, y: region.y }, { lineWidth: margin.right, stroke: bgColor });
        y = region.y + margin.top / 2;
        canvas.line({ x: region.x + region.width, y: y }, { x: region.x, y: y }, { lineWidth: margin.top, stroke: bgColor });*/
            return canvas.document;
        },
        _renderCanvasPhase: function (element, canvas) {

            var tx = 0, ty = 0;
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(this, element), phase;
            if (phases) {
                for (var i = 0; i < phases.length; i++) {
                    phase = this.nameTable[this._getChild(phases[i])];
                    var parNode = this.nameTable[element.name];
                    if (parNode) {
                        var children = this._getChildren(parNode.children);
                        if (children.length > 1)
                            var header = this.nameTable[children[0]];
                        var bounds = ej.datavisualization.Diagram.Util.bounds(parNode);
                        var points = [], nPoint;
                        var top = bounds.top + 50;
                        var left = bounds.left + 50;
                        if (phase.orientation == "vertical") {
                            points.push({ x: 0, y: 0 });
                            points.push({ x: bounds.width, y: 0 });
                            nPoint = ej.datavisualization.Diagram.SvgContext._convertToSVGPoints(points);
                            tx = bounds.x;
                            ty = bounds.y + phase.offset;
                            if (header)
                                ty += header.height;
                            for (var j = 0, len = points.length; j < len; ++j) {
                                var point = ej.datavisualization.Diagram.Geometry.translate(points[j], tx, ty);
                                points[j] = point;
                            }
                        } else {
                            points.push({ x: 0, y: header.height ? header.height : 0 });
                            points.push({ x: 0, y: bounds.height });
                            tx = bounds.x + phase.offset;
                            ty = bounds.y;
                            for (var j = 0, len = points.length; j < len; ++j) {
                                var point = ej.datavisualization.Diagram.Geometry.translate(points[j], tx, ty);
                                points[j] = point;
                            }
                        }
                    }
                    for (var k = 0; k < points.length; k++) {
                        var point = points[k];
                        point.x *= canvas._scaleX;
                        point.y *= canvas._scaleY;
                    }
                    ej.datavisualization.Diagram.CanvasContext.renderPhases(phase, canvas, points);
                }
            }
        },

        _getPrintCanvasStyle: function (img, options) {
            var width = 0, height = 0;
            if (img) {
                width = img.width;
                height = img.height;
            }
            if (options) {
                if (options.pageHeight || options.pageWidth) {
                    height = options.pageHeight ? options.pageHeight : height;
                    width = options.pageWidth ? options.pageWidth : width;
                }
                if (options.pageOrientation) {
                    var temp;
                    if (options.pageOrientation === "landscape" && height > width) {
                        temp = width;
                    }
                    else if (options.pageOrientation === "portrait" && width > height) {
                        temp = width;
                    }
                    if (temp) {
                        width = height;
                        height = temp;
                    }
                }
            }
            return { height: height, width: width };
        },

        _getMultipleImage: function (img, printSettings, isExport) {
            var imageArray = [];
            var div = document.createElement("div");
            var pageSize = this._getPrintCanvasStyle(img, printSettings), pageWidth, pageHeight;
            var margin = printSettings.margin;
            var mLeft = margin.left;
            var mTop = margin.top;
            var mRight = margin.right;
            var mBottom = margin.bottom;
            var x = 0, y = 0;
            pageWidth = pageSize.width + x;
            pageHeight = pageSize.height + y;
            var drawnX = 0;
            var drawnY = 0;
            if (printSettings && printSettings.multiplePage) {
                div.style.height = "auto";
                div.style.width = "auto";
                var imgHeight = img.height;
                var imgWidth = img.width;
                if (img) {
                    var i = 0, j = 0, url, ctx, canvas, clipWidth = 0, clipHeight = 0;
                    do {
                        do {
                            clipWidth = pageSize.width;
                            clipHeight = pageSize.height;
                            if ((drawnX + pageSize.width) >= imgWidth)
                                clipWidth = (imgWidth - drawnX);
                            if ((drawnY + pageSize.height) >= imgHeight)
                                clipHeight = (imgHeight - drawnY);
                            canvas = new ej.datavisualization.Diagram.Canvas({ "id": "multiplePrint" + i + "" + j, "width": pageSize.width, "height": pageSize.height });
                            ctx = canvas.document.getContext("2d");
                            ctx.drawImage(img, x + drawnX + mLeft,
                                y + drawnY + mTop,
                                clipWidth - mRight - mLeft,
                                clipHeight - mBottom - mTop,
                                0 + mLeft,
                                0 + mTop,
                                clipWidth - mRight - mLeft,
                                clipHeight - mBottom - mTop);

                            if ((drawnX + pageSize.width) >= imgWidth)
                                drawnX -= (drawnX - imgWidth);
                            url = canvas.document.toDataURL();
                            ctx.restore();
                            drawnX += pageWidth;
                            if (isExport)
                                imageArray.push(url);
                            else
                                this._printImage(div, url, i + "" + j); i++;
                        } while (drawnX < imgWidth)
                        j++;
                        i = x = drawnX = 0;
                        if ((drawnY + pageSize.height) >= imgHeight)
                            drawnY -= (drawnY - imgHeight);
                        drawnY += pageHeight;
                    } while (drawnY < imgHeight)
                }
            }
            else if (printSettings && printSettings.region === "content" && !printSettings.pageWidth && !printSettings.pageHeight) {
                canvas = new ej.datavisualization.Diagram.Canvas({ "id": "multiplePrint10", "width": img.width, "height": img.height });
                ctx = canvas.document.getContext("2d");
                ctx.drawImage(img, x + mLeft, y + mTop, img.width - (mRight + mLeft), img.height - (mTop + mBottom), 0 + mLeft, 0 + mTop, img.width - (mRight + mLeft), img.height - (mTop + mBottom));
                url = canvas.document.toDataURL();
                ctx.restore();
                this._printImage(div, url, 0)
            }
            else {
                var x = 0, y = 0;
                var pageSize = this._getPrintCanvasStyle(img, printSettings), pageWidth, pageHeight;
                pageWidth = pageSize.width;
                pageHeight = pageSize.height;
                canvas = new ej.datavisualization.Diagram.Canvas({ "id": "multiplePrint0", "width": img.width, "height": img.height });
                ctx = canvas.document.getContext("2d");
                var ratio = Math.min(img.width / pageWidth, img.height / pageHeight);
                pageWidth = img.width * ratio;
                pageHeight = img.height * ratio;

                ctx.drawImage(img, x + mLeft, y + mTop, img.width - (mRight + mLeft), img.height - (mTop + mBottom), 0 + mLeft, 0 + mTop, pageWidth - (mRight + mLeft), pageHeight - (mTop + mBottom));
                url = canvas.document.toDataURL();
                ctx.restore();
                this._printImage(div, url, 0)
            }
            if (isExport)
                return imageArray;
            else
                return div;
        },

        _printImage: function (div, url, i) {
            var img1, innerDiv, attr;
            img1 = document.createElement('img');
            innerDiv = document.createElement('div');
            attr = { "class": "e-diagram-print-page", };
            ej.datavisualization.Diagram.Util.attr(innerDiv, attr);
            attr = { "id": this.element[0].id + "_multiplePrint_img" + i, "style": "float:left", "src": url };
            ej.datavisualization.Diagram.Util.attr(img1, attr);
            innerDiv.appendChild(img1);
            div.appendChild(innerDiv);
        },

        printImage: function (image, options) {
            options = options || {};
            var margin = options.margin || {};
            margin = {
                top: !isNaN(margin.top) ? margin.top : 0,
                bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
                left: !isNaN(margin.left) ? margin.left : 0,
                right: !isNaN(margin.right) ? margin.right : 0
            };
            options = ej.datavisualization.Diagram.PrintSettings(options);
            this.exportImage(image, { printOptions: options, region: options.region, margin: margin });
        },

        _raisePrintAction: function (url, options) {
            var img = document.createElement('img');
            var attr = {
                "id": this.element[0].id + "_printImage",
                "src": url,
            };
            ej.datavisualization.Diagram.Util.attr(img, attr);
            var tempObj = this;
            img.onload = function () {
                var div = tempObj._getMultipleImage(img, options);
                // specify window parameters
                var PrintWind = window.open(''); 
                if (PrintWind != null) {
                    PrintWind.opener = null;
                    PrintWind.document.write('<html><head><style> body{margin:0px;}  @media print { .e-diagram-print-page {page-break-after: left; }.e-diagram-print-page:last-child {page-break-after: avoid;}}  </style><title></title></head>');
                    PrintWind.document.write('<BODY onload="setTimeout(function(){window.print();}, 100)">');
                    PrintWind.document.write("<center>" + div.innerHTML + "</center>");
                    PrintWind.document.close();
                }
            }
        },
        print: function (options) {
            options = ej.datavisualization.Diagram.PrintSettings(options);
            var url = this.exportDiagram({ mode: "data", region: options.region, margin: { top: 10, bottom: 10, left: 10, right: 10, }, stretch: options.stretch });
            this._raisePrintAction(url, options);
        },
        save: function () {
            var drawingTools = this.model.drawingTools;
            var userHandles = this.model.selectedItems.userHandles;
            this.model.drawingTools = null;
            this.model.selectedItems.children = [];
            this.model.selectedItems.userHandles = [];
            if (this.nameTable["multipleSelection"]) {
                ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.nameTable["multipleSelection"]);
                this._nodes = $.extend(true, [], this.nodes());
            }
            this._updateTableNodes();
            var model = jQuery.extend(true, {}, this.model);
            for (var i = 0; i < model.nodes.length; i++) {
                this._resetValues(model.nodes[i]);
            }
            for (var i = 0; i < model.connectors.length; i++) {
                this._resetValues(model.connectors[i]);
            }
            delete model.historyManager;
            if (ej.version)
                model.version = ej.version;
            this._updateGroupChildren(model);
            this.model.drawingTools = drawingTools;
            this.model.selectedItems.userHandles = userHandles;
            this._checkForNullValues(model);
            if (this.model.serializationSettings.preventDefaultValues) {
                model = this._optimizeJson(model);
            }
            return model;
        },
        _updateDefaults: function (node) {
            if (!this.defaultTabels) {
                this.defaultTabels = {};
                this.defaultTabels["defaults"] = $.extend(true, {}, this.defaults);
                this.defaultTabels["defaults"].snapSettings.verticalGridLines.linesInterval = [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75];
                this.defaultTabels["defaults"].snapSettings.horizontalGridLines.linesInterval = [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75];
                this.defaultTabels["defaults"].tooltip = this.defaultTabels["defaults"].selectedItems.tooltip = ej.datavisualization.Diagram.TooltipDefaults;
            }
            if (node) {
                if (node.type) {
                    if (!this.defaultTabels[node.type]) {
                        if (node.type === "group" && node.isSwimlane) {
                            var Swimlane = ej.datavisualization.Diagram.SwimLane({});
                            Swimlane.phases = [ej.datavisualization.Diagram.Phase({ label: { text: "Phase" } })];
                            Swimlane.lanes = [ej.datavisualization.Diagram.Lane({})];
                            this.defaultTabels["Swimlane"] = Swimlane;
                        }
                        else if (node.type === "group") {
                            this.defaultTabels[node.type] = $.extend(false, ej.datavisualization.Diagram.Group(this.model.defaultSettings.group ? this.model.defaultSettings.group : { type: node.type }));
                        }
                        else if (node.type === "connector") {
                            this.defaultTabels[node.type] = ej.datavisualization.Diagram.ConnectorDefaults;
                        }
                        else if (node.type === "textBlock") {
                            this.defaultTabels[node.type] = ej.datavisualization.Diagram.TextBlockDefaults;
                        }
                        else if (node.type === "labels" || node.type === "label") {
                            this.defaultTabels[node.type] = ej.datavisualization.Diagram.LabelDefaults;
                        }
                        else if (node.type === "ports") {
                            this.defaultTabels[node.type] = ej.datavisualization.Diagram.PortDefaults;
                        }
                        else if (node.type === "basic" || node.type === "flow" || node.type === "arrow" || node.type === "bpmn" || node.type === "text" || node.type === "image" || node.type === "native" || node.type === "html" || node.type === "node") {
                            var nodeDefault = ej.datavisualization.Diagram.Node($.extend(false, { type: node.type }, ej.datavisualization.Diagram.NodeBase({ type: node.type }), ej.datavisualization.Diagram.NodeType({ type: node.type, shape: node.shape }, this)));
                            if (nodeDefault.container) {
                                nodeDefault.container = ej.datavisualization.Diagram.Container(nodeDefault.container);
                            }
                            this.defaultTabels[node.type] = nodeDefault;
                        }
                        else if (node.type === "umlclassifier" || node.type === "umlactivity") {
                            var nodeDefault = ej.datavisualization.Diagram.Node(
                                $.extend(false, { "type": node.type },
                                    ej.datavisualization.Diagram.NodeBase({ "type": node.type }),
                                    ej.datavisualization.Diagram.NodeType(
                                        {
                                            "type": node.type, shape: node.shape,
                                            classifier: node.classifier,
                                            "class": node['class'], "interface": node.interface,
                                            enumeration: node.enumeration
                                        },
                                        this)
                                ));
                            this.defaultTabels[node.type] = nodeDefault;
                        }
                    }
                }
            }
        },
        _optimizeJson: function (data) {
            var jsonData = data;
            this._updateDefaults();
            var jsonData = this._compareObject(data, this.defaultTabels["defaults"]);
            return jsonData;
        },
        _updateHistoryManager: function (data) {
            for (var key in data) {
                if (data[key] !== "push" || data[key] !== "stackLimit" || data[key] !== "pop") {
                    delete data[key];
                }
            }
            return data;
        },
        _compareObject: function (orgValue, defaultValue) {
            if (orgValue && defaultValue) {
                for (var key in orgValue) {
                    var datavalue = orgValue[key];
                    if (datavalue === null || datavalue === "") {
                        delete orgValue[key];
                    }
                    else if (orgValue.hasOwnProperty(key)) {
                        if (key.charAt(0) === "_" || (orgValue["type"] === "bpmn" && key === "container")) {
                            delete orgValue[key];
                        }
                        else {
                            var defaultValues = defaultValue[key] === undefined ? this.defaultTabels[key] : defaultValue[key];
                            if (datavalue !== undefined && defaultValues !== undefined) {
                                if (key === "collapseIcon" || key === "expandIcon" || key === "layout") {
                                    if (datavalue.shape === defaultValues.shape) {
                                        delete orgValue[key].shape;
                                    }
                                    if (datavalue.type === defaultValues.type) {
                                        delete orgValue[key].type;
                                    }
                                }
                                if (key !== "isSwimlane" && key !== "classifier" && key !== "type" && key !== "shape") {
                                    if (datavalue === defaultValues) {
                                        delete orgValue[key];
                                    }
                                }
                            }
                            if ((datavalue !== null) && (typeof datavalue === 'object')) {
                                if ((datavalue !== null) && (datavalue instanceof Array)) {
                                    if (datavalue.length === 0) {
                                        delete orgValue[key];
                                    }
                                    else {
                                        for (var subKey in datavalue) {
                                            if (typeof (datavalue[subKey]) === 'object') {
                                                var defaultJson;
                                                if (key === "labels" || key === "label" || key === "textBlock" || key === "ports") {
                                                    this._updateDefaults({ type: key })
                                                    defaultJson = this.defaultTabels[key];
                                                    if (orgValue && orgValue.type === 'bpmn' && key === "labels") {
                                                        defaultJson = $.extend(true, {}, defaultJson);
                                                        defaultJson.offset = { x: 0.5, y: 1 };
                                                    }
                                                    if (key === "label") {
                                                        defaultJson = this.defaultTabels["labels"];
                                                    }
                                                    if (key === "labels" || key === "ports") {
                                                        if (this.model.defaultSettings) {
                                                            var defaultSetting = this.model.defaultSettings;
                                                            for (var innerKey in defaultSetting) {
                                                                var defaultSettingValue = defaultSetting[innerKey]
                                                                if (defaultSettingValue) {
                                                                    if (defaultSettingValue[key]) {
                                                                        for (var subInnerKey in defaultSettingValue[key][subKey]) {
                                                                            this.defaultTabels[key][subInnerKey] = defaultSettingValue[key][subInnerKey];
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                } else if (key === "children") {
                                                    this._updateDefaults({ type: datavalue[subKey].type })
                                                    defaultJson = this.defaultTabels[datavalue[subKey].type];
                                                }
                                                else {
                                                    this._updateDefaults(datavalue[subKey])
                                                    defaultJson = this.defaultTabels[datavalue[subKey].type];
                                                }
                                                if (datavalue[subKey].isSwimlane) {
                                                    defaultJson = this.defaultTabels["Swimlane"]
                                                }
                                                else if (datavalue[subKey].type === "umlclassifier" || (datavalue[subKey].type === "bpmn" && !datavalue[subKey].container)) {
                                                    delete orgValue[key][subKey]["children"]
                                                }
                                                orgValue[key][subKey] = this._compareObject(datavalue[subKey], defaultJson === undefined ? defaultValues : defaultJson)
                                            }
                                            else {
                                                orgValue[key] = this._compareObject(datavalue, defaultValues);
                                            }
                                        }
                                    }
                                }
                                else {
                                    if (key !== "class" && key !== "interface" && key !== "enumeration") {
                                        if (key === "commandManager" || key === "contextMenu") {
                                            if (key === "contextMenu" && !this.model.enableContextMenu) {
                                                delete orgValue[key];
                                            } else if (key === "commandManager") {
                                                var commands = datavalue.commands;
                                                for (var Commandkey in commands) {
                                                    if (commands[Commandkey]._isDefault) {
                                                        delete commands[Commandkey];
                                                    }
                                                } if ($.isEmptyObject(datavalue.commands)) { delete orgValue[key].commands; }
                                            }
                                        }
                                        if (key === "historyManager") {
                                            orgValue[key] = this._updateHistoryManager(datavalue);
                                        }
                                        else {
                                            orgValue[key] = this._compareObject(datavalue, defaultValues);
                                        }
                                    }
                                }
                                if ($.isEmptyObject(datavalue) || datavalue.length === 0) {
                                    delete orgValue[key];
                                }
                            }
                        }
                    }
                }
            } return orgValue;
        },
        _checkForNullValues: function (model) {
            this._checkTargetNull(model.pageSettings);
        },
        _checkTargetNull: function (target) {
            for (var member in target) {
                if (target[member] == null || target[member] == Infinity) {
                    target[member] = 0;
                }
                else if (typeof (target[member]) === "object" && target[member])
                    this._checkTargetNull(target[member]);
            }
        },
        _updateGroupChildren: function (model) {
            var nodes = [], connectors = [], swimlane;
            var tempNodes = typeof model.nodes === 'function' ? model.nodes() : model.nodes;
            if (tempNodes && tempNodes.length > 0) {
                for (var i = 0; i < tempNodes.length; i++) {
                    if (tempNodes[i].parent === "" && !tempNodes[i].isSwimlane) {
                        this._updateChildren(tempNodes[i]);
                        nodes.push(jQuery.extend(true, {}, tempNodes[i]))
                    }
                    else if (tempNodes[i].isSwimlane) {
                        swimlane = this._getNode(tempNodes[i].name);
                        this._isSwimlaneExist = true;
                        if (swimlane)
                            nodes.push(jQuery.extend(true, {}, swimlane))
                    }
                }
            }
            var tempConnectors = typeof model.connectors === 'function' ? model.connectors() : model.connectors;
            if (tempConnectors && tempConnectors.length > 0) {
                for (var i = 0; i < tempConnectors.length; i++) {
                    connectors.push(tempConnectors[i]);
                }
            }
            model.connectors = connectors;
            model.nodes = nodes;
        },
        _updateChildren: function (node) {
            var children = [];
            if (node && node.children && node.children.length > 0) {
                var child, childName;
                for (var i = 0; i < node.children.length; i++) {
                    childName = this._getChild(node.children[i]);
                    if (childName)
                        child = this.nameTable[childName];
                    if (child)
                        children.push(jQuery.extend(true, {}, child));
                }
                node.children = children;
            }
        },
        _containsNode: function (node) {
            node = this._getChild(node);
            var chnode = null;
            for (var i = 0; i < this.nodes().length; i++) {
                chnode = this.nodes()[i];
                if (chnode) {
                    if (chnode.name === node)
                        return true;
                }
            }
            return null;
        },

        _updateTableNodes: function () {
            var i = 0, node, connector, cphase;
            for (i; i < this.nodes().length; i++) {
                node = this.nameTable[this.nodes()[i].name];
                if (node) {
                    this.nodes()[i] = node;
                    if (node._type === "group") {
                        this._updateTableGroup(node);
                    }
                }
            }
            for (i; i < this.connectors().length; i++) {
                connector = this.nameTable[this.connectors()[i].name];
                if (connector) {
                    this.connectors()[i] = connector;
                }
            }
        },
        _updateTableGroup: function (group) {
            var children = group.children;
            for (var i = 0; i < group.children.length; i++) {
                group.children[i] = this.nameTable[this._getChild(group.children[i])];
                if (group.children[i] && group.children[i]._type === "group") {
                    this._updateTableGroup(group.children[i]);
                }
            }
        },
        upgrade: function (data) {
            if (data) {
                //Support to upgrade diagram JSON data from 12.1
                var version = Number(data.version);
                if (isNaN(version) && data.version) {
                    version = data.version.split(".");
                    data.version = version = Number(version[0] + "." + version[1]);
                }
                if (!data.version) {
                    //CommonAPIChanges
                    this.commonAPIChanges(data);
                    //Node and Connector constraints set to default
                    if (data.nodes) {
                        for (var i = 0; i < data.nodes.length; i++) {
                            if (!data.nodes[i].inEdges) {
                                data.nodes[i].inEdges = [];
                                data.nodes[i].outEdges = [];
                            }
                            data.nodes[i].constraints = ej.datavisualization.Diagram.NodeConstraints.Default;
                        }
                    }
                }
                else if (version < 14.2) {
                    if (data.nodes) {
                        if (version < 14.1) {
                            for (var i = 0; i < data.nodes.length; i++) {
                                var node = data.nodes[i];
                                this.setConstraints(node);
                                if (node && (node.type === "native" || node.type === "image" || node.type === "html"))
                                    node.scale = "stretch";
                            }
                        }
                    }
                    if (data.connectors) {
                        for (var j = 0; j < data.connectors.length; j++) {
                            var connector = data.connectors[j];
                            if (version < 14.1) {
                                connector.constraints |= ej.datavisualization.Diagram.ConnectorConstraints.PointerEvents;
                                if (connector.labels && connector.labels.length > 0) {
                                    for (var label, m = 0; m < connector.labels.length; m++) {
                                        label = connector.labels[m];
                                        label.relativeMode = ej.datavisualization.Diagram.LabelRelativeMode.SegmentBounds;
                                    }
                                }
                            }
                            if (version < 14.2) {
                                if (connector && connector.segments && connector.segments.length === 1 && connector.segments[0].type === "orthogonal") {
                                    connector.segments[0].length = 13;
                                }
                            }
                        }
                    }
                }
                else if (data.version == "13.1") {
                    //No Code Changes
                }
                if (data.version < 15.4) {
                    if (data.scrollSettings) {
                        data.scrollSettings.minZoom = 0.25;
                        data.scrollSettings.maxZoom = 30;
                    }
                    else {
                        data.scrollSettings = {
                            horizontalOffset: 0,
                            verticalOffset: 0,
                            currentZoom: 1,
                            viewPortHeight: 0,
                            viewPortWidth: 0,
                            zoomFactor: 0.2,
                            minZoom: 0.25,
                            maxZoom: 30,
                            padding: { left: 0, right: 0, top: 0, bottom: 0 }
                        };
                    }
                }
                data.version = ej.version;
            }
        },
        setConstraints: function (node) {
            if (node && node.type == "group" && !node.isSwimlane) {
                node.constraints |= ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                for (var i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    if (child.type == "group") {
                        this.setConstraints(child);
                    }
                    else {
                        child.constraints |= ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                    }
                }
            }
            else if (node && node.type == "group" && node.isSwimlane) {
                node.constraints |= ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                for (var j = 0; j < node.lanes.length; j++) {
                    var lane = node.lanes[j];
                    lane.constraints |= ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                    if (lane.children) {
                        for (var k = 0; k < lane.children.length; k++) {
                            var child = lane.children[k];
                            if (child.type == "group") {
                                this.setConstraints(child);
                            }
                            else {
                                child.constraints |= ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                            }
                        }
                    }
                }
            }
            else {
                node.constraints |= ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
            }
        },
        commonAPIChanges: function (data) {
            // defaultSettings API Added
            data.defaultSettings = { node: data.nodeDefaults, connectors: data.connectorDefaults };
            // line is changed to segments; Inserting segments
            if (data.connectors) {
                for (var i = 0; i < data.connectors.length; i++) {
                    //Setting the Connector's constraints to Default
                    data.connectors[i].constraints = ej.datavisualization.Diagram.ConnectorConstraints.Default;
                    if (data.connectors[i].line) {
                        if (data.connectors[i].line.type == "straight") {
                            var segments = [{
                                type: "straight",
                                startPoint: data.connectors[i].line.startPoint,
                                endPoint: data.connectors[i].line.endPoint
                            }];
                            this.commonSourceTargetChanges(data.connectors[i]);
                        }
                        else if (data.connectors[i].line.type == "orthogonal") {
                            var segments = [{
                                type: "orthogonal",
                                startPoint: data.connectors[i].line.startPoint,
                                endPoint: data.connectors[i].line.endPoint,
                            }];
                            this.commonSourceTargetChanges(data.connectors[i]);
                        }
                        else if (data.connectors[i].line.type == "bezier") {
                            var segments = [{
                                type: "bezier",
                                startPoint: data.connectors[i].line.startPoint,
                                endPoint: data.connectors[i].line.endPoint,
                                point1: data.connectors[i].line.point1,
                                point2: data.connectors[i].line.point2
                            }];
                            this.commonSourceTargetChanges(data.connectors[i]);
                        }
                        data.connectors[i].sourcePoint = data.connectors[i].line.startPoint;
                        data.connectors[i].targetPoint = data.connectors[i].line.endPoint;
                        data.connectors[i].segments = segments;
                    }
                }
            }
        },
        commonSourceTargetChanges: function (data) {
            if (data.sourceNodeName)
                data.sourceNode = data.sourceNodeName;
            if (data.sourceNodePort)
                data.sourcePort = data.sourceNodePort;
            if (data.targetNodeName)
                data.targetNode = data.targetNodeName;
            if (data.targetPortName)
                data.targetPort = data.targetPortName;
        },
        load: function (data) {
            if (data && data.version === "NewVersion") {
                data.version = ej.version;
            }
            this._isLoad = true;
            this._isOptimize = true;
            this._spatialSearch = ej.datavisualization.Diagram.SpatialSearch(this);
            this.clear();
            this._zOrder = 0;
            if (this.enableContextMenu()) {
                if (!this.model.serializationSettings.preventDefaultValues || data.contextMenu) {
                    var menuObj = $("#" + this.element[0].id + "_contextMenu").data("ejMenu");
                    menuObj.destroy();
                    $("#" + this.element[0].id + "_contextMenu").remove();
                }
            }

            if (data && data.nodes && data.nodes.length > 0) {
                for (var i = data.nodes.length - 1; i >= 0; i--) {
                    var node = data.nodes[i];
                    if (node && (node.type === "connector" || node.segments)) {
                        data.connectors.push(node);
                        data.nodes.splice(i, 1);
                    }
                    if (node._shape)
                        this._isOptimize = false;
                }
            }
            if (data && data.connectors && data.connectors.length > 0) {
                for (var i = data.connectors.length - 1; i >= 0; i--) {
                    var connector = data.connectors[i];
                    var isConnectorRemoved = false;
                    if (connector.targetNode) {
                        if (!this._isExist(data, connector.targetNode)) {
                            isConnectorRemoved = true;
                            data.connectors.splice(i, 1);
                        }
                    }
                    if (connector.sourceNode) {
                        if (!this._isExist(data, connector.sourceNode) && !isConnectorRemoved) {
                            data.connectors.splice(i, 1);
                        }
                    }
                }
            }
            if (data.selectedItems) {
                data.selectedItems.userHandles = this.model.selectedItems.userHandles ? this.model.selectedItems.userHandles : [];
                data.selectedItems.children = this.model.selectedItems.children ? this.model.selectedItems.children : [];
            }
            this.upgrade(data);
            var load = {
                nodes: data.nodes ? data.nodes : [],
                connectors: data.connectors ? data.connectors : [],
                commandManager: data.commandManager ? data.commandManager : {},
                contextMenu: data.contextMenu ? data.contextMenu : {},
                snapSettings: data.snapSettings ? data.snapSettings : {},
                historyManager: data.historyManager ? data.historyManager : this._initHistoryManager(),
                backgroundImage: data.backgroundImage ? data.backgroundImage : ej.datavisualization.Diagram.BackgroundImage({ source: "" }),
                enableAutoScroll: data.enableAutoScroll ? data.enableAutoScroll : true,
                autoScrollMargin: data.autoScrollMargin ? data.autoScrollMargin : 20,
                layout: data.layout ? data.layout : {},
                pageSettings: data.pageSettings ? data.pageSettings : {},
                click: data.click ? data.click : null,
                connectionChange: data.connectionChange ? data.connectionChange : null,
                defaultSettings: data.defaultSettings ? data.defaultSettings : { node: null, connector: null },
                dataSourceSettings: data.dataSourceSettings ? data.dataSourceSettings : {},
                doubleClick: data.doubleClick ? data.doubleClick : null,
                enableContextMenu: data.enableContextMenu === undefined ? true : data.enableContextMenu,
                tooltip: data.tooltip ? data.tooltip : null,
                height: data.height ? data.height : null,
                mouseEnter: data.mouseEnter ? data.mouseEnter : null,
                mouseOver: data.mouseOver ? data.mouseOver : null,
                mouseLeave: data.mouseLeave ? data.mouseLeave : null,
                nodeTemplate: data.nodeTemplate ? data.nodeTemplate : null,
                rotationChange: data.rotationChange ? data.rotationChange : null,
                selectedItems: data.selectedItems ? data.selectedItems : this.model.selectedItems,
                width: data.width ? data.width : null,
                constraints: data.constraints,
                phases: data.phases ? data.phases : [],
                scrollSettings: data.scrollSettings,
                rulerSettings: data.rulerSettings ? data.rulerSettings : this.rulerSettings,
                serializationSettings: data.serializationSettings ? data.serializationSettings : this.serializationSettings
            };
            this._tempCommandManager = data.commandManager;
            if (data.showTooltip !== undefined) {
                load.showTooltip = data.showTooltip;
            }
            if (data.tooltipTemplateId !== undefined) {
                load.tooltipTemplateId = data.tooltipTemplateId;
            }
            $("#" + this._id).ejDiagram(load);
            this._isLoad = false;
            delete this._isOptimize;
            delete this._tempCommandManager;
        },

        _isExist: function (data, name) {
            var isExist = false;
            for (var i = 0; data.nodes && i < data.nodes.length; i++) {
                if (!isExist) {
                    var node = data.nodes[i];
                    if (node) {
                        if (node.isSwimlane) {
                            if (node.lanes) {
                                var lanes = node.lanes;
                                for (var j = 0; j < lanes.length; j++) {
                                    isExist = this._checkNodeExist(lanes[j], name);
                                    if (isExist)
                                        break;
                                }
                            }
                        }
                        else {
                            isExist = this._checkNodeExist(node, name);
                            if (isExist)
                                break;
                        }
                    }
                }
            }
            return isExist;
        },
        _checkNodeExist: function (node, name) {
            if (node.children) {
                for (var i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    var state = this._checkNodeExist(child, name)
                    if (state) return true;
                }
            }
            else if (this.model.serializationSettings.preventDefaultValues) {
                if (node && (node.subProcess && node.subProcess.events.length > 0 || node.task && node.task.events.length > 0)) {
                    var eventsCollection = node.subProcess.events.length > 0 ? node.subProcess.events : node.task.events;
                    for (var k = 0; k < eventsCollection.length; k++) {
                        if (eventsCollection[k].name === name) {
                            return true;
                        }
                    }
                }
            }
            if (node.name === name)
                return true;
            return false;
        },

        layout: function () {
            this._isLayoutExecute = true;
            this._setLayout();
            delete this._isLayoutExecute;
        },
        _setLayout: function () {
            //this.model.layout = new ej.datavisualization.Diagram.HierarchicalLayout(this.model.layout);
            this._doLayout();
            ej.datavisualization.Diagram.PageUtil._updatePageSize(this);
            this._clearSelection();
            //this._updateNodes();
            //this._updateConnectors();
        },
        addSelection: function (node, clearSelection) {
            var selectedItem, pseudoGroup;
            if (node && !this._selectionContains(node)) {
                if (this.model.selectedItems.children.length > 0 && !clearSelection) {
                    pseudoGroup = this.nameTable["multipleSelection"];
                    if (!pseudoGroup) {
                        pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                        this.nodes().push(pseudoGroup);
                        this.nameTable[pseudoGroup.name] = pseudoGroup;
                    }
                    if (this.model.selectedItems.children.length > 1)
                        pseudoGroup.children = this.selectionList[0].children;
                    else
                        pseudoGroup.children.push(this.selectionList[0].name)
                    pseudoGroup.children.push(node.name);
                    ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this, null, true);
                    selectedItem = pseudoGroup;
                }
                else {
                    selectedItem = node;
                }
                if (this._hasSelection())
                    this._clearSelection(true);
                if (pseudoGroup && this.nameTable["multipleSelection"] === undefined && clearSelection === false) {
                    this.nodes().push(pseudoGroup);
                    this.nameTable[pseudoGroup.name] = pseudoGroup;
                }
                this._addSelection(selectedItem);
            }
        },

        clearSelection: function () {
            this._clearSelection();
        },
        removeSelection: function (node) {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                if (node) {
                    var node = this.nameTable[node.name];
                    if (this.selectionList[0] == node || this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children.length == 1) { this._clearSelection(); }
                    else if (this.selectionList[0].type == "pseudoGroup" && this._collectionContains(node.name, this.selectionList[0].children)) {
                        var index = this.selectionList[0].children.indexOf(node.name);
                        if (index != -1)
                            ej.datavisualization.Diagram.Util.removeItem(this.selectionList[0].children, node.name);
                        else
                            ej.datavisualization.Diagram.Util.removeItem(this.selectionList[0].children, node);
                        ej.datavisualization.Diagram.Util.removeItem(this.model.selectedItems.children, node);
                        ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                        this._updateSelectionHandle();
                    }
                }
            }
        },
        updateSelectedObject: function (nodeName, parent) {
            var node = this.nameTable[nodeName];
            if (node && ej.datavisualization.Diagram.Util.enableLayerOption(node, "lock", this) && (ej.datavisualization.Diagram.Util.canSelect(node) || node._isHeader)) {
                this.activeTool.selectedObject = node;
            }
            if (parent && parent.isSwimlane)
                this.activeTool.selectedObject = parent
        },
        updateSelection: function (isDragging) {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                this._updateSelectionHandle(isDragging);
            }
        },
        activateTool: function (toolName, singleAction) {
            if (this.tools[toolName]) {
                if (this.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                    this.activeTool._showAllPorts(true);
                }
                this._toolToActivate = toolName;
                this.activeTool = this.tools[this._toolToActivate];
                this.activeTool.singleAction = true;
                if (singleAction === false || toolName === "panTool")
                    this.activeTool.singleAction = false;
            }
            if (this.activeTool instanceof ej.datavisualization.Diagram.PanTool) {
                this._currentCursor = "pointer";
                this.activeTool.startPoint = ej.datavisualization.Diagram.Point(0, 0);
                this.activeTool._isMouseDown = false;
            }
            if (this.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                if (this.activeTool.singleAction)
                    this.tool(this.tool() | ej.datavisualization.Diagram.Tool.DrawOnce);
                else
                    this.tool(this.tool() | ej.datavisualization.Diagram.Tool.ContinuesDraw);
                this.activeTool._showAllPorts();
            }
            this._drawingTool = true;
        },
        deactivateTool: function () {
            if (this.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                this.activeTool._showAllPorts(true);
            }
            if (this.tool() & ej.datavisualization.Diagram.Tool.DrawOnce)
                this.tool(this.tool() ^ ej.datavisualization.Diagram.Tool.DrawOnce);
            if (this.tool() & ej.datavisualization.Diagram.Tool.ContinuesDraw)
                this.tool(this.tool() ^ ej.datavisualization.Diagram.Tool.ContinuesDraw);
            if (this.tool() & ej.datavisualization.Diagram.Tool.ZoomPan) {
                this._toolToActivate = "panTool";
                this.activeTool = this.tools[this._toolToActivate];
                this.activeTool._mousedown = false;
                this._currentCursor = "pointer";
            } else {
                this._toolToActivate = "select";
                this.activeTool = this.tools[this._toolToActivate];
                this.tool(ej.datavisualization.Diagram.Tool.SingleSelect | ej.datavisualization.Diagram.Tool.MultipleSelect);
            }
            this.activeTool._removeHighLighter();
            ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this._adornerSvg, this._adornerLayer);
        },
        updateLabel: function (nodeName, label, obj) {
            if (nodeName && (ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                var mNode = this._findNode(nodeName);
                if (!mNode)
                    mNode = this._findConnector(nodeName);
                if (obj && label && !obj.name || label.name == obj.name || (mNode && mNode._isHeader && label.name === obj.name + "_label")) {
                    if (mNode) {
                        if (obj.templateId && label.templateId && label.templateId != obj.templateId) {
                            ej.datavisualization.Diagram.DiagramContext.setLabelTemplate(mNode, label, this);
                        }
                        if (!this._isUndo)
                            this._recordPropertiesChanged(mNode, obj, "label", label);
                        if (mNode.type !== "text") {
                            label = this._findLabel(mNode, label.name);
                        }
                        obj.name = label.name;
                        this._comparePropertyValues(mNode, "labels", obj);
                        for (var prop in obj)
                            if (label.hasOwnProperty(prop)) {
                                if (typeof obj[prop] == "object")
                                    label[prop] = $.extend(true, {}, label[prop], obj[prop]);
                                else
                                    label[prop] = obj[prop];
                            }
                        if (obj["wrapText"] !== undefined) label["wrapping"] = obj["wrapText"] ? "wrapwithoverflow" : "nowrap";
                        if (mNode.segments || mNode.type !== "text") {
                            ej.datavisualization.Diagram.DiagramContext.updateLabelStyle(mNode, label, this);
                            ej.datavisualization.Diagram.DiagramContext.updateLabel(mNode, label, this);
                        } else if (mNode.type === "text") {
                            ej.datavisualization.Diagram.DiagramContext.updateTextBlock(mNode, label, this);
                        }
                        this._updateQuad(mNode);
                    }
                    if (obj.mode === ej.datavisualization.Diagram.LabelEditMode.Edit) {
                        this.startLabelEdit(mNode, label);
                    }
                }
            }
            return label;
        },
        startLabelEdit: function (node, label) {
            if (node) {
                //Disables the edit mode of labels in the selectionList
                for (var i = 0; i < this.selectionList.length; i++) {
                    var mNode = this.selectionList[i];
                    if (mNode !== node && typeof mNode.labels.length != "undefined") {
                        for (var j = 0; j < mNode.labels.length; j++)
                            mNode.labels[j].mode = ej.datavisualization.Diagram.LabelEditMode.View;
                    }
                }
                if (!label && node.type === "text")
                    label = node.textBlock;
                if (this._setLabelEditing(label))
                    this._startEdit(node);
                else {
                    this._endEdit();
                }
            }
        },
        _setSelectorConstraints: function (constraints) {
            this.model.selectedItems.constraints = constraints;
            if (this.selectionList[0]) {
                ej.datavisualization.Diagram.SvgContext.clearSelector(this._adornerSvg, this._adornerLayer, this);
                ej.datavisualization.Diagram.SvgContext.renderSelector(this.selectionList[0], this._adornerSvg, this._adornerLayer, this._currZoom, constraints, undefined, this);
                if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                    ej.datavisualization.Diagram.SvgContext.renderUserHandles(this.model.selectedItems.userHandles, this.selectionList[0], this._adornerSvg, this.selectionList[0].type == "pseudoGroup",
                        this._currZoom, this._adornerLayer, this);
            }
        },
        _raiseGroupChangeEvent: function (element, oldParent, newParent, cause) {
            var args = {};
            args.element = element ? element : null;
            args.oldParent = oldParent ? oldParent : null;
            args.newParent = newParent ? newParent : null;
            args.cause = cause ? cause : null;
            if (oldParent != newParent)
                this._raiseEvent("groupChange", args);
            return args;
        },
        group: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                var selectionList = [];
                var i;
                for (i = 0; i < this.selectionList[0].children.length; i++)
                    selectionList.push(this.nameTable[this._getChild(this.selectionList[0].children[i])]);
                this._sortByZIndex(selectionList, true);
                var element;
                var groupName = ej.datavisualization.Diagram.Util.randomId();
                var group = new ej.datavisualization.Diagram.Group({ name: groupName, rotateAngle: this.selectionList[0].rotateAngle });
                var oldParent, newParent;
                this._clearSelection(true);
                for (i = 0; i < selectionList.length; i++) {
                    this._isUndo = true;
                    group.children.push(selectionList[i]);
                    if (selectionList[i].parent) {
                        oldParent = this.nameTable[selectionList[i].parent];
                        if (oldParent) {
                            ej.datavisualization.Diagram.Util.removeChildFromGroup(oldParent.children, selectionList[i]);
                        }
                    }
                    selectionList[i].parent = groupName;
                    ej.datavisualization.Diagram.Util.removeItem(this.selectionList, selectionList[i].name);
                    if (!selectionList[i].segments) {
                        ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.nameTable[selectionList[i].name]);
                        this._nodes = $.extend(true, [], this.nodes());
                    }
                    else {
                        ej.datavisualization.Diagram.Util.removeItem(this.connectors(), this.nameTable[selectionList[i].name]);
                        this._connectors = $.extend(true, [], this.connectors());
                    }
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[selectionList[i].name], selectionList[i]);
                    if (selectionList[i].type == "html") {
                        element = document.getElementById(selectionList[i].name + "_parentdiv");
                        element.parentNode.removeChild(element);
                    } else {
                        if (selectionList[i]._type === "group")
                            this._checkForHtmlNode(selectionList[i]);
                    }
                    // $("#" + selectionList[i].name)[0].parentNode.removeChild($("#" + selectionList[i].name)[0]);
                    element = this._svg.document.getElementById(selectionList[i].name);
                    if (element)
                        element.parentNode.removeChild(element);
                    this._removeElement(selectionList[i]);
                    this._raiseGroupChangeEvent(selectionList[i], oldParent, group, "group");
                }
                ej.datavisualization.Diagram.Util.clear(this.selectionList);
                group = this._getNewGroup(group);
                this._eventCause["nodeCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.Unknown;
                this._isGroupNode = true;
                this.add(group);
                //this._addSelection(group);
                var entry = { type: "groupchanged", object: group, actionType: "group", category: "internal" };
                this.addHistoryEntry(entry);
                //var entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.GroupHandleCmd(group, "group"));
                //this.historyManager.addHistoryEntry(entry);
                this._isUndo = false;
                delete this._isGroupNode;
            }
        },
        _checkForHtmlNode: function (group) {
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                var child = this.nameTable[children[i]];
                if (child) {
                    if (child._type === "group") {
                        this._checkForHtmlNode(child);
                    } else {
                        if (child.type == "html") {
                            var element = document.getElementById(child.name + "_parentdiv");
                            element.parentNode.removeChild(element);
                        }
                    }
                }
            }
        },
        _removeChildren: function (group, args) {
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                var child = this.nameTable[children[i]];
                if (child) {
                    if (group.isLane || ((child.inEdges.length > 0) || (child.outEdges.length > 0))) {
                        this._disConnect(child, args);
                        this._removeConnector(child, args);
                    }
                    else {
                        if (child.segments) {
                            this._removeEdges(child);
                            child.sourceNode = child.sourcePort = child.targetNode = child.targetPort = null;
                        }
                        else {
                            this._disConnect(child, args, true);
                            // this._removeConnector(child, args);
                        }
                    }
                    ej.datavisualization.Diagram.Util.removeItem(this.nodes(), child);
                    this._nodes = $.extend(true, [], this.nodes());
                    if (child._type === "group") {
                        this._removeChildren(child, args);
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[child.name], child);
                        ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, child);
                        delete this.nameTable[child.name];
                    } else {
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[child.name], child);
                        ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, child);
                        delete this.nameTable[child.name];
                    }
                    this._removeElement(child);
                }
            }
        },
        ungroup: function () {
            if (this.selectionList[0] && this.selectionList[0]._type === "group" && this.selectionList[0].canUngroup && !(this.selectionList[0].isSwimlane || this.selectionList[0].isLane)) {
                this._isUndo = true;
                var selectionList = this.selectionList[0].children;
                var i, node;
                var htmlLayer = this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                node = this.selectionList[0];
                $("#" + this.selectionList[0].name)[0].parentNode.removeChild($("#" + this.selectionList[0].name)[0]);
                this._removeElement(this.selectionList[0]);
                this._checkForHtmlNode(this.selectionList[0]);
                this._clearSelection();
                var object;
                ej.datavisualization.Diagram.Util.clear(this.selectionList);
                var newParent, oldParent;
                for (i = 0; i < selectionList.length; i++) {
                    var item = this.nameTable[this._getChild(selectionList[i])];
                    if (item.parent)
                        oldParent = this.nameTable[item.parent];
                    if ($(htmlLayer).children("#" + item.name)[0])
                        htmlLayer.removeChild($(htmlLayer).children("#" + item.name)[0]);
                    if (item) {
                        if (item.parent)
                            item.parent = null;
                        if (item.segments) {
                            object = item;
                            object.parent = "";
                            this._updateEdges(object);
                            this._dock(object, this.nameTable);
                            ej.datavisualization.Diagram.DiagramContext.renderConnector(object, this);
                            if (this.connectors().indexOf(object) === -1) {
                                this.connectors().push(object);
                                this._connectors = $.extend(true, [], this.connectors());
                            }
                        }
                        else {
                            object = item;
                            object.parent = "";
                            if (object._type === "group") {
                                this._updateChildrenEdges(object);
                                if (object.isLane || object.isSwimlane) {
                                    object.width = 0;
                                    object.height = 0;
                                }
                                ej.datavisualization.Diagram.DiagramContext.renderGroup(object, this);
                            }
                            else
                                ej.datavisualization.Diagram.DiagramContext.renderNode(object, this);
                            if (this.nodes().indexOf(object) === -1) {
                                this.nodes().push(object);
                                this._nodes = $.extend(true, [], this.nodes());
                            }
                        }
                        if (item.parent)
                            newParent = this.nameTable[item.parent];
                        this._raiseGroupChangeEvent(item, oldParent, newParent, "unGroup");
                    }
                }
                //this._clearSelection();
                ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this._findNode(node.name));
                ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[node.name], node);
                ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, node);
                var entry = { type: "groupchanged", object: node, actionType: "ungroup", category: "internal" };
                this.addHistoryEntry(entry);

                //var entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.GroupHandleCmd(node, "ungroup"));
                //this.historyManager.addHistoryEntry(entry);
                this._isUndo = false;
            }
        },
        nudge: function (direction, delta) {
            delta = !delta ? 1 : delta;
            var dir = { up: { x: 0, y: -delta }, down: { x: 0, y: delta }, left: { x: -delta, y: 0 }, right: { x: delta, y: 0 } };
            var nudge = dir[direction];
            var undoDirection;
            if (direction === "up")
                undoDirection = "down";
            else if (direction === "down")
                undoDirection = "up";
            else if (direction === "left")
                undoDirection = "right";
            else if (direction === "right")
                undoDirection = "left";

            if (nudge && this.selectionList[0] && !this.selectionList[0].isLane && !this.selectionList[0].isPhase) {
                if (!this._isUndo) {
                    this.addHistoryEntry({
                        type: "nudge", object: this.selectionList[0], undoDirection: undoDirection, redoDirection: direction, values: delta,
                        category: "internal"
                    });
                }
                this._nudge(this.selectionList[0], nudge.x, nudge.y, direction);
            }
        },
        selectAll: function () {
            var collection, nodes, i, len, item = null;
            this._clearSelection(true);
            collection = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", name: "multipleSelection" });
            nodes = this.nodes();
            for (i = 0, len = nodes.length; i < len; i++) {
                if (ej.datavisualization.Diagram.Util.canSelect(nodes[i]) && ej.datavisualization.Diagram.Util.enableLayerOption(nodes[i], "lock", this)) {
                    item = this.nameTable[nodes[i].name];
                    if (item && item.parent == "" && item.type != "pseudoGroup" && item.visible) {
                        collection.children.push(item.name);
                    }
                }
            }
            var connectors = this.connectors();
            for (i = 0, len = connectors.length; i < len; i++) {
                if (ej.datavisualization.Diagram.Util.canSelect(connectors[i]) && ej.datavisualization.Diagram.Util.enableLayerOption(connectors[i], "lock", this)) {
                    if (connectors[i].parent == "" && connectors[i].visible) {
                        collection.children.push(connectors[i].name);
                    }
                }
            }
            ej.datavisualization.Diagram.Util._updateGroupBounds(collection, this);
            //ej.datavisualization.Diagram.Util.clear(this.selectionList);
            if (collection.children.length > 1) {
                this.nodes().push(collection);
                this._nodes = $.extend(true, [], this.nodes());
                this.nameTable[collection.name] = collection;
                this._addSelection(collection);
            }
            else if (collection.children.length === 1) {
                this._addSelection(this.nameTable[collection.children[0]]);
            }
        },
        align: function (direction) {
            if (this.selectionList[0] && (this.selectionList[0].type === "group" || this.selectionList[0].type == "pseudoGroup") && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var history = [];
                var cNode;
                var cornerNodes = this._findCornerNodes();
                if (direction === "left")
                    cNode = cornerNodes.left;
                else if (direction === "right")
                    cNode = cornerNodes.right;
                else if (direction === "top")
                    cNode = cornerNodes.top;
                else if (direction === "bottom")
                    cNode = cornerNodes.bottom;
                var cNodeBounds;
                if (cNode)
                    cNodeBounds = ej.datavisualization.Diagram.Util.bounds(cNode);
                else if (direction === "center" || direction === "middle") {
                    cNodeBounds = ej.datavisualization.Diagram.Util.bounds(this.selectionList[0]);
                }
                if (cNodeBounds) {
                    this._associatedConnectorsUpdate = true;
                    var i, bounds, node, x = 0, y = 0;
                    for (i = 0; i < list.length; i++) {
                        node = this.nameTable[this._getChild(list[i])];
                        bounds = ej.datavisualization.Diagram.Util.bounds(node);
                        if (direction === "left")
                            x = -(bounds.x - cNodeBounds.x);
                        else if (direction === "right")
                            x = -((bounds.x + bounds.width) - (cNodeBounds.x + cNodeBounds.width));
                        else if (direction === "top")
                            y = -(bounds.y - cNodeBounds.y);
                        else if (direction === "bottom")
                            y = -((bounds.y + bounds.height) - (cNodeBounds.y + cNodeBounds.height));
                        else if (direction === "center")
                            x = -((bounds.x + bounds.width / 2) - (cNodeBounds.x + cNodeBounds.width / 2));
                        else if (direction === "middle")
                            y = -((bounds.y + bounds.height / 2) - (cNodeBounds.y + cNodeBounds.height / 2));
                        this._moveNode(x, y, node);
                        this._updateContainerOnNudge(node);
                        history.push({ object: node, delta: { x: x, y: y } });
                    }
                    delete this._associatedConnectorsUpdate;

                    for (i = 0; i < list.length; i++) {
                        var node = this.nameTable[this._getChild(list[i])];
                        if (!node.segments) {
                            this._updateAssociateConnector(node)
                        }
                    }
                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                    ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
                }
                this.addHistoryEntry({ type: "alignCommand", values: history, category: "internal", object: this.selectionList[0] });
            }
        },
        _updateAssociateConnector: function (node) {
            if (node.children) {
                var child;
                var list = node.children;
                if (list) {
                    for (var i = 0; i < list.length; i++) {
                        child = this.nameTable[this._getChild(list[i])];
                        if (child)
                            this._updateAssociateConnector(child);
                    }
                }
            }
            ej.datavisualization.Diagram.SvgContext._updateAssociatedConnector(node, this._svg, this);
        },
        sameSize: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var fNode = this.nameTable[this._getChild(this.selectionList[0].children[0])];
                var fNodeBounds = ej.datavisualization.Diagram.Util.bounds(fNode);
                var history = [];
                this._isSizingCommand = true;
                for (var i = 0; i < list.length; i++) {
                    var element = this.nameTable[this._getChild(list[i])];
                    if (!(element.segments)) {
                        //if ((element._shape === "path") && ((element.height !== fNodeBounds.height) || (element.width !== fNodeBounds.width)))
                        //    element._scaled = true;
                        history.push({ object: element, values: { width: element.width || element._width || 0, height: element.height || element._height || 0 } });
                        this.updateNode(element.name, { width: fNodeBounds.width, height: fNodeBounds.height });
                    }
                }
                delete this._isSizingCommand;
                this.addHistoryEntry({ type: "sizeCommand", category: "internal", object: this.selectionList[0], values: history });
                ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
            }
        },
        sameHeight: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var fNode = this.nameTable[this._getChild(this.selectionList[0].children[0])];
                var history = [];
                var fNodeBounds = ej.datavisualization.Diagram.Util.bounds(fNode);
                this._isSizingCommand = true;
                for (var i = 0; i < list.length; i++) {
                    var element = this.nameTable[this._getChild(list[i])];
                    if (!(element.segments)) {
                        //if ((element._shape === "path") && ((element.height !== fNodeBounds.height)))
                        //    element._scaled = true;
                        history.push({ object: element, values: { width: element.width || element._width || 0, height: element.height || element._height || 0 } });
                        this.updateNode(element.name, { height: fNodeBounds.height });
                    }
                }
                delete this._isSizingCommand;
                this.addHistoryEntry({ type: "sizeCommand", category: "internal", object: this.selectionList[0], values: history });
                ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
            }
        },
        sameWidth: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup" && this.selectionList[0].children && this.selectionList[0].children.length > 0) {
                var list = this.nameTable[this.selectionList[0].name].children;
                var fNode = this.nameTable[this._getChild(this.selectionList[0].children[0])];
                var fNodeBounds = ej.datavisualization.Diagram.Util.bounds(fNode);
                var history = [];
                this._isSizingCommand = true;
                for (var i = 0; i < list.length; i++) {
                    var element = this.nameTable[this._getChild(list[i])];
                    if (!(element.segments)) {
                        //if ((element._shape === "path") && (element.width !== fNodeBounds.width))
                        //    element._scaled = true;
                        history.push({ object: element, values: { width: element.width || element._width || 0, height: element.height || element._height || 0 } });
                        this.updateNode(element.name, { width: fNodeBounds.width });
                    }
                }
                delete this._isSizingCommand;
                this.addHistoryEntry({ type: "sizeCommand", category: "internal", object: this.selectionList[0], values: history });
                ej.datavisualization.Diagram.Util._updateGroupBounds(this.selectionList[0], this);
                ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectionList[0], this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
            }
        },
        spaceDown: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                var lstSelections = this.selectionList[0].children;
                this._sliceDockLines(lstSelections);
                this._sortByYvalue(this.selectionList[0].children);
                var selectionCount = lstSelections.length, fSpacing;
                var history = [];
                if (lstSelections && selectionCount > 2) {
                    var cornerNodes = this._findCornerNodes();
                    var firstNode = cornerNodes.top;
                    var dHei = 0;
                    var pre = null, nxt = null;
                    for (var i = 0; i < lstSelections.length; i++) {
                        var pre = null, nxt = null;
                        pre = this.nameTable[this._getChild(lstSelections[i])];
                        nxt = this.nameTable[this._getChild(lstSelections[Number(i) + 1])];
                        if (pre && nxt) {
                            var preBounds = ej.datavisualization.Diagram.Util.bounds(pre);
                            var nxtBounds = ej.datavisualization.Diagram.Util.bounds(nxt);
                            dHei += nxtBounds.y - (preBounds.y + preBounds.height);
                        }
                    }
                    var space = dHei / (selectionCount - 1);
                    for (var i = 0; i < lstSelections.length; i++) {
                        pre = this.nameTable[this._getChild(lstSelections[i])];
                        nxt = this.nameTable[this._getChild(lstSelections[Number(i) + 1])];
                        if (pre && nxt) {
                            var preBounds = ej.datavisualization.Diagram.Util.bounds(pre);
                            var nxtBounds = ej.datavisualization.Diagram.Util.bounds(nxt);
                            this._comparePropertyOnAlign(nxt, 0, (preBounds.bottom - (nxtBounds.top)) + space);
                            this._translate(nxt, 0, (preBounds.bottom - (nxtBounds.top)) + space, this.nameTable);
                            history.push({ object: nxt, delta: { x: 0, y: (preBounds.bottom - (nxtBounds.top)) + space } });
                            this._updateQuad(this, nxt);
                            this._updateNodeMargin(nxt);
                            ej.datavisualization.Diagram.DiagramContext.update(nxt, this);
                        }
                    }
                    this.addHistoryEntry({ type: "spacingCommand", values: history, category: "internal", object: this.selectionList[0] });
                }
            }
        },
        spaceAcross: function () {
            if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                var lstSelections = this.selectionList[0].children;
                this._sliceDockLines(lstSelections);
                this._sortByXvalue(this.selectionList[0].children);
                var selectionCount = lstSelections.length, fSpacing;
                var history = [];
                if (lstSelections && selectionCount > 2) {
                    var cornerNodes = this._findCornerNodes();
                    var firstNode = cornerNodes.left;
                    var dWid = 0;
                    var pre = null, nxt = null;
                    for (var i = 0; i < lstSelections.length; i++) {

                        var pre = null, nxt = null;
                        pre = this.nameTable[this._getChild(lstSelections[i])];
                        nxt = this.nameTable[this._getChild(lstSelections[Number(i) + 1])];
                        if (pre && nxt) {
                            var preBounds = ej.datavisualization.Diagram.Util.bounds(pre);
                            var nxtBounds = ej.datavisualization.Diagram.Util.bounds(nxt);
                            dWid += nxtBounds.x - (preBounds.x + preBounds.width);
                        }
                    }
                    var space = dWid / (selectionCount - 1);
                    var sdx = 0;
                    for (var i = 0; i < lstSelections.length; i++) {
                        pre = this.nameTable[this._getChild(lstSelections[i])];
                        nxt = this.nameTable[this._getChild(lstSelections[Number(i) + 1])];
                        if (pre && nxt) {
                            var preBounds = ej.datavisualization.Diagram.Util.bounds(pre);
                            var nxtBounds = ej.datavisualization.Diagram.Util.bounds(nxt);
                            this._comparePropertyOnAlign(nxt, (preBounds.right - (nxtBounds.left)) + space, 0);
                            this._translate(nxt, (preBounds.right - (nxtBounds.left)) + space, 0, this.nameTable);
                            history.push({ object: nxt, delta: { x: (preBounds.right - (nxtBounds.left)) + space, y: 0 } });
                            this._updateQuad(this, nxt);
                            this._updateNodeMargin(nxt);
                            ej.datavisualization.Diagram.DiagramContext.update(nxt, this);
                        }
                    }
                    this.addHistoryEntry({ type: "spacingCommand", values: history, category: "internal", object: this.selectionList[0] });
                }
            }
        },
        sendBackward: function () {
            var ovarLapNodes, i;
            var prevNode;
            if (this.selectionList[0] && this.selectionList[0].type != "pseudoGroup") {
                var node = this.selectionList[0];
                if (node) {
                    ovarLapNodes = this._findOverlapNode(node, "sendBackward");
                    this._sortByZIndex(ovarLapNodes);
                    for (var k = 0; k < ovarLapNodes.length; k++)
                        if (node.zOrder > ovarLapNodes[k].zOrder) {
                            prevNode = ovarLapNodes[k];
                            break;
                        }
                    var start = node.zOrder;
                    if (prevNode) {
                        var end = prevNode.zOrder;
                        this._comparePropertyValues(node, "zOrder", { zOrder: end }, null, ej.datavisualization.Diagram.ActionType.Order);
                        this._sendElementsToBack(start, end, node, prevNode);
                        this.addHistoryEntry({ type: "zOrder", command: "back", start: end, end: start, nearestNode: prevNode, object: node, category: "internal" });
                    }
                }
            }
        },
        _sendElementsToBack: function (start, end, node, prevNode) {
            var i;
            for (i = end; i < start; i++) {
                if (node.parent != "") {
                    var object = this._findObjectByIndex(i, true);
                    if (object)
                        object.zOrder += 1;
                }
                else {
                    object = this._findObjectByIndex(i);
                    if (object)
                        object.zOrder += 1;
                }
            }
            this._deleteZorderProcess();
            if (node.parent != "") {
                if (node.parent) {
                    var parent = this.nameTable[node.parent];
                    this._findChildren(parent, node.name).zOrder = end;
                }
            } else
                this._findObjectByName(node.name).zOrder = end;
            var htmlLayer = this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
            var textElement = $(htmlLayer).find("#" + node.name + "_label")[0];
            var htmlElement = $(htmlLayer).find("#" + node.name + "_parentdiv")[0];
            var element = $(htmlLayer).find("#" + prevNode.name + "_parentdiv")[0];
            if (!element)
                element = $(htmlLayer).find("#" + prevNode.name)[0];
            if (element && htmlElement)
                element.parentNode.insertBefore(htmlElement, element);
            if (element && textElement)
                element.parentNode.insertBefore(textElement, element);
            this._svg.getElementById(prevNode.name).parentNode.insertBefore(this._svg.getElementById(node.name), this._svg.getElementById(prevNode.name));
            this._updateSelectionHandle();
        },
        _deleteZorderProcess: function () {
            var nodes = this.nodes();
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i]._isProcessed) delete nodes[i]._isProcessed;
            }
            var connectors = this.connectors()
            for (var i = 0; i < connectors.length; i++) {
                if (connectors[i]._isProcessed) delete connectors[i]._isProcessed;
            }
        },
        _bringElementsToFront: function (start, end, node, prevNode) {
            var i;
            for (i = end; i > start; i--) {
                if (node.parent != "") {
                    var obj = this._findObjectByIndex(i, true)
                    if (obj)
                        obj.zOrder -= 1;
                }
                else {
                    obj = this._findObjectByIndex(i);
                    if (obj)
                        obj.zOrder -= 1;
                }
            }
            this._deleteZorderProcess();
            if (node.parent) {
                var parent = this.nameTable[node.parent];
                this._findChildren(parent, node.name).zOrder = end;
            } else
                this._findObjectByName(node.name).zOrder = end;
            var htmlLayer = this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
            var textElement = $(htmlLayer).find("#" + node.name + "_label")[0];
            var textElement1 = $(htmlLayer).find("#" + prevNode.name + "_label")[0];
            var htmlElement = $(htmlLayer).find("#" + node.name + "_parentdiv")[0];
            var element = $(htmlLayer).find("#" + prevNode.name + "_parentdiv")[0];
            if (!element)
                element = $(htmlLayer).find("#" + prevNode.name)[0];
            if (textElement1 && htmlElement)
                textElement1.parentNode.insertBefore(htmlElement, textElement1.nextSibling);
            if (htmlElement && textElement)
                htmlElement.parentNode.insertBefore(textElement, htmlElement.nextSibling);
            if (element && htmlElement)
                element.parentNode.insertBefore(htmlElement, element.nextSibling);
            this._svg.getElementById(prevNode.name).parentNode.insertBefore(this._svg.getElementById(node.name), this._svg.getElementById(prevNode.name).nextSibling);
            this._updateSelectionHandle();
        },
        moveForward: function () {
            var ovarLapNodes, i;
            var prevNode;
            if (this.selectionList[0] && this.selectionList[0].type != "pseudoGroup") {
                var node = this.selectionList[0];
                if (node) {
                    ovarLapNodes = this._findOverlapNode(node, "moveForward");
                    this._sortByZIndex(ovarLapNodes);
                    for (var k = ovarLapNodes.length - 1; k >= 0; k--)
                        if (node.zOrder < ovarLapNodes[k].zOrder) {
                            prevNode = ovarLapNodes[k];
                            break;
                        }

                    var start = node.zOrder;
                    if (prevNode) {
                        var end = prevNode.zOrder;
                        this._comparePropertyValues(node, "zOrder", { zOrder: end }, null, ej.datavisualization.Diagram.ActionType.Order);
                        this._bringElementsToFront(start, end, node, prevNode);
                        this.addHistoryEntry({ type: "zOrder", command: "front", start: end, end: start, nearestNode: prevNode, object: node, category: "internal" });
                    }
                }
            }
        },
        sendToBack: function () {
            var node = this.selectionList[0];
            var prevNode;
            if (node && node.type != "pseudoGroup") {
                var ovarLapNodes = this._findOverlapNode(node, "sendToBack");
                var nodes = this._sortByZIndex(ovarLapNodes);
                var start = node.zOrder;
                var end = node.zOrder;
                var firstNode;
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i].zOrder < end) {
                        if (i == 0) firstNode = nodes[i];
                        end = nodes[i].zOrder;
                        prevNode = nodes[i];
                    }
                }
                if (prevNode) {
                    this._comparePropertyValues(node, "zOrder", { zOrder: end }, null, ej.datavisualization.Diagram.ActionType.Order);
                    this._sendElementsToBack(start, end, node, prevNode);
                    this.addHistoryEntry({ type: "zOrder", command: "back", start: end, end: start, nearestNode: firstNode, object: node, category: "internal" });
                }
            }
        },
        bringToFront: function () {
            var node = this.selectionList[0];
            var prevNode;
            if (node && node.type != "pseudoGroup") {
                var ovarLapNodes = this._findOverlapNode(node, "bringToFront");
                var nodes = this._sortByZIndex(ovarLapNodes);
                var start = node.zOrder;
                var end = node.zOrder;
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i].zOrder > end) {
                        end = nodes[i].zOrder;
                        prevNode = nodes[i];
                    }
                }
                if (prevNode) {
                    this._comparePropertyValues(node, "zOrder", { zOrder: end }, null, ej.datavisualization.Diagram.ActionType.Order);
                    this._bringElementsToFront(start, end, node, prevNode);
                    this.addHistoryEntry({ type: "zOrder", command: "front", start: end, end: start, nearestNode: nodes[i - 1], object: node, category: "internal" });
                }
            }
        },
        _getChildFromCollection: function (collection, name) {
            if (collection && collection.length > 0 && name) {
                for (var i = 0; i < collection.length; i++) {
                    if (collection[i].name === name)
                        return collection[i];
                }
            }
        },

        _updateNameTable: function (node) {
            if (node.children && node.children.length > 0) {
                for (var i = 0; i < node.children.length; i++) {
                    var child = typeof node.children[i] == "object" ? node.children[i] : null;
                    if (child) {
                        this.nameTable[child.name] = child;
                        if (child.children && child.children.length > 0)
                            this._updateNameTable(child);
                    }
                }
            }
        },
        _recordPageSettingsChanged: function (args) {
            var value = args.redoObject;
            if (args.isUndo)
                value = args.undoObject;
            if (value)
                this.updatePageSettings(value);
        },
        _recordMultiRotationChanged: function (args) {
            ej.datavisualization.Diagram.canvasHelper._undoMultiRotateNode(this, args);
        },
        _recordMultiPinPointChanged: function (args) {
            ej.datavisualization.Diagram.canvasHelper._undoMultiDragNode(this, args);
        },
        _recordMultiSizeChanged: function (args) {
            ej.datavisualization.Diagram.canvasHelper._undoMultiResizeNode(this, args);
        },
        undo: function () {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this)) && ej.datavisualization.Diagram.Util.canUndo(this)) {
                var args;
                this._getHistoryList();
                this._isUndo = true;
                var entryItem = this.getUndoEntry();
                if (entryItem) {
                    if (entryItem.type == "closeGroup") {
                        this._groupUndo = true;
                    }
                    else if (entryItem.type == "startGroup") {
                        this._groupUndo = false;
                    }
                    else this._undo(entryItem);
                    if (this._groupUndo) {
                        entryItem = this.getUndoEntry();
                        while (entryItem && entryItem.type != "startGroup") {
                            this._undo(entryItem);
                            if (!this._groupUndo) {
                                break;
                            }
                            entryItem = this.getUndoEntry();
                        }
                        delete this._groupUndo;
                    }
                }
                this._isUndo = false;
            }
        },
        redo: function () {
            this._isUndo = true;
            //this.historyManager.redo();
            var entryItem = this.getRedoEntry();
            if (entryItem) {
                if (entryItem.type == "startGroup") {
                    this._groupRedo = true;
                }
                else this._redo(entryItem);
                if (this._groupRedo) {
                    entryItem = this.getRedoEntry();
                    while (entryItem && entryItem.type != "closeGroup") {
                        this._isUndo = true;
                        this._redo(entryItem);
                        entryItem = this.getRedoEntry();
                    }
                    delete this._groupRedo;
                }
            }
            this._isUndo = false;
        },


        _ComparehistoryChangeEvent: function (object, entryItem) {
            var item, i, objNode, argument;
            var changes = { source: [], changes: [] };
            switch (entryItem.type) {
                case "positionchanged":
                case "rotationchanged":
                case "sizechanged":
                    changes = this._getPseudoGroupElements(object, entryItem);
                    break;
                case "endpointchanged":
                    var args;
                    if (this._UndoRedo) {
                        args = this._historyChangeEvent(entryItem.undoObject, entryItem.redoObject, entryItem);
                        argument = { type: entryItem.type, oldValues: args.changes ? args.changes.oldValues : args.oldValues, newValues: args.changes ? args.changes.newValues : args.newValues, cancel: false };
                        changes.source.push(entryItem.undoObject);
                    }
                    else {
                        args = this._historyChangeEvent(entryItem.redoObject, entryItem.undoObject, entryItem);
                        argument = { type: entryItem.type, oldValues: args.changes ? args.changes.oldValues : args.oldValues, newValues: args.changes ? args.changes.newValues : args.newValues, cancel: false };
                        changes.source.push(entryItem.redoObject);
                    }
                    changes.changes.push(argument);
                    break;
                case "collectionchanged":
                    if (entryItem.changeType == "remove")
                        argument = { type: entryItem.type, addedItems: [], deletedItems: [object] };
                    if (entryItem.changeType == "insert")
                        argument = { type: entryItem.type, addedItems: [object], deletedItems: [] };
                    changes.changes.push(argument);
                    changes.source.push(object);
                    break;
                case "labelchanged":
                    if (this._UndoRedo)
                        argument = { type: entryItem.type, newValues: { text: entryItem.previousLabelValue }, oldValues: { text: entryItem.updatedLabelValue } };
                    else
                        argument = { type: entryItem.type, newValues: { text: entryItem.updatedLabelValue }, oldValues: { text: entryItem.previousLabelValue } };
                    changes.changes.push(argument);
                    changes.source.push(entryItem.shape);
                    break;
                case "labelcollectionchanged":
                    argument = { type: entryItem.type, source: entryItem.shape, addedItems: [entryItem.label], deletedItems: [] };
                    changes.changes.push(argument);
                    changes.source.push(entryItem.shape);
                case "groupchanged":
                    if (entryItem.actionType == "group")
                        argument = { type: entryItem.type, source: entryItem.object, addedItems: [entryItem.object], deletedItems: [] };
                    else
                        argument = { type: entryItem.type, source: entryItem.object, addedItems: [], deletedItems: [entryItem.object] }
                    changes.changes.push(argument);
                    changes.source.push(entryItem.object);
                    break;
                case "phasepositionchanged":
                    if (this._UndoRedo) {
                        argument = { type: entryItem.type, newValues: { offset: entryItem.undoObject.offset }, oldValues: { offset: entryItem.redoObject.offset } };
                        changes.source.push(entryItem.undoObject);
                    }
                    else {
                        argument = { type: entryItem.type, newValues: { offset: entryItem.redoObject.offset }, oldValues: { offset: entryItem.undoObject.offset } };
                        changes.source.push(entryItem.redoObject);
                    }
                    changes.changes.push(argument);
                    break;
                case "phasecollectionchanged":
                    if (entryItem.isAdded)
                        argument = { type: entryItem.type, addedItems: [entryItem.phase], deletedItems: [] };
                    else
                        argument = { type: entryItem.type, addedItems: [], deletedItems: [entryItem.phase] };
                    changes.source.push(entryItem.phase);
                    changes.changes.push(argument);
                    break;
                case "propertiesChanged":
                    argument = this._propertyChangeEventValues(entryItem);
                    changes.source.push(argument.source);
                    changes.changes.push(argument.changes);
                    break;
                case "portscollectionchanged":
                    if (entryItem.changeType == "insert")
                        argument = { type: entryItem.type, addedItems: [entryItem.collection], deletedItems: [] };
                    if (entryItem.changeType == "remove")
                        argument = { type: entryItem.type, addedItems: [], deletedItems: [entryItem.collection] };
                    changes.source.push(entryItem.object);
                    changes.changes.push(argument);
                    break;
                case "nudge":
                    var newValues = {}, oldValues = {};
                    if (entryItem.object._type !== "label") {
                        if (this._UndoRedo) {
                            if (entryItem.undoDirection == "left") {
                                newValues.offsetX = entryItem.object.offsetX - entryItem.values;
                                oldValues.offsetX = entryItem.object.offsetX;
                            }
                            if (entryItem.undoDirection == "right") {
                                newValues.offsetX = entryItem.object.offsetX + entryItem.values;
                                oldValues.offsetX = entryItem.object.offsetX;
                            }
                            if (entryItem.undoDirection == "up") {
                                newValues.offsetY = entryItem.object.offsetY - entryItem.values;
                                oldValues.offsetY = entryItem.object.offsetY;
                            }
                            if (entryItem.undoDirection == "down") {
                                newValues.offsetY = entryItem.object.offsetY + entryItem.values;
                                oldValues.offsetY = entryItem.object.offsetY;
                            }
                            argument = { type: entryItem.type, newValues: newValues, oldValues: oldValues };
                        }
                        else {
                            if (entryItem.redoDirection == "left") {
                                newValues.offsetX = entryItem.object.offsetX - entryItem.values;
                                oldValues.offsetX = entryItem.object.offsetX;
                            }
                            if (entryItem.redoDirection == "right") {
                                newValues.offsetX = entryItem.object.offsetX + entryItem.values;
                                oldValues.offsetX = entryItem.object.offsetX;
                            }
                            if (entryItem.redoDirection == "up") {
                                newValues.offsetY = entryItem.object.offsetY - entryItem.values;
                                oldValues.offsetY = entryItem.object.offsetY;
                            }
                            if (entryItem.redoDirection == "down") {
                                newValues.offsetY = entryItem.object.offsetY + entryItem.values;
                                oldValues.offsetY = entryItem.object.offsetY;
                            }
                            argument = { type: entryItem.type, newValues: newValues, oldValues: oldValues };
                        }
                    }
                    else
                        argument = this._labelNudge(entryItem);
                    changes.source.push(entryItem.object);
                    changes.changes.push(argument);
                    break;
                case "spacingCommand":
                case "alignCommand":
                    var newValues = {}, oldValues = {}, newVal = [], oldVal = [];
                    for (var i = 0; i < entryItem.values.length; i++) {
                        var node = entryItem.values[i];
                        if (!node.object.segments) {
                            newValues = { offsetX: node.object.offsetX - node.delta.x, offsetY: node.object.offsetY - node.delta.y };
                            newVal.push(newValues);
                            oldValues = { offsetX: node.object.offsetX, offsetY: node.object.offsetY };
                            oldVal.push(oldValues);
                        }
                        else {
                            var connector = $.extend(true, {}, node.object);
                            oldValues = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };
                            oldVal.push(oldValues);
                            ej.datavisualization.Diagram.Util._translateLine(connector, node.delta.x, node.delta.y);
                            newValues = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };
                            newVal.push(newValues);
                        }
                    }
                    argument = { type: entryItem.type, newValues: newVal, oldValues: oldVal };
                    changes.source.push(entryItem.object);
                    changes.changes.push(argument);
                    break;
                case "sizeCommand":
                    var newValues = {}, oldValues = {}, newVal = [], oldVal = [];
                    for (var i = 0; i < entryItem.values.length; i++) {
                        var node = entryItem.values[i];
                        newValues = { width: node.values.width, height: node.values.height };
                        newVal.push(newValues);
                        oldValues = { width: node.object.width, height: node.object.height };
                        oldVal.push(oldValues);
                    }
                    argument = { type: entryItem.type, newValues: newVal, oldValues: oldVal };
                    changes.source.push(entryItem.object);
                    changes.changes.push(argument);
                    break;
                case "zOrder":
                    argument = { type: entryItem.type, source: entryItem.object, newValues: { zOrder: entryItem.end }, oldValues: { zOrder: entryItem.object.zOrder } };
                    changes.source.push(entryItem.object);
                    changes.changes.push(argument);
                    break;
            }
            return changes;
        },
        _labelNudge: function (entryItem) {
            var node = this.findNode(entryItem.object._parent);
            var newValues = {}, oldValues = {}, argument;
            var direction = this._UndoRedo ? entryItem.undoDirection : entryItem.redoDirection;
            if (direction == "left" || direction == "right") {
                newValues.offsetX = (direction == "left") ? (entryItem.object.offset.x - (entryItem.values / node.width)) : (entryItem.object.offset.x + (entryItem.values / node.width));
                oldValues.offsetX = entryItem.object.offset.x;
            }
            else if (direction == "up" || direction == "down") {
                newValues.offsetY = (direction == "up") ? (entryItem.object.offset.y - (entryItem.values / node.height)) : (entryItem.object.offset.y + (entryItem.values / node.height));
                oldValues.offsetY = entryItem.object.offset.y;
            }
            argument = { type: entryItem.type, newValues: newValues, oldValues: oldValues };
            return argument;
        },
        _getPseudoGroupElements: function (object, entryItem) {
            var item, i, objNode, argument;
            var changes;
            var originalObject = this._UndoRedo || !this._isUndo ? entryItem.undoObject.node : entryItem.redoObject.node;
            argument = { source: [], changes: [] };
            if (object && object.type == "pseudoGroup") {
                var children = this._getChildren(object.children);
                for (i = 0; i < children.length; i++) {
                    item = this.nameTable[this._getChild(children[i])];
                    var objNode = this._UndoRedo || !this._isUndo ? entryItem.undoObject.childTable[children[i]] : entryItem.redoObject.childTable[children[i]];
                    if (!this._isUndo) {
                        changes = this._historyChangeEvent(item, objNode, entryItem);
                    }
                    else {
                        changes = this._historyChangeEvent(objNode, item, entryItem);
                    }
                    if (changes.source)
                        argument.source.push(changes.source);
                    if (changes.changes)
                        argument.changes.push(changes.changes);
                }
            }
            else {
                if (!this._isUndo) {
                    changes = this._historyChangeEvent(object, originalObject, entryItem);
                }
                else {
                    changes = this._historyChangeEvent(originalObject, object, entryItem);
                }
                if (changes.source)
                    argument.source.push(changes.source);
                if (changes.changes)
                    argument.changes.push(changes.changes);
            }
            return argument;
        },

        _propertyChangeEventValues: function (entryItem) {
            var args;
            var changes = [];
            var values = entryItem.updateValues ? entryItem.updateValues : entryItem.values;
            if (entryItem.elementType == "label") {
                var node = entryItem.label;
            }
            else if (entryItem.elementType == "port") {
                var node = entryItem.port;
            }
            else {
                var node = entryItem.object;
            }
            var oldValues = {}, newValues = {};
            for (var property in values) {
                if (node[property] != values[property]) {
                    oldValues[property] = node[property];
                    newValues[property] = values[property];
                }
            }
            args = { type: entryItem.type, newValues: newValues, oldValues: oldValues, deletedItems: [], addedItems: [] };
            changes.push(args);
            return { changes: changes, source: node };
        },

        _historyChangeEvent: function (object, originalObject, entryItem) {
            var args = { type: entryItem.type, deletedItems: [], addedItems: [], oldValues: {}, newValues: {} };
            if (object.offsetX != originalObject.offsetX) {
                args.oldValues.offsetX = originalObject.offsetX;
                args.newValues.offsetX = object.offsetX;
            }
            if (object.offsetY != originalObject.offsetY) {
                args.oldValues.offsetY = originalObject.offsetY;
                args.newValues.offsetY = object.offsetY;
            }
            if (object.width != originalObject.width) {
                args.oldValues.width = originalObject.width;
                args.newValues.width = object.width;
            }
            if (object.height != originalObject.height) {
                args.oldValues.height = originalObject.height;
                args.newValues.height = object.height;
            }
            if (object.rotateAngle != originalObject.rotateAngle) {
                args.oldValues.rotateAngle = originalObject.rotateAngle;
                args.newValues.rotateAngle = object.rotateAngle;
            }
            if (object.sourcePoint || originalObject.sourcePoint) {
                var newObject = object.sourcePoint || {};
                var oldObject = originalObject.sourcePoint || {};
                if (newObject.x != oldObject.x || newObject.y != oldObject.y) {
                    args.oldValues.sourcePoint = originalObject.sourcePoint;
                    args.newValues.sourcePoint = object.sourcePoint;
                }
            }
            if (object.targetPoint || originalObject.targetPoint) {
                var newObject = object.targetPoint || {};
                var oldObject = originalObject.targetPoint || {};
                if (newObject.x != oldObject.x || newObject.y != oldObject.y) {
                    args.oldValues.targetPoint = originalObject.targetPoint;
                    args.newValues.targetPoint = object.targetPoint;
                }
            }
            return { changes: args, source: originalObject };
        },

        _undo: function (entryItem) {
            var argument = [];
            this._UndoRedo = true;

            if (entryItem) {
                if (entryItem.category == "internal") {
                    var object = entryItem.object || (entryItem.undoObject ? entryItem.undoObject.node || entryItem.undoObject : undefined) || entryItem.shape;
                    if (!object && entryItem.phase) object = entryItem.phase;
                    if (object && entryItem.undoObject && entryItem.undoObject.node)
                        object = this.nameTable[object.name] || object;
                    if (!object) {
                        this.undo();
                        return;
                    }
                    if (this.model.historyManager.undoStack.length > 0) {
                        var addObject = this.model.historyManager.undoStack.splice(0, 1);
                        this.model.historyManager.redoStack.splice(0, 0, addObject[0]);
                    }
                    argument = this._ComparehistoryChangeEvent(object, entryItem);
                    argument.cause = ej.datavisualization.Diagram.HistoryChangeCause.Undo;
                    this._raiseEvent("historyChange", argument);
                    if (object && object.parent)
                        var parent = typeof object.parent == "object" ? object.parent.name : object.parent;
                    if (parent && !object.isLane) {
                        if (!this.nameTable[parent]) {
                            this._isUndo = false;
                            this.undo();
                            return;
                        }
                    }
                    var args;
                    switch (entryItem.type) {
                        case "pagesettingschanged":
                            var entry = { isUndo: true, undoObject: entryItem.undoObject, redoObject: entryItem.redoObject }
                            this._recordPageSettingsChanged(entry);
                            break;
                            break;
                        case "positionchanged":
                            if (entryItem.swimlaneMultiSelection) {
                                entryItem.undo = true;
                                this._recordMultiPinPointChanged(entryItem);
                            }
                            else {
                                args = { object: entryItem.undoObject, isMultipleNode: entryItem.isMultipleNode };
                                this._recordPinPointChanged(args);
                            }
                            this._undoredoUpdateRouting(entryItem.undoObject.connectors);
                            break;
                        case "rotationchanged":
                            if (entryItem.swimlaneMultiSelection) {
                                entryItem.undo = true;
                                this._recordMultiRotationChanged(entryItem);
                            }
                            else {
                                args = { object: entryItem.undoObject, isMultipleNode: entryItem.isMultipleNode };
                                this._recordRotationChanged(args);
                            }
                            this._undoredoUpdateRouting(entryItem.undoObject.connectors);
                            break;
                        case "sizechanged":
                            entryItem.undo = true;
                            if (entryItem.swimlaneMultiSelection) {
                                this._recordMultiSizeChanged(entryItem);
                            }
                            else {
                                args = { object: entryItem.undoObject, isMultipleNode: entryItem.isMultipleNode };
                                this._recordSizeChanged(args, entryItem);
                            }
                            this._undoredoUpdateRouting(entryItem.undoObject.connectors);
                            break;
                        case "endpointchanged":
                            args = { undoObject: entryItem.undoObject, redoObject: entryItem.redoObject, removePortType: entryItem.removePortType, removedPort: entryItem.removedPort, isMultipleNode: entryItem.isMultipleNode, _isUndo: true };
                            this._recordEndPointChanged(args);
                            break;
                        case "collectionchanged":
                            if (entryItem.changeType == "insert") {
                                if (!this.nameTable[entryItem.object.name]) {
                                    if (entryItem.object._type !== "pseudoGroup") {
                                        if (this._groupUndo) return;
                                        this._isUndo = false;
                                        this.undo();
                                    }
                                }
                            }
                            args = { changeType: entryItem.changeType, childTable: entryItem.childTable, edgeTable: entryItem.edgeTable, isUndo: true, sourcePorts: entryItem.sourcePorts, targetPorts: entryItem.targetPorts, index: entryItem.index };
                            args.object = jQuery.extend(true, {}, entryItem.object);
                            var update = this._recordCollectionChanged(args, entryItem);
                            if (update) {
                                entryItem.sourcePorts = args.sourcePorts;
                                entryItem.targetPorts = args.targetPorts;
                                entryItem.edgeTable = args.edgeTable;
                                entryItem.childTable = args.childTable;
                            }
                            break;
                        case "labelchanged":
                            args = { object: entryItem.shape, label: entryItem.previousLabelValue, index: entryItem.index ? entryItem.index : 0 };
                            this._recordLabelChanged(args);
                            break;
                        case "labelpositionchanged":
                            entryItem.undo = true;
                            this._recordLabelPositionChanged(entryItem);
                            break;
                        case "labelsizechanged":
                            entryItem.undo = true;
                            this._recordLabelPositionChanged(entryItem);
                            break;
                        case "labelrotationchanged":
                            entryItem.undo = true;
                            this._recordLabelPositionChanged(entryItem);
                            break;
                        case "labelcollectionchanged":
                            entryItem.isUndo = true;
                            this.labelcollectionchanged(entryItem);
                            break;
                        case "groupchanged":
                            args = { object: entryItem.object, isUndo: true, actionType: entryItem.actionType };
                            this._recordGroupChanged(args);
                            break;
                        case "phasepositionchanged":
                            entryItem.undo = true;
                            this._recordPhasesizeChanged(entryItem);
                            break;
                        case "phasecollectionchanged":
                            entryItem = $.extend(true, {}, { phase: entryItem.phase, group: entryItem.group, isAdded: entryItem.isAdded, phaseObject: entryItem.phaseObject, islastPhase: entryItem.islastPhase, });
                            entryItem.undo = true;
                            this._recordPhaseCollectionChanged(entryItem);
                            break;
                        case "propertiesChanged":
                            var node = this.nameTable[entryItem.object.name];
                            if (node) {
                                var currentState = this._getModifiedProperties(node, entryItem.values, entryItem[entryItem.elementType]);
                                if (entryItem.elementType == "node")
                                    this.updateNode(node.name, entryItem.values);
                                else if (entryItem.elementType == "connector")
                                    this.updateConnector(node.name, entryItem.values);
                                else if (entryItem.elementType == "label")
                                    entryItem.label = this.updateLabel(node.name, entryItem.label, entryItem.values);
                                else if (entryItem.elementType == "port")
                                    this.updatePort(node.name, entryItem.port, entryItem.values);
                                entryItem.values = currentState;
                            }
                            break;
                        case "portpositionchanged":
                            entryItem.undo = true;
                            this._recordPortPositionChanged(entryItem);
                            break;
                        case "portscollectionchanged":
                            entryItem.isUndo = true;
                            this._recordPortsCollectionChanged(entryItem);
                            break;
                        case "nudge":
                            this._recordNudgingChanges(object, entryItem);
                            break;
                        case "spacingCommand":
                        case "alignCommand":
                            this._recordAlignCommandChanges(entryItem);
                            break;
                        case "sizeCommand":
                            this._recordSizeCommandChanges(entryItem);
                            break;
                        case "swapLane":
                            entryItem = jQuery.extend(true, {}, { undoObject: entryItem.undoObject, redoObject: entryItem.redoObject, moveIndex: entryItem.moveIndex, insertIndex: entryItem.currentIndex });
                            entryItem.undo = true;
                            ej.datavisualization.Diagram.canvasHelper._undoSwap(this, entryItem);
                            break;
                        case "zOrder":
                            var end = entryItem.start;
                            var node = this.nameTable[entryItem.object.name];
                            this._comparePropertyValues(node, "zOrder", { zOrder: entryItem.end });
                            if (entryItem.command == "back") {
                                this._bringElementsToFront(entryItem.start, entryItem.end, entryItem.object, entryItem.nearestNode);
                                entryItem.command = "front";
                            }
                            else {
                                this._sendElementsToBack(entryItem.start, entryItem.end, entryItem.object, entryItem.nearestNode);
                                entryItem.command = "back";
                            }
                            entryItem.nearestNode = this._findObjectByIndex(end);
                            var temp = entryItem.start;
                            entryItem.start = entryItem.end;
                            entryItem.end = temp;
                            this._deleteZorderProcess();
                            break;
                    }
                    if (!entryItem.activeLabel) {
                        if (this.selectionList.length && object && this.selectionList[0].name != object.name) {
                            this._clearSelection(true);
                            this._addSelection(this.nameTable[object.name], true);
                        }
                    }
                    else {
                        this._clearSelection(true);
                        this._addSelection(entryItem.activeLabel, true);
                    }
                } else {
                    if (this.model.historyManager.undo) {
                        var undo = this.model.historyManager.undo;
                        if (typeof undo == "string") undo = ej.util.getObject(undo, window);
                        if ($.isFunction(undo)) {
                            var data = undo(entryItem.data);
                            if (data) entryItem.data = data;
                        }
                    }
                }
            }
        },
        _undoredoUpdateRouting: function (connectors) {
            if (ej.datavisualization.Diagram.Util.canRouteDiagram(this) && connectors) {
                var keys = Object.keys(connectors);
                for (var i = 0; i < keys.length; i++) {
                    var edge = this.nameTable[keys[i]];
                    edge._undoSegments = connectors[keys[i]].segments
                    this._resetConnectorPoints(edge, null);
                    delete edge._undoSegments;
                }
            }
        },
        _redo: function (entryItem) {
            var argument = [];
            this._UndoRedo = false;
            if (entryItem) {
                if (entryItem.category == "internal") {
                    var object = entryItem.object || (entryItem.undoObject ? entryItem.undoObject.node || entryItem.undoObject : undefined) || entryItem.shape;
                    if (!object && entryItem.phase) object = entryItem.phase;
                    if (object && entryItem.undoObject && entryItem.undoObject.node)
                        object = this.nameTable[object.name] || object;
                    if (!object) {
                        this.redo();
                        return;
                    }

                    if (this.model.historyManager.redoStack.length > 0) {
                        var addObject = this.model.historyManager.redoStack.splice(0, 1);
                        this.model.historyManager.undoStack.splice(0, 0, addObject[0]);
                    }
                    argument = this._ComparehistoryChangeEvent(object, entryItem);
                    argument.cause = ej.datavisualization.Diagram.HistoryChangeCause.Redo;
                    this._raiseEvent("historyChange", argument);
                    if (object && object.parent)
                        var parent = typeof object.parent == "object" ? object.parent.name : object.parent;
                    if (parent) {
                        if (!this.nameTable[parent]) {
                            this._isUndo = false;
                            this.redo();
                            return;
                        }
                    }
                    var args;
                    switch (entryItem.type) {
                        case "pagesettingschanged":
                            var entry = { isUndo: false, undoObject: entryItem.undoObject, redoObject: entryItem.redoObject }
                            this._recordPageSettingsChanged(entry);
                            break;
                        case "positionchanged":
                            if (entryItem.swimlaneMultiSelection) {
                                entryItem.undo = false;
                                this._recordMultiPinPointChanged(entryItem);
                            }
                            else {
                                var args = { object: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode };
                                this._recordPinPointChanged(args);
                            }
                            this._undoredoUpdateRouting(entryItem.redoObject.connectors);
                            break;
                        case "rotationchanged":
                            if (entryItem.swimlaneMultiSelection) {
                                entryItem.undo = false;
                                this._recordMultiRotationChanged(entryItem);
                            }
                            else {
                                args = { object: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode };
                                this._recordRotationChanged(args);
                            }
                            this._undoredoUpdateRouting(entryItem.redoObject.connectors);
                            break;
                        case "sizechanged":
                            entryItem.undo = false;
                            if (entryItem.swimlaneMultiSelection) {
                                this._recordMultiSizeChanged(entryItem);
                            }
                            else {
                                args = { object: entryItem.redoObject, isMultipleNode: entryItem.isMultipleNode };
                                this._recordSizeChanged(args);
                            }
                            this._undoredoUpdateRouting(entryItem.redoObject.connectors);
                            break;
                        case "endpointchanged":
                            args = { undoObject: entryItem.undoObject, redoObject: entryItem.redoObject, removePortType: entryItem.removePortType, removedPort: entryItem.removedPort, isMultipleNode: entryItem.isMultipleNode, _isUndo: false };
                            this._recordEndPointChanged(args);
                            break;
                        case "collectionchanged":
                            args = {
                                changeType: entryItem.changeType, childTable: entryItem.childTable, edgeTable: entryItem.edgeTable,
                                isUndo: false, sourcePorts: entryItem.sourcePorts, targetPorts: entryItem.targetPorts, index: entryItem.index
                            };
                            args.object = jQuery.extend(true, {}, entryItem.object);
                            this._recordCollectionChanged(args, entryItem.object);
                            break;
                        case "labelchanged":
                            args = { object: entryItem.shape, label: entryItem.updatedLabelValue, index: entryItem.index ? entryItem.index : 0 };
                            this._recordLabelChanged(args);
                            break;
                        case "labelpositionchanged":
                            entryItem.undo = false;
                            this._recordLabelPositionChanged(entryItem);
                            break;
                        case "labelsizechanged":
                            entryItem.undo = false;
                            this._recordLabelPositionChanged(entryItem);
                            break;
                        case "labelrotationchanged":
                            entryItem.undo = false;
                            this._recordLabelPositionChanged(entryItem);
                            break;
                        case "labelcollectionchanged":
                            entryItem.isUndo = false;
                            this.labelcollectionchanged(entryItem);
                            break;
                        case "groupchanged":
                            args = { object: entryItem.object, actionType: entryItem.actionType, isUndo: false };
                            this._recordGroupChanged(args);
                            break;
                        case "phasepositionchanged":
                            entryItem.undo = false;
                            this._recordPhasesizeChanged(entryItem);
                            break;
                        case "phasecollectionchanged":
                            entryItem = $.extend(true, {}, { phase: entryItem.phase, group: entryItem.group, phaseObject: entryItem.phaseObject, islastPhase: entryItem.islastPhase, isAdded: entryItem.isAdded });
                            entryItem.undo = false;
                            this._recordPhaseCollectionChanged(entryItem);
                            break;
                        case "propertiesChanged":
                            var node = this.nameTable[entryItem.object.name];
                            if (node) {
                                var currentState = this._getModifiedProperties(node, entryItem.values, entryItem[entryItem.elementType]);
                                if (entryItem.elementType == "node")
                                    this.updateNode(node.name, entryItem.values);
                                else if (entryItem.elementType == "connector")
                                    this.updateConnector(node.name, entryItem.values);
                                else if (entryItem.elementType == "label")
                                    entryItem.label = this.updateLabel(node.name, entryItem.label, entryItem.values);
                                else if (entryItem.elementType == "port")
                                    this.updatePort(node.name, entryItem.port, entryItem.values);
                                entryItem.values = currentState;
                            }
                            break;
                        case "portpositionchanged":
                            entryItem.undo = false;
                            this._recordPortPositionChanged(entryItem);
                            break;
                        case "portscollectionchanged":
                            entryItem.isUndo = false;
                            this._recordPortsCollectionChanged(entryItem);
                            break;
                        case "nudge":
                            this._recordNudgingChanges(object, entryItem, true);
                            break;
                        case "spacingCommand":
                        case "alignCommand":
                            this._recordAlignCommandChanges(entryItem);
                            break;
                        case "sizeCommand":
                            this._recordSizeCommandChanges(entryItem);
                            break;
                        case "swapLane":
                            entryItem = jQuery.extend(true, {}, { undoObject: entryItem.undoObject, redoObject: entryItem.redoObject, moveIndex: entryItem.moveIndex, insertIndex: entryItem.currentIndex });
                            entryItem.undo = false;
                            ej.datavisualization.Diagram.canvasHelper._undoSwap(this, entryItem);
                            break;
                        case "zOrder":
                            var end = entryItem.start;
                            var node = this.nameTable[entryItem.object.name];
                            this._comparePropertyValues(node, "zOrder", { zOrder: entryItem.end });
                            if (entryItem.command == "back") {
                                this._bringElementsToFront(entryItem.start, entryItem.end, entryItem.object, entryItem.nearestNode);
                                entryItem.command = "front";
                            }
                            else {
                                this._sendElementsToBack(entryItem.start, entryItem.end, entryItem.object, entryItem.nearestNode);
                                entryItem.command = "back";
                            }
                            entryItem.nearestNode = this._findObjectByIndex(end);
                            var temp = entryItem.start;
                            entryItem.start = entryItem.end;
                            entryItem.end = temp;
                            this._deleteZorderProcess();
                            break;
                    }
                    if (!entryItem.activeLabel) {
                        if (this.selectionList.length && object && this.selectionList[0].name != object.name) {
                            this._clearSelection(true);
                            this._addSelection(this.nameTable[object.name], true);
                        }
                    }
                    else {
                        this._clearSelection(true);
                        this._addSelection(entryItem.activeLabel, true);
                    }
                } else if (this.model.historyManager.redo) {
                    var redo = this.model.historyManager.redo;
                    if (typeof redo == "string") redo = ej.util.getObject(redo, window);
                    if ($.isFunction(redo)) {
                        var data = redo(entryItem.data);
                        if (data) entryItem.data = data;
                    }
                }
            }
        },
        _startGroupAction: function () {
            this.addHistoryEntry({ type: "startGroup", category: "internal" });
        },
        _closeGroupAction: function () {
            this.addHistoryEntry({ type: "closeGroup", category: "internal" });
        },

        addHistoryEntry: function (entry) {
            var canLog, object, params, args;
            if (!this._preventHistoryEntry) {
                if (!this.model.historyManager.suspend) {
                    if (this.model.historyManager.canLog) {
                        canLog = this.model.historyManager.canLog;
                        if (typeof canLog == "string") canLog = ej.util.getObject(canLog, window);
                        if ($.isFunction(canLog)) {
                            object = this.getNode(entry.object || (entry.undoObject && entry.undoObject.node) || entry.shape);
                            params = this._ComparehistoryChangeEvent(object, entry);
                            args = { changes: params.changes.length ? params.changes[0] : null, source: params.source.length ? this.getNode(params.source[0]) : null };
                            if (canLog(args) == false) return;
                        }
                    }
                    if (entry.category != "internal") {
                        entry = { data: entry };
                    }
                    if (this._historyList.canUndo) {
                        if (this._historyList.currentEntry && (this._historyList.currentEntry.data || this._historyList.currentEntry.category == "internal")) {
                            var cEntry = this._historyList.currentEntry;
                            if (cEntry.next) {
                                if (cEntry.previous) {
                                    var entry1 = cEntry.next;
                                    entry1.previous = null;
                                    cEntry.next = entry;
                                    entry.previous = cEntry;
                                }
                            } else {
                                cEntry.next = entry;
                                entry.previous = cEntry;
                            }
                        }
                    }
                    this._historyList.currentEntry = entry;
                    if (this.model.historyManager.stackLimit) {
                        if (this._historyList.currentEntry && this._historyList.currentEntry.previous && !this._lastbefore) {
                            this._lastbefore = entry;
                        }
                        else if (!this._historyList.currentEntry.previous) {
                            this._lastbefore = null;
                            this._historyCount = 0;
                        }

                        if (this._historyCount < this.model.historyManager.stackLimit)
                            this._historyCount++;
                        else {
                            if (this._lastbefore) {
                                if (this._lastbefore.previous)
                                    delete this._lastbefore.previous
                                if (this._lastbefore.next)
                                    this._lastbefore = this._lastbefore.next;
                            }
                        }
                    }

                    var object = entry.object || (entry.redoObject ? entry.redoObject.node || entry.redoObject : undefined) || entry.shape;
                    var args = this._ComparehistoryChangeEvent(object, entry);
                    args.cause = ej.datavisualization.Diagram.HistoryChangeCause.CustomAction;
                    this._getHistoryList();
                    this._raiseEvent("historyChange", args);
                    this._historyList.canUndo = true;
                    this._historyList.canRedo = false;
                }
            }
        },
        removeHistoryEntry: function (entry) {
            if (this._historyList.currentEntry != null) {
                var cEntry = this._historyList.currentEntry;
                //previous and next entries of target entry
                var prev, nxt;
                if (cEntry) {
                    if (cEntry == entry) {
                        prev = cEntry.previous;
                        nxt = cEntry.next;
                        this._historyList.currentEntry = nxt || prev;
                    } else {
                        var nextEntry = cEntry.next;
                        while (nextEntry) {
                            if (nextEntry == entry) {
                                prev = nextEntry.previous;
                                nxt = nextEntry.next;
                                break;
                            } else nextEntry = nextEntry.next;
                        }
                        var prevEntry = cEntry.previous;
                        while (prevEntry) {
                            if (prevEntry == entry) {
                                prev = prevEntry.previous;
                                nxt = prevEntry.next;
                                break;
                            } else prevEntry = prevEntry.previous;
                        }
                    }
                }
                if (prev && nxt) {
                    prev.next = nxt;
                    nxt.previous = prev;
                } else if (prev) {
                    prev.next = null;
                } else if (nxt) {
                    nxt.previous = null;
                }
            }
        },
        canRemoveHistoryEntry: function (entry) {
            return entry.category != "internal";
        },
        clearHistory: function () {
            var hList = this._historyList;
            hList.currentEntry = null;
            hList.canUndo = false;
            hList.canRedo = false;
            this.model.historyManager.undoStack = [];
            this.model.historyManager.redoStack = [];
            //this._hScrollbar._scrollData = null;
            //this._vScrollbar._scrollData = null;
        },

        _getHistroyObject: function (list, object) {
            if (object) {
                if (object.type !== "startGroup" && object.type !== "closeGroup") {
                    list.push({
                        redoObject: object.redoObject ? object.redoObject : null,
                        undoObject: object.undoObject ? object.undoObject : null,
                        type: object.type ? object.type : null,
                        isMultipleNode: object.isMultipleNode ? object.isMultipleNode : null,
                        category: object.category ? object.category : ""
                    });
                }
            }
        },

        _getHistoryList: function () {
            var undoStack = [], redoStack = [];
            var currEntry = this._historyList.currentEntry;
            var undoObj, redoObj;


            currEntry = this._historyList.currentEntry;
            if (this._historyList.canUndo || this.model.historyManager.undoStack.length === 0)
                this._getHistroyObject(undoStack, currEntry)
            else
                this._getHistroyObject(redoStack, currEntry)

            while (currEntry && currEntry.previous) {
                undoObj = currEntry.previous;
                this._getHistroyObject(undoStack, undoObj)
                currEntry = currEntry.previous;
            }

            currEntry = this._historyList.currentEntry;
            while (currEntry && currEntry.next) {
                redoObj = currEntry.next;
                this._getHistroyObject(redoStack, redoObj)
                currEntry = currEntry.next;
            }
            this.model.historyManager.undoStack = undoStack;
            this.model.historyManager.redoStack = redoStack;
        },
        getUndoEntry: function () {
            var undoEntry = null;
            var currentEntry;
            var hList = this._historyList;
            if (hList.canUndo) {
                undoEntry = hList.currentEntry;
                currentEntry = hList.currentEntry.previous;
                if (currentEntry) {
                    hList.currentEntry = currentEntry;
                    if (!hList.canRedo)
                        hList.canRedo = true;
                } else {
                    hList.canRedo = true;
                    hList.canUndo = false;
                }
            }
            return undoEntry;
        },
        getRedoEntry: function () {
            var redoEntry = null;
            var entryCurrent;
            var hList = this._historyList;
            if (hList.canRedo) {
                if (!hList.currentEntry.previous && !hList.canUndo) {
                    entryCurrent = hList.currentEntry;
                } else
                    entryCurrent = hList.currentEntry.next;
                if (entryCurrent) {
                    hList.currentEntry = entryCurrent;
                    if (!hList.canUndo)
                        hList.canUndo = true;
                    if (!entryCurrent.next) {
                        hList.canRedo = false;
                        hList.canUndo = true;
                    }
                }
                redoEntry = hList.currentEntry;
            }
            return redoEntry;
        },
        cut: function () {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                this._pasteIndex = 0;
                this._setClipboard();
                this._eventCause["nodeCollectionChange"] = this._eventCause["connectorCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.ClipBoard;
                this._multipleAction = true;
                this._delete();
                delete this._multipleAction;
            }
        },

        insertLabel: function (name, label, index) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var node = this.nameTable[name];
                if (node && label) {
                    var obj = this.getObjectType(node) == "node" ? this.model.defaultSettings.node : this.model.defaultSettings.connector;
                    obj = obj ? obj : {};
                    if (obj && obj.labels && node.labels && obj.labels[index !== undefined ? index : node.labels.length])
                        label = $.extend(true, {}, obj.labels[index !== undefined ? index : node.labels.length], label);
                    obj.labels = obj.labels ? obj.labels : [];
                    label = ej.datavisualization.Diagram.Label(label);
                    label._parent = name;
                    var prtyLabels = obj.labels;
                    prtyLabels.splice();
                    if (!this._collectionContains(label, node.labels)) {
                        node.labels.splice(index, 0, label);
                    }
                    //node.labels.push(label);
                    var resource = { element: node, index: index, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "labels", oldValue: prtyLabels, newValue: node.labels };
                    this._raisePropertyChange(resource);
                    ej.datavisualization.Diagram.DiagramContext.addLabel(node, label, this, index);
                    if (!this._isUndo)
                        this.addHistoryEntry({ type: "labelcollectionchanged", shape: node, label: label, isUndo: true, category: "internal", index: index });
                }
            }
        },
        addLabel: function (name, label) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var node = this.nameTable[name];
                if (node && label) {
                    var oldlabels;
                    var obj = this.getObjectType(node) == "node" ? this.model.defaultSettings.node : this.model.defaultSettings.connector;
                    if (obj && obj.labels && node.labels && obj.labels[node.labels.length])
                        label = $.extend(true, {}, obj.labels[node.labels.length], label);
                    label = ej.datavisualization.Diagram.Label(label);
                    label._parent = name;
                    oldlabels = node.labels;
                    node.labels.push(label);
                    var resource = { element: node, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "labels", oldValue: oldlabels, newValue: node.labels };
                    this._raisePropertyChange(resource);
                    ej.datavisualization.Diagram.DiagramContext.addLabel(node, label, this);
                    this.addHistoryEntry({ type: "labelcollectionchanged", shape: node, label: label, isUndo: true, category: "internal" });
                }
            }
        },
        removeLabels: function (name, labels) {
            var removeCollection = [];
            if (labels && labels.length > 0) {
                var node = this.nameTable[name];
                if (node && node.labels && node.labels.length > 0) {
                    for (var j = labels.length - 1; j >= 0; j--) {
                        for (var i = node.labels.length - 1; i >= 0; i--) {
                            if (node.labels[i].name === labels[j].name) {
                                ej.datavisualization.Diagram.SvgContext.deleteLabel(node, node.labels[i], this);
                                removeCollection.push({ index: i, label: $.extend(true, {}, node.labels[i]) })
                                node.labels.splice(i, 1);
                            }
                        }
                    }
                }
                if (!this._isUndo)
                    this.addHistoryEntry({ type: "labelcollectionchanged", shape: node, labels: removeCollection, isLabelRemove: true, isUndo: true, category: "internal" });
            }
        },
        _initLayer: function () {
            var modelLayers = this.model.layers;
            var layer, i
            for (i = 0; i < modelLayers.length; i++) {
                modelLayers[i] = ej.datavisualization.Diagram.Layers(modelLayers[i])
                layer = modelLayers[i];
                if (!layer.visible || layer.lock) {
                    layer.active = false;
                }
                this._updateLayer(modelLayers[i])
            }
        },
        _updateLayer: function (layer) {
            var node = layer.objects;
            var i, nodeName
            for (i = 0; i < node.length; i++) {
                nodeName = node[i]
                if (this._isUpdate(this.nameTable[nodeName], layer))
                    this.updateNode(nodeName, {})
            }
        },
        _findLayer: function (name) {
            var modelLayers = this.model.layers;
            var i, layer
            for (i = 0; i < modelLayers.length; i++) {
                if (modelLayers[i].name === name) {
                    layer = modelLayers[i];
                }
            }
            return layer
        },
        _checkGroupChild: function (group) {
            var children, child, childlayer, j, index;
            children = this._getChildren(group.children);
            for (var i = 0; children && i < children.length; i++) {
                child = this.nameTable[children[i]];
                childlayer = this.model.layers;
                if (child.length > 0) {
                    for (j = 0; j < childlayer.length; j++) {
                        index = childlayer[j].objects.indexOf(child.name)
                        if (index > -1) {
                            this.model.layers[j].objects.splice(index, 1);
                            this._updateLayer(childlayer[j])
                        }
                    }
                    if (child.children) {
                        this._checkGroupChild(child);
                    }
                }
            }
        },
        addLayers: function (layers) {
            var layer, j, i, layerObject, modelLayers;
            for (j = 0; j < layers.length; j++) {
                modelLayers = this.model.layers
                layers[j] = ej.datavisualization.Diagram.Layers(layers[j])
                layer = layers[j];
                if (!layer.visible || layer.lock) {
                    layer.active = false;
                }
                if (!this._findLayer(layer.name)) {
                    this.model.layers.push(layer)
                    if (layer.objects && layer.objects.length) {
                        for (i = 0; layer && i < layer.objects.length; i++) {
                            layerObject = this.nameTable[layer.objects[i]];
                            if (layerObject) {
                                if (layerObject.type === "group")
                                    this._checkGroupChild(layerObject);
                                if (layerObject && !layerObject.isLane && !layerObject.isPhase) {
                                    if (this._isUpdate(layerObject, layer)) {
                                        this.updateNode(layerObject.name, {})
                                        this._clearSelection(true);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        addNodeToLayer: function (layerName, nodes) {
            var layer, objects, i
            layer = this._findLayer(layerName)
            if (layer) {
                objects = layer.objects;
                for (i = 0; i < nodes.length; i++) {
                    if (objects.indexOf(nodes[i]) < 0) {
                        objects.push(nodes[i]);
                        this.updateNode(nodes[i], {})
                    }
                }
            }
        },
        _isUpdate: function (node, layer) {
            var visible = ej.datavisualization.Diagram.Util.enableLayerOption(this.nameTable[node], "visible", this);
            var lock = ej.datavisualization.Diagram.Util.enableLayerOption(this.nameTable[node], "lock", this)
            if (layer.visible !== visible || layer.lock !== lock) {
                return true
            } else return false
        },
        removeNodeToLayer: function (layerName, nodes) {
            var layer, objects, i, index
            layer = this._findLayer(layerName)
            if (layer) {
                objects = layer.objects;
                for (i = 0; i < nodes.length; i++) {
                    index = objects.indexOf(nodes[i].name)
                    if (index > 0) {
                        objects.splice(index, 1);
                        this.updateNode(nodes[i], {})
                    }
                }
            }
        },
        removeLayers: function (layers) {
            var modelLayer, i, layersObject, index
            for (i = 0; i < layers.length; i++) {
                modelLayer = this.model.layers
                layersObject = this._findLayer(layers[i].name)
                index = modelLayer.indexOf(layersObject)
                this.model.layers.splice(index);
                this._updateLayer(layersObject)
            }
        },
        updateLayer: function (layerName, option) {
            var exixtingLayer = this._findLayer(layerName)
            var isUpdate = false;
            if (option.visible !== undefined) {
                if (exixtingLayer.visible !== option.visible) {
                    isUpdate = true;
                }
                exixtingLayer.visible = option.visible;
            }
            if (option.lock !== undefined) {
                if (exixtingLayer.lock !== option.lock) {
                    isUpdate = true;
                }
                exixtingLayer.lock = option.lock;
            }
            if (option.print !== undefined) {
                exixtingLayer.print = option.print;
            }
            if (option.active !== undefined) {
                exixtingLayer.active = option.active;
            }
            if (option.snap !== undefined) {
                if (exixtingLayer.snap !== option.snap) {
                    isUpdate = true;
                }
                exixtingLayer.snap = option.snap;
            }
            if (option.objects !== undefined) {
                this._updateNodeToLayer(exixtingLayer.objects, option.objects);
            }
            if (!option.visible || option.lock) {
                exixtingLayer.active = false;
            }
            if (isUpdate)
                this._updateLayer(exixtingLayer);
            this._clearSelection(true);
        },
        _updateNodeToLayer: function (exixtingLayer, newObject) {
            var commonNode, node, options, i
            for (i = 0; i < newObject.length; i++) {
                if (exixtingLayer.objects.indexOf(newObject[i]) > -1) {
                    commonNode.push(newObject[i]);
                }
            }
            if (commonNode.length > 0) {
                for (i = 0; i < newObject.length; i++) {
                    node = newObject[i]
                    if (commonNode.indexOf(node) < 0) {
                        this.addNodeToLayer(exixtingLayer.name, node)
                    }
                }
            } else {
                options = ej.datavisualization.Diagram.Layers();
                for (i = 0; i < exixtingLayer.objects.length; i++) {
                    this.updateLayer(exixtingLayer.objects[i], options)
                }
                exixtingLayer.objects = newObject;
                this._updateLayer(exixtingLayer);
            }
        },
        _isParent: function (node, layerNode) {
            var parent
            if (node) {
                if ((layerNode.indexOf(node.parent) > -1) || (layerNode.indexOf(node.name) > -1)) {
                    return true
                } else {
                    if (node.parent && this.nameTable[node.parent].parent) {
                        var parent = this._isParent(this.nameTable[this.nameTable[node.parent].parent], layerNode)
                        return parent;
                    }
                }
            }
        },
        _updatePortConnection: function (node, collection, port) {
            var line;
            for (var m = 0; m < collection.length; m++) {
                line = this.nameTable[collection[m]]
                if (line) {
                    if (line.sourcePort === port.name) {
                        port._removeFromSourcePort = true;
                        port._removeLine = line.name;
                        line.sourcePort = null;
                    }
                    else if (line.targetPort === port.name) {
                        port._removeFromTargetPort = true;
                        port._removeLine = line.name;
                        line.targetPort = null;
                    }
                    if (port._removeFromSourcePort || port._removeFromTargetPort) {
                        this._dock(line, this.nameTable);
                        ej.datavisualization.Diagram.DiagramContext.update(line, this);
                    }
                }
            }
        },
        removePorts: function (name, ports) {
            var removeCollection = [];
            if (ports && ports.length > 0) {
                var node = this.nameTable[name];
                if (node && node.ports && node.ports.length > 0) {
                    for (var j = ports.length - 1; j >= 0; j--) {
                        for (var i = node.ports.length - 1; i >= 0; i--) {
                            if (node.ports[i].name === ports[j].name) {
                                ej.datavisualization.Diagram.SvgContext.deletePort(node, node.ports[i], this);
                                this._updatePortConnection(node, node.inEdges, node.ports[i]);
                                this._updatePortConnection(node, node.outEdges, node.ports[i]);
                                removeCollection.push($.extend(true, {}, node.ports[i]));
                                node.ports.splice(i, 1)[0];
                            }
                        }
                    }
                }
                if (!this._isUndo)
                    this.addHistoryEntry({ type: "portscollectionchanged", object: node, collection: removeCollection, changeType: "remove", isUndo: true, category: "internal" });
            }
        },
        _insertPort: function (name, port, index) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var node = this.nameTable[name];
                if (node && port) {
                    port = ej.datavisualization.Diagram.Port(port);
                    if (!this._collectionContains(port, node.ports)) {
                        node.ports.splice(index, 0, port);
                        ej.datavisualization.Diagram.DiagramContext.renderPort(node, port, this, index);
                    }
                }
                var ports = [port];
                this.addHistoryEntry({ type: "portscollectionchanged", object: node, collection: ports.slice(), changeType: "insert", isUndo: true, category: "internal" });
            }
        },
        addPorts: function (name, ports) {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                var node = this.nameTable[name];
                if (node && ports) {
                    for (var i = 0; i < ports.length; i++) {
                        var port = ej.datavisualization.Diagram.Port(ports[i]);
                        port.parent = node.name;
                        node.ports.push(port);
                        this._raisePropertyChange({ element: node, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "ports", oldValue: null, newValue: port });
                        ej.datavisualization.Diagram.DiagramContext.renderPort(node, port, this);
                    }
                    this.addHistoryEntry({ type: "portscollectionchanged", object: node, collection: node.ports, changeType: "insert", isUndo: true, category: "internal" });
                }
            }
        },
        updatePort: function (nodeName, port, options) {
            if (nodeName && (ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                var mNode = this._findNode(nodeName);
                if (options && port && (!options.name || port.name == options.name)) {
                    if (mNode) {
                        port = this._findPort(mNode, port.name);
                        if (!this._isUndo)
                            this._recordPropertiesChanged(mNode, options, "port", port);
                        options.name = port.name;
                        this._comparePropertyValues(mNode, "ports", options);
                        for (var prop in options)
                            if (port.hasOwnProperty(prop)) {
                                if (typeof options[prop] == "object")
                                    port[prop] = $.extend(true, {}, port[prop], options[prop]);
                                else
                                    port[prop] = options[prop];
                            }
                        ej.datavisualization.Diagram.DiagramContext.updatePort(mNode, port, this);
                    }
                }
                if (options.offset) {
                    this._updateAssociatedConnectorEnds(mNode, this.nameTable);
                    ej.datavisualization.Diagram.SvgContext._updateAssociatedConnector(mNode, this._svg, this);
                }
            }
        },
        copy: function () {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                this._pasteIndex = 1;
                if (this.selectionList && this.selectionList.length > 0) {
                    this._setClipboard();
                }
            }
            return this._cloneSelectionList();
        },
        paste: function (object, rename) {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                //this._isUndo = true; 
                if (object || this._clipboardData)
                    this._eventCause["nodeCollectionChange"] = this._eventCause["connectorCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.ClipBoard;
                this._pasteMultipleLane();
                this._paste(object, rename !== undefined ? rename : true);
                //this._isUndo = false;
            }
        },
        _pasteMultipleLane: function () {
            var name, child, laneCollection = [], parentCollection = [], pseudoChildren, i, nodeCollection = [];
            if (this._clipboardData) {
                var data = this._clipboardData;
                data = $.extend(true, {}, this._clipboardData);
                var node = data.node;
                if (node._type == "pseudoGroup") {
                    for (i = 0; i < node.children.length; i++) {
                        name = node.children[i];
                        child = data.childTable[name];
                        if (child) {
                            if (child.isLane) {
                                child._laneIndex = this._getRemoveIndex(child);
                                if (!this._collectionContains(child.parent, parentCollection))
                                    parentCollection.push(child.parent);
                                laneCollection[i] = child;
                            }
                            else {
                                nodeCollection.push(child.name);
                            }
                        }
                    }
                    if (laneCollection.length > 0) {
                        pseudoChildren = this._sameParent(laneCollection, parentCollection, this._clipboardData.childTable);
                        if (nodeCollection.length > 0) {
                            for (i = 0; i < nodeCollection.length; i++)
                                if (!this._collectionContains(nodeCollection[i], pseudoChildren.children))
                                    pseudoChildren.children.push(nodeCollection[i]);
                        }
                        if (pseudoChildren && pseudoChildren.children)
                            this._clipboardData.node.children = pseudoChildren.children;
                    }
                }
            }
        },

        _sameParent: function (laneCollection, parentCollection, childTable) {
            var i, j, k, node, child, nameId, lanes = [], laneObj, phases = [], swimlane, laneStack, pseudoGroup;
            pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
            if (laneCollection.length > 1 && parentCollection.length > 0) {
                laneCollection = this._sortByLaneIndex(laneCollection);
                for (i = 0; i < parentCollection.length; i++) {
                    nameId = ej.datavisualization.Diagram.Util.randomId();
                    lanes = [];
                    for (j = 0; j < laneCollection.length; j++) {
                        node = laneCollection[j];
                        if (node && node.isLane && (node.parent === parentCollection[i])) {
                            child = this.getNode(node);
                            laneObj = this._cloneLaneObj(child, nameId, childTable);
                            lanes.push(laneObj);
                        }
                    }
                    laneStack = this.nameTable[parentCollection[i]];
                    if (laneStack && laneStack.parent) {
                        swimlane = this.nameTable[laneStack.parent];
                        if (swimlane.isSwimlane) {
                            phases = swimlane.children[1].children.slice();
                            for (k = 0; k < phases.length; k++) {
                                phases[k] = $.extend(true, {}, phases[k]);
                                phases[k].name += nameId;
                            }
                        }
                    }
                    if (lanes && phases && lanes.length > 0 && phases.length > 0) {
                        swimlane = {
                            type: "swimlane", offsetX: swimlane.offsetX + 10, offsetY: swimlane.offsetY + 10,
                            orientation: swimlane.orientation,
                            lanes: lanes,
                            phases: phases
                        }
                        pseudoGroup.children.push(swimlane);
                    }
                }
                return pseudoGroup;
            }
        },
        _commandPaste: function () {
            this.paste();
        },
        _getNodesfrombounds: function (rect, eachNode) {
            var i, isCollection = false;
            var len;
            var type;
            var bounds;
            var collection = [];
            var nodes = this.nodes();
            for (i = 0, len = nodes.length; i < len; i++) {
                var node = this.nameTable[nodes[i].name];
                if (eachNode && node) {
                    isCollection = (eachNode.name === node.name) ? true : false;
                }
                if (node && node.visible && !isCollection) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    bounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                    if (ej.datavisualization.Diagram.Util.canSelect(node) && ej.datavisualization.Diagram.Util.enableLayerOption(node, "lock", this)) {
                        type = this.getObjectType(node);
                        if (ej.datavisualization.Diagram.Geometry.containsRect(rect, bounds)) {
                            if (node.parent === "")
                                collection.push(node);
                        }
                        else if (type === "group") {
                            if (this.activeTool && this.activeTool.inAction) this.activeTool._checkGroupChildren(collection, node, rect);
                        }
                    }
                }

            }
            var connectors = this.connectors();
            for (i = 0, len = connectors.length; i < len; i++) {
                var connector = this.nameTable[connectors[i].name];
                if (eachNode && connector) {
                    isCollection = (eachNode.name === connector.name) ? true : false;
                }
                if (connector && connector.visible && !isCollection) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(connector);
                    bounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                    if (ej.datavisualization.Diagram.Util.canSelect(connector) && ej.datavisualization.Diagram.Util.enableLayerOption(connectors, "lock", this) && ej.datavisualization.Diagram.Geometry.containsRect(rect, bounds)) {
                        if (connector.parent === "")
                            collection.push(connector);
                    }
                }
            }
            return collection;
        },
        _setClipboard: function () {
            if (this.selectionList.length > 0) {
                var data, node = this.selectionList[0];
                var childTable = {}, collection = [], rectBounds, rect;
                if (node._type === "group" || node.type === "pseudoGroup") {
                    var temp, i, j;
                    var children = this._getChildren(node.children);
                    for (i = 0; i < children.length; i++) {
                        for (j = i + 1; j < children.length; j++) {
                            var nodei = this.nameTable[this._getChild(children[i])];
                            var nodej = this.nameTable[this._getChild(children[j])];
                            if (nodej && nodei) {
                                if (nodej.zOrder < nodei.zOrder) {
                                    temp = children[i];
                                    children[i] = children[j];
                                    children[j] = temp;
                                }
                            }
                        }
                    }
                    var connectorCollection = [];
                    for (var m = node.children.length - 1; m >= 0; m--) {
                        var element = this.nameTable[this._getChild(node.children[m])];
                        if (element.type === "connector") {
                            node.children.splice(node.children.indexOf(element.name), 1);
                            connectorCollection.push(element.name)
                        }
                    }
                    node.children = node.children.concat(connectorCollection);
                    childTable = this._getChildTable(node, childTable);
                }
                childTable[node.name] = node;
                rectBounds = ej.datavisualization.Diagram.Util.bounds(node);
                rect = { x: rectBounds.x, y: rectBounds.y, width: rectBounds.width, height: rectBounds.height };
                collection = this._getNodesfrombounds(rect, node);
                data = $.extend(true, {}, { "childTable": childTable, "node": node, "collection": collection });
                if (data.node.segments) {
                    data.node.targetNode = null;
                    data.node.targetPort = null;
                    data.node.sourceNode = null;
                    data.node.sourcePort = null;
                }
                data.addInfo = this._updateClipBoardConnectors(node, childTable);
                this._clipboardData = data;
                //this._clipboardData = this._getCollectionEvent(data);


            }
        },
        _updateClipBoardConnectors: function (pseudoGroup, childTable) {
            var child, connectors = [];
            if (pseudoGroup && pseudoGroup.type === "pseudoGroup" && pseudoGroup.children.length > 0) {
                for (var i = 0; i < pseudoGroup.children.length; i++) {
                    child = this.nameTable[this._getChild(pseudoGroup.children[i])];
                    if (child && (child.isSwimlane || child.isLane)) {
                        this._updateSwimlaneGroupConnectors(pseudoGroup, child, childTable, connectors);
                    }
                }
            }
            else this._updateSwimlaneGroupConnectors(null, pseudoGroup, childTable, connectors);
            return connectors;
        },
        _updateEdgesToClipboard: function (edge, children, node, childTable, connectors, outEdges) {
            if (node.parent && edge) {
                var sNode = this.nameTable[edge.sourceNode];
                var tNode = this.nameTable[edge.targetNode];
                if (sNode && tNode) {
                    var sparent = this.nameTable[sNode.parent];
                    var tparent = this.nameTable[tNode.parent];
                    if ((sparent && sparent.isLane && tparent && tparent.isLane) || (sparent && tparent && (sparent.type == 'group' || tparent.type == 'group'))) {
                        if (this._collectionContains(edge.name, outEdges ? node.outEdges : node.inEdges) && !this._collectionContains(edge.name, connectors) && !this._collectionContains(edge.name, children ? children : [])) {
                            connectors.push(this.nameTable[this._getChild(edge)]);
                        }
                    }
                }
            }
        },
        _updateSwimlaneConnectors: function (children, node, childTable, connectors) {
            if (node) {
                var edge, i
                for (i = 0; i < node.inEdges.length > 0; i++) {
                    edge = this.nameTable[this._getChild(node.inEdges[i])]
                    this._updateEdgesToClipboard(edge, children, node, childTable, connectors);
                }
                for (i = 0; i < node.outEdges.length > 0; i++) {
                    edge = this.nameTable[this._getChild(node.outEdges[i])]
                    this._updateEdgesToClipboard(edge, children, node, childTable, connectors, true);
                }
            }
        },
        _updateSwimlaneGroupConnectors: function (pseudoGroup, node, childTable, connectors) {

            var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(this, node), children;
            if (!lanes && pseudoGroup && node.isLane)
                lanes = [node.name];
            for (var i = 0; lanes && i < lanes.length; i++) {
                var lane = this.nameTable[this._getChild(lanes[i])];
                if (lane && lane.children && lane.children.length > 0) {
                    children = lane.children;
                    for (var j = 0; j < children.length; j++) {
                        var child = this.nameTable[this._getChild(children[j])];
                        if (child) {
                            this._updateSwimlaneGroupChildConnectors((pseudoGroup && pseudoGroup.children) ? pseudoGroup.children : null, child, childTable, connectors);
                        }
                    }
                }
            }
        },
        _updateSwimlaneGroupChildConnectors: function (pseudoGroup, node, childTable, connectors) {
            var i = 0, k = 0, child, subChild, subChildren;
            this._updateSwimlaneConnectors((pseudoGroup && pseudoGroup.children) ? pseudoGroup.children : null, node, childTable, connectors);
            subChildren = node.children;
            if (subChildren) {
                for (k = 0; k < subChildren.length; k++) {
                    subChild = this.nameTable[this._getChild(subChildren[k])];
                    if (subChild) {
                        this._updateSwimlaneGroupChildConnectors(pseudoGroup, subChild, childTable, connectors);
                    }
                }
            }
        },
        //_getCollectionEvent: function (data){
        //	var args =  {};
        //	args.clipboardCollection = data.collection ? data.collection : null;
        //	args.collectiontype = ej.datavisualization.Diagram.ClipBoardChangeType.None;
        //	args.specificCollection = [];
        //	this._raiseEvent("clipboardChange", args);
        //	switch(args.collectiontype){
        //		case "all":
        //		   data.addInfo = args.clipboardCollection;
        //		   break;
        //		case "none":
        //		   data.addInfo = [];
        //		   break;
        //		case "specific":
        //		   data.addInfo = args.specificCollection;
        //	}
        //	return data;
        // },
        _getChildTable: function (group, childTable) {
            var child, names, name;
            names = this._getChildren(group.children);
            if (names) {
                for (var i = 0; i < names.length; i++) {
                    name = names[i];
                    child = this.nameTable[name];
                    if (child && (child.parent === group.name || group.type == "pseudoGroup")) {
                        var node = childTable[child.name] = $.extend(true, {}, child);
                        if (node._type === "group" || node.type === "pseudoGroup")
                            childTable = this._getChildTable(node, childTable);
                        if (node.inEdges && node.inEdges.length > 0) {
                            for (var e in node.inEdges) {
                                var cCon = this.nameTable[node.inEdges[e]];
                                if (cCon) {
                                    if (childTable[cCon.name])
                                        delete childTable[cCon.name];
                                    childTable[cCon.name] = cCon;
                                }
                            }
                        }
                        if (node.outEdges && node.outEdges.length > 0) {
                            for (var f in node.outEdges) {
                                var cCon = this.nameTable[node.outEdges[f]];
                                if (cCon) {
                                    if (childTable[cCon.name])
                                        delete childTable[cCon.name];
                                    childTable[cCon.name] = cCon;
                                }
                            }
                        }
                    }
                }
            }
            return childTable;
        },

        isSameParent: function (array) {
            var i, node;
            if (array.length > 1) {
                for (i = 1; i < array.length; i++) {
                    if (array[i] !== array[0])
                        return false;
                }
                return true;
            }
        },

        _sortByLaneIndex: function (array) {
            return array.sort(function (a, b) {
                return (a._laneIndex > b._laneIndex) ? 1 : ((b._laneIndex > a._laneIndex) ? -1 : 0);
            });
        },

        _paste: function (object, rename) {
            if (!object) {
                if (this._clipboardData) {
                    var data = this._clipboardData;
                    var dx, child, connectors = [];
                    data = $.extend(true, {}, this._clipboardData);
                    var node = data.node;
                    var startGroupAction = false;
                    node.zOrder = -1;
                    if (this.tools["move"]._outOfBoundsDrag(node, this._pasteIndex * 10, this._pasteIndex * 10)) {
                        if (node && node.type != "phase") {
                            if (!node.container) {
                                if (node.type == "pseudoGroup") {
                                    var names = node.children;
                                    var pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                                    this._isUndo = true;
                                    this._eventCause["nodeCollectionChange"] = this._eventCause["connectorCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.ClipBoard;
                                    this._multipleAction = true;
                                    for (var i = 0; i < names.length; i++) {
                                        var name = names[i];
                                        child = (typeof name == "object") ? name : data.childTable[name];
                                        child.zOrder = -1;
                                        if (child._annotation) delete child._annotation;
                                        if (child && (child.isSwimlane || child.type === "swimlane")) {
                                            startGroupAction = true;
                                            var child = this._pasteSwimlaneObj(child, data);
                                            if (child && this._isUndo) {
                                                var dx = this._pasteIndex * 10;
                                                this._translate(child, dx, dx, this.nameTable);
                                                ej.datavisualization.Diagram.DiagramContext.update(child, this);
                                            }
                                            if (!child) {
                                                this.add(name);
                                                child = this.nameTable[name.name];
                                                this._clipboardData.childTable = this._getChildTable(child, data.childTable);
                                                this._clipboardData.node.children[i] = child;
                                                this._clipboardData.childTable[child.name] = child;
                                                var lanePaste = true;
                                            }
                                            if (child)
                                                pseudoGroup.children.push(child.name);
                                            node = pseudoGroup;
                                        }
                                        else if (child && (child.isLane)) {
                                            var swimChild = this._pasteSwimlane(child, data, true, this._pasteIndex * 10);
                                            if (swimChild)
                                                pseudoGroup.children.push(swimChild.name);
                                            dx = this._pasteIndex * 10;
                                            this._translate(swimChild, dx, dx, this.nameTable);
                                            ej.datavisualization.Diagram.DiagramContext.update(swimChild, this);
                                        } else if (child) {
                                            name = name + ej.datavisualization.Diagram.Util.randomId();
                                            delete (data.childTable[child.name]);
                                            if (lanePaste) this._clipboardData.childTable[child.name] = child;
                                            child.name = name;
                                            child.parent = "";
                                            data.childTable[child.name] = child;
                                            this._preserveConnection(data.childTable, child);
                                            var drawChild = true;
                                            if (child.segments) {
                                                var drawChild1 = true, drawChild2 = true;
                                                if (data.childTable[child._oldSourceNode] && !this.nameTable[child.sourceNode]) {
                                                    drawChild1 = false;
                                                    child.sourceNode = null;
                                                }
                                                if (data.childTable[child._oldTargetNode] && !this.nameTable[child.targetNode]) {
                                                    drawChild2 = false;
                                                    child.targetNode = null;
                                                }
                                                if (!drawChild1 && !drawChild2)
                                                    drawChild = false;
                                            }
                                            if (drawChild) {
                                                pseudoGroup.children.push(name);
                                                if (child._type === "group" && child.type != "bpmn") {
                                                    this._pasteChildren(data.childTable, child);
                                                }
                                                else
                                                    child.children = [];
                                                dx = this._pasteIndex * 10;
                                                this._translate(child, dx, dx, this.nameTable);
                                                if (child.segments && child.segments.length == 1 && child.segments[0].type == "orthogonal" && !child.sourceNode && !child.targetNode) {
                                                    points = child.segments[0].points;
                                                }
                                                var success = false;
                                                success = this.add(child);
                                                if (points && success) {
                                                    child = this.nameTable[child.name];
                                                    child.segments[0].points = points;
                                                    ej.datavisualization.Diagram.DiagramContext.update(child, this);
                                                    ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.selectionList[0], this._adornerSvg, this._currZoom);
                                                }
                                            }
                                        }
                                    }
                                    if (startGroupAction) {
                                        this.model.historyManager.startGroupAction();
                                    }
                                    delete this._multipleAction;
                                    this._clearSelection();
                                    if (pseudoGroup && pseudoGroup.children.length > 0) {
                                        this.nodes().push(pseudoGroup);
                                        this._nodes = $.extend(true, [], this.nodes());
                                        this.nameTable[pseudoGroup.name] = pseudoGroup;
                                        ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this);
                                        this._addSelection(pseudoGroup);
                                        var childTable = {};
                                        childTable = this._getChildTable(this.selectionList[0], childTable);
                                        var entry = { type: "collectionchanged", object: this._updatePsedoGroupChildren(this.selectionList[0]), childTable: jQuery.extend(true, {}, childTable), changeType: "insert", category: "internal" };
                                        this.addHistoryEntry(entry);
                                        this._isUndo = false;
                                    }
                                } else if (node.type == "bpmn") {
                                    var randomId = ej.datavisualization.Diagram.Util.randomId();
                                    node.parent = "";
                                    node.name = node.name + randomId;
                                    node.inEdges = [];
                                    node.outEdges = [];
                                    node.children = [];
                                    if (node._annotation) delete node._annotation;
                                    dx = this._pasteIndex * 10;
                                    this._translate(node, dx, dx, this.nameTable);
                                    this.add(node);
                                } else {
                                    node.name = node.name + ej.datavisualization.Diagram.Util.randomId();
                                    node.parent = "";
                                    if (node._type === "group") {
                                        this._pasteChildren(data.childTable, node);
                                    } else if (node.segments) {
                                        //this._disConnect(node);
                                    } else if (!node.segments) {
                                        //@Fix
                                        //this._disConnect(node);
                                        node.inEdges = [];
                                        node.outEdges = [];
                                    }
                                    dx = this._pasteIndex * 10;
                                    this._translate(node, dx, dx, this.nameTable);
                                    if (node.segments && node.segments.length == 1 && node.segments[0].type == "orthogonal" && !node.sourceNode && !node.targetNode) {
                                        var points = node.segments[0].points;
                                    }
                                    var success = this.add(node);
                                    if (success && points) {
                                        node = this.nameTable[node.name];
                                        node.segments[0].points = points;
                                        ej.datavisualization.Diagram.DiagramContext.update(node, this);
                                        ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.selectionList[0], this._adornerSvg, this._currZoom);
                                    }
                                    this._updateSelectionHandle();
                                    //this._clearSelection();
                                    //this._addSelection(node);
                                }
                            } else {
                                if (node.isSwimlane) {
                                    this.model.historyManager.startGroupAction();
                                    startGroupAction = true;
                                    node = this._pasteSwimlaneObj(node, data);
                                    data.childTable = this._getChildTable(node, data.childTable);
                                }
                                else {
                                    if (node.isLane) {
                                        node = this._cloneLaneObj(node, ej.datavisualization.Diagram.Util.randomId(), data.childTable);
                                        if (node.orientation === "vertical") {
                                            node.height = node.height;
                                        }
                                        var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(node, this, this._clipboardData, true);
                                        if (swimlane) {
                                            this._pasteObj = true;
                                            this.add(swimlane);
                                            this._pasteObj = false;
                                        }
                                        node = swimlane;
                                    }
                                    else if (node.container && !node.isLane && !node.isSwimlane) {
                                        node = this._cloneContainer(node, ej.datavisualization.Diagram.Util.randomId(), data.childTable)
                                        this._preserveConnection(data.childTable, node);
                                        this.add(node);
                                        node = this.nameTable[node.name];
                                    }
                                    dx = this._pasteIndex * 10;
                                    this._translate(node, dx, dx, this.nameTable);
                                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                                }
                                if (this._selectionContains(node)) {
                                    this._clearSelection(true);
                                    this._addSelection(node);
                                }
                            }
                            if (data.addInfo.length) {
                                for (var m in data.addInfo) {
                                    var addobj, cName;
                                    addobj = data.addInfo[m];
                                    if (addobj.isSwimlane) {
                                        data.childTable[addobj.name] = addobj;
                                        data.childTable = this._getChildTable(addobj, data.childTable);
                                        addobj = this._pasteSwimlaneObj(addobj, data);
                                        data.childTable[addobj.name] = addobj;
                                        data.childTable = this._getChildTable(addobj, data.childTable);
                                    }
                                    else {
                                        if (data.childTable[addobj.name] && addobj !== data.childTable[addobj.name]) {
                                            addobj = $.extend(true, {}, data.childTable[addobj.name]);
                                        }
                                        cName = addobj.name + ej.datavisualization.Diagram.Util.randomId();
                                        addobj.name = cName;
                                        addobj.parent = "";
                                        if (addobj._oldSourceNode && addobj._oldTargetNode) {
                                            data.childTable[addobj.name] = addobj;
                                            this._preserveConnection(data.childTable, addobj);
                                            dx = this._pasteIndex * 10;
                                            this._translate(addobj, dx, dx, this.nameTable);
                                            this.add(addobj);
                                            if (lanePaste) {
                                                connectors[m] = addobj;
                                            }
                                            if (this._selectionContains(addobj)) {
                                                this._clearSelection(true);
                                            }
                                        }
                                    }
                                }
                                if (lanePaste) {
                                    this._clipboardData.addInfo = connectors;
                                }
                                if (!this._selectionContains(node)) {
                                    this._addSelection(node);
                                }
                            }
                            if (startGroupAction) {
                                this.model.historyManager.closeGroupAction();
                            }
                            this._pasteIndex++;
                        }
                    }
                }
            }
            else {
                var name = "";
                var connectors = [];
                var pseudoGroup = ej.datavisualization.Diagram.Group({ "name": "multipleSelection", type: "pseudoGroup" });
                if (rename)
                    name = ej.datavisualization.Diagram.Util.randomId();
                for (var i = 0; i < object.length; i++) {
                    object[i].name += name;
                    if (object[i].outEdges) object[i].outEdges = [];
                    if (object[i].inEdges) object[i].inEdges = [];
                    if (object.length > 1) pseudoGroup.children.push(object[i].name);
                    if (object[i].type != "connector") {
                        if ((object[i].type === "group" || object[i].type === "bpmn") && !object[i].isSwimlane) {
                            this._clonePasteGroup(object[i], name, object);
                            this.add($.extend({}, object[i]));
                        }
                        if (object[i].isSwimlane) {
                            this._clonePasteSwimlaneObj(object[i], name, object);
                            var cloneObj = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, object[i], data);
                            if (this._outOfBoundsOnNudge(cloneObj, diagram._pasteIndex * 10, this._pasteIndex * 10)) {
                                this.add(cloneObj);
                            }
                        }
                        else this.add($.extend({}, object[i]));

                    }
                    else
                        connectors.push(object[i]);

                }
                for (var i = 0; i < connectors.length; i++) {
                    if (connectors[i].sourceNode && this.nameTable[connectors[i].sourceNode + name])
                        connectors[i].sourceNode += name;
                    else {
                        connectors[i].sourceNode = "";
                        connectors[i].sourcePort = "";
                    }
                    if (connectors[i].targetNode && this.nameTable[connectors[i].targetNode + name])
                        connectors[i].targetNode += name;
                    else {
                        connectors[i].targetNode = "";
                        connectors[i].targetPort = "";
                    }
                    if (object.length > 1) pseudoGroup.children.push(connectors[i].name);
                    this.add($.extend({}, connectors[i]));
                }
                if (object.length > 1) {
                    this.nodes().push(pseudoGroup);
                    this._nodes = $.extend(true, [], this.nodes());
                    this.nameTable[pseudoGroup.name] = pseudoGroup;
                    this._clearSelection(true);
                    ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this);
                    this.addSelection(pseudoGroup, true);
                }
            }
        },

        _cloneContainer: function (group, name, childTable) {
            group.name = group.name + name;
            for (var i = 0; i < group.children.length; i++) {
                var nameTable = childTable ? childTable : this.nameTable;
                var child = nameTable[this._getChild(group.children[i])];
                child.name += name;
                child.parent = group.name;
                if (child.children && child.children.length > 0) {
                    child = this._cloneContainer(child, name, childTable);
                }
                group.children[i] = child;
            }
            ej.datavisualization.Diagram.bpmnHelper.updateProcessCollection(group, this);
            return group
        },

        _clonePasteGroup: function (group, name, objects) {
            for (var i = 0; i < group.children.length; i++) {
                group.children[i].name += name;
                group.children[i].parent = group.name;
                if (group.children[i].segments) {
                    if (group.children[i].sourceNode)
                        group.children[i].sourceNode += name;
                    if (group.children[i].targetNode)
                        group.children[i].targetNode += name;
                }
                else {
                    var edge;
                    for (var e = 0; e < group.children[i].inEdges.length; e++) {
                        edge = group.children[i].inEdges[e];
                        if (this._collectionContains(edge, group.children) || (objects && this._collectionContains(edge, objects))) {
                            edge += name;
                        }
                        else group.children[i].inEdges.splice(e, 1);
                    }
                    for (var e = 0; e < group.children[i].outEdges.length; e++) {
                        edge = group.children[i].outEdges[e];
                        if (this._collectionContains(edge, group.children) || (objects && this._collectionContains(edge, objects))) {
                            edge += name;
                        }
                        else group.children[i].outEdges.splice(e, 1);
                    }
                }
            }
        },
        _clonePasteSwimlaneObj: function (obj, name, objects) {
            //obj.name += name;
            //update lanes
            if (obj.lanes && obj.lanes.length > 0) {
                for (var i = 0; i < obj.lanes.length; i++) {
                    if (obj.lanes[i]) {
                        obj.lanes[i].name += name;
                        if (obj.lanes[i].children && obj.lanes[i].children.length > 0) {
                            var children = obj.lanes[i].children;
                            var nChildren = [];
                            for (var m = 0; m < children.length; m++) {
                                var child = jQuery.extend(true, {}, children[m]);
                                child.name += name;
                                child.parent = obj.lanes[i].name;
                                for (var e = 0; e < child.inEdges.length; e++) {
                                    if (this._collectionContains(child.inEdges[e], objects)) {
                                        child.inEdges[e] += name;
                                        obj.lanes[i].children[m] = child;
                                    }
                                    else child.inEdges.splice(e, 1);
                                }
                                for (var e = 0; e < child.outEdges.length; e++) {
                                    if (this._collectionContains(child.outEdges[e], objects)) {
                                        child.outEdges[e] += name;
                                        obj.lanes[i].children[m] = child;
                                    }
                                    else child.outEdges.splice(e, 1);
                                }
                                nChildren.push(child)
                            }
                            obj.lanes[i].children = nChildren;
                        }
                    }
                }
            }
            //update phases
            if (obj.phases && obj.phases.length > 0) {
                var phases = [];
                for (var i = 0; i < obj.phases.length; i++) {
                    if (obj.phases[i]) {
                        var phase = jQuery.extend(true, {}, obj.phases[i]);
                        phase.name += name;
                        phase.parent = "";
                        phases.push(phase);
                    }
                }
                obj.phases = phases;
            }
        },

        _cloneLaneObj: function (obj, name, childTable) {
            var obj = ej.datavisualization.Diagram.SwimLaneContainerHelper._cloneLaneObj(this, obj, name, childTable)
            return obj;
        },

        _cloneSwimlaneObj: function (obj, name, data) {
            obj = $.extend(true, {}, obj);
            var obj = ej.datavisualization.Diagram.SwimLaneContainerHelper._cloneSwimlaneObj(this, obj, name, data)
            return obj;
        },

        _pasteSwimlaneObj: function (node, data) {
            node = ej.datavisualization.Diagram.SwimLaneContainerHelper._pasteSwimlaneObj(this, node, data)
            return node;
        },

        _pasteSwimlane: function (node, data, mSelection, x) {
            if (node && node.isSwimlane) {
                var cloneObj = ej.datavisualization.Diagram.SwimLaneContainerHelper._pasteSwimlane(this, node, data, mSelection, x)
                return cloneObj;
            }
        },
        _cloneNode: function (node, data, name, pnode) {
            var nameState = false;
            var parentName = null;
            if (node) {
                node = (typeof (node) === "string") ? node : node.name;
                var node = jQuery.extend(true, {}, data.childTable[node]);
                if (node.isPhaseStack) {
                    node.name = node.name.split("phaseStack")[0] + name + "phaseStack";
                    nameState = true;
                    parentName = node.name;
                }
                if (node.children && node.children.length > 0) {
                    for (var i = 0; i < node.children.length; i++) {
                        this._cloneNode(node.children[i], data, name, parentName);
                        if (node.children[i]) (typeof (node.children[i]) === "string") ? node.children[i] += name : node.children[i].name += name;
                    }
                }
                if (pnode) {
                    node.parent = (typeof (pnode) === "string") ? pnode : pnode.name;
                }
                else if (node.parent != "")
                    node.parent += name;
                if (!nameState)
                    node.name += name;
                this._preserveConnection(data.childTable, node);
                this.nameTable[node.name] = node;
            }
        },
        _cloneSwimlane: function (node, data, name) {
            var tempName = node.name;
            node.name += name;
            if (node.children && node.children.length > 0) {
                for (var i = 0; i < node.children.length; i++) {
                    this._cloneNode(node.children[i], data, name, node);
                    if (typeof (node.children[i]) === "string") {
                        (node.children[i] += name)
                    }
                    else {
                        if (node.children[i].isPhaseStack)
                            node.children[i] = tempName + name + "phaseStack";
                        else
                            node.children[i] = node.children[i].name + name;
                    }
                }
            }
            if (node.phases && node.phases.length > 0) {
                var phase;
                for (var i = 0; i < node.phases.length; i++) {
                    phase = jQuery.extend(true, {}, this.nameTable[this._getChild(node.phases[i])]);
                    phase.name += name;
                    phase.parent += name;
                    this.nameTable[phase.name] = phase;
                    node.phases[i] = phase.name;
                }
            }
            this.nameTable[node.name] = node;
        },
        _pasteChild: function (child, childTable, group, childNames) {
            var name = child.name + ej.datavisualization.Diagram.Util.randomId();
            delete (childTable[child.name]);
            child.name = name;
            childTable[child.name] = child;
            this._preserveConnection(childTable, child);
            child.parent = group.name;
            childNames.push(name);
            if (child._type === "group") {
                this._pasteChildren(childTable, child);
            }
            this.add(child);
        },
        _pasteChildren: function (childTable, group) {
            var child, names, name;
            var childNames = [];
            names = group.children;
            for (var i = 0; i < names.length; i++) {
                name = this._getChild(names[i]);
                child = childTable[name];
                child.zOrder = -1;
                if (child) {
                    this._pasteChild(child, childTable, group, childNames);
                }
            }
            group.children = [];
            for (var i = 0; i < childNames.length; i++) {
                group.children.push(this.nameTable[childNames[i]]);
            }
            this._preserveConnection(childTable, group);
        },
        _preserveConnections: function (childTable, group) {
            var child, names;
            names = this._getChildren(group.children);
            for (var i = 0; i < names.length; i++) {
                child = childTable[names[i]];
                if (child) {
                    this._preserveConnection(childTable, child);
                    if (child._type === "group")
                        this._preserveConnections(childTable, group);
                }
            }
        },
        _preserveConnection: function (childTable, child) {
            var i, connection, len;
            if (!child.segments) {
                len = child.inEdges.length;
                if (len > 0) {
                    for (i = 0; i < len; i++) {
                        connection = childTable[child.inEdges[i]];
                        if (connection) {
                            connection._oldTargetNode = connection.targetNode;
                            connection.targetNode = child.name;
                        }
                    }
                    child.inEdges = [];
                }
                len = child.outEdges.length;
                if (len > 0) {
                    for (i = 0; i < child.outEdges.length; i++) {
                        connection = childTable[child.outEdges[i]];
                        if (connection) {
                            connection._oldSourceNode = connection.sourceNode;
                            connection.sourceNode = child.name;
                        }
                    }
                    child.outEdges = [];
                }
            } else {
                var node;
                if (child.targetNode) {
                    node = childTable[child.targetNode];
                    if (node)
                        node.inEdges.push(child.name);
                    //else
                    //    child.targetNode = null;
                }
                if (child.sourceNode) {
                    node = childTable[child.sourceNode];
                    if (node)
                        node.outEdges.push(child.name);
                    //else
                    //    child.sourceNode = null;
                }
            }
        },
        _expandChildren: function (node) {
            for (var i = 0; i < node.outEdges.length; i++) {
                var conn = this.nameTable[node.outEdges[i]];
                var target = this.nameTable[conn.targetNode];
                if (!target.excludeFromLayout) {
                    conn.visible = true;
                    ej.datavisualization.Diagram.DiagramContext.update(conn, this);
                    this._updateQuad(conn);
                    if (target.isExpanded)
                        this._expandChildren(target);
                    target.visible = true;
                    ej.datavisualization.Diagram.DiagramContext.update(target, this);
                    this._updateQuad(target);
                }
            }
        },
        _collapseChildren: function (node) {
            for (var i = 0; i < node.outEdges.length; i++) {
                var conn = this.nameTable[node.outEdges[i]];
                var target = this.nameTable[conn.targetNode];
                if (!target.excludeFromLayout) {
                    conn.visible = false;
                    ej.datavisualization.Diagram.DiagramContext.update(conn, this);
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[conn.name], conn);
                    ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, conn);
                    if (this._checkParentNodeVisible(target, conn)) {
                        if (target.isExpanded)
                            this._collapseChildren(target);
                        target.visible = false;
                        ej.datavisualization.Diagram.DiagramContext.update(target, this);
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[target.name], target);
                        ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, target);
                    }
                }
            }
        },
        _checkParentNodeVisible: function (target, connector) {
            if (target.inEdges.length >= 1) {
                for (var i = 0; i < target.inEdges.length; i++) {
                    var inEdge = this._findNode(target.inEdges[i]);
                    if (inEdge.name != connector.name && inEdge.visible)
                        return false;
                }
                return true;
            }
        },
        zoomTo: function (zoom) {
            if (!zoom) {
                zoom = new ej.datavisualization.Diagram.Zoom();
            }
            if (zoom.zoomCommand & ej.datavisualization.Diagram.ZoomCommand.ZoomIn) {
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 + zoom.zoomFactor), 0, 0, zoom.focusPoint, true);
            } else {
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 / (1 + zoom.zoomFactor)), 0, 0, zoom.focusPoint, true);
            }
        },
        remove: function (node) {
            if (node && this.nameTable[node.name] && (ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                this._delete(node);
            }
            else
                this._delete();
        },
        clear: function () {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                this._clearSelection();
                var i;
                var diagram = this;
                this._views.forEach(function (viewid) {
                    var view = diagram._views[viewid];
                    $(view.diagramLayer).empty();
                    $(diagram._expander).empty();
                    $(diagram._adornerLayer.children).empty();
                    $(view.svg.document.parentNode.getElementsByClassName("htmlLayer")[0]).empty();
                });
                while (this.nodes().length > 0) {
                    this.nodes().pop();
                }
                while (this.connectors().length > 0) {
                    this.connectors().pop();
                }
                this._nodes = [];
                this._connectors = [];
                this.nameTable = {};
                this.selectionList = [];
                this.clearHistory();
                this._spatialSearch = ej.datavisualization.Diagram.SpatialSearch(this);
                this._updateScrollOffset(0, 0);
            }
        },
        _clearElementCollection: function () {
            $(this.element).find(".ej-d-node").remove();
            $(this.element).find(".ej-d-group").remove();
            $(this.element).find(".ej-d-seperator").remove();
            var dataSource = this.model.dataSourceSettings.dataSource;
            if (typeof dataSource != "string" && dataSource.length) {
                $(this.element).find(".ej-d-connector").remove();
                while (this.nodes().length > 0) {
                    this.nodes().pop();
                }
                while (this.connectors().length > 0) {
                    this.connectors().pop();
                }
                this._nodes = [];
                this._connectors = [];
                this.nameTable = {};
                this.selectionList = [];
                this._spatialSearch = ej.datavisualization.Diagram.SpatialSearch(this);
            }
        },

        _updateChildOnGroup: function (node) {
            var parent = null;
            if (node && node.parent) {
                parent = this._svg.document.getElementById(node.parent);
                var parentObj = this.nameTable[node.parent];
                if (parentObj) {
                    if (parentObj.container) {
                        ej.datavisualization.Diagram.ContainerHelper._add(this, node);
                    }
                    else {
                        node = this.nameTable[this._getChild(node)];
                        if (node != null) {
                            parentObj.children.push(node);
                        }
                        if (node._type == "group")
                            this._initGroupNode(node);
                        ej.datavisualization.Diagram.Util._refreshParentGroup(node, this);
                    }
                }
            }
            return parent;
        },
        _raiseChildrenPropertyChange: function (node, isAdd) {
            if (node && node.parent) {
                var parent = this._findNode(node.parent);
                var element, property, currCollection = [], preCollection = [];
                if (parent) {
                    if (parent.isLaneStack) {
                        var swimlane = this._getNode(parent.parent);
                        preCollection = swimlane.lanes;
                        preCollection = preCollection.slice();
                        if (isAdd)
                            swimlane.lanes.push(node);
                        else {
                            var index = ej.datavisualization.Diagram.canvasHelper._getLaneIndex(swimlane, node);
                            swimlane.lanes.splice(index, 1);
                        }
                        currCollection = swimlane.lanes
                        element = swimlane;
                        property = "lanes";
                    }
                    else if (parent.isPhaseStack) {
                        var swimlane = this._getNode(parent.parent);
                        preCollection = swimlane.phases;
                        preCollection = preCollection.slice();
                        if (isAdd)
                            swimlane.phases.push(node);
                        else {
                            var index = ej.datavisualization.Diagram.SwimLaneContainerHelper._getPhaseIndex(this, node.name);
                            swimlane.phases.splice(index, 1);
                        }
                        currCollection = swimlane.phases
                        element = swimlane;
                        property = "phases";
                    }
                    else {
                        var parent = this._getNode(node.parent);

                        var children = [];
                        var index = -1;
                        for (var k = 0; k < parent.children.length; k++) {
                            var child = this._getNode(parent.children[k]);
                            if (child) {
                                if (child.name === node.name) {
                                    index = k;
                                }
                                children.push(child);
                            }
                        }
                        preCollection = children.slice();
                        currCollection = children.slice();
                        if (isAdd)
                            currCollection.push(node);
                        else
                            currCollection.splice(index, 1)

                        element = parent;
                        property = "children";
                    }

                    var resource = {
                        element: element, cause: this._isDragg || (this.activeTool.inAction) ?
                            ej.datavisualization.Diagram.ActionType.Mouse : ej.datavisualization.Diagram.ActionType.Unknown,
                        propertyName: property, oldValue: preCollection, newValue: currCollection
                    };
                    this._raisePropertyChange(resource);
                }
            }
        },
        addLane: function (node, index) {
            this._isLaneApi = true;
            if (node.isLane) {
                node = this._dynamicLane(node, this);
                if (!index && !node.parent) {
                    node = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(node, this);
                    this.add(node);
                }
                else {
                    var swimlane = this._updateDynamicLane(this, node, index);
                    if (swimlane && swimlane.isSwimlane) {
                        var stack = this.nameTable[this._getChild(swimlane.children[2])];
                        node = ej.datavisualization.Diagram.canvasHelper._updateDropLaneProperties(this, node, swimlane);
                        if (index || index === 0) {
                            stack.children.splice(index, 0, node);
                        }
                        else
                            stack.children.push(node);
                        node.parent = stack.name;
                        this._swimlaneObject = true;
                    }
                    else
                        node = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(node, this);
                    this.add(node);
                    if (stack && swimlane) {
                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, stack);
                        ej.datavisualization.Diagram.canvasHelper._updateLastPhase(this, swimlane);
                        this._clearSelection(true);
                        this._addSelection(swimlane);
                    }
                    delete this._swimlaneObject;
                }
            }
            delete this._isLaneApi;
        },
        _dynamicLane: function (node, diagram) {
            var obj = ej.datavisualization.Diagram.SwimLaneHelper._createPaletteLane(node, diagram.nameTable);
            var orientation = obj.orientation;
            obj = ej.datavisualization.Diagram.SwimLaneHelper._createDiagramLane(obj, diagram.nameTable);
            obj.minHeight = node.height;
            obj.minWidth = node.width;
            obj.parent = node.parent;
            obj.orientation = orientation;
            if (node.orientation)
                obj.orientation = node.orientation;
            if (obj.isLane)
                obj = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, obj);
            return obj;
        },
        _updateDynamicLane: function (diagram, node, arg) {
            if (node.parent)
                var swimlane = diagram.nameTable[node.parent];
            else {
                for (var i = 0; i < this.selectionList.length; i++)
                    var swimlane = this.selectionList[i];
            }
            return swimlane;
        },

        _resetValues: function (node) {
            if (ej.datavisualization.Diagram.Util.canRouteDiagram(this) && !this._checkFromSwimlane(node)) {
                if (node) {
                    if (node._points)
                        delete node._points
                    if (node._sourceNodeInfo)
                        delete node._sourceNodeInfo;
                    if (node._targetNodeInfo)
                        delete node._targetNodeInfo;
                    if (node._obstacle)
                        delete node._obstacle;
                    if (node._outerBounds)
                        delete node._outerBounds;
                    if (node._sourcePointInfo)
                        delete node._sourcePointInfo;
                    if (node._sourcePortInfo)
                        delete node._sourcePortInfo;
                    if (node._targetPointInfo)
                        delete node._targetPointInfo;
                    if (node._targetPortInfo)
                        delete node._targetPortInfo;
                }
            }
        },

        _add: function (node, render, arg, restrictSelection) {
            this._resetValues(node);
            if (!node.length > 0) {
                node = ej.datavisualization.Diagram.NodeType(node, this);
                var nodeTemplate, connectorTemplate;
                if (this.model.nodeTemplate && node._type === "node")
                    nodeTemplate = this._getNodeTemplate();
                else
                    connectorTemplate = this._getConnectorTemplate();
                if (nodeTemplate)
                    nodeTemplate(this, node);
                if (connectorTemplate)
                    connectorTemplate(this, node);
            }
            if (!node.pivot) node.pivot = { x: 0.5, y: 0.5 };

            var node1;
            if (node && (node.segments || node.sourcePoint || node.targetPoint || node.sourceNode || node.targetNode)
                && !((node.segments && node.segments[0] && node.segments[0].points))) {
                node1 = $.extend(true, {}, node);
                node1 = this._getNewConnector(node1);
            }
            if ((node1 && this._outOfBoundsOnNudge(node1, 0, 0)) || (!node1 && this._outOfBoundsOnNudge(node, 0, 0))) {
                var tempEventCause = this._eventCause;
                this._raiseChildrenPropertyChange(node, true);
                this._eventCause = tempEventCause;
                var success = false, type;
                if ((node.isSwimlane || node.type === "swimlane") && !this._pasteObj) {
                    if (this._isNewNode)
                        node = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, node);
                }
                if (node.length > 0) {
                    for (var i = 0; i < node.length; i++) {
                        this.add(node[i]);
                    }
                } else {
                    //#region for temporary
                    if (node.addInfo) {
                        if (node.addInfo.height)
                            node.height = node.addInfo.height;
                        if (node.addInfo.width)
                            node.width = node.addInfo.width;
                    }
                    //#endregion
                    if (node.type == "connector") type = "connector"; else type = "node";
                    var args = { changeType: "insert", element: this.getNode(node) };
                    if (node.isLane) {
                        if (this._isDragg || !this._selectedSymbol) {
                            var cause = this._isUndo ? ej.datavisualization.Diagram.GroupChangeCause.HistoryChange : ej.datavisualization.Diagram.GroupChangeCause.Drop;
                            if (this._isLaneApi) {
                                cause = ej.datavisualization.Diagram.GroupChangeCause.Unknown;
                            }

                            var laneNode = this.getNode(node);
                            var args = { changeType: "insert", element: laneNode, state: "changing" };
                            this._eventCause["nodeCollectionChange"] = cause;

                            var args1 = args;
                            args = this._raiseEvent(type + "CollectionChange", args);
                            if (!args)
                                args = args1;

                            if (!args.cancel) {
                                this._updateLane(node, args.element);
                                this._raiseGroupChangeEvent(laneNode, null, this.getNode(node.parent), cause);
                            }
                        }
                        else {
                            this._updateLane(node, args.element);
                        }
                    }
                    else if (node.isSwimlane) {
                        args = this._raiseCollectionChangeEvent(node, type);
                        this._updateSwimlane(node, args.element, true);

                    }
                    else if (node.container && !$.isEmptyObject(node.container)) {
                        node = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, node);
                    }
                    if (!(node.isLane || node.isSwimlane)) {
                        if (node.type != "connector") {
                            var cause = this._eventCause[type + "CollectionChange"];
                            if (!cause)
                                this._eventCause[type + "CollectionChange"] = this._isUndo ? ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange : ej.datavisualization.Diagram.CollectionChangeCause.Unknown;
                            if (node._type === "group" || (node.children && node.children.length > 0)) {
                                this._convertGroupChild(node, []);
                                node = ej.datavisualization.Diagram.Group(node);
                                this.nameTable[node.name] = node;
                                args = this._raiseCollectionChangeEvent(node, type);
                                node._type = "group";
                                if (node.type == "bpmn") node = ej.datavisualization.Diagram.Util._updateBpmnChild(node, this);
                                this._initGroupNode(node);
                                if (!this._isGroupNode && node.type !== "bpmn")
                                    this._udpateChildRotateAngle(node);
                            }
                            else if (!node.isPhase) {
                                //if (!(this.activeTool && this.activeTool.name === "textTool"))
                                node = this._getNewNode(node);
                                this.nameTable[node.name] = node;
                                args = this._raiseCollectionChangeEvent(node, type);
                                this._getNodeDimension(node);
                            }
                            if (!args.cancel) {
                                node._status = "new";
                                success = (!node.parent) ? this.nodes().push(node) : true;
                                this._nodes = $.extend(true, [], this.nodes());
                                this.nameTable[node.name] = node;

                                if (success) {
                                    if (this._containerOverNode) {
                                        ej.datavisualization.Diagram.canvasHelper._addNodeToContainer(this, node, this._containerOverNode);
                                        delete this._containerOverNode;
                                    }
                                    if (node._type === "group" || (node.children && node.children.length > 0)) {
                                        this._updateParent(node);

                                        if (node.offsetX == 0 && node.offsetY == 0)
                                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, this, true);
                                        this._updateChildrenEdges(node);
                                        var parent = null;
                                        parent = this._updateChildOnGroup(node);
                                        if (render && !node.parent) {
                                            delete this._isNodeInitializing;
                                            //ej.datavisualization.Diagram.Util._updateGroupBounds(node, this, true);
                                            ej.datavisualization.Diagram.DiagramContext.renderGroup(node, this);
                                        }
                                    } else {
                                        if (render) {
                                            var parent = null;
                                            parent = this._updateChildOnGroup(node);
                                            if ((node.parent === "" || node.isPhase) || this._isInsert)
                                                ej.datavisualization.Diagram.DiagramContext.renderNode(node, this, parent);
                                            if (this._selectedSymbol && node.textBlock) {
                                                var htmlLayer = this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                                                if (htmlLayer) {
                                                    var textElement = $(htmlLayer).find("#" + node.name + "label")[0];
                                                    if (textElement && textElement.childNodes && textElement.childNodes.length > 0)
                                                        textElement.childNodes[0].style.display = "none";
                                                }
                                            }
                                        }
                                    }
                                    this._updateQuad(node);
                                    this.nameTable[node.name] = node;
                                    if (node._type === "group" || (node.children && node.children.length > 0)) {
                                        for (var i = 0; i < node.children.length; i++) {
                                            var child = node.children[i];
                                            this.nameTable[child.name] = child;
                                        }
                                    }
                                    if (render && !restrictSelection) {
                                        this._clearSelection(true);
                                        this._addSelection(node);
                                    }
                                }
                            }
                            this._addNodeToGraph(node)
                        }
                        else {
                            node = this._getNewConnector(node);
                            this.nameTable[node.name] = node;
                            var cause = this._eventCause[type + "CollectionChange"];
                            if (!cause)
                                this._eventCause[type + "CollectionChange"] = this._isUndo ? ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange : ej.datavisualization.Diagram.CollectionChangeCause.Unknown;
                            args = this._raiseCollectionChangeEvent(node, type);
                            if (!args.cancel) {
                                success = (!node.parent) ? this.connectors().push(node) : true;
                                node._status = "new";
                                if (success) {
                                    this._updateEdges(node);
                                    this._dock(node, this.nameTable);
                                    this._routeEdge(node);
                                    ej.datavisualization.Diagram.Util.updateBridging(node, this);
                                    this._updateConnectorBridging(node);
                                    if (!node.parent) {
                                        if (render) {
                                            ej.datavisualization.Diagram.DiagramContext.renderConnector(node, this);
                                        }
                                    }
                                    this.nameTable[node.name] = node;
                                    this._updateQuad(node);
                                    this._updateChildOnGroup(node);
                                    if (render && !restrictSelection) {
                                        this._clearSelection(true);
                                        this._addSelection(node);
                                    }
                                }
                            }

                        }
                    }
                    else {
                        if (!args.cancel) {
                            if (node.isLane && (((this._selectedSymbol && this._selectedSymbol.isLane) || this._swimlaneObject) || this._isUndo))
                                success = true;
                            else
                                success = this.nodes().push(node);

                            this._nodes = $.extend(true, [], this.nodes());
                            this.nameTable[node.name] = node;

                            if (success) {
                                if (node._type === "group") {
                                    if (render) {
                                        if (this._paletteItemClick) {
                                            node.offsetX = node.minWidth / 2 + 50;
                                            node.offsetY = node.minHeight / 2 + 50;
                                        }
                                        ej.datavisualization.Diagram.DiagramContext.renderGroup(node, this);
                                        if (node.phases && node.phases.length > 0) {
                                            var cphase = null;
                                            for (var i = 0, len = node.phases.length; i < len; i++) {
                                                cphase = this.nameTable[this._getChild(node.phases[i])];
                                                if (cphase.type == "phase") {
                                                    ej.datavisualization.Diagram.SvgContext.renderphase(cphase, this._svg, this._diagramLayer, this);
                                                }
                                            }
                                        }
                                        this._clearSelection(true);
                                        this._addSelection(node);
                                    }
                                }
                                this._updateQuad(node);
                            }
                        }
                    }
                }
                this._setZorder(node);
                if (!this._isUndo && (!this._selectedSymbol || this._endEditing) && success) {
                    var childTable = {};
                    if (this.selectionList && this.selectionList.length > 0)
                        childTable = this._getChildTable(this.selectionList[0], childTable);
                    //if (node.isSwimlane) {
                    //    node = this._getNode(node.name, this.nameTable);
                    //}
                    if ((!arg || (arg && !arg.entryHistory)) && !node.isPhase) {
                        var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, node), childTable: jQuery.extend(true, {}, childTable), changeType: "insert", category: "internal" };
                        this.addHistoryEntry(entry);
                    }
                }
                this._trigger("refresh");
                this._isRefreshTriggered = true;
                if (success && !node.isPhase && !node.isLane && (!this._selectedSymbol || this._endEditing)) {
                    args.state = "changed";
                    this._raiseEvent(type + "CollectionChange", args);
                }
            }
            delete this._isNewNode;
            return success;
        },
        _raiseCollectionChangeEvent: function (node, type) {
            var args = { changeType: "insert", element: this.getNode(node), state: "changing" };
            if (!node.isPhase && (!this._selectedSymbol || this._endEditing)) {
                this._raiseEvent(type + "CollectionChange", args);
                node._absolutePath = null;
            }
            return args;
        },
        add: function (node, args) {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                this._isNodeInitializing = true;
                this._isNewNode = true;
                var activelayer = ej.datavisualization.Diagram.Util.enableLayerOption({}, "active", this);

                if (activelayer) {
                    activelayer = ej.datavisualization.Diagram.Layers(activelayer);
                    if (activelayer.objects.indexOf(node.name) < 0) {
                        activelayer.objects.push(node.name)
                    }
                }
                var returnVal = this._add(node, true, args);
                delete this._isNodeInitializing;
                return returnVal;
            }
        },
        updateUserHandles: function (node) {
            node = this.nameTable[node.name];
            ej.datavisualization.Diagram.SvgContext.updateUserHandles(this.model.selectedItems.userHandles, node, this._adornerSvg, false, false, this._currZoom, this);
        },
        scrollToNode: function (node) {
            var nodeX, nodeY;
            var hScrollPadding = (this._vScrollbar && this._vScrollbar._scrollData) ? this._vScrollbar._scrollData.buttonSize : 0;
            var vScrollPadding = (this._hScrollbar && this._hScrollbar._scrollData) ? this._hScrollbar._scrollData.buttonSize : 0;
            var curZoomfactor = this._currZoom;
            var elementBounds = this.element[0].getBoundingClientRect();
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            nodeX = (nodeBounds.x + nodeBounds.width / 2) * curZoomfactor;
            nodeY = (nodeBounds.y + nodeBounds.height / 2) * curZoomfactor;
            var hScrollOffset = this._hScrollOffset, vScrollOffset = this._vScrollOffset;
            if (elementBounds.width + this._hScrollOffset < (nodeX + ((nodeBounds.width / 2) * curZoomfactor))) {
                hScrollOffset = (nodeX + ((nodeBounds.width / 2 + hScrollPadding) * curZoomfactor) - elementBounds.width); // * 20 as scroll bar width 
            }
            if (elementBounds.height + this._vScrollOffset < (nodeY + ((nodeBounds.height / 2) * curZoomfactor))) {
                vScrollOffset = (nodeY + ((nodeBounds.height / 2 + vScrollPadding) * curZoomfactor) - elementBounds.height); // * 20 as scroll bar height 
            }
            this._updateScrollOffset(hScrollOffset, vScrollOffset);
        },
        findNode: function (id) {
            return this._findNode(id);
        },
        getObjectType: function (element) {
            return ej.datavisualization.Diagram.Util.getObjectType(element);
        },
        //#endregion
        //#region support methods       
        _registerDrawingTools: function () {
            for (var toolname in this.model.drawingTools) {
                var tool = this.model.drawingTools[toolname];
                tool.diagram = this;
                this.tools[tool.name] = tool;
            }
        },
        _sortByXvalue: function (nodes) {
            var temp, i, j;
            var fNode, lNode;
            for (i = 0; i < nodes.length; i++) {
                for (j = i + 1; j < nodes.length; j++) {
                    var nodei = this.nameTable[this._getChild(nodes[i])];
                    var nodej = this.nameTable[this._getChild(nodes[j])];
                    fNode = ej.datavisualization.Diagram.Util.bounds(nodei);
                    lNode = ej.datavisualization.Diagram.Util.bounds(nodej);
                    if ((fNode.x > lNode.x) || (fNode.right > lNode.right)) {
                        temp = nodes[i];
                        nodes[i] = nodes[j];
                        nodes[j] = temp;
                    }
                }
            }
            return nodes;
        },
        _sortByYvalue: function (nodes) {
            var temp, i, j;
            var fNode, lNode;
            for (i = 0; i < nodes.length; i++) {
                for (j = i + 1; j < nodes.length; j++) {
                    var nodei = this.nameTable[this._getChild(nodes[i])];
                    var nodej = this.nameTable[this._getChild(nodes[j])];
                    fNode = ej.datavisualization.Diagram.Util.bounds(nodei);
                    lNode = ej.datavisualization.Diagram.Util.bounds(nodej);
                    if ((fNode.y > lNode.y) || (fNode.bottom > lNode.bottom)) {
                        temp = nodes[i];
                        nodes[i] = nodes[j];
                        nodes[j] = temp;
                    }
                }
            }
            return nodes;
        },
        _sortByZIndex: function (nodes, asc) {
            var temp, i, j;
            if (!asc) {
                for (i = 0; i < nodes.length; i++) {
                    for (j = i + 1; j < nodes.length; j++) {
                        if (nodes[i].zOrder < nodes[j].zOrder) {
                            temp = nodes[i];
                            nodes[i] = nodes[j];
                            nodes[j] = temp;
                        }
                    }

                }
            }
            else {
                for (i = 0; i < nodes.length; i++) {
                    for (j = i + 1; j < nodes.length; j++) {
                        if (nodes[i].zOrder > nodes[j].zOrder) {
                            temp = nodes[i];
                            nodes[i] = nodes[j];
                            nodes[j] = temp;
                        }
                    }

                }
            }
            return nodes;
        },
        _updateBPMNIndex: function (node, asc) {
            var temp, i, j;
            if (node.type === "bpmn" && node.parent) {
                var parent = this.nameTable[node.parent];
                if (parent && parent.isLane) {
                    var children = parent.children;
                    for (i = 0; i < children.length; i++) {
                        for (j = i + 1; j < children.length; j++) {
                            var childeNode1 = this.nameTable[this._getChild(children[i])];
                            var childeNode2 = this.nameTable[this._getChild(children[j])];
                            if ((!asc ? childeNode1.zOrder < childeNode2.zOrder : childeNode1.zOrder > childeNode2.zOrder) &&
                                !childeNode1.isPhase && !childeNode2.isPhase && !childeNode1.isLane && !childeNode2.isLane) {
                                temp = children[i];
                                children[i] = children[j];
                                children[j] = temp;
                            }
                        }
                    }
                }
            }
        },
        _sortByGroupChildrenZIndex: function (asc) {
            var nodes = this.nodes();
            var temp, i, j, k;
            for (k = 0; k < nodes.length; k++) {
                var node = nodes[k];
                this._updateBPMNIndex(node, asc);
                if (node._type === "group" && node.type !== "bpmn" && !node.isSwimlane) {
                    var children = this._getChildren(node.children);
                    for (i = 0; i < children.length; i++) {
                        for (j = i + 1; j < children.length; j++) {
                            var childeNode1 = this.nameTable[this._getChild(children[i])];
                            var childeNode2 = this.nameTable[this._getChild(children[j])];
                            if ((!asc ? childeNode1.zOrder < childeNode2.zOrder : childeNode1.zOrder > childeNode2.zOrder) &&
                                !childeNode1.isPhase && !childeNode2.isPhase && !childeNode1.isLane && !childeNode2.isLane) {
                                temp = children[i];
                                children[i] = children[j];
                                children[j] = temp;
                            }
                        }
                    }
                    node.children = children;
                }
            }
        },
        _findCornerNodes: function () {
            var lNode, rNode, tNode, bNode, i, nBounds;
            var list = this.selectionList[0].children;
            var fnode = this.nameTable[this._getChild(this.selectionList[0].children[0])];
            lNode = fnode, rNode = fnode, tNode = fnode, bNode = fnode;
            if (list.length > 1) {
                for (i = 0; i < list.length; i++) {
                    var node = this.nameTable[this._getChild(list[i])];
                    nBounds = ej.datavisualization.Diagram.Util.bounds(node);

                    var rNodeBounds = ej.datavisualization.Diagram.Util.bounds(rNode);
                    if ((nBounds.x + nBounds.width) > (rNodeBounds.x + rNodeBounds.width))
                        rNode = node;

                    var bNodeBounds = ej.datavisualization.Diagram.Util.bounds(bNode);
                    if ((nBounds.y + nBounds.height) > (bNodeBounds.y + bNodeBounds.height))
                        bNode = node;

                    var lNodeBounds = ej.datavisualization.Diagram.Util.bounds(lNode);
                    if (nBounds.x < lNodeBounds.x)
                        lNode = node;

                    var tNodeBounds = ej.datavisualization.Diagram.Util.bounds(tNode);
                    if (nBounds.y < tNodeBounds.y)
                        tNode = node;
                }
            }
            return { left: lNode, right: rNode, top: tNode, bottom: bNode };
        },

        _comparePropertyOnAlign: function (node, diffX, diffY, root) {
            if (node) {
                if (!node.segments) {
                    if (node.offsetX != (node.offsetX + diffX))
                        this._comparePropertyValues(node, "offsetX", { offsetX: node.offsetX + diffX }, null, root);
                    if (node.offsetY != node.offsetY + diffY)
                        this._comparePropertyValues(node, "offsetY", { offsetX: node.offsetY + diffY }, null, root);
                }
                else {
                    this._comparePropertyValues(node, "sourcePoint", { sourcePoint: { x: node.sourcePoint.x + diffX, y: node.sourcePoint.y + diffY } }, root);
                    this._comparePropertyValues(node, "targetPoint", { targetPoint: { x: node.targetPoint.x + diffX, y: node.targetPoint.y + diffY } }, root);
                }
            }
        },

        _moveNode: function (diffX, diffY, node) {
            this._comparePropertyOnAlign(node, diffX, diffY, ej.datavisualization.Diagram.ActionType.Align);
            this._translate(node, diffX, diffY, this.nameTable);
            this._updateNodeMargin(node);
            ej.datavisualization.Diagram.DiagramContext.update(node, this);
        },

        _updateContainerOnNudge: function (node) {
            var parent = this.nameTable[node.parent];
            if (parent && parent.container) {
                ej.datavisualization.Diagram.canvasHelper._updateNodeMargin(this, node, parent);
                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, parent, true);
            }
        },


        _outOfBoundsOnNudge: function (node, ptX, ptY) {
            var lane = this.nameTable[this._getChild(node.parent)];
            if (lane && lane.isLane && lane.parent) {
                var stack = this.nameTable[this._getChild(lane.parent)];
                if (stack && stack.isLaneStack && stack.parent) {
                    var swimlane = this.nameTable[this._getChild(stack.parent)];
                    if (swimlane && this.model.pageSettings.boundaryConstraints != "infinity") {
                        var laneBounds = ej.datavisualization.Diagram.Util.bounds(lane);
                        var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
                        var swmlnBounds = ej.datavisualization.Diagram.Util.bounds(swimlane);
                        var swimRight = swmlnBounds.right;
                        var swimBottom = swmlnBounds.bottom;
                        if ((nodeBounds.bottom + ptY + 20 >= laneBounds.bottom))
                            swimBottom += ptY;
                        if ((nodeBounds.right + ptX + 20 >= laneBounds.right))
                            swimRight += ptX;
                        var size = this.activeTool._getPageBounds();
                        if ((ptY > 0 && swmlnBounds.bottom != swimBottom && swimBottom > size.height) || (ptX > 0 && swmlnBounds.right != swimRight && swimRight > size.width))
                            return false
                    }
                }
            }
            else {
                var tool = this.tools['move'];
                return tool._outOfBoundsDrag(node, ptX, ptY);
            }
            return true;
        },
        _anyFromSwimlane: function (node) {
            if (node.parent) {
                var parent = this.nameTable[node.parent];
                if (parent && parent.container && parent.isLane) {
                    return this._getSwimlane(parent);
                }
                else {
                    return this._anyFromSwimlane(parent)
                }
            }
            return null;
        },
        _nudge: function (node, x, y, direction, isChild, lastChild) {
            if (node && node.segments && (node.sourceNode && node.targetNode))
                return;
            var proceedY = true, proceedX = true, child;
            var pNode = this.nameTable[node.parent];

            var resource;
            if (node._type !== "label") {
                if (this._outOfBoundsOnNudge(node, x, y)) {
                    if (!isChild) {
                        if (!node.segments) {
                            var oldValue = (direction === "right" || direction === "left") ? node.offsetX : node.offsetY;
                            var newValue = (direction === "right" || direction === "left") ? node.offsetX + x : node.offsetY + y;
                            var propertyName = (direction === "right" || direction === "left") ? "offsetX" : "offsetY";
                            resource = { element: node, cause: ej.datavisualization.Diagram.ActionType.Nudge, keyCode: direction, propertyName: propertyName, oldValue: oldValue, newValue: newValue };
                            this._raisePropertyChange(resource);
                        }
                        else {
                            resource = {
                                element: node, cause: ej.datavisualization.Diagram.ActionType.Nudge, keyCode: direction, propertyName: "sourcePoint", oldValue: { sourcePoint: node.sourcePoint },
                                newValue: { sourcePoint: { x: node.sourcePoint.x + x, y: node.sourcePoint.y + y } }
                            };
                            this._raisePropertyChange(resource);
                            resource = {
                                element: node, cause: ej.datavisualization.Diagram.ActionType.Nudge, keyCode: direction, propertyName: "targetPoint", oldValue: { targetPoint: node.targetPoint },
                                newValue: { targetPoint: { x: node.targetPoint.x + x, y: node.targetPoint.y + y } }
                            };
                            this._raisePropertyChange(resource);
                        }
                    }
                    var parent = this.nameTable[node.parent];
                    var move
                    if (parent && parent.isLane)
                        move = this._moveOnLane(node, parent, x, y);
                    if (!proceedY || (move && !move.proceedY))
                        y = 0;
                    if (!proceedX || (move && !move.proceedX))
                        x = 0;
                    if (node.type == "pseudoGroup") {
                        var children = this._removeContainerConnector(this._getChildren(node.children));
                        children = this._sortByYvalue(children);
                        children = this._sortByXvalue(children);
                        //ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                        for (var i = children.length - 1; i >= 0; i--) {
                            child = this.nameTable[this._getChild(children[i])];
                            if (child) {
                                if (!this._nudge(child, x, y, direction, true, (i === 0))) {
                                    break;
                                }
                                //this._updateContainerOnNudge(child);
                            }
                        }
                        ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdateNode(this, child);
                        delete this._disableSwimlaneUptate;
                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                    }
                    else {
                        this._translate(node, x, y, this.nameTable, undefined, undefined, true);
                        if (!lastChild) {
                            if (node.parent) {
                                var parent = this.nameTable[node.parent];
                                var swimlane = this._anyFromSwimlane(node);
                                if (swimlane && swimlane.isSwimlane) {
                                    ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                                    this._disablePhaseUpdate = true;
                                    this._disableSwimlaneUptate = true;
                                }
                            }
                        }
                        this._updateContainerOnNudge(node);
                    }
                    this._updateNodeMargin(node);
                    if (node.parent) {
                        var parent = this.nameTable[node.parent];
                        if (parent && parent.container) {
                            ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                            this._disablePhaseUpdate = true;
                            this._disableSwimlaneUptate = true;
                            if (parent.container.type === "canvas")
                                ej.datavisualization.Diagram.canvasHelper._updateCollectionChange(this, parent);
                            delete this._disablePhaseUpdate;
                            if (!isChild) {
                                //delete this._disableSwimlaneUptate;
                            }
                            var swimlane = this._anyFromSwimlane(node);
                            if (swimlane) {
                                ej.datavisualization.Diagram.canvasHelper._updateLastPhase(this, swimlane);
                                if (!isChild) {
                                    //delete this._disableSwimlaneUptate;
                                    //ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, swimlane);
                                }
                                if (!this._updateSwimlanes) {
                                    this._updateSwimlanes = [];
                                }
                                if (!this._collectionContains(swimlane.name, this._updateSwimlanes))
                                    this._updateSwimlanes.push(swimlane.name)
                                if (!isChild) {
                                    delete this._disableSwimlaneUptate;
                                    ej.datavisualization.Diagram.DiagramContext.update(swimlane, this);
                                    ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, swimlane, true);

                                }
                            }
                        }
                        if (lastChild && this._updateSwimlanes) {
                            delete this._disableSwimlaneUptate;
                            for (var m = 0; m < this._updateSwimlanes.length; m++) {
                                ej.datavisualization.Diagram.DiagramContext.update(this.nameTable[this._updateSwimlanes[m]], this);
                                ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, this.nameTable[this._updateSwimlanes[m]]);
                            }
                            delete this._updateSwimlanes;
                        }
                    }
                    else {
                        if (lastChild && this._updateSwimlanes) {
                            for (var m = 0; m < this._updateSwimlanes.length; m++) {
                                ej.datavisualization.Diagram.DiagramContext.update(this.nameTable[this._updateSwimlanes[m]], this);
                                ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, this.nameTable[this._updateSwimlanes[m]]);
                            }
                            delete this._updateSwimlanes;
                        }
                        else if (node.type != "pseudoGroup")
                            ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    }
                    this._updateSelectionHandle(true);
                    return true;
                }
                else return false;
                //ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._svg, this._currZoom, this, this.model.selectedItems.constraints);
            }
            else {
                pNode = this.findNode(node._parent);
                this.translateLabel(pNode, node, x, y);
                ej.datavisualization.Diagram.DiagramContext.update(node, this);
                this._updateSelectionHandle(true);
                return true;
            }
        },
        _removeContainerConnector: function (collection) {
            var rCollection = [];
            if (collection && collection.length > 0) {
                for (var i = 0; i < collection.length; i++) {
                    var child = this.nameTable[this._getChild(collection[i])];
                    if (child && !child.segments) {
                        rCollection.push(collection[i]);
                    }
                    else if (child.segments && ((!child.sourceNode && !child.targetNode))) {
                        rCollection.push(collection[i]);
                    }
                }
            }
            return rCollection;
        },
        _moveOnLane: function (node, parent, x, y) {
            var proceedY = false, dx = 0, proceedX = false, dy = 0;
            x = x ? x : 0; y = y ? y : 0;
            if (parent.children && parent.children.length > 0) {
                var header = this.nameTable[this._getChild(parent.children[0])];
                if (header && header.name.indexOf("_Headerr") != -1) {
                    if (parent.orientation === "horizontal") {
                        dx = header.width;
                    }
                    else if (parent.orientation === "vertical") {
                        dy = header.height;
                    }
                }
            }
            if (node && parent) {
                var nBBox = ej.datavisualization.Diagram.Util.bounds(node);
                var gBBox = ej.datavisualization.Diagram.Util.bounds(parent);
                if (nBBox.y + y >= gBBox.y + parent.paddingTop + dy) {
                    proceedY = true;
                }
                if (nBBox.x + x >= gBBox.x + parent.paddingLeft + dx) {
                    proceedX = true;
                }
                return {
                    proceedY: proceedY, proceedX: proceedX,
                    x: (gBBox.x + parent.paddingLeft + dx) - nBBox.x + x,
                    y: (gBBox.y + parent.paddingTop + dy) - nBBox.y + y,
                };
            }
        },
        _selectCommand: function (args) {
            if (this._isEditing) {
                this._endEdit();
                document.getElementById(this._id).focus();
            }
            args.keyDownEventArgs.preventDefault();
            this.selectAll();
        },
        _nudgeCommand: function (args) {
            if (!this._currentState && this.selectionList[0]) { this._currentState = { x: this.selectionList[0].offsetX, y: this.selectionList[0].offsetY }; }
            this.nudge(args.parameter, args.keyDownEventArgs.shiftKey ? 5 : 1);
            args.keyDownEventArgs.preventDefault();
        },
        _startEditCommand: function () {
            if (this.selectionList.length > 0) {
                var shape = this.selectionList[0];
                if (!(shape.type == "pseudoGroup")) {
                    if (shape.type === "text" && this._setLabelEditing(shape.textBlock))
                        this._startEdit(shape);
                    if (shape.isSwimlane) {
                        var header = this.nameTable[shape.name + "_header_swimlane"];
                        if (header)
                            this._startEdit(header);
                    }
                    else if (shape.isLane) {
                        if (shape.children && shape.children.length > 0) {
                            header = this.nameTable[this._getChild(shape.children[0])];
                            if (header)
                                this._startEdit(header);
                        }
                    }
                    else if (shape.type && shape.type === "phase") {
                        var phase = this.nameTable["phaseStack" + shape.name]
                        if (phase)
                            this._startEdit(phase);
                    }
                    else if (shape.labels.length > 0 && this._setLabelEditing(shape.labels[0]))
                        this._startEdit(shape);
                }
            }
        },
        _findObjectByName: function (name) {
            var node = null;
            if (this._findNode(name))
                node = this._findNode(name);
            if (this._findConnector(name))
                node = this._findConnector(name);
            return node;
        },
        _findObjectByIndex: function (index, group) {
            var nodes, findNode = null, node, m, k;
            if (group) {
                var parent = this.nameTable[this.selectionList[0].parent];
                if (parent) {
                    nodes = this._getChildren(parent.children);
                    for (k = 0; k < nodes.length; k++) {
                        node = this.nameTable[nodes[k]];
                        if (node.zOrder === index)
                            findNode = nodes[k];
                    }
                }
            } else {
                for (m = 0; m < this.nodes().length; m++) {
                    node = this.nodes()[m];
                    if (node.zOrder === index && !node._isProcessed) {
                        findNode = node;
                        node._isProcessed = true;
                    }
                }
                for (m = 0; m < this.connectors().length; m++) {
                    node = this.connectors()[m];
                    if (node.zOrder === index && !node._isProcessed) {
                        findNode = node;
                        node._isProcessed = true;
                    }
                }
            }
            if (typeof (findNode) === "string")
                return this.nameTable[findNode];
            return findNode;
        },
        _findOverlapNode: function (node, orderType) {
            var oNodes = [], m, i, rNodes = [];
            if (!node.parent) {
                for (m = 0; m < this.nodes().length; m++) {
                    oNodes.push(this.nameTable[this._getChild(this.nodes()[m])]);
                }
                for (m = 0; m < this.connectors().length; m++) {
                    oNodes.push(this.nameTable[this._getChild(this.connectors()[m])]);
                }
                if (orderType === "sendToBack" || orderType === "bringToFront")
                    return oNodes;
                var nBound = ej.datavisualization.Diagram.Util.bounds(node);
                if (node) {
                    for (i = 0; i < oNodes.length; i++) {
                        var chBound = ej.datavisualization.Diagram.Util.bounds(oNodes[i]);
                        if (node.name !== oNodes[i].name && !(node.children && this._collectionContains(oNodes[i].name, node.children))) {
                            if (this._intersect(nBound, chBound))
                                rNodes.push(oNodes[i]);
                        }
                    }
                }
            } else {
                var nBound = ej.datavisualization.Diagram.Util.bounds(node);
                var parent = this.nameTable[node.parent], child;
                if (parent) {
                    var children = this._getChildren(parent.children);
                    for (m = 0; m < children.length; m++) {
                        if (children[m] !== node.name) {
                            child = this.nameTable[children[m]];
                            var chBound = ej.datavisualization.Diagram.Util.bounds(child);
                            if (child && this._intersect(nBound, chBound))
                                rNodes.push(child);
                        }
                    }
                }
            }
            return rNodes;
        },
        _intersect: function (a, b) {
            return (a.x <= (b.x + b.width) &&
                b.x <= (a.x + a.width) &&
                a.y <= (b.y + b.height) &&
                b.y <= (a.y + a.height));
        },
        _focusToItem: function (args) {
            var nodes = this.nodes(), connectors = this.connectors();
            var index = 0, elements = [], bounds;
            var diagram = this;
            if (nodes.length || connectors.length) {
                if (!this._diagramElements) {
                    elements = this.nodes().concat(this.connectors());
                    elements = this._sortByZIndex(elements, true);
                    elements = elements.map(function (item) { return item.name; })
                    this._diagramElements = elements;
                }
                if (!this._focusedElement && !this.selectionList.length && this._diagramElements.length) {
                    index = args.keyDownEventArgs.shiftKey ? 0 : this._diagramElements.length - 1;
                }
                else {
                    if (!this._focusedElement) {
                        if (this.selectionList[0].type != "pseudoGroup")
                            index = this._diagramElements.indexOf(this.selectionList[0].name);
                        else
                            index = Math.min.apply(Math, this.selectionList[0].children.map(function (child) { return diagram._diagramElements.indexOf(child.name || child); }));
                    }
                    else index = this._diagramElements.indexOf(this._focusedElement);
                }
                do {
                    if (args.keyDownEventArgs.shiftKey)
                        index = index != 0 ? --index : this._diagramElements.length - 1;
                    else
                        index = index != this._diagramElements.length - 1 ? ++index : 0;
                    if (this.nameTable[this._diagramElements[index]].type == "pseudoGroup") continue;
                    this._focusedElement = this._diagramElements[index];
                } while (!ej.datavisualization.Diagram.Util.canSelect(this.nameTable[this._focusedElement]) && ej.datavisualization.Diagram.Util.enableLayerOption(this.nameTable[this._focusedElement], "lock", this));

                bounds = ej.datavisualization.Diagram.Util.bounds(this.nameTable[this._focusedElement]);
                bounds = { x: bounds.x - 8, y: bounds.y - 8, width: bounds.width + 16, height: bounds.height + 16 };
                this.bringIntoView({ x: bounds.x - 25, y: bounds.y - 25, width: bounds.width + 50, height: bounds.height + 50 });
                ej.datavisualization.Diagram.SvgContext._drawNavigationHighlighter(bounds, this._adornerSvg, this._adornerLayer, this._currZoom);
                args.keyDownEventArgs.preventDefault();
            }
        },
        _selectFocusedItem: function (args) {
            ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this._adornerSvg, this._adornerLayer);
            var element = this.nameTable[this._focusedElement];
            this._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.Keydown;
            if (element) this.addSelection(element, true);
            this._diagramElements = null;
            this._focusedElement = null;
            args.keyDownEventArgs.preventDefault();
        },
        //#endregion 
        //#region Rendering
        _createDefaultTooltip: function () {
            var div = document.createElement("div");
            var attr = {
                "id": this.element[0].id + "_DefaulttooltipDiv",
                "class": "e-diagram-tooltip-default",
                "style": "padding-top:3px; height: 24px;pointer-events:none;",
            };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            this._tooltipLayer.appendChild(div);
            if (!this.model.tooltipTemplateId) {
                var span = document.createElement("span");
                attr = { "class": "e-diagram-tooltipLabel-default", "id": "e-diagram-tooltipLabel-default" };
                ej.datavisualization.Diagram.Util.attr(span, attr);
                div.appendChild(span);
            }
            return div;
        },
        _createMouseOverTooltip: function () {
            var div = document.createElement("div");
            var attr = {
                "id": this.element[0].id + "_mouseovertooltipDiv",
                "class": "e-diagram-tooltip-mouseover",
                "style": "pointer-events:none;",
            };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            this._tooltipLayer.appendChild(div);
            return div;
        },
        _renderTooltip: function (object, start) {
            if ((object.parent && this.nameTable[object.parent] && this.nameTable[object.parent].container)) {
                var scale = this._currZoom;
                var bounds = ej.datavisualization.Diagram.Util.bounds(this.activeTool.helper, true);
                object = { x: (bounds.x) * scale, y: (bounds.y) * scale, width: (bounds.width) * scale, height: (bounds.height) * scale, rotateAngle: this.activeTool.helper.rotateAngle, offsetX: this.activeTool.helper.offsetX, offsetY: this.activeTool.helper.offsetY, type: "SwimlaneHelper" };
            }
            if (this.model.selectedItems.tooltip) {
                var tooltipDiv = document.getElementById(this.element[0].id + "_DefaulttooltipDiv");
                if (!tooltipDiv) {
                    tooltipDiv = this._createDefaultTooltip();
                }
                var template;
                var objectValues;
                var html;
                var width;
                var curZoomfactor = this._currZoom;
                if (!this.model.selectedItems.tooltip.templateId) {
                    if (start) tooltipDiv.style.width = "150px";
                    width = 150;
                    var span = tooltipDiv.childNodes[0];
                    if (this.activeTool instanceof ej.datavisualization.Diagram.MoveTool) {
                        if (!object.segments) {
                            if (object.type !== "SwimlaneHelper") {
                                objectValues = "X : " + Math.round((object.offsetX - object.width * object.pivot.x)) + "px  " + "Y : " + Math.round((object.offsetY - object.height * object.pivot.y)) + "px";
                            }
                            else {
                                objectValues = "X : " + Math.round(object.x) + "px  " + "Y : " + Math.round(object.y) + "px";
                            }
                        }
                    } else if (this.activeTool instanceof ej.datavisualization.Diagram.ResizeTool) {
                        objectValues = "W : " + Math.round(object.width) + "px  H : " + Math.round(object.height) + "px";
                    } else if (this.activeTool instanceof ej.datavisualization.Diagram.RotateTool) {
                        if (start) tooltipDiv.style.width = "50px";
                        width = 50;
                        objectValues = Math.round(object.rotateAngle) + "\xB0";
                    }
                    if (objectValues) {
                        var obj = this._getTooltipPosition(object, this.model.selectedItems.tooltip);
                        obj.x = -this._hScrollOffset + obj.x * curZoomfactor;
                        obj.y = - this._vScrollOffset + obj.y * curZoomfactor;
                        tooltipDiv.style.top = obj.y + "px";
                        tooltipDiv.style.left = obj.x + "px";
                        tooltipDiv.style.transform = "translate(" + obj.tx + " ," + obj.ty + ")";
                        span.textContent = objectValues;
                    } else {
                        this._removeTooltip();
                    }
                } else if ($.templates && this.model.selectedItems.tooltip) {
                    if (!object.segments) {
                        var obj = this._getTooltipPosition(object, this.model.selectedItems.tooltip);
                        obj.x = -this._hScrollOffset + obj.x * curZoomfactor;
                        obj.y = - this._vScrollOffset + obj.y * curZoomfactor;
                        tooltipDiv.style.top = obj.y + "px";
                        tooltipDiv.style.left = obj.x + "px";
                        tooltipDiv.style.transform = "translate(" + obj.tx + " ," + obj.ty + ")";
                        template = $.templates("#" + this.model.selectedItems.tooltip.templateId);
                        // objectValues = [{ name: this.activeTool.selectedObject.name, x: (object.offsetX - object.width / 2) + "px", y: (object.offsetY - object.height / 2) + "px", width: object.width + "px", height: object.height + "px", rotationAngle: object.rotateAngle }];
                        html = template.render(object);
                        $(tooltipDiv).html(html);
                    }
                }
            }
        },

        _removeTooltip: function () {
            var tooltipDiv = document.getElementById(this.element[0].id + "_DefaulttooltipDiv");
            if (tooltipDiv) {
                tooltipDiv.parentNode.removeChild(tooltipDiv);
            }
        },
        _removeMouseOverTooltip: function () {
            var tooltipDiv = document.getElementById(this.element[0].id + "_mouseovertooltipDiv");
            if (tooltipDiv) {
                tooltipDiv.parentNode.removeChild(tooltipDiv);
            }
        },
        _renderCanvas: function (isLoad) {
            this._browserInfo = ej.browserInfo();
            this._canvas = document.getElementById(this.element[0].id + "_canvas");
            if (!this._canvas) {
                this._canvas = document.createElement("div");
                this.element.append(this._canvas);
            }
            this._canvas.setAttribute("id", this.element[0].id + "_canvas");
            if (this._canvas.getAttribute("class") === null || this._canvas.getAttribute("class") === "")
                this._canvas.setAttribute("class", "drawing");
            $(this._canvas).css({
                position: "relative", height: this.model.height, width: this.model.width
            });
            this.element.css({
                overflow: "hidden", outline: "none", display: "block", height: this.model.height, width: this.model.width
            });
            this._views[this._id].canvas = this._canvas;
            this.element[0].setAttribute("tabindex", "0");

            this._renderDiagram(isLoad);
            if (ej.datavisualization.Diagram.Util.canFloatElements(this)) this._setItemDraggable(this._canvas);
        },
        _getDigramBounds: function (mode) {
            var left, top, right, bottom;
            left = this._spatialSearch.pageLeft || 0;
            top = this._spatialSearch.pageTop || 0;
            right = this._spatialSearch.pageRight - this._spatialSearch.pageLeft || 0;
            bottom = this._spatialSearch.pageBottom - this._spatialSearch.pageTop || 0;
            if (mode != "content") {
                if (this.model.pageSettings && this._multiplePage()) {
                    left = this._spatialSearch.pageLeft;
                    top = this._spatialSearch.pageTop;
                    if (this._pageWidth()) {
                        left = Math.floor(left / this._pageWidth()) * this._pageWidth();
                        right = Math.ceil(this._spatialSearch.pageRight / this._pageWidth()) * this._pageWidth() - left;
                    }
                    if (this._pageHeight()) {
                        top = Math.floor(top / this._pageHeight()) * this._pageHeight();
                        bottom = Math.ceil(this._spatialSearch.pageBottom / this._pageHeight()) * this._pageHeight() - top;
                    }
                    if (this._spatialSearch.pageRight === null) {
                        if (this._pageWidth() !== 0) {
                            right = this._pageWidth();
                        }
                    }
                    if (this._spatialSearch.pageBottom === null) {
                        if (this._pageHeight() !== 0) {
                            bottom = this._pageHeight();
                        }
                    }
                }
                else {
                    if (this._pageWidth()) {
                        left = 0;
                        right = this._pageWidth();
                    }
                    if (this._pageHeight()) {
                        top = 0;
                        bottom = this._pageHeight();
                    }
                }
            }
            var svgBounds = new ej.datavisualization.Diagram.Rectangle();
            svgBounds.x = left;
            svgBounds.y = top;
            svgBounds.width = right;
            svgBounds.height = bottom;
            return svgBounds;
        },
        _initContextMenu: function (isLoad) {
            if (this.enableContextMenu()) {
                this._renderContextMenu(isLoad);
            }
            else {
                $("#" + this.element[0].id + "_contextMenu").remove();
            }
        },
        _renderContextMenuItem: function (item) {
            var li = document.createElement("li");
            var a = document.createElement("a");
            var menu = ej.datavisualization.Diagram.Locale[this.locale()];
            if (!menu)
                menu = ej.datavisualization.Diagram.Locale["en-US"];
            a.innerText = menu[item.name] || item.text;
            li.setAttribute("id", this.element[0].id + "_contextMenu_" + item.name);
            var div = document.createElement("span");
            div.setAttribute("id", item.name + "_image");
            var imageUrlAttribute = "display:table-cell; vertical-align:middle; text-align:center;"
            if (item.imageUrl)
                imageUrlAttribute = imageUrlAttribute + "background-image: url(" + item.imageUrl + ");width:25px;height:25px";
            div.setAttribute("style", imageUrlAttribute);
            var cssClassAttribute = "sf-d-menuitem " + item.name;
            if (item.cssClass)
                cssClassAttribute = cssClassAttribute + " " + item.cssClass;
            div.setAttribute("class", cssClassAttribute);
            a.appendChild(div);
            if (item.subItems && item.subItems.length > 0) {
                var subUl = document.createElement("ul");
                var i = 0, subli;
                for (i; i < item.subItems.length; i++) {
                    subli = this._renderContextMenuItem(item.subItems[i], subUl);
                    subli.setAttribute("style", "display:block;");
                    subUl.appendChild(subli);
                }
                li.appendChild(subUl);
            }
            li.appendChild(a);
            return li;
        },
        _renderContextMenu: function (isLoad) {
            var menuCollection = $.extend(true, [], this.model.contextMenu.items);
            if (!this.model.contextMenu.showCustomMenuItemsOnly) {
                var additionalItems = [];
                for (var i = 0; i < this._defaultContextMenuItems.length; i++) {
                    var isExist = false;
                    if (this.model.contextMenu.items.length) {
                        for (var j = 0; j < this.model.contextMenu.items.length; j++) {
                            if (this.model.contextMenu.items[j].name === this._defaultContextMenuItems[i].name) {
                                isExist = true;
                                break;
                            }
                            if (j === this.model.contextMenu.items.length - 1 && !isExist) {
                                additionalItems.push(this._defaultContextMenuItems[i])
                            }
                        }
                    }
                    else
                        additionalItems.push(this._defaultContextMenuItems[i])
                }

                for (var i = 0; i < additionalItems.length; i++) {
                    menuCollection.push(additionalItems[i]);
                }
            }

            var i = 0, item, mItem;
            var ul = document.createElement("ul");
            ul.setAttribute("id", this.element[0].id + "_contextMenu");
            for (i = 0; i < menuCollection.length; i++) {
                item = menuCollection[i];
                if (item.templateId) {

                    var temptag = this._renderEjTemplate("#" + item.templateId, item);
                    if (temptag)
                        ul.innerHTML = temptag;
                }
                else {
                    if (item && item.name) {
                        mItem = this._renderContextMenuItem(item, ul);
                        ul.appendChild(mItem);
                    }
                }
            }
            this._canvas.appendChild(ul);
            $("#" + this.element[0].id + "_contextMenu").ejMenu({
                menuType: ej.MenuType.ContextMenu,
                contextMenuTarget: "#" + this.element[0].id + "_canvas",
                click: $.proxy(this._onMenuItemClick, this),
                beforeOpen: $.proxy(this._onContextMenuOpen, this),
                mouseover: $.proxy(this._onMenuItemMouseOver, this),
                mouseout: $.proxy(this._onMenuItemMouseOut, this),
                close: $.proxy(this._onContextMenuClose, this),
            });
            $("#" + this.element[0].id + "_contextMenu")[0].style.display = "none";
        },
        _onContextMenuClose: function (args) {
            if (this.model.contextMenuClose) {
                var obj = ({ diagram: this, contextMenu: args });
                this._trigger("contextMenuClose", obj);
            }
            else
                this.element[0].focus();
        },
        _onContextMenuOpen: function (args) {
            if (args.events && !args.events.originalEvent)
                args.events.originalEvent = args.events;
            if (this.activeTool.mouseup) {
                if (this.activeTool.name == "textTool") {
                    this._endEdit();
                    if (this.activeTool.singleAction) {
                        this.activeTool.diagram.deactivateTool();
                    }
                }
                else
                    this.activeTool.mouseup(args.events, true);
            }
            if (this._disableDefaultContextMenu) {
                delete this._disableDefaultContextMenu;
                return false;
            }
            var _id = this.element[0].id;
            var node = this._findNodeUnderMouse(args);
            if (node === null && args.target) {
                if ($(args.target).attr("class") === "segmentEnd" && this.selectionList[0]) {
                    node = this.selectionList[0];
                }
            }
            var isMulSel = false;
            if ($(args.target).parents(".e-scrollbar").length && this.enableContextMenu()) {
                args.cancel = true;
                $("#" + this.element[0].id + "_contextMenu").ejMenu("instance").hideContextMenu();
            }
            if (this.selectionList[0] && (this.selectionList[0].type === "pseudoGroup" || this.selectionList[0]._type === "group"))
                isMulSel = true;
            if (!node && this.selectionList.length > 0 && !isMulSel && !(this.activeTool && this.activeTool.name == "textTool")) {
                this._clearSelection();
            }
            if (this.enableContextMenu()) {
                if ($("#" + _id + "_contextMenu_cut")[0])
                    $("#" + _id + "_contextMenu_cut")[0].style.display = this.selectionList.length ? "block" : "none";
                if ($("#" + _id + "_contextMenu_copy")[0])
                    $("#" + _id + "_contextMenu_copy")[0].style.display = this.selectionList.length ? "block" : "none";
                if ($("#" + _id + "_contextMenu_paste")[0])
                    $("#" + _id + "_contextMenu_paste")[0].style.display = this._clipboardData ? "block" : "none";
                if ($("#" + _id + "_contextMenu_undo")[0])
                    $("#" + _id + "_contextMenu_undo")[0].style.display = this._historyList && this._historyList.canUndo ? "block" : "none";
                if ($("#" + _id + "_contextMenu_redo")[0])
                    $("#" + _id + "_contextMenu_redo")[0].style.display = this._historyList && this._historyList.canRedo ? "block" : "none";
                if ($("#" + _id + "_contextMenu_selectAll")[0])
                    $("#" + _id + "_contextMenu_selectAll")[0].style.display = this.nodes().length + this.connectors().length ? "block" : "none";
                if ($("#" + _id + "_contextMenu_grouping")[0])
                    $("#" + _id + "_contextMenu_grouping")[0].style.display = this.selectionList[0] && (this.selectionList[0].type == "group" ||
                        this.selectionList[0].type == "pseudoGroup") ? "block" : "none";
                if ($("#" + _id + "_contextMenu_order")[0])
                    $("#" + _id + "_contextMenu_order")[0].style.display = this.selectionList.length ? "block" : "none";
            }
            var obj = ({ diagram: this, contextMenu: args, contextmenu: args });
            obj.target = this.selectionList.length ? this.selectionList[0] : this.activeTool.prevSelectObject ? this.activeTool.prevSelectObject : this;
            this._trigger("contextMenuBeforeOpen", obj);
            if (this.enableContextMenu()) {
                $("#" + _id + "_contextMenu")[0].style.display = "block";
                if ($("#" + _id + "_contextMenu")[0].clientHeight <= 2) args.cancel = true;
                $("#" + _id + "_contextMenu")[0].style.display = "none";
            }

        },
        _onMenuItemClick: function (args) {
            var menuId = args.events.ID.replace(this._id + "_" + "contextMenu_", "");
            args.canExecute = true;
            args.target = this.selectionList.length ? this.selectionList[0] : this.activeTool.prevSelectObject ? this.activeTool.prevSelectObject : this;
            this._trigger("contextMenuClick", args);
            if (args.canExecute) {
                switch (menuId) {
                    case "cut":
                        this.cut();
                        break;
                    case "copy":
                        this.copy();
                        break;
                    case "paste":
                        this.paste();
                        break;
                    case "undo":
                        this.undo();
                        break;
                    case "redo":
                        this.redo();
                        break;
                    case "selectAll":
                        this.selectAll();
                        break;
                    case "group":
                        this.group();
                        break;
                    case "ungroup":
                        this.ungroup();
                        break;
                    case "bringToFront":
                        this.bringToFront();
                        break;
                    case "sendToBack":
                        this.sendToBack();
                        break;
                    case "moveForward":
                        this.moveForward();
                        break;
                    case "sendBackward":
                        this.sendBackward();
                        break;
                    default:
                        break;
                }
            }
        },
        _onMenuItemMouseOver: function (args) {
            var t = args.events.element.lastChild.childNodes[1];
            $(t).addClass("hover");
        },
        _onMenuItemMouseOut: function (args) {
            var t = args.events.element.lastChild.childNodes[1];
            $(t).removeClass("hover");
        },
        _renderDiagram: function (isload) {
            var diagram = this;
            this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            if (!this._layoutUpdate) {
                this._doLayout();
            }
            this._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                if (view.type == "mainview" && view.context == ej.datavisualization.Diagram.SvgContext) {
                    view.context._renderDocument(view, diagram, isload);
                    diagram._createScrollbar(diagram._canvas, diagram);
                    ej.datavisualization.Diagram.ScrollUtil._initScrollbar(diagram);
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
                }
                if (!isload) {
                    var nodes = diagram._setNodeZOrder(view);
                    diagram._renderDiagramObjects(nodes, view);
                }
            });
            $(this._svg.document).pinchDiagram(this._view, this);
        },
        _createScrollbar: function (canvas, diagram) {
            var hScrollbar = document.createElement("div");
            hScrollbar.setAttribute("id", canvas.id + "_hScrollbar");
            if (!document.getElementById(canvas.id + "_hScrollbar")) {
                diagram._svgParent.appendChild(hScrollbar);
            }
            var vScrollbar = document.createElement("div");
            vScrollbar.setAttribute("id", canvas.id + "_vScrollbar");
            if (!document.getElementById(canvas.id + "_vScrollbar")) {
                diagram._svgParent.appendChild(vScrollbar);
            }
        },
        _disableScrollbar: function () {
            if (this._isMobile) {
                $("#" + this._hScrollbar._id).addClass("e-disable").attr({ "aria-disabled": true, "style": "display: none;" });
                $("#" + this._vScrollbar._id).addClass("e-disable").attr({ "aria-disabled": true, "style": "display: none;" });
            }
        },
        _doLayout: function () {
            if (this.model.layout && this._layoutType() !== ej.datavisualization.Diagram.LayoutTypes.None && !this._isLoad) {
                //this.model.layout = new ej.datavisualization.Diagram.HierarchicalLayout(this.model.layout);
                //this.model.layout._setModel(this);
                this._updateEdgeCollection();
                ej.datavisualization.Diagram.Layout.doLayout(this);
                //this.model.layout.doLayout(this);
                if (ej.datavisualization.Diagram.Util.canRouteDiagram(this)) {
                    var nodes = this.nodes();
                    if (nodes.length > 1) {
                        this.lineRouting.GenerateVisibilityGraph(this, nodes.length);
                        for (var i = 0; i < nodes.length; i++)
                            this._updateAllEdges(nodes[i]);
                    }
                }
            }
        },
        _updateNodes: function () {
            var nodes = this.nodes();
            for (var i = 0; i < nodes.length; i++) {
                ej.datavisualization.Diagram.DiagramContext.update(nodes[i], this);
            }
        },
        _updateConnectors: function () {
            var connections = this.connectors();
            for (var i = 0; i < connections.length; i++) {
                ej.datavisualization.Diagram.DiagramContext.update(connections[i], this);
            }
        },
        _updateEdgeCollection: function () {
            for (var i = 0; i < this.connectors().length; i++) {
                this._updateEdges(this.connectors()[i]);
            }
        },
        updateViewPort: function () {
            this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            ej.datavisualization.Diagram.DiagramContext.updateViewPort(this);
            this.model.scrollSettings.viewPortHeight = this._viewPort.height;
            this.model.scrollSettings.viewPortWidth = this._viewPort.width;
            var diagram = this;
            this._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                if (view.type == "overview") {
                    var ovw = $("#" + viewid).ejOverview("instance");
                    if (ovw)
                        ovw._scrollOverviewRect(diagram._hScrollOffset, diagram._vScrollOffset, diagram._currZoom);
                }
            });
            ej.datavisualization.Diagram.ScrollUtil._updateRuler(this, diagram._hScrollOffset, diagram._vScrollOffset)
        },
        _containsSameIndex: function (index, parent) {
            //if (!parent) {
            //    var nodes = this.nodes(), cNode;
            //    for (var i = 0; i < nodes.length > 0; i++) {
            //        cNode = nodes[i];
            //        if (cNode && cNode.zOrder === index)
            //            return true;
            //    }
            //    var connectors = this.connectors(), cConnector;
            //    for (var i = 0; i < connectors.length > 0; i++) {
            //        cConnector = connectors[i];
            //        if (cConnector && cConnector.zOrder === index)
            //            return true;
            //    }
            //}
            //else {
            //    var children = parent.children, child;
            //    for (var i = 0; i < children.length; i++) {
            //        child = this.nameTable[this._getChild(children[i])];
            //        if (child && child.zOrder) {
            //            if (child.zOrder === index)
            //                return true;
            //        }
            //    }
            //}
            return false;
        },
        _setZorder: function (node) {
            if (node && node.zOrder) {
                if (node.zOrder == -1) {
                    if (this._containsSameIndex(this._zOrder)) {
                        do {
                            this._zOrder++;
                        } while (this._containsSameIndex(this._zOrder));
                        node.zOrder = this._zOrder;
                    }
                    else {
                        node.zOrder = this._zOrder;
                        this._zOrder++;
                    }
                }
                else {
                }
                if (node._type === "group") {
                    var children = node.children, child;
                    for (var i = 0; i < children.length; i++) {
                        child = this.nameTable[this._getChild(children[i])];
                        if (child && child.zOrder && child.zOrder === -1) {
                            this._setZorder(child);
                        }
                    }
                }
            }
        },
        _union: function (rect1, rect2) {
            var x = Math.min(rect1.x, rect2.x);
            var y = Math.min(rect1.y, rect2.y);
            var overWidth = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
            var overheight = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);
            return new ej.datavisualization.Diagram.Rectangle(x, y, overWidth - x, overheight - y);
        },
        _getSeperetor: function (id) {
            return this.nameTable[id];
        },

        _updateNextPhase: function (swimlane, dif, index) {
            ej.datavisualization.Diagram.SwimLaneContainerHelper._updateNextPhase(this, swimlane, dif, index);
        },

        _getOuterNodes: function (swimlane, x, y) {
            return ej.datavisualization.Diagram.SwimLaneContainerHelper._getOuterNodes(this, swimlane, x, y);
        },

        _getInnerNodes: function (swimlane, value1, value2) {
            return ej.datavisualization.Diagram.SwimLaneContainerHelper._getInnerNodes(this, swimlane, value1, value2);
        },

        _moveOuterNodes: function (swimlane, dif, index) {
            return ej.datavisualization.Diagram.SwimLaneContainerHelper._moveOuterNodes(this, swimlane, dif, index);
        },

        _moveOnPhaseChange: function (phase, dif, index) {
            ej.datavisualization.Diagram.SwimLaneContainerHelper._moveOnPhaseChange(this, phase, dif, index);
        },

        _getPhaseDifferece: function (swimlane, index, difference) {
            return ej.datavisualization.Diagram.SwimLaneContainerHelper._getPhaseDifferece(this, swimlane, index, difference);
        },

        _updatePhaseOffset: function (obj) {
            var node = this.nameTable[obj.name], phase, dif;
            var phaseStack = this.nameTable[node.parent];
            var children = this._getChildren(phaseStack.children);
            var index = children.indexOf(node.name);
            if (children && children.length > 0) {
                if (index > -1 && obj.offset != undefined) {
                    phase = this.nameTable[children[index]];
                    dif = obj.offset - node.offset;
                    var swimlane = this.nameTable[phaseStack.parent]
                    dif = this._getPhaseDifferece(swimlane, index, dif);
                    this._moveOuterNodes(swimlane, dif, index);
                    if (index === 0) {
                        if (node.orientation === "horizontal") {
                            node.width += dif;
                            node.offset = node.width;
                            this._comparePropertyValues(swimlane, "offsetX", { offsetX: swimlane.offsetX + (dif / 2) }, this.activeTool.inAction);
                        }
                        else {
                            node.height += dif;
                            node.offset = node.height;
                            this._comparePropertyValues(swimlane, "offsetY", { offsetY: swimlane.offsetY + (dif / 2) }, this.activeTool.inAction);
                        }
                    }
                    else {
                        if (node.orientation === "horizontal") {
                            node.width += dif;
                            node.offset += dif;
                            this._comparePropertyValues(swimlane, "offsetX", { offsetX: swimlane.offsetX + (dif / 2) }, this.activeTool.inAction);
                        }
                        else {
                            node.height += dif;
                            node.offset += dif;
                            this._comparePropertyValues(swimlane, "offsetY", { offsetY: swimlane.offsetY + (dif / 2) }, this.activeTool.inAction);
                        }
                    }
                    this._disablePhaseUpdate = true;
                    this._disableSwimlaneUptate = true;
                    ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                    this._moveOnPhaseChange(node, dif, index);
                    this._updateNextPhase(swimlane, dif, index);
                    delete this._disablePhaseUpdate;
                    delete this._disableSwimlaneUptate;
                    ej.datavisualization.Diagram.DiagramContext.update(swimlane, this);
                    ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, swimlane);
                }
            }
        },
        _updatePhase: function (obj) {
            var node = this.nameTable[obj.name], phase, prevPhase, dif;
            if (node) {
                if ((node.offset != undefined && obj.offset != undefined) && obj.offset != node.offset) {
                    this._comparePropertyValues(node, "offset", { offset: obj.offset }, this.activeTool.inAction);
                    this._updatePhaseOffset(obj);
                    if (this._hasSelection())
                        this._clearSelection(true);
                }
                this._updateSwimlanePhase(node, obj);
            }
        },

        _setNodeZOrder: function (view) {
            var temp = null, jindex, iindex;
            var nodes = this.nodes();
            nodes = nodes.concat(this.connectors());
            for (var f = 0; f < nodes.length; f++) {
                if (nodes[f].parent === "")
                    this._setZorder(nodes[f]);
            }
            for (var i = 0; i < nodes.length; i++) {
                for (var j = i + 1; j < nodes.length; j++) {
                    if (nodes[i].zOrder > nodes[j].zOrder && (nodes[i].parent === "" && nodes[j].parent === "")) {
                        temp = nodes[i];
                        nodes[i] = nodes[j];
                        nodes[j] = temp;
                    }
                }
                if (nodes[i]._type === "group") {
                    var children = nodes[i].children;
                    if (!nodes[i].isSwimlane) {
                        for (var m = 0; m < children.length; m++) {
                            for (var n = m + 1; n < children.length; n++) {
                                var child1 = typeof (children[m]) === "object" ? children[m] : this.nameTable[children[m]];
                                var child2 = typeof (children[n]) === "object" ? children[n] : this.nameTable[children[n]];
                                if (child1.zOrder > child2.zOrder && !child1.isPhase && !child2.isPhase && !child1.isLane && !child2.isLane) {
                                    temp = children[m];
                                    children[m] = children[n];
                                    children[n] = temp;
                                }
                            }
                        }
                    }
                }
            }
            return nodes;
        },

        _renderDiagramObjects: function (nodes, view, isLoad, isoverView) {
            var rejectedNodes = new Array();
            var rejectedConnectors = new Array();
            this._initLayer();
            for (var i = 0, len = nodes.length; i < len; ++i) {
                if (this.getObjectType(nodes[i]) === "node" || this.getObjectType(nodes[i]) === "group") {
                    var node = this.nameTable[nodes[i].name];
                    if (node && this._outOfBoundsOnNudge(node, 0, 0)) {
                        if (this._isLoad)
                            this._disableSegmentChange = true;
                        ej.datavisualization.Diagram.DiagramContext._renderNodeObject(node, view, isLoad, isoverView, this)
                        if (this._isLoad)
                            delete this._disableSegmentChange;
                        this._updateQuad(node);
                    }
                    else
                        rejectedNodes.push(i)
                }
                else {
                    var connector = this.nameTable[nodes[i].name] || nodes[i];
                    if (connector && this._outOfBoundsOnNudge(connector, 0, 0)) {
                        ej.datavisualization.Diagram.DiagramContext._renderConnectorObject(connector, view, this);
                        this._updateQuad(connector);
                    }
                    else
                        rejectedConnectors.push(i);
                }

            }
            if (rejectedNodes.length > 0 || rejectedConnectors.length > 0) {
                if (rejectedNodes.length > 0) {
                    for (var i = rejectedNodes.length - 1; i >= 0; i--) {
                        this._removeFromNameTable(this.nodes()[i]);
                        this.nodes().splice(i, 1);
                    }
                    this._nodes = $.extend(true, [], this.nodes());
                }
                if (rejectedConnectors.length > 0) {
                    for (var i = rejectedConnectors.length - 1; i >= 0; i--) {
                        this._removeFromNameTable(this.connectors()[i]);
                        this.connectors().splice(i, 1);
                    }
                    this._connectors = $.extend(true, [], this.connectors());
                }
            }
        },

        _removeFromNameTable: function (node) {
            if (node && node._type === "group") {
                for (var i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    if (child._type === "group") {
                        this._removeChildrenFromNameTable(child);
                    }
                    else
                        delete this.nameTable[this._getChild(child)];
                }
            }
            delete this.nameTable[this._getChild(node)];
        },


        _unWireEvents: function () {
            var svgDocument = $(this._canvas);
            this._off(svgDocument, ej.eventType.mouseDown, this._mousedown);
            this._off(svgDocument, ej.eventType.mouseMove, this._mousemove);
            this._off(svgDocument, ej.eventType.mouseUp, this._mouseup);
            this._off(svgDocument, ej.eventType.mouseLeave, this._documentmouseup);
            this._off(svgDocument, "doubletap", this._doubleclick);
            this._off(this.element, "keydown", this._keydown);
            this._off(this.element, "keyup", this._keyup);
            //this._on(this.element, "contextmenu", this._contextmenu);
            this._off(svgDocument, "pinchin", this._pinchin);
            this._off(svgDocument, "pinchout", this._pinchout);
            this._off(this.element, "touchstart", this._handleTouchStart);
            if (ej.browserInfo().name === "mozilla") {
                this._off(this.element, "DOMMouseScroll", this._handleMouseWheel);
            }
            else
                this._off(this.element, "mousewheel", this._handleMouseWheel);
            //window document event
            this._off($(document), "mouseup", this._documentmouseup);

            if (window && (this.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Resizable)) {
                this._off($(window), "resize", this.updateViewPort);
            }
        },

        //#endregion
        //#region Events
        _wireEvents: function () {
            //svg document events
            var svgDocument = $(this._canvas);
            this._on(svgDocument, ej.eventType.mouseDown, this._mousedown);
            this._on(svgDocument, ej.eventType.mouseMove, this._mousemove);
            this._on(svgDocument, ej.eventType.mouseUp, this._mouseup);
            this._on(svgDocument, ej.eventType.mouseLeave, this._documentmouseup);
            this._on(svgDocument, "doubletap", this._doubleclick);
            this._on(this.element, "keydown", this._keydown);
            this._on(this.element, "keyup", this._keyup);
            this._on(this.element, "contextmenu", this._preventDefaultContextMenu);
            //this._on(this.element, "contextmenu", this._contextmenu);
            this._on(svgDocument, "pinchin", this._pinchin);
            this._on(svgDocument, "pinchout", this._pinchout);
            this._on(this.element, "touchstart", this._handleTouchStart);
            if (ej.browserInfo().name === "mozilla") {
                this._on(this.element, "DOMMouseScroll", this._handleMouseWheel);
            }
            else
                this._on(this.element, "mousewheel", this._handleMouseWheel);
            //window document event
            this._on($(document), "mouseup", this._documentmouseup);

            if (window && (this.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Resizable)) {
                this._on($(window), "resize", this.updateViewPort);
            }
            var obj = this;
            $(svgDocument).ejDroppable({
                over: function (event, ui) {
                    obj._isDropOver = true;
                    var isTouch = false;
                    if (event.originalEvent && event.originalEvent.changedTouches) {
                        isTouch = true;
                    }
                    else if (event && event.changedTouches) {
                        isTouch = true;
                    }
                    if (!isTouch) {
                        if ((obj.activeTool.inAction === false) && obj._selectedSymbol) {
                            if (!obj._viewPort) obj._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(obj, true);
                            obj._addSymbolToDiagram(event);
                            obj._isSvgDropover = true;
                        }
                    }
                },
                out: function (event) {
                    delete obj._isDropOver;
                },
                drop: function (event, ui) {
                    obj._svgdrop(event, ui);
                    obj._isDropped = true;
                },
            });
        },
        _preventDefaultContextMenu: function (e) {
            if (this._disableDefaultContextMenu) {
                e.preventDefault();
                e.stopPropagation();
                delete this._disableDefaultContextMenu;
                return false;
            }
        },
        _mousePosition: function (evt, exOffset) {
            var e = this._isTouchEvent(evt);
            var scrollLeft = this._scrollLeft !== undefined ? this._scrollLeft : this._canvas.scrollLeft;
            var scrollTop = this._scrollTop !== undefined ? this._scrollTop : this._canvas.scrollTop;
            var controlBBox = this._controlBBox ? this._controlBBox : this._canvas.getBoundingClientRect();
            var layerx = (e.clientX + scrollLeft) - controlBBox.left;
            var layery = (scrollTop + e.clientY) - controlBBox.top;
            var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(this)
            if (!exOffset) {
                layerx = (layerx + this._hScrollOffset - rulerSize.left) / this._currZoom;
                layery = (layery + this._vScrollOffset - rulerSize.top) / this._currZoom;
            }
            return new ej.datavisualization.Diagram.Point(Math.round(layerx * 100) / 100, Math.round(layery * 100) / 100);
        },
        _contextmenu: function (evt) {
            evt.preventDefault();
            evt.stopPropagation();
        },
        _pinchin: function (evt) {
            this._getTouchEvent(evt);
            evt.preventDefault();
        },
        _pinchout: function (evt) {
            this._getTouchEvent(evt);
            evt.preventDefault();
        },
        _handleTouchStart: function (evt) {
            this._getTouchEvent(evt);
            var foreignObject = this._isForeignObject(evt.originalEvent.target);
            if (!foreignObject) {
                evt.preventDefault();
            }
        },

        _getTouchEvent: function (evt) {
            if (evt.type == "touchmove" || evt.type == "touchstart" || evt.type == "touchend")
                this._isTouchedEvent = true;
            else
                this._isTouchedEvent = false;
        },
        _getvalues: function (evt) {
            var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group");
            var obj;
            var id = evt.target.id.split('_');
            obj = this.findNode(id[0]);
            var point = this._mousePosition(evt);
            var curport = this._findPortAtPoint(point, obj);
            return { "source": curport, "action": ej.datavisualization.Diagram.ActiveTool };
        },
        _mousedown: function (evt) {
            this._isDiagramMouseDown = true;
            this._getTouchEvent(evt);
            this._isPinching = false;
            this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            this._diagramElements = null;
            ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this._adornerSvg, this._adornerLayer);
            if (this._invoke(evt)) {
                this._scrollLeft = this._canvas.scrollLeft;
                this._scrollTop = this._canvas.scrollTop;
                this._controlBBox = this._canvas.getBoundingClientRect();
                var position = this._mousePosition(evt);
                var foreignObject = this._isForeignObject(evt.originalEvent.target);
                if ((!foreignObject && !this._isHyperLink(evt)) || this._isForeignEvent(evt))
                    evt.preventDefault();
                if (this.model.contextMenu && $("#" + this.element[0].id + "_contextMenu").css("display") !== "none") {
                    evt.cancel = true;
                }
                if (this._isEditing) {
                    this._endEdit();
                    if (this.activeTool.name === "textTool") {
                        if (this.activeTool.singleAction) {
                            this.activeTool.diagram.deactivateTool();
                        }
                    }
                }
                if ((evt.which === 1 || evt.which === 3) || (evt.which === 0 && evt.originalEvent.changedTouches)) {
                    this._removeMouseOverTooltip();
                    if (evt.which === 0 && evt.originalEvent.changedTouches) {
                        var node = null;
                        var isUserHandle = this._isUserHandle(evt);
                        if ((this._isInternalTool(this.activeTool) && !this.activeTool.inAction)) {
                            if (!isUserHandle) {
                                node = this._findNodeUnderMouse(evt);
                                this._raiseMouseEvents(node, position);
                            }
                            if (!node && this.selectionList[0]) {
                                node = this.selectionList[0];
                            }
                            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                                this._checkToolToActivate(evt, node);
                            }
                        }
                    }
                    if ((navigator.platform.match("Mac") ? evt.metaKey : evt.ctrlKey) && evt.shiftKey) {
                        node = this._findNodeUnderMouse(evt);
                        if (!node && this.selectionList[0]) {
                            node = this.selectionList[0];
                        }
                        this._checkToolToActivate(evt, node);
                    }
                    if (this._toolToActivate === "panTool") {
                        this.activeTool = this.tools[this._toolToActivate];
                    }
                    else {
                        if (this._toolToActivate === "move") {
                            node = this._findNodeUnderMouse(evt);
                            if (node && node.isLane && ej.datavisualization.Diagram.Util.canMultiSelectOnLane(node)) {
                                this._toolToActivate = "select";
                                this._currentCursor = "default";
                                this._updateCursor();
                            }
                        }
                        var tool = this.tools[this._toolToActivate] || this.activeTool;
                        this.activateTool(this._toolToActivate, tool ? tool.singleAction : null);
                    }
                    if (this.activeTool.mousedown)
                        this.activeTool.mousedown(evt);
                    if (this.activeTool._findNodeUnderMouse)
                        this._focusedElement = this.activeTool._findNodeUnderMouse(evt, true);
                }
            }
        },

        _getParentNode: function (name) {
            var parentNode;
            var node = this.findNode(name);
            if (node.parent) {
                parentNode = this.findNode(node.parent);
                if (parentNode.parent) {
                    this._getParentNode(parentNode.name);
                }
            }
            return parentNode.name;
        },

        _getDiagramElements: function (node) {
            if (node && (node.isSwimlane || node.isLane)) {
                node = this.getNode(node);
            }
            return node;
        },

        _mousemove: function (evt) {
            this._getTouchEvent(evt);
            this._mouseEventTriggered = true;
            if (!this._viewPort) this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            if (evt.type == "touchmove" && evt.originalEvent.touches.length > 1) {
                this._isPinching = true;
            } else {
                this._isPinching = false;
                var node = null;
                var isUserHandle = this._isUserHandle(evt);

                if ((this.activeTool.inAction === false) && this._selectedSymbol) {
                    this._previousData = null;
                    this._addSymbolToDiagram(evt);
                } else {
                    if (this.activeTool.inAction && this.activeTool.name === "move" && this.selectionList[0]) {
                        var currentNode = this._findNodeUnderMouse(evt);
                        if (this.nameTable[this._previousData] && (!currentNode || (this._previousData != (currentNode._isHeader ? currentNode.parent : currentNode.name)))) {
                            if (this.nameTable[this._previousData].parent) {
                                var actualObject = this._getParentNode(this.nameTable[this._previousData].name);
                            }
                            var args = { element: this._getDiagramElements(this.selectionList[0]), target: this._getDiagramElements(this.nameTable[this._previousData]), targetType: this.getObjectType(this.nameTable[this._previousData]), actualObject: this.findNode(actualObject) ? actualObject : null };
                            this._raiseEvent("dragLeave", args);
                            this._previousData = null;
                        }
                        if (currentNode && this._previousData && this.nameTable[this._previousData] !== (currentNode._isHeader ? this.nameTable[currentNode.parent] : currentNode)) {
                            this._previousData = currentNode._isHeader ? currentNode.parent : currentNode.name;
                            if (this.nameTable[this._previousData].parent) {
                                var actualObject = this._getParentNode(this.nameTable[this._previousData].name);
                            }
                            var args = { element: this._getDiagramElements(this.selectionList[0]), target: this._getDiagramElements(this.nameTable[this._previousData]), targetType: this.getObjectType(this.nameTable[this._previousData]), actualObject: this.findNode(actualObject) ? actualObject : null };
                            this._raiseEvent("dragEnter", args);
                        }
                    }
                    if (ej.datavisualization.Diagram.Util.isClassifier(evt))
                        var node = ej.datavisualization.Diagram.ClassifierHelper.getSelectableElementUnderMouse(evt, this);
                    else
                        node = this._findNodeUnderMouse(evt)
                    if ((this._isInternalTool(this.activeTool) && !this.activeTool.inAction)) {
                        if (!isUserHandle) {
                            if (node) {
                                if (this._nodeUnderMouse && this._nodeUnderMouse != node && !this._nodeUnderMouse.segments) {
                                    this.activeTool._showPort(this._nodeUnderMouse, true);
                                }
                                if (!node.segments) {
                                    this.activeTool._showPort(node);
                                }
                            }
                            //this._raiseMouseEvents(node);
                        }
                        if (!node && this.selectionList[0]) {
                            node = this.selectionList[0];
                        }
                        if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                            this._checkToolToActivate(evt, node);
                        }
                        if (evt.which == 1 && evt.buttons == 1)
                            this._focusedElement = this.activeTool._findNodeUnderMouse(evt, true);
                    } else {
                        var canProceed = true;
                        if (this._activatedFromPort && !this.activeTool.inAction) {
                            var point, port = null;
                            if (this._nodeUnderMouse && !this._nodeUnderMouse.segments) {
                                point = this._mousePosition(evt);
                                port = this._findPortAtPoint(point, this._nodeUnderMouse);
                            }
                            if (!port || (port && !(port.constraints & ej.datavisualization.Diagram.PortConstraints.ConnectOnDrag))) {
                                ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this._adornerSvg, this._adornerLayer);
                                this.deactivateTool();
                                canProceed = false;
                                delete this._activatedFromPort;
                            }
                        }
                        if (canProceed) {
                            if (!this.activeTool.inAction) {
                                this._toolToActivate = this.activeTool.name;
                                this._currentCursor = this.activeTool.cursor;
                            }
                            if (ej.datavisualization.Diagram.Util.isClassifier(evt))
                                nodeUnderMouse = ej.datavisualization.Diagram.ClassifierHelper.getDropableElementUnderMouse(evt, this);
                            else
                                nodeUnderMouse = this._findNodeUnderMouse(evt);
                            if (node) {
                                //this._raiseMouseEvents(node);
                            }
                        }
                    }
                    this._updateCursor();
                    var nodeUnderMouse = nodeUnderMouse || this._findNodeUnderMouse(evt);
                    if (this.activeTool.mousemove)
                        this.activeTool.mousemove(evt);
                    // var position = this._mousePosition(evt);
                    this._raiseMouseEvents(nodeUnderMouse, evt);
                    var canAvoidConnection = false;
                    if (this.activeTool.inAction) {
                        do {
                            if (nodeUnderMouse && !ej.datavisualization.Diagram.Util.canAllowDrop(nodeUnderMouse)) {
                                if (nodeUnderMouse.parent) nodeUnderMouse = this.nameTable[nodeUnderMouse.parent];
                                else
                                    if (nodeUnderMouse.segments)
                                    { canAvoidConnection = true; break; }
                                    else if (nodeUnderMouse.container) {
                                        break;
                                    }
                                    else
                                        nodeUnderMouse = null;
                            }
                            else break;
                        } while (nodeUnderMouse);
                        if (this._nodeUnderMouse && this._nodeUnderMouse.segments && this._nodeUnderMouse != nodeUnderMouse)
                            ej.datavisualization.Diagram.SvgContext._removeConnectorHighlighter(this._adornerLayer, this._adornerSvg);
                        if (nodeUnderMouse && ((nodeUnderMouse != this._focusedElement && nodeUnderMouse != this.nodeUnderMouse) &&
                            (canAvoidConnection || ej.datavisualization.Diagram.Util.canAllowDrop(nodeUnderMouse)))) {
                            var type = this.getObjectType(nodeUnderMouse);
                            if (!((this._focusedElement && (this._focusedElement.isLane || this._focusedElement.isSwimlane || this._focusedElement.isPhase)) && type == "node" && type == "connector")) {
                                if (!((this._nodeUnderMouse && (this._nodeUnderMouse.isLane || this._nodeUnderMouse.isSwimlane || this._nodeUnderMouse.isPhase))
                                    && nodeUnderMouse.segments)) {
                                    this._nodeUnderMouse = nodeUnderMouse;
                                }
                            }
                            else this._nodeUnderMouse = null;
                        }
                        else if (nodeUnderMouse && nodeUnderMouse.container)
                        { }
                        else
                            this._nodeUnderMouse = null;
                    } else if (!this._focusedElement)
                        this._nodeUnderMouse = nodeUnderMouse;
                    this._initiateAutoScroll(evt);
                }
            }
        },
        _mouseup: function (evt) {
            this._getTouchEvent(evt);
            if (!this._isPinching && evt.originalEvent && evt.originalEvent.target) {
                if (this._invoke(evt)) {
                    var foreignObject = this._isForeignObject(evt.originalEvent.target);
                    if (!foreignObject && this._isHyperLink(evt))
                        evt.preventDefault();
                    if (this.activeTool instanceof ej.datavisualization.Diagram.PanTool) {
                        document.onmousemove = null;
                        document.onmouseup = null;
                        if ((!ej.datavisualization.Diagram.Util.isPageEditable(this) || this.activeTool instanceof ej.datavisualization.Diagram.PanTool) && !this.activeTool.inAction) {
                            var obj = this.activeTool._findNodeUnderMouse(evt);
                            if (obj)
                                this._raiseEvent("itemClick", { actualObject: obj, selectedObject: obj, model: this.model, cancel: false, event: evt });
                            var mousePosition = this._mousePosition(evt.originalEvent);
                            this._raiseEvent("click", { element: obj, actualObject: this.getNode(this.activeTool.actualObject), count: this._getEventDetail(evt), offsetX: mousePosition.x, offsetY: mousePosition.y, event: evt });
                            if (this.activeTool instanceof ej.datavisualization.Diagram.PanTool) {
                                document.onmousemove = null;
                                document.onmouseup = null;
                            }
                        }
                    } else if (evt.target.id === this._id + "_canvas_svg" && (!this.activeTool.name == "panTool" || !this.activeTool.inAction)) {
                        var mousePosition = this._mousePosition(evt.originalEvent);
                        this._raiseEvent("click", { element: this, actualObject: this.getNode(this.activeTool.actualObject), count: this._getEventDetail(evt), offsetX: mousePosition.x, offsetY: mousePosition.y, event: evt });
                    }
                    if (evt.target && !this._isAnimating) {
                        var parent = $(evt.target).parents(".ej-d-icon-template");
                        if (parent) {
                            if (parent.length) {
                                var target = parent[0];
                                if (target.id.endsWith("_expander")) {
                                    var id = target.id.replace("_expander", "");
                                    var obj = this.nameTable[id];
                                    if (obj) {
                                        var type = this.getObjectType(obj);
                                        if (type == "node" || type == "group") {
                                            this.clearSelection();
                                            ej.datavisualization.Diagram.LayoutUtil.expandSubTree(this, obj, obj.name, true, ej.datavisualization.Diagram.Util.canSelect(obj));
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (this._selectedSymbol && !this._selectedSymbol.isLane && !this._isNodeEnters) {
                        this._findLabelEditing = true;
                        this._dropSymbol(null, evt);
                        delete this._findLabelEditing;
                        this._isDragg = true;
                    }
                    else if (this._selectedSymbol && this._isNodeEnters) {
                        var element = this.findNode(this.selectionList[0].name);
                        if (this.edgeTable)
                            delete this.edgeTable;
                        else {
                            var childTable = {};
                            childTable = this._getChildTable(this.selectionList[0], childTable);
                            if (this._selectedSymbol.type == "pseudoGroup")
                                var entry = { type: "collectionchanged", object: this._updatePsedoGroupChildren(this._selectedSymbol), childTable: jQuery.extend(true, {}, childTable), changeType: "insert", category: "internal" };
                            else if (!this._selectedSymbol.isPhase)
                                var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, this._selectedSymbol), childTable: jQuery.extend(true, {}, childTable), changeType: "insert", category: "internal" };
                            this.addHistoryEntry(entry);
                            this._isDragg = true;
                        }
                        this._clearSelection(true);
                        this._selectedSymbol = null;
                        delete this._isNodeEnters;

                        if (element.type == "pseudoGroup") {
                            this.nodes().push(element);
                            this._nodes = $.extend(true, [], this.nodes());
                            this.nameTable[element.name] = element;
                            ej.datavisualization.Diagram.Util._updateGroupBounds(element, this);
                        }
                        this._addSelection(element);
                    }
                    var cursor;
                    if (ej.browserInfo().name === "msie" && this._doubleClickEvent)
                        this.activeTool._isMouseDown = true;
                    if (this.activeTool.mouseup) {
                        if (!this.activeTool.inAction)
                            this._isSelectMode = true;
                        this.activeTool.mouseup(evt);
                        delete this._isSelectMode;
                    }
                    else if (!this._isInternalTool(this.activeTool)) {
                        if (this._isUserHandle(evt))
                            cursor = this.activeTool.cursor;
                        this.deactivateTool()
                    };
                    if ((!(this.activeTool instanceof ej.datavisualization.Diagram.TextTool)) && document.activeElement && document.activeElement.id !== this.element[0].id)
                        if (!this._isEditing && !foreignObject && !(evt.which === 3 && this.enableContextMenu())) {
                            if (this._isDiagramMouseDown)
                                this.element[0].focus();
                        }
                    this._currentCursor = cursor ? cursor : this.activeTool.cursor;
                    if (this.activeTool.name === "move" && this._focusedElement && !ej.datavisualization.Diagram.Util.canSelect(this._focusedElement) && ej.datavisualization.Diagram.Util.enableLayerOption(this._focusedElement, "lock", this)) {
                        this._currentCursor = "default"
                        this._updateCursor();
                    }
                    else
                        this._updateCursor();
                }
            }
            if (this._isSvgDropover) {
                $("#" + this.element[0].id + "_canvas").ejDroppable("instance")._mouseOver = false;
            }
            delete this._isSvgDropover;
            this._focusedElement = null;
            this._nodeUnderMouse = this._findNodeUnderMouse(evt);
            delete this._scrollLeft;
            delete this._scrollTop;
            delete this._controlBBox;
            this._mouseEventTriggered = false;
            this._isDragg = false;
            delete this._viewPort;
            delete this._isDropOver;
            this._timeStamp = evt.timeStamp;
            delete this._isDiagramMouseDown;
        },
        _doubleclick: function (evt) {
            this._getTouchEvent(evt);
            this._doubleClickEvent = !this._doubleClickEvent;
            var args;
            var obj = this._nodeUnderMouse || this;
            args = { element: this.getNode(obj), cancel: false, actualObject: this.getNode(this.activeTool.actualObject) }
            if (!this._isEditing)
                this._raiseEvent("doubleClick", args);
            var preventEditing = this.activeTool._drawingPolygon;
            if (this.activeTool.name != "panTool") {
                if (this._nodeUnderMouse)
                    this.activeTool._doubleClick(this._nodeUnderMouse);
                if (ej.datavisualization.Diagram.Util.isClassifier(evt))
                    var editableElement = ej.datavisualization.Diagram.ClassifierHelper.getEditableElementUnderMouse(evt, this);
                if (ej.datavisualization.Diagram.Util.isPageEditable(this) && !this.activeTool.inAction && (((this.selectionList.length > 0) || editableElement) || this.activeTool.selectedObject) && !args.cancel && !preventEditing) {
                    if (this.activeTool.selectedObject)
                        var obj = this.activeTool.selectedObject;
                    else if (this.selectionList[0])
                        var obj = this.selectionList[0];
                    else
                        obj = editableElement;
                    if (obj.type == "umlclassifier") {
                        for (var i = 0; i < obj.children.length; i++) {
                            obj.children[i] = typeof obj.children[i] == "string" ? this.nameTable[obj.children[i]] : obj.children[i];
                            if (i != obj.children.length - obj.children.length && i == obj.children.length - 1)
                                obj.children[i].labels[0].text = "\n" + "---" + "\n" + obj.children[i].labels[0].text;
                            if (i != obj.children.length - obj.children.length && i == obj.children.length - 2)
                                obj.children[i].labels[0].text = "\n" + "---" + "\n" + obj.children[i].labels[0].text;
                            obj.labels[0].text += obj.children[i].labels[0].text;
                        }
                    }
                    if (!this._isEditing && !(obj.type == "pseudoGroup") && !args.cancel) {
                        this.activeTool._findLabelUnderMouse(evt, false, this._mousePosition(evt.originalEvent), true);
                        if (obj.labels && obj.labels.length > 0) {
                            var label = this.activeTool.getLabelUnderMouse();
                            if (!label) label = obj.labels[0];
                        }
                        if (!this._isEditing && obj.type === "text" && this._setLabelEditing(obj.textBlock)) {
                            this.scrollToNode(obj);
                            this._startEdit(obj);
                        }
                        else if (!this._isEditing && this.selectionList.length === 1 && this.selectionList[0]._type === "label" && obj.name === this.selectionList[0].name) {
                            this.scrollToNode(this.nameTable[obj._parent]);
                            this._startEdit(this.nameTable[obj._parent]);
                        }
                        else if (!this._isEditing && !obj.isLaneStack && !obj.isLane && !obj.isSwimlane && (obj.labels && (obj.labels.length === 0 || typeof obj.labels.length === "undefined") || (obj.labels && obj.labels.length > 0 && this._setLabelEditing(label)))) {
                            this.scrollToNode(obj);
                            this._startEdit(obj);
                        }
                        else if (obj.isLane && (obj.labels && obj.labels.length > 0 && this._setLabelEditing(label))) {
                            if (obj.labels && obj.labels.length > 0) {
                                this.scrollToNode(obj);
                                this._startEdit(obj);
                            }
                            else
                                this.activeTool.selectedObject = null;
                        }
                        else if (obj.isLane) {
                            this.activeTool.selectedObject = null;
                        }
                    }
                }
            }
            this.activeTool._isMouseDown = false;
        },
        _documentmouseup: function (evt) {
            this._getTouchEvent(evt);
            var selectedSymbol = this._selectedSymbol;
            this._removeMouseOverTooltip();
            if (!this._viewPort) this._viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this, true);
            if (this.activeTool && this.activeTool.inAction && !(this.activeTool instanceof ej.datavisualization.Diagram.TextTool) &&
                !(this.activeTool instanceof ej.datavisualization.Diagram.ShapeTool && this.activeTool._drawingPolygon)) {


                if (this._selectedSymbol && evt.type != "mouseleave") {
                    this._findLabelEditing = true;
                    this._dropSymbol(null, evt);
                    delete this._findLabelEditing;
                    this._isDragg = true;
                }

                this.activeTool.mouseup(evt, true);
            }
            this.activeTool._removeRulerMarkers();
            if (selectedSymbol) {
                if (evt.keyCode != 27 && evt.keyCode != 46) {
                    var preview = document.getElementsByClassName("e-paletteItem dragClone")[0];
                    if (preview != null) {
                        preview.style.display = "block";
                    }
                    this._selectedSymbol = selectedSymbol;
                }
                this._raiseEvent("dragLeave", { element: this.selectionList[0], target: this, targetType: "diagram" });
                if (this._mouseEventTriggered) {
                    this._delete(this.selectionList[0]);
                }
            }
            if (this._isNodeEnters) {
                delete this._isNodeEnters;
                this._selectedSymbol = null;
                var preview = document.getElementsByClassName("dragClone")[0];
                if (preview != null) {
                    preview.style.display = "block";
                }
            }
            delete this._viewPort;
            delete this._isDropOver;
            this._mouseEventTriggered = false;
            this._isDragg = false;
        },
        _invoke: function (evt) {
            if (evt.originalEvent.target) {
                var className = evt.originalEvent.target.className;
                if (className && typeof className === "string" && (className == "edit" || className == "editBox" || className.indexOf("e-hhandle") > -1 || className.indexOf("e-hhandlespace") > -1 || className.indexOf("e-vhandle") > -1 || className.indexOf("e-vhandlespace") > -1)) {
                    return false;
                }
            }
            return true;
        },
        _handleMouseWheel: function (evt) {
            if (!this._isForeignEvent(evt, true)) {
                if (evt.originalEvent.preventDefault)
                    evt.originalEvent.preventDefault();
                var position = new ej.datavisualization.Diagram.Point(0, 0);
                if (this._isEditing) {
                    this._endEdit();
                }
                //this.deactivateTool();
                if ((navigator.platform.match("Mac") ? evt.metaKey : evt.ctrlKey)) {
                    position = this._mousePosition(evt.originalEvent);
                    if (evt.originalEvent.wheelDelta > 0 || -40 * evt.originalEvent.detail > 0) {
                        ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 + Number(this.zoomFactor())), 0, 0, position, true);
                    } else {
                        ej.datavisualization.Diagram.ZoomUtil.zoomPan(this, (1 / (1 + Number(this.zoomFactor()))), 0, 0, position, true);
                    }
                } else {
                    var offsetY = 0;
                    var oVal = {
                        zoom: this._getCurrentZoom(), horizontalOffset: this._hScrollOffset,
                        verticalOffset: this._vScrollOffset, viewPort: this._viewPort
                    };
                    var scrolled;
                    if (evt.originalEvent.wheelDelta > 0 || -40 * evt.originalEvent.detail > 0) {
                        var top = this._vScrollbar.model.minimum;

                        var limited = this._scrollLimit() === "limited" && (this._vScrollOffset - this._scrollPixel) >= this.model.pageSettings.scrollableArea.y * this._currZoom;
                        if ((this._vScrollOffset - this._scrollPixel) >= top || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity || limited) {
                            var executeScroll = false;
                            if (this._scrollLimit() !== "diagram") {
                                executeScroll = true;
                            } else {
                                if (this._vScrollbar && this._vScrollbar._scrollData) {
                                    var vScrollElement = this._vScrollbar.element[0];
                                    if (vScrollElement && (vScrollElement.style.visibility === "visible" || vScrollElement.style.visibility === "")) {
                                        executeScroll = true;
                                    }
                                }
                            }
                            if (executeScroll) {
                                this._updateScrollOffset(this._hScrollOffset, (this._vScrollOffset - this._scrollPixel));
                                scrolled = true;
                                offsetY = -this._scrollPixel;
                            }
                        } else {
                            this._updateScrollOffset(this._hScrollOffset, top);
                            scrolled = true;
                            offsetY = 0;
                        }
                    } else {
                        var cHeight = this._vScrollbar.model.maximum;
                        var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
                        limited = this._scrollLimit() === "limited" &&
                            (this.model.pageSettings.scrollableArea.y + this.model.pageSettings.scrollableArea.height) * this._currZoom >=
                            (this._vScrollOffset + this._scrollPixel + viewPort.height);
                        if ((cHeight) >= (this._vScrollOffset + this._scrollPixel) || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity || limited) {
                            this._updateScrollOffset(this._hScrollOffset, (this._vScrollOffset + this._scrollPixel));
                            scrolled = true;
                            offsetY = this._scrollPixel;
                        } else {
                            this._updateScrollOffset(this._hScrollOffset, cHeight);
                            scrolled = true;
                            offsetY = 0;
                        }
                    }
                    if (scrolled) {
                        var nVal = {
                            zoom: this._getCurrentZoom(), horizontalOffset: this._hScrollOffset,
                            verticalOffset: this._vScrollOffset, viewPort: this._viewPort
                        };
                        if ((oVal.horizontalOffset != nVal.horizontalOffset) || (oVal.verticalOffset != nVal.verticalOffset)) {
                            this._eventCause["scrollChange"] = ej.datavisualization.Diagram.ScrollChangeCause.Pan;
                            this._raiseEvent("scrollChange", { newValues: nVal, oldValues: oVal });
                        }
                    }
                    this._updateEditBox(0, offsetY);
                }
            }
        },
        _setActiveTool: function (evt) {
            var point = this._mousePosition(evt);
            if (!this.activeTool.inAction && (this._isUserHandleActive(this.activeTool.name) || !this.model.selectedItems.userHandles || !this.model.selectedItems.userHandles.length)) {
                if (this._isInternalTool(this.activeTool) || this.activeTool.singleAction) {
                    var node;
                    var success = false;
                    //var handle = this._isHandle(evt);
                    if (this.selectionList[0]) {
                        node = this.selectionList[0];
                        success = this._checkToolToActivate(evt, node);
                    }
                    if (!success) {
                        node = this._findNodeUnderMouse(evt);
                        if (this._isUserHandle(evt)) {
                            var handleName = $(evt.target).parents("g").first().context.id.split("_")[0];
                            this._checkToolToActivate(evt, node);
                            this.activeTool = this.tools[this._toolToActivate];
                        }
                        else {
                            this._checkToolToActivate(evt, node);
                            this._raiseMouseEvents(node);
                            if (this._isUserHandleActive(this.activateTool.name) && !this._drawingTool)
                                this.activeTool = this.tools[this._toolToActivate];
                        }
                    }
                }
            }
        },
        _beginAutoScroll: function (option, evt, delay1) {
            var delay = delay1 ? delay1 : 100;
            var callBack = this;
            var left = 0, top = 0;
            var counter = 0;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
            var cWidth = this._hScrollbar.model.maximum + viewPort.width;
            var cHeight = this._vScrollbar.model.maximum + viewPort.height;
            var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(this);
            var intervalID;
            if (this._canAutoScroll) {
                switch (option) {
                    case "right":
                        if ((this._hScrollOffset + viewPort.width + 10) - rulerSize.left < cWidth || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            left = 10;
                        }
                        break;
                    case "left":
                        if (this._hScrollOffset - 10 > this._hScrollbar.model.minimum - rulerSize.left || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            left = -10;
                        }
                        break;
                    case "bottom":
                        if ((this._vScrollOffset + viewPort.height + 10) - rulerSize.top < cHeight || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            top = 10;
                        }
                        break;
                    case "top":
                        if (this._vScrollOffset - 10 > this._vScrollbar.model.minimum - rulerSize.top || this._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                            top = -10;
                        }
                        break;
                }
                callBack._clearTimeOutValue = window.setTimeout(function (args) {
                    var s1 = this;
                    var args = { delay: delay };
                    callBack._raiseEvent("autoScrollChange", args);
                    callBack._updateScrollBar(left, top, option, evt, args.delay);
                }, delay);

            }
        },
        _updateScrollBar: function (x, y, option, evt, delay) {
            if (this._clearTimeOutValue)
                window.clearTimeout(this._clearTimeOutValue);
            if (x === 0 && y === 0) {
                this._canAutoScroll = false;
            }
            else if (this.activeTool.inAction) {
                var hScrollOffset = this._hScrollOffset + (x * this._currZoom);
                var vScrollOffset = this._vScrollOffset + (y * this._currZoom);
                var isUpdated = this._updateSelectionOnScroll(x, y);
                if (isUpdated) {
                    this._updateScrollOffset(hScrollOffset, vScrollOffset);
                    this._beginAutoScroll(option, evt, delay);
                }
                else {
                    this._canAutoScroll = false;
                }
            }
        },
        _updateSelectionOnScroll: function (x, y) {
            var tool = this.activeTool;
            if (tool.name === "select") {
                tool.currentPoint = new ej.datavisualization.Diagram.Point(tool.currentPoint.x + x, tool.currentPoint.y + y);
                tool._updateHelper();
            } else if (tool.name === "orthogonalLine" || tool.name === "straightLine") {
                tool.currentPoint = new ej.datavisualization.Diagram.Point(tool.currentPoint.x + x, tool.currentPoint.y + y);
                tool._targetPossibleConnection = tool._currentPossibleConnection;
                tool._targetPort = tool._possibleConnectionPort;
                tool._updateHelper();
            } else if (this.selectionList.length > 0) {
                var node = this.selectionList[0];
                if (!node.isLane)
                    tool.currentPoint = ej.datavisualization.Diagram.Point(tool.currentPoint.x + x, tool.currentPoint.y + y);
                if (tool.name === "move") {
                    if (!node.isLane && tool._outOfBoundsDrag(node, x, y)) {
                        if (tool._canMoveLabel)
                            this._translateLabel(node, tool.activeLabel, x, y);
                        else
                            this._translate(node, x, y, this.nameTable);
                    }
                    else
                        return false;
                } else if (tool.name === "resize") {
                    ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this);
                    tool._updateSize(node, tool.previousPoint, tool.currentPoint);
                } else if (tool.name === "endPoint") {
                    if (tool.selectedSegment && tool._endPoint == "segmentEnd") {
                        var difx = tool.currentPoint.x - tool.previousPoint.x;
                        var dify = tool.currentPoint.y - tool.previousPoint.y;
                        tool._updateAdjacentSegments(difx, dify);

                    } else {
                        var cancelEvent = tool._updatePoints(node);
                        if (!cancelEvent.cancel) {
                            tool._disconnect(node);
                            tool._updateConnection(node, cancelEvent.updateSelection);
                        }
                    }
                }
                tool.previousPoint = ej.datavisualization.Diagram.Point(tool.currentPoint.x, tool.currentPoint.y);
                if (!tool._canMoveLabel && node.type != "phase") {
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this._updateSelectionHandle(true);
                    this._renderTooltip(node);
                }
            }
            return true;
        },
        _isUserHandle: function (evt) {
            if (evt.target.parentNode.className.animVal === "userHandle") {
                return true;
            } else {
                return false;
            }
        },
        _isUserHandleActive: function (name) {
            var userHandleActive = false;
            if (this.model.selectedItems.userHandles && this.model.selectedItems.userHandles.length > 0) {
                var i = 0;
                var length = this.model.selectedItems.userHandles.length;
                for (i; i < length; i++) {
                    if (this.model.selectedItems.userHandles[i].name === name) {
                        userHandleActive = true;
                        break;
                    } else
                        userHandleActive = true;
                }
            }
            return userHandleActive;
        },
        _getEventDetail: function (evt) {
            if (ej.browserInfo().name === "msie") {
                if (!this._timeStamp)
                    return 1;
                return ((evt.timeStamp - this._timeStamp) >= 300) ? 1 : 2;
            }
            return evt.originalEvent.detail;
        },
        _raiseMouseEvents: function (node, evt) {
            if (!this._isEditing) {
                if (this.nameTable[this._lastNodeUnderMouse] && (!node || (this._lastNodeUnderMouse != (node._isHeader ? node.parent : node.name)))) {
                    var tooltipDiv = document.getElementById(this.element[0].id + "_mouseovertooltipDiv");
                    if (tooltipDiv) {
                        tooltipDiv.parentNode.removeChild(tooltipDiv);
                    }
                    if (!this.activeTool.inAction) {
                        this._raiseEvent("mouseLeave", { element: this.getNode(this.nameTable[this._lastNodeUnderMouse]) });
                        this._lastNodeUnderMouse = null;
                    }
                    if (this._nodeUnderMouse != null && (!this._nodeUnderMouse.segments) && !(this.activeTool instanceof ej.datavisualization.Diagram.LineTool)) {
                        if (this.activeTool._showPort)
                            this.activeTool._showPort(this._nodeUnderMouse, true);
                    }
                }
                if (node && !this.activeTool.inAction) {
                    if (!this._lastNodeUnderMouse || (this._lastNodeUnderMouse != (node._isHeader ? node.parent : node.name))) {
                        this._lastNodeUnderMouse = node._isHeader ? node.parent : node.name;
                        this._raiseEvent("mouseEnter", { element: this.getNode(this._lastNodeUnderMouse) });
                    }
                }
                if (node) {
                    var args = { element: this.getNode(node) };
                    this._raiseEvent("mouseOver", args);
                    if (args.element && !this.activeTool.inAction) {
                        this._renderMouseOverTooltip(node, evt);
                    }
                    else {
                        this._removeMouseOverTooltip();
                    }
                }
            }
        },
        _renderMouseOverTooltip: function (node, evt) {
            if (ej.datavisualization.Diagram.Util.canShowTooltip(node, this)) {
                var type = this.getObjectType(node);
                var tooltip;
                if (type == "node" || type == "group")
                    var Constraints = ej.datavisualization.Diagram.NodeConstraints;
                else Constraints = ej.datavisualization.Diagram.ConnectorConstraints;
                if (node.constraints & Constraints.InheritTooltip) {
                    tooltip = this.model.tooltip;
                    var modeltooltip = true;
                }
                else tooltip = node.tooltip;
                if (tooltip && (!modeltooltip || this._tooltipTemplateId())) {
                    var x, y, tx, ty;
                    var obj = this._getTooltipPosition(node, tooltip, evt, modeltooltip);
                    x = obj.x; y = obj.y; tx = obj.tx; ty = obj.ty;
                    x = -this._hScrollOffset + x * this._currZoom;
                    y = -this._vScrollOffset + y * this._currZoom;
                    var style = "left:" + x + "px; top:" + y + "px; display: block; position: absolute; pointer-events: none; transform:" + "translate(" + tx + "," + ty + ")";
                    var tooltipDiv = document.getElementById(this.element[0].id + "_mouseovertooltipDiv");
                    if (!tooltipDiv) {
                        tooltipDiv = this._createMouseOverTooltip();
                    }
                    tooltipDiv.style.left = x + "px";
                    tooltipDiv.style.top = y + "px";
                    tooltipDiv.style.transform = "translate(" + tx + " ," + ty + ")";
                    tooltipDiv.style.display = "block";
                    tooltipDiv.style.position = "absolute";
                    if ($.templates) {
                        var templateId = modeltooltip ? this._tooltipTemplateId() : tooltip.templateId;
                        var template = $.templates("#" + templateId).render(node);
                    }
                    $(tooltipDiv).html(template);
                    var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(this);
                    tooltipDiv.style.marginLeft = tooltipDiv.style.marginTop = "0px";
                    var diagramBounds = this.element[0].getBoundingClientRect();
                    var tooltipBounds = tooltipDiv.getBoundingClientRect();
                    var currentZoom = this.model.scrollSettings.currentZoom;
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node, this.activeTool.name == "rotatetool" ? true : false);
                    if ((diagramBounds.left > tooltipBounds.left) || (diagramBounds.right < tooltipBounds.right)) {
                        if ((modeltooltip ? this._tooltipMode() : tooltip.relativeMode) == "mouse" || tooltip.alignment.horizontal == "center") {
                            var side = diagramBounds.left > tooltipBounds.left ? "left" : "right";
                            var alignment = side == "right" ? tooltipBounds.right - diagramBounds.right : diagramBounds.left - tooltipBounds.left;
                            var position = side == "right" ? -alignment - tooltip.margin.right : tooltip.margin.left + alignment;
                        }
                        else {
                            if ((tooltip.alignment.horizontal == "left" || tooltip.alignment.horizontal == "right") && (tooltip.alignment.vertical == "center")) {
                                position = bounds.width * currentZoom + tooltipBounds.width + tooltip.margin.left + tooltip.margin.right;
                                position = tooltip.alignment.horizontal == "left" ? position * 1 : position * (-1);
                            }
                            else {

                                side = tooltip.alignment.horizontal;
                                if (side == "center") side = diagramBounds.left > tooltipBounds.left ? "left" : "right";
                                alignment = side == "right" ? tooltipBounds.right - diagramBounds.right : diagramBounds.left - tooltipBounds.left;
                                position = side == "right" ? -alignment - tooltip.margin.right : tooltip.margin.left + alignment;
                            }
                        }
                        tooltipDiv.style.marginLeft = position + "px";
                    }
                    if ((diagramBounds.bottom < tooltipBounds.bottom) || (diagramBounds.top > tooltipBounds.top)) {
                        if ((modeltooltip ? this._tooltipMode() : tooltip.relativeMode) == "mouse" || tooltip.alignment.vertical == "center") {
                            side = diagramBounds.top > tooltipBounds.top ? "top" : "bottom";
                            alignment = side == "top" ? tooltipBounds.top - diagramBounds.top : tooltipBounds.bottom - diagramBounds.bottom;
                            position = side == "top" ? tooltip.margin.top - alignment : -(alignment + tooltip.margin.bottom);
                        }
                        else {
                            if ((tooltip.alignment.horizontal == "center") && (tooltip.alignment.vertical == "bottom" || tooltip.alignment.vertical == "top")) {
                                position = bounds.height * currentZoom + tooltipBounds.height + (tooltip.margin.bottom + tooltip.margin.top);
                                position = tooltip.alignment.vertical == "bottom" ? position * (-1) : position * 1;
                            }
                            else {
                                alignment = tooltip.alignment.vertical == "top" ?
                                    diagramBounds.top - tooltipBounds.top : diagramBounds.bottom - tooltipBounds.bottom;
                                position = tooltip.alignment.vertical == "top" ? tooltip.margin.top + alignment : alignment - tooltip.margin.bottom;
                            }
                        }
                        tooltipDiv.style.marginTop = position + "px";
                    }
                }
            }
        },
        _getTooltipPosition: function (node, tooltip, evt, model) {
            var bounds = ej.datavisualization.Diagram.Util.bounds(node, false);
            var x, y, tx, ty;
            if ((model ? this._tooltipMode() : tooltip.relativeMode) == "object") {
                switch (model ? this._horizontalTooltipAlignment() : tooltip.alignment.horizontal) {
                    case "left":
                        x = bounds.x;
                        x -= tooltip.margin.left;
                        tx = "-100%";
                        break;
                    case "right":
                        x = bounds.right;
                        x += tooltip.margin.right;
                        tx = "0%";
                        break;
                    case "center":
                        x = bounds.center.x;
                        tx = "-50%";
                        break;
                }
                switch (model ? this._verticalTooltipAlignment() : tooltip.alignment.vertical) {
                    case "top":
                        y = bounds.y;
                        y -= tooltip.margin.top;
                        ty = "-100%";
                        break;
                    case "bottom":
                        y = bounds.bottom;
                        y += tooltip.margin.bottom;
                        ty = "0%";
                        break;
                    case "center":
                        y = bounds.center.y;
                        ty = "-50%";
                        break;
                }
            }
            else if (evt) {
                var position = this._mousePosition(evt);
                x = position.x + tooltip.margin.left; y = position.y + tooltip.margin.top;
            }
            return { x: x, y: y, tx: tx, ty: ty };
        },
        _isHandle: function (evt) {
            var handle = $(evt.target).parent("g.handle");
            if (handle.length > 0) {
                return true;
            }
            return false;
        },
        _findNodeUnderMouse: function (evt, defalt) {
            var node = null;
            var type;
            if (evt.target) {
                var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group")[0];
                var className = evt.target.className;
                var id = evt.target.id.split('_');
                if (id[id.length - 1] == "lblbg") return;
                if (parent) {
                    type = typeof parent.className === "object" ? parent.className.baseVal : parent.className;
                    if (type && (type === "ej-d-node" || type === "ej-d-group" || ej.datavisualization.Diagram.Util.isClassifier(evt))) {
                        node = this._findNode(parent.id);
                        if (!node) node = this._findNode(parent.id.split("_label")[0]);
                        //  node = ej.datavisualization.Diagram.ClassifierHelper.getmoveelement(node,this)
                        if (!node) node = this._findNode(parent.id.split('_parentdiv')[0]);
                        if (node && node._isInternalShape && node.parent && this.nameTable[node.parent] && this.nameTable[node.parent].type == "bpmn")
                            node = this.nameTable[node.parent];
                    } else if (type === "ej-d-connector") {
                        node = this._findConnector(parent.id);
                        if (!node) node = this._findConnector(parent.id.split("_label")[0]);
                    }
                }
                if (!node && evt.target && evt.target.parentNode) {
                    var id = (evt.target.parentNode.id).split("_ej_ports");
                    node = this.findNode(id[0]);
                }
            }
            return node;
        },
        _findConnectableNodeUnderMouse: function (evt) {
            var node = null;
            if (evt && evt.type === "touchmove") {
                var epoint = this._mousePosition(evt);
                var bounds = ej.datavisualization.Diagram.Rectangle(epoint.x, epoint.y, 0, 0);
                var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(this._spatialSearch, bounds);
                for (var i = 0; i < quads.length; i++) {
                    var quad = quads[i];
                    if (quad.objects.length > 0) {
                        for (var j = 0; j < quad.objects.length; j++) {
                            var nd = quad.objects[j];
                            var nodebounds = ej.datavisualization.Diagram.Util.bounds(nd);
                            if (ej.datavisualization.Diagram.Geometry.intersectsRect(bounds, nodebounds)) {
                                if (!nd.segments && nd.visible) {
                                    return nd;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var type;
                var parents = $(evt.target).parents(".ej-d-node,.ej-d-group");
                var parent = parents[0];
                var i = 1;
                while (parent) {
                    type = parent.getAttribute("class");
                    node = this._findNode(parent.getAttribute("id"));
                    if (!node)
                        node = this._findNode(parent.getAttribute("id").split('_parentdiv')[0]);
                    if (node && (ej.datavisualization.Diagram.Util.canConnect(node) || !node.parent)) {
                        parent = null;
                    } else {
                        parent = parents[i];
                        i++;
                    }
                }
                if (node) {
                    if (node.type == "umlclassifier")
                        var connector = this.activeTool.selectedObject;
                    if (connector && connector.sourceNode)
                        var sourceNode = this.nameTable[connector.sourceNode];
                    if (connector && connector.targetNode)
                        var targetNode = this.nameTable[connector.targetNode];
                    if (sourceNode)
                        node = ej.datavisualization.Diagram.ClassifierHelper.EnableorDisableConnection(node, sourceNode, connector, this);
                    if (targetNode)
                        node = ej.datavisualization.Diagram.ClassifierHelper.EnableorDisableConnection(node, targetNode, connector, this);
                }
                if (!node && evt.target && evt.target.parentNode) {
                    var id = (evt.target.parentNode.id).split("_ej_ports");
                    node = this.findNode(id[0]);
                }
            }
            return node;
        },
        _isForeignEvent: function (evt, keyDown) {
            if (evt.originalEvent && evt.originalEvent.target) {
                if (keyDown) {
                    if ((evt.originalEvent.target.localName === "input" && (
                        evt.originalEvent.target.type === "text" || evt.originalEvent.target.type === "password")) ||
                        evt.originalEvent.target.localName === "textarea" && !(this._isEditing && evt.originalEvent.target.id === this.element[0].id + "_editBox"))
                        return true;

                }
                else if (evt.originalEvent.target.localName === "img") {
                    return true;
                }
            }
        },
        _isForeignObject: function (target) {
            var foreignObj = target;
            if (foreignObj) {
                while (foreignObj.parentNode != null) {
                    if (foreignObj.tagName === "foreignObject" || (typeof foreignObj.className == "string" && foreignObj.className.split(' ').indexOf("foreignObject") !== -1)) {
                        return foreignObj;
                    } else {
                        foreignObj = foreignObj.parentNode;
                    }
                }
            }
            return null;
        },
        _altKeyPressed: function (keyModifier) {
            return keyModifier & ej.datavisualization.Diagram.KeyModifiers.Alt;
        },
        _ctrlKeyPressed: function (keyModifier) {
            return keyModifier & ej.datavisualization.Diagram.KeyModifiers.Control;
        },
        _shiftKeyPressed: function (keyModifier) {
            return keyModifier & ej.datavisualization.Diagram.KeyModifiers.Shift;
        },
        _keydown: function (evt) {
            this._isKeyDown = true;
            this._removeMouseOverTooltip();
            var keycode = evt.keyCode ? evt.keyCode : evt.which;
            var ctrlKey = navigator.platform.match("Mac") ? evt.metaKey : evt.ctrlKey;
            var key = evt.key;
            if (!this._isForeignEvent(evt, true)) {
                for (var i in this.model.commandManager.commands) {
                    var command = this.model.commandManager.commands[i];
                    if (command && command.gesture) {
                        if (command.gesture.keyModifiers || command.gesture.key) {
                            if ((!command.gesture.key || (keycode == command.gesture.key || key == command.gesture.key) || (navigator.platform.match("Mac") && key === "Backspace" && i === "delete"))
                                && (!command.gesture.keyModifiers || ((ctrlKey || evt.altKey || evt.shiftKey) &&
                                    (!this._altKeyPressed(command.gesture.keyModifiers) || evt.altKey) &&
                                    (!this._shiftKeyPressed(command.gesture.keyModifiers) || evt.shiftKey) &&
                                    (!this._ctrlKeyPressed(command.gesture.keyModifiers) || ctrlKey)))) {
                                this._currentCommand = i;
                                if (this._currentCommand !== "focusToNextItem" && this._currentCommand !== "focusToPreviousItem" && this._currentCommand !== "selectFocusedItem") {
                                    this._diagramElements = null;
                                    this._focusedElement = null;
                                    ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this._adornerSvg, this._adornerLayer);
                                }
                                if (command.execute && command.canExecute) {
                                    var canExecute = command.canExecute;
                                    if (typeof command.canExecute == "string") canExecute = ej.util.getObject(command.canExecute, window);
                                    if ($.isFunction(canExecute) && canExecute({ model: this.model })) {
                                        var execute = command.execute;
                                        if (typeof command.execute === "string") {
                                            execute = ej.util.getObject(command.execute, window);
                                        }
                                        if ($.isFunction(execute))
                                            execute({ keyDownEventArgs: evt, parameter: command.parameter, model: this.model });
                                    }
                                }
                            }
                        }
                    }
                }
                if (this.activeTool.keydown)
                    this.activeTool.keydown(evt);
            }
            this._isKeyDown = false;
        },
        _keyup: function (evt) {
            var keycode = evt.keyCode ? evt.keyCode : evt.which;
            if (!this._isEditing && (keycode === 37 || keycode === 38 || keycode === 39 || keycode === 40)) {
                if (this._currentState) {
                    //this.addHistoryEntry({ type: "nudge", category: "internal", values: this._currentState, object: this.selectionList[0] });
                }
                delete this._currentState;
                evt.preventDefault();
                this.activeTool.inAction = false;
                this._updateSelectionHandle();
            }
        },
        _registerHistoryEvents: function () {
            this.historyManager.addEventHandler("collectionchanged", $.proxy(this._recordCollectionChanged, this));
            this.historyManager.addEventHandler("positionchanged", $.proxy(this._recordPinPointChanged, this));
            this.historyManager.addEventHandler("sizechanged", $.proxy(this._recordResizeChanged, this));
            this.historyManager.addEventHandler("rotationchanged", $.proxy(this._recordRotationChanged, this));
            this.historyManager.addEventHandler("endpointchanged", $.proxy(this._recordEndPointChanged, this));
            this.historyManager.addEventHandler("labelchanged", $.proxy(this._recordLabelChanged, this));
            this.historyManager.addEventHandler("groupingchanged", $.proxy(this._recordGroupChanged, this));
        },
        _svgdrop: function (evt, ui) {
            if (this._selectedSymbol && ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var args = {};
                var e = evt.originalEvent;
                if (e.preventDefault)
                    e.preventDefault();
                else
                    e.returnValue = false;
                var scale = this._currZoom;
                var offset = $("#" + this.element[0].id).offset();
                var coor = this._isTouchEvent(evt);
                if (!coor.pageX && !evt.pageX) {
                    if (evt.originalEvent && evt.originalEvent.changedTouches) {
                        coor = evt.originalEvent.changedTouches[0];
                    }
                    else if (evt && evt.changedTouches) {
                        coor = evt.changedTouches[0];
                    }
                }
                var x = (coor ? coor.pageX : evt.pageX) + this._hScrollOffset - offset.left;
                var y = (coor ? coor.pageY : evt.pageY) + this._vScrollOffset - offset.top;
                var paletteItem = $.extend(true, {}, this._selectedSymbol);
                var symbolPaletteId = ui.helper[0].getAttribute("paletteId");
                var symbolPalette = $("#" + symbolPaletteId).ejSymbolPalette("instance");
                if (symbolPaletteId) {
                    this._selectedSymbol = null;
                    paletteItem.name += ej.datavisualization.Diagram.Util.randomId();
                    if (!paletteItem.isPhase && paletteItem.segments) {
                        if (paletteItem.segments) {
                            ej.datavisualization.Diagram.Util._translateLine(paletteItem, x, y);
                        }
                        paletteItem = this.getNode(paletteItem);
                    } else if (!paletteItem.isPhase) {
                        var palNameTable = $.extend(true, {}, symbolPalette.nameTable);
                        paletteItem.offsetX = x / scale;
                        paletteItem.offsetY = y / scale;
                        if (paletteItem._type === "group") {
                            var children = this._getChildren(paletteItem.children);
                            for (var j = 0; j < children.length; j++) {
                                var newObj = $.extend(true, {}, palNameTable[children[j]]);
                                newObj.parent = paletteItem.name;
                                newObj.name = paletteItem.name + newObj.name;
                                children[j] = newObj.name;
                                this.nameTable[newObj.name] = newObj;
                                this.nodes().push(newObj);
                                this._nodes = $.extend(true, [], this.nodes());
                                this._updateQuad(this.nameTable[newObj.name]);
                            }
                            paletteItem.height = paletteItem.width = 0;
                            this._updateChildBounds(paletteItem, this.nameTable);
                        }
                        if (paletteItem._type === "group")
                            paletteItem = this._getNewGroup(paletteItem);
                        else if (paletteItem.segments)
                            paletteItem = this._getNewConnector(paletteItem);
                        else if (!(paletteItem.isPhase || paletteItem.type === "phase"))
                            paletteItem = this._getNewNode(paletteItem);
                    }
                    if (paletteItem && paletteItem.isLane) {
                        this._cloneGroupNode(paletteItem, ej.datavisualization.Diagram.Util.randomId());
                        paletteItem = ej.datavisualization.Diagram.SwimLaneHelper._createDiagramLane(paletteItem, this.nameTable)
                        paletteItem = this._initLaneContaier(paletteItem);
                    }
                    args = { element: paletteItem, cancel: false };
                    this._raiseDropEvent(args);

                    if (paletteItem && paletteItem.isLane) {
                        var header = paletteItem.children[0];
                        var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(paletteItem, this, null, null, header);
                        if (swimlane && swimlane.isSwimlane)
                            paletteItem = swimlane;
                    }
                    if (!paletteItem.isPhase) {
                        if (!args.cancel) {
                            this.add(paletteItem);
                        }
                        paletteItem = this.selectionList[0];
                        this.scrollToNode(paletteItem);
                        if (paletteItem.labels.length > 0 && paletteItem.labels[0].mode === "edit") {
                            this._isEditing = true;
                            this.startLabelEdit(paletteItem, paletteItem.labels[0]);
                        } else
                            this.element[0].focus();
                    }
                }
            } else {
                var node = null;
                node = this._findNodeUnderMouse(evt);
                args = { element: ui.helper, e: evt, draggable: ui.draggable, targetNode: node };
                this._raiseDropEvent(args);
            }
        },
        _isTouchEvent: function (evt) {
            if (evt.type == "touchmove" || evt.type == "touchstart" || evt.type == "touchend") {
                return evt.originalEvent ? evt.originalEvent.changedTouches[0] : evt.changedTouches[0];
            }
            return evt;
        },
        _raiseDropEvent: function (args) {
            args.source = this._symbolPalette ? this._symbolPalette : null;
            args.objectType = args.source ? ej.datavisualization.Diagram.ObjectTypes.Palette : ej.datavisualization.Diagram.ObjectTypes.Diagram;
            this._raiseEvent("drop", args);
            this._symbolPalette = null;
        },
        //#endregion
        //#region Undo Redo
        _recordCollectionChanged: function (args, orgObj) {
            this._isUndo = true;
            this._isInsert = true;
            var i;
            var changeType = args.changeType;
            if (args.isUndo) {
                if (args.changeType == "insert")
                    changeType = "remove";
                else
                    changeType = "insert";
            }
            this._clearSelection(changeType == "insert" ? false : true);
            if (changeType == "insert") {
                if (!args.object.container && !args.object._isMultipleLaneDelete) {
                    if (args.object.type != "pseudoGroup") {
                        if (!args.object.segments) {
                            var port = null;
                            if (args.object.inEdges && args.object.inEdges.length > 0) {
                                for (i = 0; i < args.object.inEdges.length; i++) {
                                    if (this.nameTable[args.object.inEdges[i]])
                                        this.nameTable[args.object.inEdges[i]].targetNode = args.object.name;
                                    if (args.targetPorts)
                                        port = args.targetPorts[args.object.inEdges[i]];
                                    if (port)
                                        if (this.nameTable[args.object.inEdges[i]])
                                            this.nameTable[args.object.inEdges[i]].targetPort = port;
                                }
                            }
                            if (args.object.outEdges && args.object.outEdges.length > 0) {
                                for (i = 0; i < args.object.outEdges.length; i++) {
                                    if (this.nameTable[args.object.outEdges[i]])
                                        this.nameTable[args.object.outEdges[i]].sourceNode = args.object.name;
                                    if (args.sourcePorts)
                                        port = args.sourcePorts[args.object.outEdges[i]];
                                    if (port)
                                        if (this.nameTable[args.object.outEdges[i]])
                                            this.nameTable[args.object.outEdges[i]].sourcePort = port;
                                }
                            }
                        }
                        if (args.object._type === "group")
                            this._addChildren(args.object, args.childTable);
                        if (args.object.isSwimlane)
                            args.object = ej.datavisualization.Diagram.SwimLaneHelper._initSwimLane(args.object, this)
                        this.add(args.object, args);
                        if (args.object.parent) {
                            var pNode = this.nameTable[args.object.parent];
                        }
                        if (args.object._type === "group") {
                            this._addConnector(args.object, args);
                            this._addGroupConnector(args.object, args);
                        }
                        else {
                            this._addConnector(args.object, args);
                        }
                    } else {
                        delete this.nameTable["multipleSelection"];
                        var node, j, objectType, childConnectors = [];
                        var pseudoGroup = ej.datavisualization.Diagram.Group({ "name": "multipleSelection", type: "pseudoGroup" });

                        for (i = 0; i < args.object.children.length; i++) {
                            child = typeof args.object.children[i] === "object" ? args.object.children[i] : args.childTable[args.object.children[i]];
                            if (child) {
                                objectType = this.getObjectType(child);
                                if (objectType === "group" && !child.isSwimlane)
                                    this._addChildren(child, args.childTable);
                                if (child.isSwimlane) {
                                    this._swimlanePaste = true;
                                    this._isUndo = true;
                                    var child = this._pasteSwimlaneObj(child, args);
                                    delete this._swimlanePaste;
                                }
                                else if (objectType != "connector")
                                    this.add(child, args);
                                else
                                    childConnectors.push(child);
                                if (child)
                                    pseudoGroup.children.push(child.name);
                            }
                        }
                        for (i = 0; i < childConnectors.length; i++) {
                            this.add(childConnectors[i], args);
                            //  pseudoGroup.children.push(childConnectors[i].name);
                        }
                        this._addGroupConnector(args.object, args);
                        for (i = 0; i < pseudoGroup.children.length; i++) {
                            node = this.nameTable[this._getChild(pseudoGroup.children[i])];
                            if (node && !node.segments) {
                                if (node.inEdges.length > 0) {
                                    for (j = 0; j < node.inEdges.length; j++) {
                                        if (!this._isUndo) {
                                            this.nameTable[node.inEdges[j]].targetNode = node.name;
                                        }
                                        else {
                                            args.childTable[node.inEdges[j]].targetNode = node.name;
                                        }
                                    }
                                }
                                if (node.outEdges.length > 0) {
                                    for (j = 0; j < node.outEdges.length; j++) {
                                        if (!this._isUndo) {
                                            this.nameTable[node.outEdges[j]].sourceNode = node.name;
                                        }
                                        else {
                                            args.childTable[node.outEdges[j]].sourceNode = node.name;
                                        }
                                    }
                                }
                            }
                        }
                        this._clearSelection();
                        this.nodes().push(pseudoGroup);
                        this._nodes = $.extend(true, [], this.nodes());
                        pseudoGroup.offsetX = args.object.offsetX;
                        pseudoGroup.offsetY = args.object.offsetY;
                        pseudoGroup.height = args.object.height;
                        pseudoGroup.width = args.object.width;
                        pseudoGroup.rotateAngle = args.object.rotateAngle;
                        this.nameTable[pseudoGroup.name] = pseudoGroup;
                        this.addSelection(pseudoGroup, true);
                    }
                } else {
                    var child, laneChild = [], laneCollection;
                    for (var i in args.childTable) {
                        child = args.childTable[i];
                        this.nameTable[i] = child;
                    }
                    node = args.object;
                    if (node.isSwimlane) {
                        this.nameTable[node.name] = node;
                        node.width = 0;
                        node.height = 0;
                        this._swimlanePaste = true;
                        this._multipleAction = true;
                        this._eventCause["nodeCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange;
                        this._pasteSwimlaneObj(node);
                        delete this._swimlanePaste;
                        this._eventCause["connectorCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange;
                        this._addAssiciatedChildConnectors(node);
                        delete this._multipleAction;
                        this._clearSelection(true);
                    } else if ((node._type == "pseudoGroup") || (node.isLane)) {
                        if (node._type == "pseudoGroup") {
                            for (i = 0; i < node.children.length; i++) {
                                child = node.children[i];
                                laneChild[i] = args.childTable[child.name];
                                if (child.isLane) {
                                    if (this.nameTable[child.name]) delete this.nameTable[child.name];
                                }
                            }
                            laneCollection = this._sortByLaneIndex(laneChild);
                            for (i = 0; i < laneCollection.length; i++) {
                                child = laneCollection[i];
                                if (child.isLane)
                                    this._recordCollectionChangedAddLane(child, child._laneIndex);
                                else {
                                    this.add(child, args);
                                    this._clearSelection(true);
                                }
                            }
                        }
                        else
                            this._recordCollectionChangedAddLane(args.object, args.index)
                    }
                    else {
                        this.add(node);
                        this._addConnector(node, args);
                    }
                }
            }
            else if (changeType == "remove") {
                if (args.object.type != "pseudoGroup" && !args.object.isLane) {
                    this._removeAdjacentConnections(args.object, args);
                    if (args.object.isSwimlane || args.object.annotation)
                        this._remove(this.nameTable[args.object.name]);
                    else
                        this._remove(args.object);
                    return true;
                }
                else if (args.object.isLane) {
                    var obj = args.object;
                    if (!args.index && args.index != 0) {
                        var index = null;
                        if (args.object.isLane && orgObj) {
                            orgObj.index = this._getRemoveIndex(args.object, true);
                        }
                    }
                    this._remove(obj);
                }
                else {
                    for (i = 0; i < args.object.children.length; i++) {
                        this._remove(this.nameTable[this._getChild(args.object.children[i])]);
                    }
                }
            }
            if (!this._groupUndo)
                this._isUndo = false;
            this._isInsert = false;
            this.tools['move']._isLane = false;
        },

        _recordCollectionChangedAddLane: function (child, index) {
            var swimlane, parentStack;
            if (child && child.isLane && child.parent) {
                if (child && child.parent)
                    parentStack = this.nameTable[child.parent];
                if (parentStack) {
                    if (parentStack)
                        swimlane = this.nameTable[parentStack.parent];
                }
                if (swimlane) {
                    this.activeTool.selectedObject = child;
                    this._eventCause["nodeCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange;
                    ej.datavisualization.Diagram.canvasHelper._addNewLane(this, child, swimlane, true, index);
                    this._eventCause["connectorCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange;
                    this._addAssiciatedChildConnectors(child);
                    this._clearSelection(true);
                }
            }
        },

        _addAssiciatedChildConnectors: function (group) {
            var children = this._getChildren(group.children);
            if (children && children.length > 0) {
                for (var i = 0, len = children.length; i < len; i++) {
                    var child = this.nameTable[children[i]];
                    if (child) {
                        this._addConnector(child);
                        if (child.type === "group") {
                            this._addAssiciatedChildConnectors(child);
                        }
                    }
                }
            }
        },
        _updateRecordPinPoint: function (node, childTable, isMultipleSelection) {
            var object, i, item, objNode;
            // this._clearSelection();
            if (node.type == "pseudoGroup") {
                var undoObj = node;
                var children = this._getChildren(node.children);
                for (i = 0; i < children.length; i++) {
                    item = this.nameTable[children[i]];
                    objNode = childTable[children[i]];
                    if (objNode) {
                        if (!item.segments) {
                            this._propertyChangeValues(item, objNode);
                            this._translate(item, objNode.offsetX - item.offsetX, objNode.offsetY - item.offsetY, this.nameTable);
                        } else {
                            var objLine = childTable[item.name];
                            item.sourcePoint = objLine.sourcePoint;
                            item.targetPoint = objLine.targetPoint;
                            item.segments = jQuery.extend(true, item.segments, objLine.segments);
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(item, this);
                    }
                }
                if (this.selectionList[0]) {
                    if (this.selectionList[0].name === undoObj.name) {
                        this.selectionList[0].offsetX = undoObj.offsetX;
                        this.selectionList[0].offsetY = undoObj.offsetY;
                    }
                }
                ej.datavisualization.Diagram.SvgContext.updateSelector(undoObj, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
            } else {
                if (node.segments) {
                    if (isMultipleSelection) {
                        object = childTable[node.name];
                        node.sourcePoint = object.sourcePoint;
                        node.targetPoint = object.targetPoint;
                        node.segments = $.extend(true, [], object.segments);
                        ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    } else {
                        this._clearSelection(true);
                        object = this._findConnector(node.name);
                        var obj;

                        if (node.targetNode) {
                            obj = this.nameTable[node.targetNode];
                            ej.datavisualization.Diagram.Util.removeItem(obj.inEdges, node);
                        }
                        if (node.sourceNode) {
                            obj = this.nameTable[node.sourceNode];
                            ej.datavisualization.Diagram.Util.removeItem(obj.outEdges, node);
                        }
                        if (node.targetNode) {
                            obj = this.nameTable[node.targetNode];
                            obj.inEdges.push(node.name);
                        }
                        if (node.sourceNode) {
                            obj = this.nameTable[node.sourceNode];
                            obj.outEdges.push(node.name);
                        }
                        this._propertyChangeConnectorValues(object, node);
                        object.targetNode = node.targetNode;
                        object.sourceNode = node.sourceNode;
                        object.targetPort = node.targetPort;
                        object.sourcePort = node.sourcePort;
                        object.sourcePoint = node.sourcePoint;
                        object.targetPoint = node.targetPoint;
                        object.segments = $.extend(true, [], node.segments);
                        ej.datavisualization.Diagram.DiagramContext.update(object, this);
                        ej.datavisualization.Diagram.SvgContext.updateSelector(node, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
                        this.addSelection(node, true);
                    }
                } else {
                    if (isMultipleSelection) {
                        object = childTable[node.name];
                        this._translate(node, object.offsetX - node.offsetX, object.offsetY - node.offsetY, childTable);
                        ej.datavisualization.Diagram.DiagramContext.update(object, this);
                    } else {
                        object = this._findNode(node.name);
                        this._clearSelection(true);
                        this._propertyChangeValues(object, node);
                        if (node.parent)
                            parent = this.nameTable[node.parent];
                        if (!parent) {
                            parent = this.nameTable[object.parent];
                            var update = true;
                        }
                        if (parent && parent.container) {
                            this._raiseGroupChangeEvent(node, object.parent ? this.nameTable[object.parent] : null, this.nameTable[node.parent], ej.datavisualization.Diagram.GroupChangeCause.HistoryChange);
                            ej.datavisualization.Diagram.canvasHelper._undoDragNode(this, this.nameTable[node.name], node);
                            if (update) {
                                var swimlane = this.nameTable[parent.parent.split("laneStack")[0]];
                                if (swimlane) {
                                    ej.datavisualization.Diagram.DiagramContext.update(swimlane, this);
                                }
                            }
                        }
                        else {
                            this._translate(object, node.offsetX - object.offsetX, node.offsetY - object.offsetY, this.nameTable);
                            if (node.parent) {
                                ej.datavisualization.Diagram.Util._updateGroupBounds(this.nameTable[object.parent], this);
                            }
                            if (object.parent) {
                                var parent = this.nameTable[object.parent];
                                if (parent && object.parent && node.parent == "") {
                                    ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, object.name);
                                    this._delete(object);
                                    if (node.type === "group" || node.type === "bpmn")
                                        this._initGroupNode(node, childTable);
                                    this.add(node);
                                }
                            }
                            if (node.parent) {
                                var parent = this.nameTable[node.parent];
                                if (node.parent && object.parent == "") {
                                    this._delete(object);
                                    node = $.extend(true, {}, node);
                                    if (node.type === "group" || node.type === "bpmn")
                                        this._initGroupNode(node, childTable);
                                    this.add(node);
                                }
                            }
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(object, this);
                        ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, object);
                        this.addSelection(object, true);
                    }
                }
            }
        },

        _propertyChangeValues: function (item, objNode) {
            var propertyNamex = (item.offsetX === objNode.offsetX) ? "" : "offsetX";
            var propertyNamey = (item.offsetY === objNode.offsetY) ? "" : "offsetY";
            if (propertyNamex === "offsetX") {
                var resource = { element: objNode, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: propertyNamex, oldValue: item.offsetX, newValue: objNode.offsetX };
                this._raisePropertyChange(resource);
            }
            if (propertyNamey === "offsetY") {
                resource = { element: objNode, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: propertyNamey, oldValue: item.offsetY, newValue: objNode.offsetY };
                this._raisePropertyChange(resource);
            }
        },
        _propertyChangeResizeValues: function (item, childObj) {
            var propertyName = (childObj.width === item.width) ? "" : "width";
            var propertyName1 = (childObj.height === item.height) ? "" : "height";
            if (propertyName === "width") {
                var resource = { element: item, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: propertyName, oldValue: item.width, newValue: childObj.width };
                this._raisePropertyChange(resource);
            }
            if (propertyName1 === "height") {
                resource = { element: item, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: propertyName1, oldValue: item.height, newValue: childObj.height };
                this._raisePropertyChange(resource);
            }
        },
        _propertyChangeConnectorValues: function (connector, currentObject) {
            var propertyName = (connector.sourcePoint.x === currentObject.sourcePoint.x || connector.sourcePoint.y === currentObject.sourcePoint.y) ? "" : "sourcePoint";
            var propertyName1 = (connector.targetPoint.x === currentObject.targetPoint.x || connector.targetPoint.y === currentObject.targetPoint.y) ? "" : "targetPoint";
            if (propertyName === "sourcePoint") {
                var resource = { element: currentObject, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: propertyName, oldValue: connector.sourcePoint, newValue: currentObject.sourcePoint };
                this._raisePropertyChange(resource);
            }
            if (propertyName1 === "targetPoint") {
                resource = { element: currentObject, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: propertyName1, oldValue: connector.targetPoint, newValue: currentObject.targetPoint };
                this._raisePropertyChange(resource);
            }
        },

        _renderNodeOnLane: function (group, parent) {
            var view, panel;
            var diagram = this;
            diagram._views.forEach(function (viewid) {
                var isOverView
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                parent = view.svg.getElementById(group.parent);
                if (view.type == "overview") {
                    isOverView = true;
                }
                if (group._type === "group")
                    view.context.renderGroup(group, panel, parent || view.diagramLayer, diagram.nameTable, diagram, null, true);
                else if (diagram.getObjectType(group) === "node")
                    view.context.renderNode(group, panel, parent || view.diagramLayer);
            });
        },

        _updateUndoObject: function (node, object) {
            if (object.parent)
                var parent = this.nameTable[object.parent];
            if (parent && this._collectionContains(object.name, parent.children)) {
                ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, object.name);
                if (node.parent)
                    var newParent = this.nameTable[node.parent];
                if (newParent && newParent.children && !this._collectionContains(object.name, newParent.children)) {
                    newParent.children.push(node.name);
                    this.nameTable[node.name].parent = newParent.name;
                    if (newParent.isLane) {
                        var moveTool = this.tools["move"];
                        moveTool._updateMargin(object, newParent);
                    }
                }
            }
            else {
                if (node.parent) {
                    var parent = this.nameTable[node.parent];
                }
            }
        },
        _collectionContains: function (name, coll) {
            for (var i = 0; i < coll.length; i++) {
                if (typeof (coll[i]) === "string" && coll[i] === name) {
                    return true;
                }
                else if (coll[i].name === name) {
                    return true;
                }
            }
        },

        _recordPinPointChanged: function (args) {
            var node = args.object.node;
            var childTable = args.object.childTable;
            if (node || node.isSwimlane)
                this._updateRecordPinPoint(node, childTable);
        },

        _updateRecordRotation: function (object, childTable) {
            var node, i, item, objNodeChild;
            if (object.type == "pseudoGroup") {
                this._clearSelection(true);
                this.nameTable[object.name] = object;
                node = this.nameTable[object.name];
                var children = object.children;
                for (i = 0; i < children.length; i++) {
                    item = this.nameTable[this._getChild(children[i])];
                    objNodeChild = childTable[children[i]];
                    if (item) {
                        if (!item.segments) {
                            if (objNodeChild) {
                                this._translate(item, objNodeChild.offsetX - item.offsetX, objNodeChild.offsetY - item.offsetY, this.nameTable);
                                this._comparePropertyValues(item, "rotateAngle", { rotateAngle: objNodeChild.rotateAngle });
                                this._rotate(item, objNodeChild.rotateAngle - item.rotateAngle, this.nameTable);
                            }
                        } else {
                            var objLine = childTable[item.name];
                            item.sourcePoint = objLine.sourcePoint;
                            item.targetPoint = objLine.targetPoint;
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(item, this);
                    }
                }
                if (node) {
                    var newangle = object.rotateAngle - node.rotateAngle;
                    node.rotateAngle += newangle;
                    if (this.selectionList[0])
                        this.selectionList[0].rotateAngle = node.rotateAngle;
                }
                this.nameTable[object.name] = object;
                this.addSelection(object, true);
            }
            else {
                var parent = null;
                if (object.parent) {
                    parent = this.nameTable[object.parent];
                }
                if (parent && parent.container) {
                    var node = this._findNode(object.name);
                    ej.datavisualization.Diagram.canvasHelper._undoRotateNode(this, node, object);
                }
                else if (object) {
                    this._clearSelection(true);
                    node = this._findNode(object.name);
                    this._comparePropertyValues(node, "rotateAngle", { rotateAngle: object.rotateAngle });
                    this._rotate(node, object.rotateAngle - node.rotateAngle, this.nameTable);
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this.addSelection(node, true);
                }
            }
        },

        _recordSizeChanged: function (args, entryItem) {
            var node = args.object.node;
            var childTable = args.object.childTable;
            //  if (!node.container)
            this._updateRecordSize(node, childTable, entryItem);
        },

        _updateRecordSize: function (object, childTable, args) {
            var node, i, childObj;
            this._clearSelection(true);
            if ((object._type === "group" || object.type === "pseudoGroup") && !(object.isLane || object.isSwimlane || object.type === "bpmn")) {
                if (object.type == "pseudoGroup")
                    this.nameTable[object.name] = object;
                node = this._findNode(object.name);
                var nodeChildren = this._getChildren(node.children);
                var objChildren = this._getChildren(object.children);
                for (i = 0; nodeChildren && i < nodeChildren.length; i++) {
                    var item = this.nameTable[objChildren[i]];
                    childObj = childTable[objChildren[i]];
                    if (childObj) {
                        if (!item.segments) {
                            this._propertyChangeResizeValues(item, childObj);
                            this._translate(item, childObj.offsetX - item.offsetX, childObj.offsetY - item.offsetY, this.nameTable);
                            this.scale(item, (childObj.width / item.width), (childObj.height / item.height), ej.datavisualization.Diagram.Point(item.offsetX, item.offsetY), this.nameTable);
                            //ej.datavisualization.Diagram.DiagramContext.update(item, this);
                        } else {
                            var kk = childTable[item.name];
                            item.sourcePoint = kk.sourcePoint;
                            item.targetPoint = kk.targetPoint;
                            item.segments = $.extend(true, [], kk.segments);;
                            //ej.datavisualization.Diagram.DiagramContext.update(item, this);
                        }
                    }
                }
                //if (node.name === object.name) {
                var parent = null;
                if (object.parent) {
                    parent = this.nameTable[object.parent];
                }
                if (parent && parent.container) {
                    node = this._findNode(object.name);
                    ej.datavisualization.Diagram.canvasHelper._undoResizeNode(this, node, object);
                }
                else {
                    node.offsetX = object.offsetX;
                    node.offsetY = object.offsetY;
                    node.width = object.width;
                    node.height = object.height;
                    if (!(this.activeTool.name == "resize" && this.activeTool.inAction && this.selectionList[0].type != "pseudoGroup" && this.selectionList[0].type != "group"))
                        this._updateAssociatedConnectorEnds(node, this.nameTable);

                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this.addSelection(node, true);
                }
            }
            else if (object.isLane || object.isSwimlane) {
                node = this._findNode(object.name);
                ej.datavisualization.Diagram.canvasHelper._undoResizeLane(this, object, args);
            }
            else if (object.type == "bpmn" && object.container) {
                node = this._findNode(object.name);
                ej.datavisualization.Diagram.canvasHelper._undoResizeNode(this, node, object);
            }
            else {
                var parent = null;
                if (object.parent) {
                    parent = this.nameTable[object.parent];
                }
                if (parent && parent.container) {
                    node = this._findNode(object.name);
                    ej.datavisualization.Diagram.canvasHelper._undoResizeNode(this, node, object);
                }
                else if (!object.segments) {
                    node = this._findNode(object.name);
                    this._propertyChangeResizeValues(node, object);
                    this._translate(node, object.offsetX - node.offsetX, object.offsetY - node.offsetY, this.nameTable);
                    this.scale(node, object.width / node.width, object.height / node.height, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), this.nameTable);
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this.addSelection(node, true);
                }
                else { }
            }

        },

        _recordRotationChanged: function (args) {
            var node = args.object.node;
            var childTable = args.object.childTable;
            //  if (!node.container)
            this._updateRecordRotation(node, childTable);
        },

        _recordEndPointChanged: function (args) {
            this.clearSelection(true);
            var connector, currentObject, previousObject, obj;
            if (args._isUndo) {
                connector = currentObject = args.undoObject;
                previousObject = args.redoObject;
            }
            else {
                connector = currentObject = args.redoObject;
                previousObject = args.undoObject;
            }
            if (connector.parent) {
                connector = this._findChildren(this.nameTable[connector.parent], connector.name);
            }
            else
                connector = this._findConnector(connector.name);

            if (previousObject.targetNode) {
                obj = this.nameTable[previousObject.targetNode];
                ej.datavisualization.Diagram.Util.removeItem(obj.inEdges, previousObject.name);
            }
            if (previousObject.sourceNode) {
                obj = this.nameTable[previousObject.sourceNode];
                ej.datavisualization.Diagram.Util.removeItem(obj.outEdges, previousObject.name);
            }
            if (currentObject.targetNode) {
                obj = this.nameTable[currentObject.targetNode];
                obj.inEdges.push(currentObject.name);
            }
            if (currentObject.sourceNode) {
                obj = this.nameTable[currentObject.sourceNode];
                obj.outEdges.push(currentObject.name);
            }
            this._propertyChangeConnectorValues(connector, currentObject);
            this._comparePropertyValues(connector, "targetNode", { targetNode: currentObject.targetNode });
            connector.targetNode = currentObject.targetNode;
            this._comparePropertyValues(connector, "sourceNode", { sourceNode: currentObject.sourceNode });
            connector.sourceNode = currentObject.sourceNode;
            this._comparePropertyValues(connector, "targetPort", { targetPort: currentObject.targetPort });
            if (args.removePortType == "targetpoint" || args.removePortType == "sourcepoint") {
                var connectedNode = null;
                if (args.removePortType == "targetpoint")
                    connectedNode = this._findNode(args.undoObject.targetNode);
                else
                    connectedNode = this._findNode(args.undoObject.sourceNode);
                var connectedPort = this._findPort(connectedNode, args.removedPort.name);
                if (connectedNode._ports) {
                    if (this._UndoRedo)
                        connectedNode._ports.push(args.removedPort);
                    else {
                        var idx = connectedNode._ports.indexOf(args.removedPort);
                        connectedNode._ports.splice(idx, 1);
                    }
                }
            }
            connector.targetPort = currentObject.targetPort;
            this._comparePropertyValues(connector, "sourcePort", { sourcePort: currentObject.sourcePort });
            connector.sourcePort = currentObject.sourcePort;
            this._comparePropertyValues(connector, "sourcePoint", { sourcePoint: currentObject.sourcePoint });
            connector.sourcePoint = currentObject.sourcePoint;
            this._comparePropertyValues(connector, "targetPoint", { targetPoint: currentObject.targetPoint });
            connector.targetPoint = currentObject.targetPoint;
            connector.segments = $.extend(true, [], currentObject.segments);
            this._updateEdges(connector);
            this._dock(connector, this.nameTable);
            ej.datavisualization.Diagram.Util._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort, this);
            ej.datavisualization.Diagram.DiagramContext._refreshSegments(connector, this);
            ej.datavisualization.Diagram.Util.updateBridging(connector, this);
            ej.datavisualization.Diagram.DiagramContext.update(connector, this);
            this._updateConnectorBridging(connector);
            this._addSelection(connector, this._selectionContains(connector) ? true : false);
            if (this.selectionList[0])
                ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.selectionList[0], this._adornerSvg, this._currZoom);
            ej.datavisualization.Diagram.SvgContext.updateSelector(connector, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
        },
        _recordLabelPositionChanged: function (entryItem) {
            var label = entryItem.activeLabel, node, obj;
            if (label) {
                node = entryItem.redoObject ? entryItem.redoObject.node : null;
                if (entryItem.undo)
                    node = entryItem.undoObject ? entryItem.undoObject.node : null;
                if (node) {
                    obj = this._findLabel(node, label.name);
                    this.updateLabel(node.name, label, { margin: obj.margin, offset: obj.offset, segmentOffset: obj.segmentOffset, width: obj.width, height: obj.height, rotateAngle: obj.rotateAngle });
                }
            }
        },
        _recordPortPositionChanged: function (entryItem) {
            var port = entryItem.activePort, node, obj;
            if (port) {
                node = entryItem.redoObject ? entryItem.redoObject.node : null;
                if (entryItem.undo)
                    node = entryItem.undoObject ? entryItem.undoObject.node : null;
                if (node) {
                    obj = this._findPort(node, port.name);
                    this.updatePort(node.name, port, { offset: obj.offset });
                }
            }
        },
        _recordLabelChanged: function (args) {
            var node = this.nameTable[args.object.name];
            this._comparePropertyValues(node.labels[args.index ? args.index : 0], "text", { text: args.label });
            if (args.object.type === "text") {
                node.textBlock.text = args.label;
                ej.datavisualization.Diagram.DiagramContext.updateTextBlock(node, node.textBlock, this);
            } else {
                if (node.type == "umlclassifier") {
                    this._clearSelection(true);
                    args.label = ej.datavisualization.Diagram.ClassifierHelper.getEditboxValue(args.label, node, this);
                    node = ej.datavisualization.Diagram.ClassifierHelper.getClassifierNodeDimension(node, this);
                    node.labels[args.index].text = "";
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                    this.addSelection(node, true);
                }
                else if (node.shape && node.shape.type == "umlclassifier") {
                    node = ej.datavisualization.Diagram.ClassifierHelper.getUMLConnectorValue(node, args.label, node.labels[args.index]);
                    ej.datavisualization.Diagram.DiagramContext.update(node, this);
                }
                else {
                    if (node.labels[args.index]) {
                        node.labels[args.index].text = args.label;
                        ej.datavisualization.Diagram.DiagramContext.updateLabel(node, node.labels[args.index], this);
                    }
                    else {
                        node.labels[args.index] = ej.datavisualization.Diagram.Label({ text: args.label, _parent: node.name });
                        ej.datavisualization.Diagram.DiagramContext.addNodeLabel(node, node.labels[args.index], null, this);
                    }
                }
            }
        },
        labelcollectionchanged: function (args) {
            var node = this.nameTable[args.shape.name];
            var prtyLabels = node.labels;
            prtyLabels.slice(0);
            if (args.isLabelRemove) {
                if (args.labels && args.labels.length > 0) {
                    var labels = args.labels.slice();
                    var index, label;
                    for (var i = 0; i < labels.length; i++) {
                        index = labels[i].index;
                        label = labels[i].label;
                        if (index != undefined && label) {
                            if (args.isUndo)
                                this.insertLabel(node.name, label, index);
                            else
                                this.removeLabels(node.name, [label]);

                        }
                    }
                }
            }
            else {
                if (args.isUndo) {
                    this.removeLabels(node.name, [args.label]);
                }
                else {
                    this.addLabel(node.name, args.label);
                }
                this._raisePropertyChange({ element: node, cause: ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "labels", oldValue: prtyLabels, newValue: node.labels });
            }

        },
        _recordGroupChanged: function (args) {
            var actionType = args.actionType;
            if (args.isUndo) {
                if (args.actionType === "group")
                    actionType = "ungroup";
                if (args.actionType === "ungroup")
                    actionType = "group";
            }
            this._clearSelection(actionType == "group" ? true : false);
            var selectionList = this._getChildren(args.object.children);
            if (actionType === "group") {
                var group = new ej.datavisualization.Diagram.Group(args.object);
                group.children = [];
                for (i = 0; i < selectionList.length; i++) {
                    var childNode = this.nameTable[selectionList[i]];
                    group.children.push(childNode);
                    ej.datavisualization.Diagram.Util.removeItem(this.nodes(), childNode);
                    if (childNode.parent)
                        oldParent = this.nameTable[childNode.parent];
                    childNode.parent = group.name;
                    var groupElement = this._svg.document.getElementById(selectionList[i]);
                    if (groupElement)
                        groupElement.parentNode.removeChild(groupElement);
                    if (childNode.parent)
                        newParent = this.nameTable[childNode.parent];
                    this._raiseGroupChangeEvent(childNode, oldParent, newParent, "group");
                }
                //group.name = args.object.name;
                this._eventCause["nodeCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange;
                this.add(group);
                this._addSelection(group);
            }
            else {
                var i, node, oldParent, newParent;
                node = args.object;
                var groupElement = this._svg.document.getElementById(node.name);
                if (groupElement)
                    groupElement.parentNode.removeChild(groupElement);
                var nodeChildren = this._getChildren(node.children);
                for (i = 0; i < nodeChildren.length; i++) {
                    var childNode = this.nameTable[nodeChildren[i]];
                    if (childNode.parent)
                        oldParent = this.nameTable[childNode.parent];
                    childNode.parent = "";
                    this._isUndo = true;
                    if (!childNode.segments) {
                        if (childNode._type == "group")
                            ej.datavisualization.Diagram.DiagramContext.renderGroup(childNode, this);
                        else
                            ej.datavisualization.Diagram.DiagramContext.renderNode(childNode, this);
                        if (this.nodes().indexOf(childNode) === -1) {
                            this.nodes().push(childNode);
                            this._nodes = $.extend(true, [], this.nodes());
                        }
                    }
                    if (childNode.segments) {
                        ej.datavisualization.Diagram.DiagramContext.renderConnector(childNode, this);
                        if (this.connectors().indexOf(childNode) === -1) {
                            this.connectors().push(childNode);
                            this._connectors = $.extend(true, [], this.connectors());
                        }
                    }
                    this._isUndo = false;
                    this._nodes = $.extend(true, [], this.nodes());
                    if (childNode.parent)
                        newParent = this.nameTable[childNode.parent];
                    this._raiseGroupChangeEvent(childNode, oldParent, newParent, "ungroup");
                }
                this._removeElement(node);
                ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this._findNode(node.name));
                this._nodes = $.extend(true, [], this.nodes());
            }
        },

        _recordNudgingChanges: function (obj, entryItem, isRedo) {
            this._isUndo = true;
            var direction = entryItem.undoDirection;
            if (isRedo)
                direction = entryItem.redoDirection;
            this._clearSelection(true);
            if (obj.type === "pseudoGroup") {
                var pseudoGroup = ej.datavisualization.Diagram.Group(obj);
                delete this.nameTable[pseudoGroup.name];
                this.nameTable[pseudoGroup.name] = obj;
            }
            this._addSelection(obj._type == "label" ? obj : this.nameTable[obj.name], true);
            this.nudge(direction, entryItem.values);
            this._isUndo = false;
        },

        _recordPropertiesChanged: function (node, options, type, object) {
            var currentState = this._getModifiedProperties((type == "port" || type == "label") ? object : node, options);
            if (currentState && Object.keys(currentState).length) {
                if (type == "connector") {
                    if (options.sourcePoint || options.sourceNode) {
                        currentState.sourcePoint = node.sourcePoint;
                        currentState.sourceNode = node.sourceNode;
                        currentState.sourcePort = node.sourcePort;
                    }
                    if (options.targetPoint || options.targetNode) {
                        currentState.targetNode = node.targetNode;
                        currentState.targetPort = node.targetPort;
                        currentState.targetPoint = node.targetPoint;
                    }
                }
                var entry = { type: "propertiesChanged", values: currentState, category: "internal", object: node, elementType: type, updateValues: options };
                entry[type] = object;
                this.addHistoryEntry(entry);
            }
        },
        _recordAlignCommandChanges: function (entryItem) {
            if (entryItem && entryItem.values.length) {
                this._associatedConnectorsUpdate = true;
                for (var i = 0; i < entryItem.values.length; i++) {
                    var obj = entryItem.values[i];
                    if (obj.object && obj.delta) {
                        var current = { x: -obj.delta.x, y: -obj.delta.y };
                        var child = this.nameTable[this._getChild(obj.object)];
                        this._comparePropertyOnAlign(child, -obj.delta.x, -obj.delta.y);
                        this._translate(child, -obj.delta.x, -obj.delta.y, this.nameTable);
                        this._updateContainerOnNudge(child);
                        obj.delta = current;
                        this._updateObject(child);
                    }
                }

                delete this._associatedConnectorsUpdate;

                for (i = 0; i < entryItem.values.length; i++) {
                    var node = this.nameTable[this._getChild(entryItem.values[i].object)];
                    if (!node.segments) {
                        this._updateAssociateConnector(node)
                    }
                }
                if (!this.nameTable[entryItem.object.name]) this.nameTable[entryItem.object.name] = entryItem.object;
                ej.datavisualization.Diagram.Util._updateGroupBounds(entryItem.object, this);
                if (this._hasSelection())
                    ej.datavisualization.Diagram.SvgContext.updateSelector(entryItem.object, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
                else
                    this.addSelection(entryItem.object, true);
            }
        },
        _recordPhaseCollectionChanged: function (entryItem) {
            if (entryItem.undo) {
                if (entryItem.isAdded) {
                    if (entryItem.phase)
                        this._removePhase(entryItem.phase.name);
                }
                else {
                    if (entryItem.phase) {
                        this._addPhase(entryItem.group, entryItem.phase, entryItem);
                    }
                }
            }
            else {
                if (entryItem.isAdded) {
                    if (entryItem.phase) {
                        this._addPhase(entryItem.group, entryItem.phase, entryItem);
                    }
                }
                else {
                    if (entryItem.phase)
                        this._removePhase(entryItem.phase.name);
                }
            }
            this._clearSelection(true)
        },
        _recordSizeCommandChanges: function (entryItem) {
            if (entryItem && entryItem.values.length) {
                for (var i = 0; i < entryItem.values.length; i++) {
                    var obj = entryItem.values[i];
                    if (obj.object && obj.values) {
                        var current = { width: obj.object.width || obj.object._width || 0, height: obj.object.height || obj.object._height || 0 };
                        var child = this.nameTable[this._getChild(obj.object)];
                        this._comparePropertyValues(child, "height", { height: obj.values.height });
                        this._comparePropertyValues(child, "width", { width: obj.values.width });
                        this.scale(child, obj.values.width / (child.width || child._width || 0),
                            obj.values.height / (child.height || child.height || 0),
                            { x: child.offsetX, y: child.offsetY }, this.nameTable);
                        obj.values = current;
                        this._updateObject(child);
                    }
                }
                if (!this.nameTable[entryItem.object.name] && entryItem.object.type == "pseudoGroup") this.nameTable[entryItem.object.name] = entryItem.object;
                ej.datavisualization.Diagram.Util._updateGroupBounds(entryItem.object, this);
                if (this._hasSelection())
                    ej.datavisualization.Diagram.SvgContext.updateSelector(entryItem.object, this._adornerSvg, this._currZoom, this, this.model.selectedItems.constraints);
                else
                    this.addSelection(entryItem.object, true);
            }
        },
        _getModifiedProperties: function (node, options, object) {
            object = object || node;
            if (options && Object.keys(options).length && object) {
                var current = {};
                for (var prop in options) {
                    if (options[prop] != object[prop] || typeof object[prop] == "object") {
                        if (object[prop] && object[prop] instanceof Array)
                            current[prop] = object[prop];
                        else if (object[prop] && typeof object[prop] == "object")
                            current[prop] = $.extend(true, {}, object[prop]);
                        else
                            current[prop] = object[prop];
                    }
                }
                return current;
            }
        },
        _addCollectionChangeToHistory: function (node) {
            if (node.parent == "") {
                var childTable = {};
                if (this.selectionList && this.selectionList.length > 0)
                    childTable = this._getChildTable(this.selectionList[0], childTable);
                var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, node), childTable: jQuery.extend(true, {}, childTable), changeType: "insert", category: "internal" };
                this.addHistoryEntry(entry);
            }
        },
        _recordPhasesizeChanged: function (args) {
            var undoObject = $.extend(true, {}, args.undoObject);
            var redoObject = $.extend(true, {}, args.redoObject);
            if (args.undo) {
                this._updatePhase({ name: undoObject.name, offset: undoObject.offset })
            }
            else {
                this._updatePhase({ name: redoObject.name, offset: redoObject.offset })
            }
        },
        _recordPortsCollectionChanged: function (args) {
            var changeType = args.changeType;
            if (args.isUndo) {
                if (args.changeType == "insert")
                    changeType = "remove";
                else
                    changeType = "insert";
            }
            var node = this.nameTable[args.object.name];
            if (changeType == "remove") {
                for (var i = 0; i < args.collection.length; i++) {
                    this._updatePortConnection(node, node.inEdges, args.collection[i]);
                    this._updatePortConnection(node, node.outEdges, args.collection[i]);
                    ej.datavisualization.Diagram.Util.removeItem(node.ports, args.collection[i]);
                    for (var j = 0; j < this._views.length; j++) {
                        var view = this._views[j];
                        var element = this._views[view].svg.document.getElementById(node.name + "_" + args.collection[i].name);
                        if (element)
                            element.parentNode.removeChild(element);
                    }
                }
            }
            else {
                for (var i = 0; i < args.collection.length; i++) {
                    node.ports.push(args.collection[i]);
                    ej.datavisualization.Diagram.DiagramContext.renderPort(node, args.collection[i], this);
                    if (args.collection[i]._removeLine) {
                        var lineName = args.collection[i]._removeLine, line;
                        if (lineName) {
                            line = this.nameTable[lineName];
                            if (line && (args.collection[i]._removeFromSourcePort || args.collection[i]._removeFromTargetPort)) {
                                if (args.collection[i]._removeFromSourcePort)
                                    line.sourcePort = args.collection[i].name;
                                if (args.collection[i]._removeFromTargetPort)
                                    line.targetPort = args.collection[i].name;
                                this._dock(line, this.nameTable);
                                ej.datavisualization.Diagram.DiagramContext.update(line, this);
                            }
                        }

                    }
                }
            }
        },

        //#endregion
        //#region Helper methods
        _initLaneContaier: function (element) {
            if (element.isLane) {
                element = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, element);
            }
            return element;
        },
        _addSymbolToDiagram: function (evt) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var scale = this._currZoom;
                var offset = $("#" + this.element[0].id).offset();
                var coor = this._isTouchEvent(evt);
                if (!coor.pageX && !evt.pageX) {
                    if (evt.originalEvent && evt.originalEvent.changedTouches) {
                        coor = evt.originalEvent.changedTouches[0];
                    }
                    else if (evt && evt.changedTouches) {
                        coor = evt.changedTouches[0];
                    }
                }
                var x = (coor ? coor.pageX : evt.pageX) + this._hScrollOffset - offset.left;
                var y = (coor ? coor.pageY : evt.pageY) + this._vScrollOffset - offset.top;
                var paletteItem = $.extend(true, {}, this._selectedSymbol);
                var element;
                if (this._selectedSymbol) {
                    element = paletteItem;
                    if (!this._isNodeEnters) {
                        if (element && element.type != "pseudoGroup")
                            paletteItem.name += ej.datavisualization.Diagram.Util.randomId();
                        if (paletteItem.segments) {
                            ej.datavisualization.Diagram.Util._translateLine(paletteItem, x / scale, y / scale);
                        }
                        else {
                            this._cloneGroupNode(paletteItem, ej.datavisualization.Diagram.Util.randomId());
                            if (paletteItem._type === "group") {
                                if (paletteItem.type == "bpmn") {
                                    if (paletteItem.offsetX !== 0 || paletteItem.offsetY !== 0) {
                                        paletteItem.offsetX = x / scale;
                                        paletteItem.offsetY = y / scale;
                                    }
                                    else {
                                        var cBound = ej.datavisualization.Diagram.Util._getChildrenBounds(paletteItem, this);
                                        ej.datavisualization.Diagram.Util._translate(paletteItem, (x / scale - cBound.x - cBound.height / 2), (y / scale - cBound.y - cBound.width / 2), this.nameTable, null, this);
                                    }
                                }
                                else {
                                    var cBound = ej.datavisualization.Diagram.Util._getChildrenBounds(paletteItem, this);
                                    ej.datavisualization.Diagram.Util._translate(paletteItem, (x / scale - cBound.x - cBound.height / 2), (y / scale - cBound.y - cBound.width / 2), this.nameTable, null, this);
                                }
                            } else {
                                paletteItem.offsetX = x / scale;
                                paletteItem.offsetY = y / scale;
                            }
                            if (paletteItem.isLane) {
                                var obj = ej.datavisualization.Diagram.SwimLaneHelper._createDiagramLane(paletteItem, this.nameTable);
                                obj.isLane = paletteItem.isLane;
                                obj.orientation = paletteItem.orientation;
                                element = obj;
                            }
                            if (paletteItem.type == "bpmn") delete element.children;
                        }
                    } else if (element.isSwimlane) {
                        this.nameTable[element.name] = element;
                        element = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, element, { childTable: this.childTable, object: element });
                        this._addAssiciatedChildConnectors(element);
                    }
                    if (element) {
                        var args = { element: element, target: this, targetType: "diagram" };
                        this._raiseEvent("dragEnter", args);
                        if (!args.cancel) {
                            if (this._isEditing) {
                                this._endEditing = true;
                                this._endEdit();
                                delete this._endEditing;
                            }
                            if (element && !this._isNodeEnters) {
                                element = this._initLaneContaier(element);
                            }
                            if (element.type != "pseudoGroup") {
                                if (element.isLane) {
                                    this.nameTable[this._getChild(element.children[0])]._isHeader = true;
                                }
                                this.add(element);
                            }
                            else {
                                for (var k = 0; k < element.children.length; k++) {
                                    this.add(element.children[k]);
                                    element.children[k] = element.children[k].name;
                                }
                                for (var conn in this.edgeTable) if (!this.nameTable[conn]) this.add(this.edgeTable[conn]);
                                if (this._hasSelection()) this._clearSelection(true);
                                this.nodes().push(element);
                                this._nodes = $.extend(true, [], this.nodes());
                                this.nameTable[element.name] = element;
                                ej.datavisualization.Diagram.Util._updateGroupBounds(element, this);
                                this.addSelection(element, true);
                            }
                            this._focusedElement = element;
                            if (element.isLane)
                                ej.datavisualization.Diagram.SvgContext._hideNode(element, this._svg);
                            this.element[0].focus();
                            this._toolToActivate = "move";
                            if (document.getElementsByClassName("e-paletteItem dragClone")[0]) {
                                $(".e-paletteItem.dragClone").css("display", "none");
                            }
                            this.activateTool("move", false);
                            this._symbolDrop = true;
                            this.activeTool.mousedown(evt);
                            this.activeTool.mousemove(evt);
                        }
                    }
                }
            }
            delete this._symbolDrop;
        },
        _removeSymbolFromDiagram: function () {
            if (this._selectedSymbol) {
                var displays = document.getElementsByClassName("e-paletteItem dragClone")[0];
                if (displays != null) {
                    displays.style.display = "block";
                }
                this._remove(this.selectionList[0]);
                this._selectedSymbol = null;
            }
        },
        _updateGroupChild: function (group) {
            var children = group.children;
            for (var i = 0; i < group.children.length; i++) {
                group.children[i] = this.nameTable[this._getChild(group.children[i])];
                if (group.children[i] && group.children[i]._type === "group") {
                    this._updateGroupChild(group.children[i]);
                }
            }
        },
        _dropSymbol: function (object, evt) {
            if (ej.datavisualization.Diagram.Util.isPageEditable(this)) {
                var actualObject = object || this.selectionList[0] || this.activeTool.selectedObject;
                var args = { element: this.getNode(actualObject) };
                if (this._nodeUnderMouse) {
                    args.target = this._nodeUnderMouse;
                }
                var added = false;
                if (!args.target) args.target = this.model;
                if (actualObject && actualObject._type === "group")
                    this._updateGroupChild(actualObject);
                this._remove(actualObject);
                this.nameTable[args.element.name] = args.element;
                this._selectedSymbol = null;
                var newElement = object || args.element;
                var overNode = this.activeTool._getMouseOverElement(evt);
                if (this.activeTool._outOfBoundsDrag(newElement) && ej.datavisualization.Diagram.canvasHelper._outOfBoundaryNodeDrop(this, this.activeTool.selectedObject, overNode)) {


                    this._raiseDropEvent(args);



                    if (!args.cancel) {
                        this._isInsert = true;
                        this._containerOverNode = null;
                        if (overNode && overNode.container && ej.datavisualization.Diagram.Util.canAllowDrop(overNode) && !overNode.isSwimlane && ej.datavisualization.Diagram.bpmnHelper.canAllowDropOnContainer(this.activeTool.selectedObject, overNode)) {
                            if (this.getObjectType(newElement) !== "connector") {
                                newElement.parent = overNode.name;
                                this._containerOverNode = overNode;
                            }
                        }
                        this._eventCause["nodeCollectionChange"] = this._eventCause["connectorCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.Drop;
                        added = this.add(newElement);
                        delete this._containerOverNode;
                        this.activeTool.selectedObject = this.selectionList[0];
                        this._isInsert = false;

                    }
                    if (added) {
                        var node = this.nameTable[args.element.name];
                        this._updateDroppedSymbol(node);
                    }
                    else
                        this.activeTool.selectedObject = null;
                }
                else {
                    this.activeTool.selectedObject = null;
                    delete this.nameTable[args.element.name];
                    this._clearSelection(true);
                }
                if (!ej.datavisualization.Diagram.Util.canDoSingleSelection(this)) {
                    this._clearSelection(true);
                    if (this.tool() & ej.datavisualization.Diagram.Tool.ZoomPan) {
                        this.activateTool("panTool");
                    }
                }
            }
        },
        _updateDroppedSymbol: function (node) {
            if (node && this.selectionList.length > 0) {
                this.scrollToNode(node);
                if ((node.labels.length > 0 && node.labels[0].mode === "edit") && !node.labels[0].readOnly) {
                    if (!node.isPhase && !(node.isSwimlane || node.isLane)) {
                        if (node.type !== "umlclassifier") {
                            this._isEditing = true;
                            this.startLabelEdit(node, node.labels[0]);
                        }
                    }
                } else {
                    this.element[0].focus();
                }
                if (this._nodeUnderMouse && this._nodeUnderMouse.segments) {
                    ej.datavisualization.Diagram.SvgContext._removeConnectorHighlighter(this._adornerLayer, this._adornerSvg);
                }
            }
        },
        _initiateAutoScroll: function (evt) {
            if (this.activeTool.inAction && this.enableAutoScroll() && !(this.activeTool instanceof ej.datavisualization.Diagram.RotateTool)) {
                var viewPort = this._viewPort;
                var pt = this._mousePosition(evt, true);
                var autoScrollBorder = this.model.pageSettings.autoScrollBorder;
                var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(this);
                if (pt.x + autoScrollBorder.right - rulerSize.left >= viewPort.width - 18) {
                    this._beginAutoScroll("right", evt);
                    this._canAutoScroll = true;
                }
                else if (pt.x <= (autoScrollBorder.left + rulerSize.left)) {
                    this._beginAutoScroll("left", evt);
                    this._canAutoScroll = true;
                }
                else if (pt.y + autoScrollBorder.bottom + rulerSize.top >= viewPort.height - 18) {
                    this._beginAutoScroll("bottom", evt);
                    this._canAutoScroll = true;
                }
                else if (pt.y <= autoScrollBorder.top + rulerSize.top) {
                    this._beginAutoScroll("top", evt);
                    this._canAutoScroll = true;
                }
                else {
                    this._canAutoScroll = false;
                }
            }
        },
        _updatePoints: function (helper, startPoint, endPoint, isTarget) {
            var offset = new ej.datavisualization.Diagram.Point(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                helper._updateEndPoint(offset.x, offset.y, isTarget);
            }
        },
        _cloneGroupNode: function (node, id, nameTable) {
            var child = null, clnObj;
            var children = node.children = this._getChildren(node.children);
            if (node._type === "group") {
                for (var i = 0; i < children.length; i++) {
                    if (nameTable)
                        child = nameTable[children[i]];
                    else {
                        if (this._paletteTable)
                            child = this._paletteTable[children[i]];
                    }
                    if (child) {
                        child = $.extend(true, {}, child);
                        if (child._type === "group")
                            this._cloneGroupNode(child, id);
                        clnObj = $.extend(true, {}, child);
                        clnObj.name += id;
                        clnObj.parent = node.name;
                        children[i] = clnObj.name;
                        this.nameTable[clnObj.name] = clnObj;
                    }
                }
            }
        },
        _addGroupConnector: function (group, arg) {
            var edges;
            var connector;
            var k, j, len, l;
            if (!group.segments) {
                var children = this._getChildren(group.children);
                for (k = 0; k < children.length; k++) {
                    var child = this.nameTable[children[k]];
                    if (child) {
                        if (child.inEdges && child.inEdges.length > 0) {
                            edges = child.inEdges;
                            for (j = 0, len = edges.length; j < len; j++) {
                                if (arg.edgeTable)
                                    connector = arg.edgeTable[edges[j]];
                                else
                                    connector = arg.childTable[edges[j]];
                                if (connector && !this.nameTable[connector.name])
                                    this.add(connector);
                            }
                        }
                        if (child.outEdges && child.outEdges.length > 0) {
                            edges = child.outEdges;
                            for (j = 0, len = edges.length; j < len; j++) {
                                if (arg.edgeTable)
                                    connector = arg.edgeTable[edges[j]];
                                else
                                    connector = arg.childTable[edges[j]];
                                if (connector && !this.nameTable[connector.name])
                                    this.add(connector);
                            }
                        }
                    }
                }
            }
        },
        _addConnector: function (node, arg) {
            var edges;
            var connector;
            var k, j, len, l;
            if (!node.segments) {
                if (node.inEdges && node.inEdges.length > 0) {
                    edges = node.inEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        connector = arg ? arg.edgeTable[edges[j]] : this.nameTable[edges[j]];
                        connector.zOrder = -1;
                        this.add(connector);
                    }
                }
                if (node.outEdges && node.outEdges.length > 0) {
                    edges = node.outEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        connector = arg ? arg.edgeTable[edges[j]] : this.nameTable[edges[j]];
                        connector.zOrder = -1;
                        this.add(connector);
                    }
                }
            }
        },
        _addChildren: function (group, childTable) {
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                var node = childTable[children[i]];
                if (node._type === "group")
                    this._addChildren(node, childTable);
                this.nameTable[children[i]] = node;
                group.children[i] = node;
            }
        },
        _updateLabels: function (node, labels) {
            node.labels = labels;
            for (var i = 0; i < node.labels.length; i++)
                ej.datavisualization.Diagram.DiagramContext.updateLabel(node, node.labels[i], this);
        },
        _getNode: function (name, childTable) {
            if (!childTable)
                var node = typeof (name) === "object" ? this.nameTable[name.name] : this.nameTable[name];
            else var node = typeof (name) === "object" ? childTable[name.name] : childTable[name];
            if (!node && typeof (name) === "object") {
                node = name;
            }
            else if (node && typeof (name) === "string") {
                node = childTable ? childTable[name] : this.nameTable[name];
            }
            if (node) {
                if (node.isLane) {
                    return ej.datavisualization.Diagram.SwimLaneHelper._mapObject(this, node, "lane")
                }
                else if (node.isPhase || node.type === "phase") {
                    return ej.datavisualization.Diagram.SwimLaneHelper._mapObject(this, node, "phase")
                }
                else if (node.isSwimlane) {
                    return ej.datavisualization.Diagram.SwimLaneHelper._mapObject(this, node, "swimlane", childTable)
                }
                else if (node._type === "node" || node._type === "group" || node._type === "pseudoGroup" || this.getObjectType(node) == "node") {
                    return node;
                }
                //else if (node.shape) {
                //    return this._getNewNode(node);
                //}
                //else if (node.segments) {
                //    return this._getNewConnector(node);
                //}
                else
                    return node;
            }
            return null;
        },
        _updateEdges: function (connector) {
            var node;
            if (ej.datavisualization.Diagram.Util.isTargetConnected(connector)) {
                node = this.nameTable[connector.targetNode];
                if (node && node.inEdges.indexOf(connector.name) == -1)
                    node.inEdges.push(connector.name);
            }
            if (ej.datavisualization.Diagram.Util.isSourceConnected(connector)) {
                node = this.nameTable[connector.sourceNode];
                if (node && node.outEdges.indexOf(connector.name) == -1)
                    node.outEdges.push(connector.name);
            }
        },
        _updateChildrenEdges: function (object) {
            var children = this._getChildren(object.children);
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.segments) {
                    this._updateEdges(child);
                    this._dock(child, this.nameTable);
                }
                else if (child._type === "group") {
                    this._updateChildrenEdges(child);
                }
            }
        },
        _updateParent: function (object) {
            var children = this._getChildren(object.children);
            for (var i = 0; i < children.length; i++) {
                var index = this.nodes().indexOf(this.nameTable[children[i]]);
                var child = this.nameTable[children[i]];
                child = (child.type != "bpmn" && child.type != "connector") ? this._getNewNode(child) : child;
                if (child && child._type === "group") {
                    this._updateParent(child);
                }
                else if (child) {
                    child.parent = object.name;
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[child.name], this.nameTable[child.name]);
                    ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, this.nameTable[child.name]);
                    this.nameTable[child.name] = child;
                    if (index != -1) {
                        this.nodes()[index] = child;
                    }
                }
                this._updateQuad(this.nameTable[child.name]);
            }
        },
        _findPortAtPoint: function (point, node) {
            var ports;
            var port;
            var location;
            var size, pt, x, y;
            var bounds;
            if (node) {
                bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                ports = node.ports;
                var matrix;
                for (var i = 0, len = ports.length; i < len; ++i) {
                    port = ports[i];
                    size = ej.datavisualization.Diagram.Size(port.size, port.size);
                    pt = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds);
                    matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                    pt = ej.Matrix.transform(matrix, pt);
                    x = pt.x - port.size / 2;
                    y = pt.y - port.size / 2;
                    location = ej.datavisualization.Diagram.Rectangle(x, y, size.width, size.height);
                    if (ej.datavisualization.Diagram.Geometry.containsPoint(location, point)) {
                        return ej.datavisualization.Diagram.Util.canConnect(port, true) ? port : null;
                    }
                    else {
                        if (this.portHighlight) {
                            location = ej.datavisualization.Diagram.Rectangle(x - 1, y - 1, size.width + 1, size.height + 1);
                            if (ej.datavisualization.Diagram.Geometry.containsPoint(location, point)) {
                                return ej.datavisualization.Diagram.Util.canConnect(port, true) ? port : null;
                                delete this.portHighlight;
                            }
                        }
                    }
                }
            }
            return null;
        },
        _findLabelAtPoint: function (point, node) {
            var labels, label = null;
            var location;
            var size, pt, x, y, width, height, tempPt;
            var bounds, textElement, matrix;
            var htmlLayer = this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
            var intersectingLabels = [];
            if (node && this.model.labelRenderingMode !== ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                labels = node.labels;
                if (labels && labels.length > 0) {
                    label = labels[0];
                    for (var i = 0, len = labels.length; i < len; i++) {
                        label = labels[i];
                        textElement = $(htmlLayer).find("#" + node.name + "_" + label.name)[0];

                        width = textElement ? textElement.offsetWidth : 0;
                        height = textElement ? textElement.offsetHeight : 0;
                        if (!width) width = bounds.width;
                        if (!height) height = label.fontSize;
                        size = ej.datavisualization.Diagram.Size(width, height);
                        pt = ej.datavisualization.Diagram.Util._getLabelPosition(label, bounds);
                        pt.x = bounds.x + pt.x;
                        pt.y = bounds.y + pt.y;
                        matrix = ej.Matrix.identity();
                        if (!node.segments) ej.Matrix.rotate(matrix, -node.rotateAngle, node.offsetX, node.offsetY);
                        else ej.Matrix.rotate(matrix, 0, bounds.x + bounds.width / 2, bounds.y + bounds.height / 2);
                        tempPt = ej.Matrix.transform(matrix, point);
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, -label.rotateAngle, pt.x, pt.y);
                        tempPt = ej.Matrix.transform(matrix, tempPt);

                        if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Top) pt.y += size.height / 2;
                        else if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Bottom) pt.y -= size.height / 2;

                        if (label.horizontalAlignment == ej.datavisualization.Diagram.HorizontalAlignment.Left) pt.x += size.width / 2;
                        else if (label.horizontalAlignment == ej.datavisualization.Diagram.HorizontalAlignment.Right) pt.x -= size.width / 2;

                        x = pt.x - size.width / 2;
                        y = pt.y - size.height / 2;
                        location = ej.datavisualization.Diagram.Rectangle(x, y, size.width, size.height);
                        if (ej.datavisualization.Diagram.Geometry.containsPoint(location, tempPt))
                            intersectingLabels.push(label);
                        if (i == labels.length - 1)
                            return (intersectingLabels.length ? intersectingLabels[intersectingLabels.length - 1] : null);
                    }
                }
            }
            return label;
        },
        _getCurrentZoom: function () {
            return this._currZoom;
        },
        _findNode: function (id) {
            return this.nameTable[id];
        },
        _findPort: function (node, portId) {
            var ports = node.ports;
            for (var i = 0, len = ports.length; i < len; i++) {
                if (ports[i].name === portId) {
                    return ports[i];
                }
            }
            return null;
        },
        _findLabel: function (node, labelId) {
            var labels = node.labels;
            for (var i = 0, len = labels.length; i < len; i++) {
                if (labels[i].name === labelId) {
                    return labels[i];
                }
            }
            return null;
        },
        _findLabelRotateAngle: function (label) {
            var node = this.findNode(label._parent);
            var rotateAngle = 0;
            if (node) {
                if (node.segments)
                    rotateAngle = label.rotateAngle;
                else
                    rotateAngle = label.rotateAngle + node.rotateAngle;
                if (rotateAngle > 360) {
                    rotateAngle %= 360;
                }
            }
            return rotateAngle;
        },
        _findConnector: function (id) {
            return this.nameTable[id];
        },
        _findChildren: function (group, name) {
            var child, innerchild;
            var children = this._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = this.nameTable[children[i]];
                if (child) {
                    if (name == child.name) {
                        return child;
                    }
                    if (child._type === "group") {
                        innerchild = this._findChildren(child, name);
                        if (innerchild) return innerchild;
                    }
                }
            }
            return null;
        },
        _removeLaneParent: function (node) {
            var swimlane, i, parentCollection = [], laneStack, stack, child = [];
            var uniqueParent = [], j, k, count = 0, selectLane = false, selectedNode = [], parentNode, pseudoGroup;
            if (node.isLane && node.parent) {
                stack = this.nameTable[node.parent];
                if (stack.children && stack.children.length === 1) {
                    if (stack && stack.parent) {
                        var swimlane = this.nameTable[stack.parent];
                        if (swimlane) {
                            return { remove: true, node: swimlane };
                        }
                    }
                }
            }
            else if (node._type == "pseudoGroup") {
                for (i = 0; i < node.children.length; i++) {
                    child[i] = this.nameTable[node.children[i]];
                    if (child[i] && child[i].isLane && child[i].parent) {
                        parentCollection[i] = child[i].parent;
                        selectLane = true;
                    }
                    else
                        selectedNode.push(child[i]);
                }
                if (this.isSameParent(parentCollection) && (parentCollection.length == node.children.length)) {
                    laneStack = this.nameTable[parentCollection[0]];
                    if (laneStack.children.length == parentCollection.length) {
                        swimlane = this.nameTable[laneStack.parent];
                        if (swimlane && swimlane.isSwimlane) {
                            return { remove: true, node: swimlane };
                        }
                    }
                }
                else if (selectLane) {
                    pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                    uniqueParent = parentCollection.filter(function (item, index, inputArray) {
                        return inputArray.indexOf(item) == index;
                    });
                    for (i = 0; i < uniqueParent.length; i++) {
                        count = 0;
                        for (j = 0; j < parentCollection.length; j++) {
                            if (uniqueParent[i] == parentCollection[j])
                                count++;
                        }
                        parentNode = this.nameTable[uniqueParent[i]];
                        if (count && parentNode && parentNode.children && parentNode.children.length == count) {
                            swimlane = this.nameTable[parentNode.parent];
                            if (swimlane && swimlane.isSwimlane)
                                pseudoGroup.children.push(swimlane);
                        }
                        else if (count) {
                            for (k = 0; k < node.children.length; k++) {
                                child = this.nameTable[node.children[k]];
                                if (child.parent == uniqueParent[i])
                                    pseudoGroup.children.push(child);
                            }
                        }
                    }
                    if (selectedNode.length > 0) {
                        for (k = 0; k < selectedNode.length; k++)
                            pseudoGroup.children.push(selectedNode[k]);
                    }
                    if (pseudoGroup && pseudoGroup.children.length > 1) {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this);
                        return { remove: true, node: pseudoGroup };
                    }
                }
            }
            return { remove: false }
        },
        _delete: function (node) {

            var clearSelection = false;
            var child, lane, pseudoGroup, children, obj, i, removeParent, swimChild, isMultipleLane = false;
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                node = node || this.selectionList[0];
                if (node) {
                    if (!node.isPhase && ((node.type && node.type != "phase") || node.segments || node._type == "node" || node._type == "pseudoGroup") || this._dropPhase) {
                        removeParent = this._removeLaneParent(node)
                        if (removeParent.remove) {
                            node = removeParent.node;
                        }
                        obj = node;
                        if (obj.type == "pseudoGroup") {
                            for (i = 0; i < obj.children.length; i++) {
                                lane = (typeof obj.children[i] == "object") ? obj.children[i].name : obj.children[i];
                                child = this.findNode(lane);
                                if (child && child.parent) {
                                    if (child.isLane) {
                                        child._laneIndex = this._getRemoveIndex(child);
                                        isMultipleLane = true;
                                    }
                                }
                            }
                        }

                        if (obj.type == "pseudoGroup" && (isMultipleLane)) {
                            pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                            children = this._getChildren(obj.children);
                            this._multipleAction = true;
                            for (i = children.length - 1; i >= 0; i--) {
                                child = this.nameTable[children[i]];
                                if (child.isLane && child.parent) {
                                    removeParent = this._removeLaneParent(child)
                                    swimChild = removeParent.remove ? removeParent.node : child;
                                }
                                else swimChild = child;
                                if (swimChild)
                                    pseudoGroup.children.push(swimChild);
                            }
                            if (isMultipleLane)
                                pseudoGroup._isMultipleLaneDelete = true;
                            if (pseudoGroup && pseudoGroup.children.length > 0) {
                                ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this);
                                if (!this._selectedSymbol) this._removeAdjacentConnections(pseudoGroup);
                            }
                            children = pseudoGroup.children;
                            for (i = children.length - 1; i >= 0; i--) {
                                child = (typeof children[i] == "object") ? children[i] : this.nameTable[children[i]];
                                this._isUndo = false;
                                clearSelection = this._remove(child);
                                this._isUndo = true;
                            }
                            delete this._multipleAction;
                            this._isUndo = false;
                        }
                        else if (obj._type == "pseudoGroup") {
                            for (i = 0; i < node.children.length; i++) {
                                node.children[i] = (typeof node.children[i] == "object") ? node.children[i].name : node.children[i];
                            }
                            if (!this._selectedSymbol) this._removeAdjacentConnections(node);
                            children = this._getChildren(obj.children);
                            this._multipleAction = true;
                            for (i = children.length - 1; i >= 0; i--) {
                                if (this._remove(this.nameTable[children[i]]))
                                    clearSelection = true;
                                this._isUndo = true;
                            }
                            delete this._multipleAction;
                            this._isUndo = false;
                        }
                        else {
                            if (!this._selectedSymbol) this._removeAdjacentConnections(node);
                            if (this._nodeUnderMouse === obj)
                                this._nodeUnderMouse = null;
                            clearSelection = this._remove(obj);
                            if (obj.container && obj.parent) {
                                var parent = this.nameTable[obj.parent];
                                if (parent && parent.container) {
                                    if (parent.container.type == "stack") {
                                        if (this._getChild(parent.children[0])) {
                                            var swimlane = this._getSwimlane(obj);
                                            if (swimlane)
                                                this._updateChildAdjacentConnectors(swimlane, true);
                                            ej.datavisualization.Diagram.DiagramContext.update(parent, this);
                                        } else {
                                            var prePar = this.nameTable[parent.parent];
                                            if (prePar) {
                                                this._remove(prePar);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (clearSelection)
                            this._clearSelection();
                    }
                    else if (node.type && node.type == "phase") {
                        this._removePhase(node.name);
                        this._clearSelection();
                    }
                    this._removeNodeFromGraph(node);
                }
            }
        },

        _canUpdateOnGraph: function (node) {
            if (!node.parent)
                return true;
            return false;
        },
        _addNodeToGraph: function (node) {
            if (node.type !== "pseudoGroup" && ej.datavisualization.Diagram.Util.canRouteDiagram(this) && !this._checkFromSwimlane(node)) {
                if (this._canUpdateOnGraph(node)) {
                    this._setBounds(node);
                }
            }
        },
        _updateNodeFromGraph: function (node) {
            if (node.type !== "pseudoGroup" && ej.datavisualization.Diagram.Util.canRouteDiagram(this) && !this._checkFromSwimlane(node)) {
                if (this._canUpdateOnGraph(node)) {
                    this._setBounds(node);
                }
            }
        },
        _routeEdge: function (node) {
            if (ej.datavisualization.Diagram.Util.canRouteDiagram(this) && !this._checkFromSwimlane(node)) {
                if (!this.activeTool.inAction)
                    this.lineRouting.routeEdge(node, this);
            }
        },
        _updateAllEdges: function (node) {
            if (ej.datavisualization.Diagram.Util.canRouteDiagram(this) && !this._checkFromSwimlane(node)) {
                if (this.lineRouting) {
                    this.lineRouting.updateAllQuadObjects(this._spatialSearch.parentQuad);
                    this.lineRouting.RerouteConnectors(this, node);
                }
            }
        },
        _removeNodeFromGraph: function (node) {
            if (node.type !== "pseudoGroup" && ej.datavisualization.Diagram.Util.canRouteDiagram(this) && !this._checkFromSwimlane(node)) {
                if (this._canUpdateOnGraph(node)) {
                    this.lineRouting.RemoveNode(node);
                }
            }
        },

        _removeAdjacentConnections: function (node, entry) {
            var childTable = {};
            var edgeTable = {};
            childTable = this._getChildTable(node, childTable);
            edgeTable = this._getEdgeTable(node, edgeTable);
            if (!this._isUndo || entry) {
                var sourcePorts = {}, targetPorts = {}, connector, count, i;
                if (!node.segments) {
                    if (node.outEdges && node.outEdges.length > 0) {
                        count = node.outEdges.length;
                        for (i = 0; i < count; i++) {
                            connector = this.nameTable[node.outEdges[i]];
                            if (connector && connector.sourcePort)
                                sourcePorts[connector.name] = connector.sourcePort;
                        }
                    }
                    if (node.inEdges && node.inEdges.length > 0) {
                        count = node.inEdges.length;
                        for (i = 0; i < count; i++) {
                            connector = this.nameTable[node.inEdges[i]];
                            if (connector && connector.targetPort)
                                targetPorts[connector.name] = connector.targetPort;
                        }
                    }
                }
                if (!this._isUndo) {
                    var index = null;
                    if (node.isLane) {
                        index = this._getRemoveIndex(node);
                    }
                    var entry = { type: "collectionchanged", object: this._updatePsedoGroupChildren(node), index: index, childTable: jQuery.extend(true, {}, childTable), edgeTable: jQuery.extend(true, {}, edgeTable), sourcePorts: sourcePorts, targetPorts: targetPorts, changeType: "remove", category: "internal" };
                    if (!node.isPhase) {
                        if (ej.datavisualization.Diagram.Util.canDelete(node))
                            this.addHistoryEntry(entry);
                    }
                }
                else {
                    entry.targetPorts = targetPorts;
                    entry.sourcePorts = sourcePorts;
                    entry.edgeTable = edgeTable;
                    entry.childTable = childTable;
                }
            }
        },
        _updatePsedoGroupChildren: function (node) {
            var obj = jQuery.extend(true, {}, node), child;
            if (node && node.type == "pseudoGroup") {
                for (var i = 0; i < obj.children.length; i++) {
                    child = this.nameTable[this._getChild(obj.children[i])];
                    if (child && (child.isSwimlane || (child.isLane && node._isMultipleLaneDelete))) {
                        obj.children[i] = this.getNode(child);
                    }
                }
            }
            return obj;
        },
        _getRemoveIndex: function (lane, isReverse) {
            if (lane.parent) {
                var parent = this.nameTable[lane.parent], child;
                if (parent && parent.children && parent.children.length > 0) {
                    for (var i = 0; i < parent.children.length; i++) {
                        child = this._getChild(parent.children[i])
                        if (child === this._getChild(lane)) {
                            return Number(i);
                        }
                    }
                }
            }
            return 0;
        },
        _getSwimlaneHeader: function (group) {
            var header;
            if (group && group.isSwimlane) {
                if (group.children && group.children.length > 0) {
                    header = this.nameTable[this._getChild(group.children[0])];
                }
            }
            return header;
        },
        _addPhase: function (name, options, entryItem) {
            var group = this.nameTable[name];
            var excess = false;
            if (group && group.isSwimlane && options) {
                if (group && group.orientation && options.offset) {
                    if (group.orientation == "horizontal") {
                        var stoffset = group.offsetX - group.width / 2;
                        var laneHdr = this._getFirstLane(group);
                        if (laneHdr)
                            stoffset += laneHdr.width;
                        excess = ((options.offset > group.width) || (((group.offsetX - group.width / 2) + options.offset) < stoffset)) ? true : false;
                    }
                    else if (group.orientation == "vertical") {
                        stoffset = group.offsetY - group.height / 2;
                        var swlnhdr = this._getSwimlaneHeader(group);
                        if (swlnhdr)
                            stoffset += swlnhdr.height;
                        var laneHdr = this._getFirstLane(group);
                        if (laneHdr)
                            stoffset += laneHdr.height;
                        excess = (options.offset > group.height || (((group.offsetY - group.height / 2) + options.offset) < stoffset)) ? true : false;
                    }
                }
                if (options.offset && !excess) {
                    if (entryItem && entryItem.islastPhase) {
                        var itemPhase = entryItem.phase;
                        if (group.orientation === "horizontal") {
                            if (group.width > options.offset) {
                                options.width += (group.width - options.offset);
                                options.offset = group.width;
                            }
                        }
                        else {
                            if ((group.height - swlnhdr.height) > options.offset) {
                                options.height += ((group.height - swlnhdr.height) - options.offset);
                                options.offset = group.height - swlnhdr.height;
                            }
                        }
                    }
                    var phase = ej.datavisualization.Diagram.Phase(options);
                    phase.orientation = group.orientation;
                    phase.label = ej.datavisualization.Diagram.Label(options.label ? options.label : { text: "Phase" });
                    phase.parent = group.name;
                    if (this.nameTable[phase.name]) {
                        ej.datavisualization.Diagram.Util.removeItem(this.model.phases, this.nameTable[phase.name]);
                        delete this.nameTable[phase.name];
                    }
                    if (entryItem && entryItem.islastPhase) {
                        var index = this._getInsertIndex(phase) + 1;
                        var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(this, group);
                        var prevPhase = $.extend(true, {}, entryItem.phaseObject.prevPhase);
                        this._updateInsertPhase(phase, prevPhase.name, group, index, entryItem);
                        ej.datavisualization.Diagram.SvgContext.renderphase(phase, this._svg, this._diagramLayer, this, group);
                        ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, this.nameTable[this._getChild(group.children[1])], true);
                        ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdatePhase(this, phase);
                    }
                    else {
                        var index = this._getInsertIndex(phase) + 1;
                        var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(this, group);
                        var prevPhase = $.extend(true, {}, this.nameTable[this._getChild(phases[index - 1])]);
                        this._updateInsertPhase(phase, phases[index], group, index);
                        ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                        ej.datavisualization.Diagram.SvgContext.renderphase(phase, this._svg, this._diagramLayer, this, group);
                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, this.nameTable[this._getChild(group.children[1])], true);
                        ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdatePhase(this, phase);
                    }
                    if (!this._isUndo) {
                        var entry = { type: "phasecollectionchanged", phase: phase, category: "internal", group: group.name, isAdded: true };
                        this.addHistoryEntry(entry);
                    }
                }
            }
            this._clearSelection(true);
        },
        _removePhase: function (name, needDelete) {
            var phase = this.nameTable[name];
            var islastPhase = false;
            var phaseObject = null;
            if (phase) {
                this._raiseChildrenPropertyChange(phase);
                var parent = this.nameTable[phase.parent.split('phaseStack')[0]];
                var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(this, parent);

                if (parent && phases && phases.length > 1) {
                    var diagram = this;
                    var index = phases.indexOf(phase.name);

                    this._views.forEach(function (viewid) {
                        var view = diagram._views[viewid];
                        var phaseEle = view.svg.getElementById(name + "_phase_g");
                        if (phaseEle)
                            phaseEle.parentNode.removeChild(phaseEle);
                    });
                    var nextPhase = ej.datavisualization.Diagram.SwimLaneContainerHelper._getNextPhase(this, phase);
                    if (index === phases.length - 1) {
                        nextPhase = ej.datavisualization.Diagram.SwimLaneContainerHelper._getPrevPhase(this, phase);
                        phaseObject = $.extend(true, {}, { prevPhase: nextPhase, currPhase: phase });
                        nextPhase.offset = phase.offset;
                        islastPhase = true;
                    }
                    if (parent.orientation === "horizontal")
                        nextPhase.width += phase.width;
                    else
                        nextPhase.height += phase.height;

                    var delNode = this.nameTable[name];
                    ej.datavisualization.Diagram.Util.removeItem(this.nodes(), delNode);
                    this._nodes = $.extend(true, [], this.nodes());
                    var stack = this.nameTable[delNode.parent];
                    delete this.nameTable[name];
                    ej.datavisualization.Diagram.SvgContext._updatephase(nextPhase, this);
                    ej.datavisualization.Diagram.Util.removeItem(phases, phase.name);
                    ej.datavisualization.Diagram.Util.removeItem(stack.children, delNode);
                    ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, stack, true);
                    ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdatePhase(this, phase);
                    var diagram = this;
                    this._views.forEach(function (viewid) {
                        var view = diagram._views[viewid];
                        var phaseEle = view.svg.getElementById(name);
                        if (phaseEle)
                            phaseEle.parentNode.removeChild(phaseEle);
                        var htmlLayer = view.svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                        var label = $(htmlLayer).find("#" + delNode.name + "_label")[0];
                        var element = view.svg.getElementById(delNode.name);
                        if (element && element.parentNode)
                            element.parentNode.removeChild(element);
                        if (label)
                            htmlLayer.removeChild(label);
                    });
                    if (!this._isUndo) {
                        var entry = { type: "phasecollectionchanged", phase: phase, group: parent.name, category: "internal", phaseObject: phaseObject, islastPhase: islastPhase, isAdded: false };
                        this.addHistoryEntry(entry);
                    }
                }
            }
        },

        _getEdgeTable: function (group, edgeTable) {
            var edges, len, i, j, depend;
            if (!group.segments) {
                if (group._type === "group" || group._type === "pseudoGroup") {
                    var children = this._getChildren(group.children);
                    for (i = 0; i < children.length; i++) {
                        var node = this.nameTable[children[i]];
                        if (node && node.inEdges && node.inEdges.length > 0) {
                            edges = node.inEdges;
                            for (j = 0, len = edges.length; j < len; j++) {
                                depend = this.nameTable[edges[j]];
                                if (depend)
                                    var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                            }
                        }
                        if (node && node.outEdges && node.outEdges.length > 0) {
                            edges = node.outEdges;
                            for (j = 0, len = edges.length; j < len; j++) {
                                depend = this.nameTable[edges[j]];
                                if (depend)
                                    var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                            }
                        }
                    }
                }
                if (group.inEdges && group.inEdges.length > 0) {
                    edges = group.inEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        depend = this.nameTable[edges[j]];
                        if (depend)
                            var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                    }
                }
                if (group.outEdges && group.outEdges.length > 0) {
                    edges = group.outEdges;
                    for (j = 0, len = edges.length; j < len; j++) {
                        depend = this.nameTable[edges[j]];
                        if (depend)
                            var table = edgeTable[depend.name] = $.extend(true, {}, depend);
                    }
                }
            }
            return edgeTable;
        },
        _remove: function (obj, dependent, isClear) {
            var isObjectDeleted = false;
            this._raiseChildrenPropertyChange(obj);
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                if (obj && (ej.datavisualization.Diagram.Util.canDelete(obj) || isClear)) {
                    var type;
                    if (obj.segments) type = "connector";
                    else type = "node";
                    var dependent = dependent ? ej.datavisualization.Diagram.dependentconnector.dependent : ej.datavisualization.Diagram.dependentconnector.independent;
                    var args = { changeType: "remove", element: this.getNode(obj), cancel: false, dependent: dependent, state: "changing" };
                    if (!obj.segments) { args.adjustDependent = true; args.deleteDependent = true; }

                    var cause = this._eventCause[type + "CollectionChange"];
                    if (!cause) {
                        if (this._isKeyDown || this._isUndo)
                            this._eventCause[type + "CollectionChange"] = (this._isUndo && !this._multipleAction) ? ej.datavisualization.Diagram.CollectionChangeCause.HistoryChange : ej.datavisualization.Diagram.CollectionChangeCause.Keydown;
                    }
                    if (!obj.isPhase && !this._selectedSymbol)
                        this._raiseEvent(type + "CollectionChange", args);
                    if (!args.cancel) {
                        isObjectDeleted = true;
                        var name = obj.name;
                        if (obj.type == "group" && obj.type != "pseudoGroup") {
                            var children = this._getChildren(obj.children);
                            for (var i = 0; i < children.length; i++) {
                                var child = this.nameTable[children[i]];
                                if (child && !ej.datavisualization.Diagram.Util.canDelete(child)) return;
                            }
                        }
                        if (obj.isSwimlane) {
                            ej.datavisualization.Diagram.SvgContext._removephases(obj, this);
                        }
                        if (obj.type == "bpmn") {
                            var children = this._getChildren(obj.children);
                            for (var i = 0; children && i < children.length; i++) {
                                var child = this.nameTable[children[i]];
                                if (child && child.annotation && child._annotation)
                                    for (var n = 0; n < child._annotation.length; n++)
                                        if (this.nameTable[child._annotation[n]]) this._remove(this.nameTable[child._annotation[n]], dependent, true);
                            }
                        }

                        if (!obj.segments) {
                            if (obj.annotation && obj._annotation) {
                                for (var n = 0; n < obj._annotation.length; n++)
                                    if (this.nameTable[obj._annotation[n]]) this._remove(this.nameTable[obj._annotation[n]]);
                            }
                            this._disConnect(obj, args);
                            //if (obj.type != "group")
                            this._removeConnector(obj, args);
                            if (this._crudDeleteNodes && !this._selectedSymbol) {
                                this._crudDeleteNodes.push(this.nameTable[obj.name]);
                            }
                            ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.nameTable[obj.name]);
                            this._nodes = $.extend(true, [], this.nodes());
                            this._removeNodeFromGraph(obj);
                        } else {
                            this._removeEdges(obj);
                            obj.sourceNode = obj.sourcePort = obj.targetNode = obj.targetPort = null;
                            if (this._crudDeleteNodes && !this._selectedSymbol) {
                                this._crudDeleteNodes.push(this.nameTable[obj.name]);
                            }
                            ej.datavisualization.Diagram.Util.removeItem(this.connectors(), this.nameTable[obj.name]);
                            this._connectors = $.extend(true, [], this.connectors());
                        }
                        type = this.getObjectType(obj);
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(this._spatialSearch, this._spatialSearch.quadTable[obj.name], obj);
                        ej.datavisualization.Diagram.SpatialUtil._updateBounds(this, this._spatialSearch, obj, false);
                        if (obj.parent) {
                            var parent = this.nameTable[obj.parent];
                            if (parent && (parent.type == "group" || parent.type == "bpmn" || parent.type == "umlclassifier")) {
                                ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, obj.name);
                                ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                                //this._disableSwimlaneUptate = true;
                                var prevObj = $.extend(true, {}, parent)
                                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(this, parent, true);
                                //delete this._disableSwimlaneUptate;
                                if (parent.parent)
                                    ej.datavisualization.Diagram.canvasHelper._updateLastPhase(this, this.nameTable[parent.parent]);
                                ej.datavisualization.Diagram.Util._refreshParentGroup(obj, this);
                                ej.datavisualization.Diagram.canvasHelper._updateAddRemoveNodeConnectors(this, parent, prevObj);
                                ej.datavisualization.Diagram.canvasHelper._updateAddRemoveLaneConnectors(this, obj)
                                ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, this.nameTable[parent.parent]);
                                this._updateQuad(parent);
                            }
                        }
                        delete this.nameTable[name];
                        if (obj.segments)
                            this._updateConnectorBridging(obj);
                        var element = this._svg.getElementById(obj.name);
                        if (obj._type == "group" && obj.type != "pseudoGroup") {
                            this._removeChildren(obj, args);
                        }
                        this._removeElement(obj);

                        if (element && element.parentNode)
                            element.parentNode.removeChild(element);
                        ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.activeTool.selectedObject, this._adornerSvg, this._adornerLayer);
                        this._clearSelection((this._selectedSymbol || this._dropPhase) ? true : false);

                    }
                }
            }
            if (isObjectDeleted && !obj.isPhase && !this._selectedSymbol) {
                args.state = "changed";
                if (obj.type === "connector")
                    this._raiseEvent("connectorCollectionChange", args);
                else
                    this._raiseEvent("nodeCollectionChange", args);
            }
            return isObjectDeleted;
        },
        _removeConnector: function (node, args) {
            var edges;
            var connector;
            var i, len;
            if (!node.segments) {
                //If adjustDependent is false all connector associated with Nodes get deleted.
                if (args.deleteDependent && !(args.adjustDependent)) {
                    if (node.inEdges && node.inEdges.length > 0) {
                        edges = node.inEdges;
                        for (i = edges.length - 1; i >= 0; i--) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    if (node.outEdges && node.outEdges.length > 0) {
                        edges = node.outEdges;
                        for (i = 0, len = edges.length; i < len; i++) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                }
                //If both deleteDependent & adjustDependent are true changes to Visio behaviour
                if (args.deleteDependent && args.adjustDependent) {
                    if (node.inEdges && node.inEdges.length > 0 && node.outEdges && node.outEdges.length > 0) {
                        edges = node.outEdges;
                        for (i = edges.length - 1; i >= 0; i--) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                        edges = node.inEdges;
                        for (i = edges.length - 1; i >= 0; i--) {
                            //Remove the Connector
                            if (this.nameTable[edges[i]])
                                this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    else if (node.inEdges && node.inEdges.length == 0 && node.outEdges.length > 0) {
                        edges = node.outEdges;
                        for (i = edges.length - 1; i >= 0; i--) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    else if (node.outEdges && node.outEdges.length == 0 && node.inEdges.length > 0) {
                        edges = node.inEdges;
                        for (i = edges.length - 1; i >= 0; i--) {
                            //Remove the Connector
                            if (this.nameTable[edges[i]])
                                this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    else if ((node.inEdges && node.inEdges.length == 1 || node.inEdges.length > 1) && (node.outEdges.length == 1)) {
                        edges = node.outEdges;
                        for (i = 0, len = edges.length; i < len; i++) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                    else if (!(node.inEdges && node.inEdges.length > 1 && node.outEdges.length > 1)) {
                        edges = node.inEdges;
                        for (i = 0, len = edges.length; i < len; i++) {
                            //Remove the Connector
                            this._updateConnection(this.nameTable[edges[i]], true);
                        }
                    }
                }
            }
        },
        _updateConnection: function (connector, args) {
            if (connector && ej.datavisualization.Diagram.Util.canDelete(connector)) {
                this._remove(connector, args);
                this.updateConnector(connector.name);
            }
        },
        _removeElement: function (element) {
            for (var i = 0; i < this._views.length; i++) {
                var view = this._views[i];
                this._views[view].context.removeChild(element, this._views[view]);
            }
        },
        _disConnect: function (node, args, isChild) {
            var edgesIn, edgesOut, connector, parentNode, targetNode, data;
            var i, j, leni, lenj, canDelete;
            if (node.inEdges && node.inEdges.length > 0) {
                edgesIn = node.inEdges;
                for (i = 0, leni = edgesIn.length; i < leni; i++) {
                    if (ej.datavisualization.Diagram.Util.canDelete(this.nameTable[edgesIn[i]]))
                        canDelete = true;
                }
            }
            if (node.outEdges && node.outEdges.length > 0) {
                edgesOut = node.outEdges;
                for (i = 0, leni = edgesOut.length; i < leni; i++) {
                    if (ej.datavisualization.Diagram.Util.canDelete(this.nameTable[edgesOut[i]]))
                        canDelete = true;
                }
            }
            if (args.deleteDependent && args.adjustDependent && !isChild && canDelete) {
                if (node.inEdges && node.inEdges.length > 0 && node.outEdges.length > 0) {
                    edgesIn = node.inEdges;
                    edgesOut = node.outEdges;
                    if ((node.inEdges.length > 1 || node.inEdges.length == 1) && node.outEdges.length == 1) {
                        for (i = 0, leni = edgesIn.length; i < leni; i++) {
                            if (this.nameTable[edgesIn[i]] && this.nameTable[edgesOut[0]]) {
                                if ((this.nameTable[edgesIn[i]].targetNode == this.nameTable[edgesOut[0]].sourceNode)) {
                                    targetNode = this.nameTable[this.nameTable[edgesOut[0]].targetNode];
                                    if (targetNode) {
                                        data = $.extend(true, {}, targetNode);
                                        if (this.nameTable[edgesIn[i]].sourceNode != this.nameTable[edgesOut[0]].targetNode) {
                                            this.nameTable[edgesIn[i]].targetNode = this.nameTable[edgesOut[0]].targetNode;
                                            this.nameTable[edgesIn[i]].targetPort = this.nameTable[edgesOut[0]].targetPort;
                                            targetNode.inEdges.push(this.nameTable[edgesIn[i]].name);
                                        }
                                    }
                                    //Updating the Connector Dock and Connector
                                    ej.datavisualization.Diagram.Util.dock(this.nameTable[edgesIn[i]], this.nameTable);
                                    ej.datavisualization.Diagram.DiagramContext.update(this.nameTable[edgesIn[i]], this);
                                }
                            }
                        }
                        if (this.nameTable[edgesOut[0]]) {
                            this.nameTable[edgesOut[0]].sourceNode = null;
                            this.nameTable[edgesOut[0]].sourcePort = null;
                        }
                    }
                    else if (!(node.inEdges.length > 1 && node.outEdges.length > 1)) {
                        // Need to code when many in and only one out 
                        for (i = 0, leni = edgesIn.length; i < leni; i++) {
                            if (node.outEdges.length > 0) {
                                if (this.nameTable[edgesIn[i]]) {
                                    parentNode = this.nameTable[this.nameTable[edgesIn[i]].sourceNode];
                                    data = $.extend(true, {}, parentNode);
                                    for (j = 0, lenj = edgesOut.length; j < lenj; j++) {
                                        if ((this.nameTable[edgesIn[i]].targetNode == this.nameTable[edgesOut[j]].sourceNode)) {
                                            this.nameTable[edgesOut[j]].sourceNode = this.nameTable[edgesIn[i]].sourceNode;
                                            this.nameTable[edgesOut[j]].sourcePort = this.nameTable[edgesIn[i]].sourcePort;
                                            parentNode.outEdges[data.outEdges.length + j] = this.nameTable[edgesOut[j]].name;
                                            //Updating the Connector Dock and Connector
                                            ej.datavisualization.Diagram.Util.dock(this.nameTable[edgesOut[j]], this.nameTable);
                                            ej.datavisualization.Diagram.DiagramContext.update(this.nameTable[edgesOut[j]], this);
                                        }
                                    }
                                    this.nameTable[edgesIn[i]].targetNode = null;
                                    this.nameTable[edgesIn[i]].targetPort = null;
                                }
                            }
                        }
                    }
                } return;
            }
            if (node.inEdges && node.inEdges.length > 0) {
                edgesIn = node.inEdges;
                for (i = 0, leni = edgesIn.length; i < leni; i++) {
                    connector = this.nameTable[edgesIn[i]];
                    if (connector) {
                        connector.targetNode = null;
                        connector.targetPort = null;
                    }
                }
            }
            if (node.outEdges && node.outEdges.length > 0) {
                edgesOut = node.outEdges;
                for (i = 0, leni = edgesOut.length; i < leni; i++) {
                    connector = this.nameTable[edgesOut[i]];
                    if (connector) {
                        connector.sourceNode = null;
                        connector.sourcePort = null;
                    }
                }
            }
        },
        _removeEdges: function (connector) {
            if (connector.targetNode) {
                if (this.nameTable[connector.targetNode] && this.nameTable[connector.targetNode].inEdges)
                    ej.datavisualization.Diagram.Util.removeItem(this.nameTable[connector.targetNode].inEdges, connector.name);
            }
            if (connector.sourceNode) {
                if (this.nameTable[connector.sourceNode] && this.nameTable[connector.sourceNode].outEdges)
                    ej.datavisualization.Diagram.Util.removeItem(this.nameTable[connector.sourceNode].outEdges, connector.name);
            }
        },
        _selectionContains: function (node) {
            if (this._hasSelection() && node)
                for (var i = 0; i < this.selectionList.length; i++) {
                    if (node.name === this.selectionList[i].name)
                        return true;
                }
            return false;
        },
        _getPhaseIndex: function (name) {
            return ej.datavisualization.Diagram.SwimLaneContainerHelper._getPhaseIndex(this, name);
        },
        _getPhaseBounds: function (phase) {
            return ej.datavisualization.Diagram.SwimLaneContainerHelper._getPhaseBounds(this, phase);
        },
        _addSelection: function (selectedShape, preventEvent) {
            if ((ej.datavisualization.Diagram.Util.isPageEditable(this) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this)) && (ej.datavisualization.Diagram.Util.canDoSingleSelection(this) || (selectedShape && selectedShape._type === "pseudoGroup" || this._selectedSymbol) || ej.datavisualization.Diagram.Util.canEnableAPIMethods(this))) {
                if (selectedShape && ej.datavisualization.Diagram.Util.enableLayerOption(selectedShape, "lock", this) && (ej.datavisualization.Diagram.Util.canSelect(selectedShape) || selectedShape.type == "phase")) {
                    if (!this._selectionContains(selectedShape)) {
                        var newItems = [], oldItems = [], selectedItems = [];
                        if (this._previousSelectedItems) oldItems = this._previousSelectedItems;
                        if (selectedShape.type == "pseudoGroup") {
                            var children = this._getChildren(selectedShape.children);
                            for (var i = 0; i < children.length; i++) {
                                var child = this.nameTable[children[i]];
                                if (oldItems.indexOf(child) == -1) newItems.push(child);
                                else ej.datavisualization.Diagram.Util.removeItem(oldItems, child);
                                selectedItems.push(child);
                            }
                        }
                        else {
                            newItems.push(selectedShape);
                            selectedItems.push(selectedShape);
                        }
                        var cause = this._eventCause["selectionChange"];
                        if (!cause)
                            this._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.Unknown;
                        var element = this.getNode(selectedShape)
                        var args = { changeType: "insert", element: this.getNode(selectedShape), state: "changing", selectedItems: selectedItems, oldItems: oldItems, newItems: newItems, cancel: false };
                        if ((!this._selectedSymbol || this._endEditing) && !preventEvent) {
                            this._raiseEvent("selectionChange", args);
                            this._previousSelectedItems = args.newItems;
                        }
                        if (!args.cancel) {
                            this.selectionList.push(selectedShape);
                            this._updateSelectorObject(selectedShape);
                            if (selectedShape.isPhase)
                                var bounds = this._getPhaseBounds(selectedShape);
                            //  if (selectedShape.type !="umlclassifier")
                            ej.datavisualization.Diagram.SvgContext.renderSelector(selectedShape, this._adornerSvg, this._adornerLayer, this._currZoom,
                                this.model.selectedItems.constraints, bounds, this);
                            if ((this.model.selectedItems.userHandles != null && this.model.selectedItems.userHandles.length > 0)) {
                                var isMultipleSelection = false;
                                if (selectedShape.type == "pseudoGroup")
                                    isMultipleSelection = true;
                                if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                                    ej.datavisualization.Diagram.SvgContext.renderUserHandles(this.model.selectedItems.userHandles, selectedShape, this._adornerSvg, isMultipleSelection, this._currZoom, this._adornerLayer, this);
                            }
                            if ((!this._selectedSymbol || this._endEditing) && !preventEvent) {
                                args = { changeType: "insert", element: this.getNode(selectedShape), state: "changed", cause: args.cause, selectedItems: selectedItems, oldItems: oldItems, newItems: newItems, cancel: false };
                                this._raiseEvent("selectionChange", args);
                            }
                        }
                        else {
                            if (selectedShape && selectedShape.type == "pseudoGroup") {
                                ej.datavisualization.Diagram.Util.removeItem(this.nodes(), selectedShape);
                                this._nodes = $.extend(true, [], this.nodes());
                                delete this.nameTable[selectedShape.name];
                            }
                        }
                    }
                }
            }
        },
        _getInsertIndex: function (phase) {
            var index = -1, offset, cphase;
            var group = this.nameTable[phase.parent];
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(this, group);
            if (phases && phases.length > 0) {
                if (this.nameTable[this._getChild(phases[0])]) {
                    offset = this.nameTable[this._getChild(phases[0])].offset;
                    for (var i = 0; i < phases.length; i++) {
                        cphase = this.nameTable[this._getChild(phases[i])];
                        if (cphase && cphase.offset <= phase.offset && cphase.offset >= offset) {
                            offset = cphase.offset;
                            index = i;
                        }
                    }
                }
            }
            return index;
        },
        _updateInsertPhase: function (nphase, ophase, group, index, entryItem) {
            var oldPhase = this.nameTable[ophase];
            var phaseStack = this.nameTable[this._getChild(group.children[1])];

            if (phaseStack && phaseStack.children && phaseStack.children.length > 0) {
                var oldChild = this.nameTable[ophase];
                var newStackChild = ej.datavisualization.Diagram.Node(nphase);
                if (group.isSwimlane && group.orientation && group.orientation == "vertical") {
                    if (entryItem) {
                        h = nphase.height
                        oldChild.height = entryItem.phaseObject.prevPhase.height;
                        oldChild.offset = entryItem.phaseObject.prevPhase.offset;
                    }
                    else {
                        var h = oldChild.height;
                        oldChild.height = oldPhase.offset - nphase.offset;
                        var dH = h - oldChild.height;
                        newStackChild.height = dH;
                    }
                    newStackChild.parent = phaseStack.name;
                    newStackChild.name = nphase.name;
                    newStackChild.width = oldChild.width;
                    newStackChild.isPhase = true;
                }
                else {
                    if (entryItem) {
                        w = nphase.width
                        oldChild.width = entryItem.phaseObject.prevPhase.width;
                        oldChild.offset = entryItem.phaseObject.prevPhase.offset;
                    }
                    else {
                        var w = oldChild.width;
                        oldChild.width = oldPhase.offset - nphase.offset;
                        var dW = w - oldChild.width;
                        newStackChild.width = dW;
                    }
                    newStackChild.parent = phaseStack.name;
                    newStackChild.name = nphase.name;
                    newStackChild.height = oldChild.height;

                    newStackChild.isPhase = true;
                    //var newStackChild = ej.datavisualization.Diagram.Node({ parent: phaseStack.name, name: nphase.name, height: oldChild.height, width: dW, isPhase: true });
                }
                newStackChild.x = 0;
                newStackChild.y = 0;
                if (!this._isUndo || newStackChild.labels.length === 0)
                    newStackChild.labels = [(nphase.label ? nphase.label : ej.datavisualization.Diagram.Label())];
                newStackChild.labels[0].rotateAngle = (nphase.orientation == "horizontal") ? 0 : 270;
                newStackChild.constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.Select | ej.datavisualization.Diagram.NodeConstraints.Connect);
                newStackChild.isPhase = true;
                newStackChild._type = "node";
                this.add(newStackChild, { entryHistory: true });
                //#region swapping the element 
                phaseStack.children.pop(newStackChild);
                phaseStack.children.splice(index, 0, newStackChild);
                //#endregion  
            }
        },
        _getFirstLane: function (group) {
            if (group.children[2])
                var stack = this.nameTable[this._getChild(group.children[2])];
            if (stack && stack.children && stack.children.length > 0) {
                var lane = this.nameTable[this._getChild(stack.children[0])]
                if (lane && lane.children && lane.children.length > 0) {
                    var laneHdr = this.nameTable[this._getChild(lane.children[0])];
                    if (laneHdr)
                        return laneHdr;
                }
            }
            return null;
        },
        updateSelector: function (option) {
            if (this._selectedItem != "") {
                var options = {};
                if (option.offsetX)
                    options.offsetX = Number(typeof option.offsetX === 'function' ? option.offsetX() : option.offsetX);
                if (option.offsetY)
                    options.offsetY = Number(typeof option.offsetY === 'function' ? option.offsetY() : option.offsetY);
                if (option.width)
                    options.width = Number(typeof option.width === 'function' ? option.width() : option.width);
                if (option.height)
                    options.height = Number(typeof option.height === 'function' ? option.height() : option.height);
                if (option.rotateAngle)
                    options.rotateAngle = Number(typeof option.rotateAngle === 'function' ? option.rotateAngle() : option.rotateAngle);
                this.updateNode(this._selectedItem, options);
            }
            if (option.userHandles) {
                this.model.selectedItems.userHandles = option.userHandles;
                this._initHandles();
                if (this.selectionList[0] && this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                    ej.datavisualization.Diagram.SvgContext.updateUserHandles(this.model.selectedItems.userHandles, this.selectionList[0], this._adornerSvg, this.selectionList[0].type == "pseudoGroup", false, this._currZoom, this);
            }
            if (option.tooltip) {
                this.model.selectedItems.tooltip = ej.datavisualization.Diagram.Tooltip($.extend(true, this.model.selectedItems.tooltip, {}, option.tooltip));
            }
        },
        _updateSelectorObject: function (selectedShape) {
            if (!selectedShape.segments) {
                this._selectorOffsetX(selectedShape.offsetX);
                this._selectorOffsetY(selectedShape.offsetY);
                this._selectorWidth(selectedShape.width);
                this._selectorHeight(selectedShape.height);
                this._selectorRotateAngle(selectedShape.rotateAngle);
                this._selectedItem = selectedShape.name;
            }
            if (selectedShape.type == "pseudoGroup") {
                for (var i = 0; i < selectedShape.children.length; i++) {
                    var child = selectedShape.children[i];
                    if (typeof (child) === "object") {
                        if (this.model.selectedItems.children.indexOf(child) < 0)
                            this.model.selectedItems.children.push(child);
                    }
                    else if (typeof (child) === "string") {
                        if (this.model.selectedItems.children.indexOf(this.nameTable[this._getChild(child)]) < 0)
                            this.model.selectedItems.children.push(this.nameTable[this._getChild(child)]);
                    }
                }
            }
            else {
                if (this.model.selectedItems.children.indexOf(selectedShape) < 0)
                    this.model.selectedItems.children.push(selectedShape);
            }
        },
        _clearSelectorObject: function () {
            this._selectorOffsetX(0);
            this._selectorOffsetY(0);
            this._selectorWidth(0);
            this._selectorHeight(0);
            this._selectorRotateAngle(0);
            this._selectedItem = "";
            this.model.selectedItems.children = [];
        },
        _raiseEvent: function (type, args) {
            if (this.model[type]) {
                args.elementType = this.getObjectType(args.element);
                if (((type === "nodeCollectionChange" || type === "connectorCollectionChange" || type === "selectionChange") && args.state === "changing") || type === "scrollChange")
                    args.cause = this._eventCause[type] ? this._eventCause[type] : "unknown";
                if (!this._multipleAction)
                    this._eventCause = {};
                args.diagramId = this.element[0].id;
                return this._trigger(type, args);
            }
        },
        _clearSelection: function (preventEvent) {
            if (this._hasSelection()) {
                if (this._isEditing && this.selectionList.length > 0 && !this._isDragg) {
                    this._endEdit();
                }
                var args = { changeType: "remove", state: "changing", element: null, selectedItems: [], oldItems: this.model.selectedItems.children, newItems: [], cancel: false };
                if (!this._selectedSymbol && !preventEvent) {
                    this._raiseEvent("selectionChange", args);
                    this._previousSelectedItems = [];
                }
                if (!args.cancel) {
                    this._clearSelectorObject();
                    if (this.selectionList[0] && this.selectionList[0].type == "pseudoGroup") {
                        ej.datavisualization.Diagram.Util.removeItem(this.nodes(), this.selectionList[0]);
                        this._nodes = $.extend(true, [], this.nodes());
                        delete this.nameTable[this.selectionList[0].name];
                    }
                    ej.datavisualization.Diagram.Util.clear(this.selectionList);
                    ej.datavisualization.Diagram.SvgContext.clearSelector(this._adornerSvg, this._adornerLayer, this);
                    if (!this._selectedSymbol && !preventEvent) {
                        args = { changeType: "remove", state: "changed", cause: args.cause, element: null, selectedItems: [], oldItems: this.model.selectedItems.children, newItems: [], cancel: false };
                        this._raiseEvent("selectionChange", args);
                    }
                }
            }
        },
        _updateSelectionHandle: function (isDragging) {
            if (this.selectionList.length > 0) {
                var shape = this.selectionList[0]._type == "label" ? this.selectionList[0] : this.nameTable[this.selectionList[0].name];
                var constraints = this.model.selectedItems.constraints;
                if (isDragging && (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles))
                    constraints = constraints & ~ej.datavisualization.Diagram.SelectorConstraints.UserHandles;
                if (this.selectionList[0]._type !== "label")
                    this._updateSelectorObject(shape);
                var updated = ej.datavisualization.Diagram.SvgContext.updateSelector(shape, this._adornerSvg, this._currZoom, this, constraints, this.activeTool._resizeDirection, isDragging);
                if (!updated) {
                    if ((this.model.selectedItems.userHandles != null && this.model.selectedItems.userHandles.length > 0)) {
                        var isMultipleSelection = false;
                        if (shape.type == "pseudoGroup")
                            isMultipleSelection = true;
                        if (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                            ej.datavisualization.Diagram.SvgContext.updateUserHandles(this.model.selectedItems.userHandles, shape, this._adornerSvg, isMultipleSelection, isDragging, this._currZoom, this);
                    }
                }
            }
        },
        _hasSelection: function () {
            return this.selectionList.length > 0;
        },
        _canActivateLabelTool: function (evt, node) {
            if (node) {
                var label = this._findLabelAtPoint(this._mousePosition(evt), node);
                if (label == null) {
                    var targetClass = "", id1, target = evt.target;
                    if (this.model.labelRenderingMode === ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                        var target1 = $(evt.target).parents(".ej-d-label");
                        if (target1[0]) {
                            target = target1[0];
                        }
                    }
                    if (target) {
                        targetClass = target.getAttribute("class");
                        if (targetClass == "ej-d-label") {
                            var id = target.id.split('_');
                            for (var i = 0; i < node.labels.length; i++) {
                                id1 = node.labels[i].name.split('_');
                                if (id[id.length - 1] == id1[id1.length - 1])
                                    label = node.labels[i];
                            }
                        }
                    }
                }
                if (label) {
                    if (ej.datavisualization.Diagram.Util.canMoveLabel(node))
                        return 1;
                    return (ej.datavisualization.Diagram.Util.canSelect(label) || ej.datavisualization.Diagram.Util.canMove(label) ||
                        ej.datavisualization.Diagram.Util.canResize(label) || ej.datavisualization.Diagram.Util.canRotate(label));
                }
            }
            return false;
        },
        _checkToolToActivate: function (evt, node) {
            var success = false, label = false;
            var pseudoGroupConstraints;
            pseudoGroupConstraints = ej.datavisualization.Diagram.Util._getPseudoGroupConstraints(this, node, this.selectionList[0]);
            if (node) {
                if (node.segments && ((navigator.platform.match("Mac") ? evt.metaKey : evt.ctrlKey) && evt.shiftKey) || ((navigator.platform.match("Mac") ? evt.metaKey : evt.ctrlKey) && evt.altKey)) {
                    this._toolToActivate = "endPoint";
                    this._currentCursor = "move";
                    success = true;
                }
                if (!success) {
                    if (evt.target && evt.target.getAttribute("class") != "ej-d-port" && this._selectionContains(node)) {
                        if (node.segments) {
                            success = this._canActivateEndPointTool(evt, node);
                        }
                        else {
                            if (!pseudoGroupConstraints || pseudoGroupConstraints & ej.datavisualization.Diagram.NodeConstraints.Resize)
                                success = this._canActivateResizeTool(evt, node);
                            if (!success) {
                                if ((!pseudoGroupConstraints || (pseudoGroupConstraints & ej.datavisualization.Diagram.NodeConstraints.Rotate)))
                                    success = this._canActivateRotateTool(evt, node);
                            }
                        }
                        if (!success) {
                            success = this._canActivateUserHandle(evt, node);
                        }
                        if (!success) {
                            if (!pseudoGroupConstraints || pseudoGroupConstraints & ej.datavisualization.Diagram.NodeConstraints.Drag)
                                if (node && node.isLane && ej.datavisualization.Diagram.Util.canMultiSelectOnLane(node)) {
                                    this._toolToActivate = "select";
                                    this._currentCursor = "default";
                                }
                                else if ((evt && evt.target) && this._canActivateLabelTool(evt, node) && (evt.target.getAttribute("class") === "ej-d-label" ||
                                    evt.target.parentNode.getAttribute("class") === "ej-d-label" || this.model.labelRenderingMode === ej.datavisualization.Diagram.LabelRenderingMode.Svg)) {
                                    label = true;
                                }
                                else
                                    success = this._canActivateMoveTool(evt, node);
                        }
                        if (!success) {
                            success = this._canActivatephaseTool(evt);
                        }
                    }
                    else {
                        if (evt && evt.target && evt.target.className.baseVal === "ej-d-port") {
                            var point = this._mousePosition(evt);
                            var port = this._findPortAtPoint(point, node);
                            if (port) {
                                var args = this._getvalues(evt);
                                var setTool = this._getSetTool();
                                if (setTool)
                                    setTool(args, port);
                                if ((setTool && args.action === "draw") || (args.action != "drag" && port.constraints & ej.datavisualization.Diagram.PortConstraints.ConnectOnDrag && ej.datavisualization.Diagram.PortConstraints.Connect) && ((port.visibility & ej.datavisualization.Diagram.PortVisibility.Visible) || (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover))) {
                                    this._currentCursor = "crosshair";
                                    var drawType = this.model.drawType;
                                    var type = drawType.segments && drawType.segments.length && drawType.segments[0].type ? drawType.segments[0].type : "orthogonal";
                                    if (type === "orthogonal")
                                        this.activateTool("orthogonalLine", true);
                                    else
                                        this.activateTool("straightLine", true);
                                    this._activatedFromPort = true;
                                    success = true;
                                }
                            }
                        }
                        if (evt && this._canActivateLabelTool(evt, node) && evt.target && (evt.target.getAttribute("class") === "ej-d-label"
                            || evt.target.parentNode.getAttribute("class") === "ej-d-label" || this.model.labelRenderingMode === ej.datavisualization.Diagram.LabelRenderingMode.Svg)) {
                            label = true;
                        }
                        else
                            if (!pseudoGroupConstraints || pseudoGroupConstraints & ej.datavisualization.Diagram.NodeConstraints.Drag)
                                success = this._canActivateMoveTool(evt, node);
                    }
                }
            }
            else {
                success = this._canActivatephaseTool(evt);
            }
            if (port && args.action === "drag") {
                this._currentCursor = "pointer";
                this._toolToActivate = "portTool";
            }
            if (label) {
                this._currentCursor = "pointer";
                this._toolToActivate = "labelMove";
                success = true;
            }
            if (!success) {
                if (this.tool() & ej.datavisualization.Diagram.Tool.ZoomPan) {
                    if (this.tool() & ej.datavisualization.Diagram.Tool.SingleSelect) {
                        var findNode = this._findNodeUnderMouse(evt);
                        if (findNode) {
                            this._toolToActivate = "select";
                            this._currentCursor = "default";
                            success = true;
                        }
                    }
                    if (!success) {
                        this._toolToActivate = "panTool";
                        this._currentCursor = "pointer";
                    }

                }
                else {
                    this._toolToActivate = "select";
                    this._currentCursor = "default";
                }
            }
            if ((this._toolToActivate != "rotate") && (this._toolToActivate != "labelRotate")) {
                this._adornerSvg.document.removeAttribute("class");
            }
            return success;
        },
        _canActivatephaseTool: function (evt) {
            if ($(evt.target).parents(".ej-d-seperator").first()[0]) {
                var id = $(evt.target).parents("g").first()[0].id;
                var phase = this._getSeperetor(id.split('_phase_g')[0]);
                var swimlane = this.nameTable[phase.parent.split("phaseStack")[0]];
                if (swimlane && ej.datavisualization.Diagram.Util.canResize(swimlane)) {
                    if (phase) {
                        if (phase.orientation == "horizontal")
                            this._currentCursor = "e-resize";
                        else
                            this._currentCursor = "n-resize";
                    }
                    else
                        this._currentCursor = "default";
                    this._toolToActivate = "phase";
                    return true;
                }
            }
        },
        _canActivateUserHandle: function (evt) {
            if (this._isUserHandle(evt) && evt.target) {
                var handleName = evt.target.id.split("_")[0];
                this._toolToActivate = handleName;
                this._currentCursor = this.tools[this._toolToActivate].cursor;
                return true;
            }
            return false;
        },

        _canActivateEndPointTool: function (evt, connector) {
            if (connector) {
                var endPointHandle = evt.target.getAttribute("class");
                if (endPointHandle && ((endPointHandle === "targetEndPoint" && ej.datavisualization.Diagram.Util.canDragTargetEnd(connector)) ||
                    (endPointHandle === "sourceEndPoint" && ej.datavisualization.Diagram.Util.canDragSourceEnd(connector)) ||
                    (endPointHandle.match("bezierpoint") || endPointHandle == "segmentEnd") && ej.datavisualization.Diagram.Util.canDragSegmentThumbs(connector))
                ) {
                    this._toolToActivate = "endPoint";
                    this._currentCursor = "move";
                    return true;
                }
            }
            return false;
        },
        _canActivateResizeTool: function (evt, node) {
            var dir = evt.target.getAttribute("class");
            var rotateAngle;
            if (ej.datavisualization.Diagram.Util.canResize(node, dir) && (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.Resizer)) {
                if (dir === "nw-resize" || dir === "n-resize" || dir === "ne-resize" || dir === "w-resize" || dir === "e-resize" || dir === "sw-resize" || dir === "s-resize" || dir === "se-resize") {
                    if (node._type !== "label") {
                        this._toolToActivate = "resize";
                        rotateAngle = node.rotateAngle
                    } else {
                        this._toolToActivate = "labelResize";
                        rotateAngle = this._findLabelRotateAngle(node);
                    }
                    if ((rotateAngle >= 0 && rotateAngle < 25) || (rotateAngle >= 160 && rotateAngle <= 205) || (rotateAngle >= 340 && rotateAngle <= 360)) {
                        this._currentCursor = dir;
                    }
                    else if ((rotateAngle >= 25 && rotateAngle <= 70) || (rotateAngle >= 205 && rotateAngle <= 250)) {

                        if (dir === "n-resize" || dir === "s-resize") {
                            this._currentCursor = "ne-resize";
                        }
                        else if (dir === "nw-resize" || dir === "se-resize") {
                            this._currentCursor = "n-resize";
                        }
                        else if (dir === "e-resize" || dir === "w-resize") {
                            this._currentCursor = "nw-resize";
                        }
                        else {
                            this._currentCursor = "e-resize";
                        }
                    }
                    else if ((rotateAngle >= 70 && rotateAngle <= 115) || (rotateAngle >= 250 && rotateAngle <= 295)) {
                        if (dir === "n-resize" || dir === "s-resize") {
                            this._currentCursor = "e-resize";
                        }
                        else if (dir === "nw-resize" || dir === "se-resize") {
                            this._currentCursor = "ne-resize";
                        }
                        else if (dir === "e-resize" || dir === "w-resize") {
                            this._currentCursor = "n-resize";
                        }
                        else {
                            this._currentCursor = "nw-resize";
                        }
                    }
                    else if ((rotateAngle >= 115 && rotateAngle <= 155) || (rotateAngle >= 295 && rotateAngle <= 340)) {
                        if (dir === "n-resize" || dir === "s-resize") {
                            this._currentCursor = "nw-resize";
                        }
                        else if (dir === "nw-resize" || dir === "se-resize") {
                            this._currentCursor = "e-resize";
                        }
                        else if (dir === "e-resize" || dir === "w-resize") {
                            this._currentCursor = "ne-resize";
                        }
                        else {
                            this._currentCursor = "n-resize";
                        }
                    }
                    return true;
                }
            }
            return false;
        },
        _canActivateMoveTool: function (evt, node) {
            if (evt.target)
                var className = evt.target.className;
            if (className && ej.datavisualization.Diagram.Util.isClassifier(evt))
                var findNode = ej.datavisualization.Diagram.ClassifierHelper.getMovableElementUnderMouse(evt, this);
            else if (className && className.animVal === "ej-d-multiselector" && node && node.type == "pseudoGroup" && ej.datavisualization.Diagram.Util.canDragHelper(this)) {
                findNode = this.selectionList[0];
            }
            else
                findNode = this._findNodeUnderMouse(evt);
            if (findNode && findNode.name === node.name) {
                var canMove = true;
                if (node.parent) {
                    if (this.selectionList.length > 0 && this._selectionContains(node))
                        canMove = true;
                    else
                        canMove = false;
                }
                var swimlane = false;
                if (node.parent) {
                    var parent = this.nameTable[node.parent];
                    if (parent && (((parent.isSwimlane || parent.isLane) && ej.datavisualization.Diagram.Util.canMove(parent)) || parent.isPhaseStack)) {
                        swimlane = true;
                    }
                }
                if (ej.datavisualization.Diagram.Util.canMove(node) || swimlane) {
                    this._toolToActivate = "move";
                    if (this._isHyperLink(evt)) {
                        this._currentCursor = "pointer";
                    }
                    else if (this.selectionList.length > 0 && (this._selectionContains(node) || (this.selectionList[0].children && this._findChildren(this.selectionList[0], node.name)))) {
                        this._currentCursor = "move";
                    }
                    else {
                        this._currentCursor = "default";
                    }
                    return true;
                }
            }
            return false;
        },
        _isLabelTemplate: function (evt) {
            if (evt) {
                var parents = $(evt.target).parents(".ej-label-template");
                var parent = parents[0]
                if (parent) {
                    var id = parent.parentNode.id.split('_');
                    if (id[id.length - 1] == "lblbg") {
                        return true;
                    }
                    else {
                        var parentNode = evt.target.parentNode;
                        var targetClass = parentNode.getAttribute("class");
                        while (parentNode) {
                            if (targetClass === "ej-label-template")
                                return true;
                            parentNode = parentNode.parentNode;
                            targetClass = parentNode.getAttribute("class");
                        }
                    }
                }
            }
        },
        _isHyperLink: function (evt) {
            var target = evt.target;
            var targetClass = target.getAttribute("class");
            if (!targetClass || !targetClass == "ej-d-label") {
                if (target.parentNode)
                    if ($(target.parentNode).hasClass("ej-d-label")) {
                        target = target.parentNode;
                        if ($(target.parentNode).hasClass("ej-d-anchor")) {
                            return true;
                        }
                    }
            }
            return false;
        },
        _canActivateRotateTool: function (evt, node) {
            if (ej.datavisualization.Diagram.Util.canRotate(node) && (this.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.Rotator)) {
                var rotateHandle = evt.target.getAttribute("class");
                if (rotateHandle === "rotateHandle") {
                    if (node._type !== "label")
                        this._toolToActivate = "rotate";
                    else
                        this._toolToActivate = "labelRotate";
                    if (ej.browserInfo().name === "msie") {
                        this._currentcursor = "default";
                        this._adornerSvg.document.setAttribute("class", "svg-rotate-ie");
                        this._currentCursor = "";
                    }
                    else {
                        this._adornerSvg.document.setAttribute("class", "svg-rotate");
                        this._currentCursor = "";
                    }
                    return true;
                }
            }
            return false;
        },
        _canActivatePivotTool: function (evt) {
            var pivotHandle = evt.target.getAttribute("class");
            if (pivotHandle === "pivot") {
                this._toolToActivate = "pivot";
                this._currentCursor = "default";
                return true;
            }
            return false;
        },
        _updateCursor: function () {
            if (!this._isInit) {
                this.element[0].style.cursor = this._currentCursor;
                this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0].style.cursor = this._currentCursor;
            }
        },
        _getResizeCursor: function (resizeDirection) {
            var cursor = "default";
            switch (resizeDirection) {
                case "topleft": cursor = "nw-resize";
                    break;
                case "topcenter": cursor = "n-resize";
                    break;
                case "topright": cursor = "ne-resize";
                    break;
                case "middleleft": cursor = "w-resize";
                    break;
                case "middleright": cursor = "e-resize";
                    break;
                case "bottomleft": cursor = "sw-resize";
                    break;
                case "bottomcenter": cursor = "s-resize";
                    break;
                case "bottomright": cursor = "se-resize";
                    break;
            }
            return cursor;
        },
        _startEdit: function (shape) {
            var label;
            var centerX, centerY;
            var bbox;
            var nodeBounds;
            var bounds;
            var curZoomfactor;
            var matrix = ej.Matrix.identity();
            var width = shape.width ? shape.width : shape._width;
            var height = shape.height ? shape.height : shape._height;
            ej.Matrix.rotate(matrix, shape.rotateAngle, width / 2, height / 2);
            if (shape.type === "text") {
                if (this._svg.getElementById(shape.name + "_shape") !== null)
                    bbox = this._svg.getElementById(shape.name + "_shape").getBBox();
                else
                    bbox = { x: shape.offsetX - width * shape.pivot.x, y: shape.offsetY - height * shape.pivot.y, width: width, height: height };
                label = shape.textBlock;
                if (label && !label.readOnly) {
                    nodeBounds = ej.datavisualization.Diagram.Util.bounds(shape);
                    bounds = new ej.datavisualization.Diagram.Rectangle(bbox.x - label.fontSize, bbox.y - label.fontSize, bbox.width + label.fontSize / 2, bbox.height + label.fontSize / 2);
                    curZoomfactor = this._currZoom;
                    var diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds));
                    centerX = shape.offsetX - width * shape.pivot.x + diff.x;
                    centerY = shape.offsetY - height * shape.pivot.y + diff.y;
                    if (label.horizontalAlignment == "left")
                        centerX += bbox.width / 2;
                    else if (label.horizontalAlignment == "right")
                        centerX -= bbox.width / 2;
                    if (label.verticalAlignment == "top")
                        centerY += bbox.height / 2;
                    else if (label.verticalAlignment == "bottom")
                        centerY -= bbox.height / 2;
                    if (bbox.width === 0 || bbox.height === 0) {
                        bbox = ej.datavisualization.Diagram.Util.bounds(shape);
                        bounds.width = bbox.width == 0 ? 50 : nodeBounds.width * curZoomfactor;
                        bounds.x = (centerX * curZoomfactor - bounds.width / 2 * curZoomfactor) - this._hScrollOffset;

                        bounds.height = label.fontSize;
                        bounds.y = (centerY * curZoomfactor - bounds.height / 2 * curZoomfactor) - this._vScrollOffset;
                    }
                    else {
                        bounds.width = 50;
                        bounds.height = label.fontSize;
                        bounds.x = (centerX * curZoomfactor - (bounds.width / 2 * curZoomfactor)) - this._hScrollOffset;
                        bounds.y = (centerY * curZoomfactor - (bounds.height / 2 * curZoomfactor)) - this._vScrollOffset;
                    }
                    this._boundingBox = bounds;
                    this._createEditBox(label, bounds.x, bounds.y, bounds.width, bounds.height, shape);
                    this._isEditing = true;
                }
            }
            else {
                if (shape.labels.length > 0) {
                    label = this.activeTool.getLabelUnderMouse();
                    if (!label) label = shape.labels[0];
                }
                else {
                    this._newLabelCreated = true;
                    var mNode = this._findNode(shape.name);
                    label = new ej.datavisualization.Diagram.Label({ "name": "label" + ej.datavisualization.Diagram.Util.randomId() });
                    label._parent = shape.name;
                    shape.labels.push(label);
                    var parent = (mNode !== shape) ? mNode : null;
                    ej.datavisualization.Diagram.DiagramContext.addNodeLabel(shape, label, parent, this);
                    if (this.activeTool.name === "textTool")
                        this.activateTool.activeLabel = label;
                }
                if (label && !label.readOnly && label.hyperlink === "" && label.templateId === "") {
                    if (this.model.labelRenderingMode !== "svg") {
                        var htmlLayer = this._htmlLayer ? this._htmlLayer : this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0]
                        var element = $(htmlLayer).find("#" + shape.name + "_" + label.name)[0];
                    }
                    else {
                        var element = this._svg.document.getElementById(shape.name + "_" + label.name);
                    }
                    if (element) {
                        nodeBounds = ej.datavisualization.Diagram.Util.bounds(shape);
                        if (this.model.labelRenderingMode !== "svg") {
                            bounds = new ej.datavisualization.Diagram.Rectangle(element.offsetLeft, element.offsetTop, element.offsetWidth, element.offsetHeight);
                            bbox = bounds;
                        }
                        else {
                            bbox = element.getBBox();
                            bounds = new ej.datavisualization.Diagram.Rectangle(0, 0, bbox.width, bbox.height);
                        }
                        curZoomfactor = this.model.labelRenderingMode != "svg" ? this._currZoom : 1;
                        var position = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds);
                        if (shape.segments || label.relativeMode == "segmentpath") {
                            bounds = element.getBoundingClientRect();
                            bounds = { x: bounds.left, y: bounds.top, width: bounds.width, height: bounds.height };
                            var controlBBox = this._controlBBox ? this._controlBBox : this._canvas.getBoundingClientRect();
                            centerX = (bounds.x + bounds.width / 2 - controlBBox.left + this._hScrollOffset) / curZoomfactor;
                            centerY = (bounds.y + bounds.height / 2 - controlBBox.top + this._vScrollOffset) / curZoomfactor;
                        }
                        else {
                            if (label.horizontalAlignment == "left")
                                position.x += bbox.width / 2;
                            else if (label.horizontalAlignment == "right")
                                position.x -= bbox.width / 2;
                            if (label.verticalAlignment == "top")
                                position.y += bbox.height / 2;
                            else if (label.verticalAlignment == "bottom")
                                position.y -= bbox.height / 2;
                            var diff = ej.Matrix.transform(matrix, position);
                            centerX = shape.offsetX - width * shape.pivot.x + diff.x;
                            centerY = shape.offsetY - height * shape.pivot.y + diff.y;
                        }
                        if (bbox.width === 0 || bbox.height === 0) {
                            bbox = ej.datavisualization.Diagram.Util.bounds(shape);
                            if (shape.segments) {
                                bounds.width = bbox.width < 50 ? 50 : nodeBounds.width;
                                bounds.x = (centerX * curZoomfactor - bounds.width / 2) - this._hScrollOffset;
                            }
                            else {
                                bounds.width = bbox.width < 50 ? 50 : nodeBounds.width;
                                bounds.x = (centerX * curZoomfactor - bounds.width / 2) - this._hScrollOffset;
                            }
                            if (shape.type == "umlclassifier")
                                bounds.height = shape.height;
                            else
                                bounds.height = label.fontSize;
                            bounds.y = (centerY * curZoomfactor - bounds.height / 2 * curZoomfactor) - this._vScrollOffset;
                        }
                        else {
                            bounds.x = (centerX * curZoomfactor - (bounds.width / 2 * curZoomfactor)) - this._hScrollOffset;
                            bounds.y = (centerY * curZoomfactor - (bounds.height / 2 * curZoomfactor)) - this._vScrollOffset;
                        }
                        this._boundingBox = bounds;
                        this._createEditBox(label, bounds.x, bounds.y, bounds.width, bounds.height, shape);
                        this._isEditing = true;
                    }
                    else {
                        this.activeTool.selectedObject = null;
                    }
                }
            }
        },

        _hideShowSVGLabels: function (label, shape, show) {
            if (this._svg && shape) {
                var lblEle;
                if (shape.type === "text")
                    lblEle = this._svg.document.getElementById(shape.name + "_shape_lblbg");
                else
                    lblEle = this._svg.document.getElementById(shape.name + "_" + label.name);
                if (lblEle) {
                    lblEle.setAttribute("visibility", show && (label.visible || shape.visible) ? "visible" : "hidden");
                }

                lblEle = this._svg.document.getElementById(shape.name + "_" + label.name + "_lblbg");
                if (lblEle) {
                    lblEle.setAttribute("visibility", show && label.visible ? "visible" : "hidden");
                }

            }
        },

        _createEditBox: function (label, x, y, width, height, shape) {
            if (this._svg) {
                if (this.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                    this._hideShowSVGLabels(label, shape)
                }
                else {
                    var htmlLayer = this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                    if (htmlLayer) {
                        if (shape.type === "text")
                            var lblEle = $(htmlLayer).find("#" + shape.name + "_shape_lblbg")[0];
                        else
                            var lblEle = $(htmlLayer).find("#" + shape.name + "_" + label.name + "_lblbg")[0];
                        if (lblEle) {
                            lblEle.style.display = "none";
                        }
                    }
                }
                var nodeBounds = ej.datavisualization.Diagram.Util.bounds(shape);
                var div = document.createElement("div");
                if (label.horizontalAlignment == "stretch" && label.textOverflow && label.rotateAngle == 0 && shape.isSwimlane)
                    y = y - label.fontSize;
                else if (label.horizontalAlignment == "stretch" && !shape.isSwimlane && shape._isHeader && label.textOverflow && label.rotateAngle != 0)
                    x = -x - label.fontSize - width / 4;
                var attr = {
                    "id": this.element[0].id + "_editBoxDiv",
                    "class": "edit",
                    "style": "top:" + y + "px;left:" + x + "px;width:" + width + "px;" +
                        "font-family:" + label.fontFamily + ";font-size:" + label.fontSize + "px;min-width: 50px;min-height:" + label.fontSize + "px;",
                };
                if (ej.datavisualization.Diagram.Util.canZoomTextEditor(this))
                    attr.style += "transform: scale(" + this._currZoom + ");";
                ej.datavisualization.Diagram.Util.attr(div, attr);
                var textBox = document.createElement("textarea");
                var fontColor = label.fontColor ? label.fontColor.toLowerCase() : "black";
                fontColor = fontColor != "white" && fontColor != "ffffff" && fontColor != "rgb(255,255,255)" ? fontColor : "black";
                attr = {
                    "id": this.element[0].id + "_editBox",
                    "class": "editBox",
                    "style": "font-size:" + label.fontSize + "px;font-family:" + label.fontFamily + ";min-height:"
                        + label.fontSize + "px; height: " + height + "px; line-height: normal; color:" + fontColor +
                        ";font-weight:" + (label.bold ? "bold" : "normal") + ";font-style:" + (label.italic ? "italic" : "normal") + ";text-decoration:" + (label.textDecoration),
                    "nodeWidth": nodeBounds.width, "nodeHeight": nodeBounds.height, "fontSize": label.fontSize, "nodeOffsetX": shape.offsetX, "nodeOffsetY": shape.offsetY, "containerName": shape.name,
                };
                ej.datavisualization.Diagram.Util.attr(textBox, attr);
                textBox.value = label.text;
                div.appendChild(textBox);
                $(this._canvas).append(div);
                if (label.text !== "") {
                    this._updateEditor(null, div, textBox, nodeBounds.width, label.fontSize, label, shape);
                }
                this._on($(textBox), "focusout", this._editboxfocusout);
                this._on($(textBox), "keyup", this._editBoxKeyUp);
                this._on($(textBox), "input", this._editBoxTextChange);
                this._on($(textBox), "focusin", this._editboxfocusin);
                textBox.focus();
            }
        },
        _editBoxKeyUp: function (evt) {
            this._updateLabelPosition(evt);
        },
        _editBoxTextChange: function (evt) {
            this._updateLabelPosition(evt);
        },
        _updateEditBox: function (x, y) {
            var editBox = document.getElementById(this.element[0].id + "_editBoxDiv");
            if (editBox) {
                editBox.style.left = editBox.offsetLeft - x + "px";
                editBox.style.top = editBox.offsetTop - y + "px";
            }
        },
        _editboxfocusout: function () {
            this._endEditing = true;
            this._endEdit();
            delete this._endEditing;
        },
        _editboxfocusin: function (evt) {
            evt.target.select();
            this._raiseEvent("editorFocusChange", evt);
        },
        _updateLabelPosition: function (evt) {
            var minWidth = 50;
            var curZoomfactor = this._currZoom;
            var parentBoundary = this._boundingBox;
            var fontSize = Number(evt.target.getAttribute("fontSize"));
            var nodeWidth = Number(evt.target.getAttribute("nodeWidth"));
            var conCenterX = parentBoundary.x + (parentBoundary.width / 2);
            var conCenterY = parentBoundary.y + (parentBoundary.height / 2);
            var bounds = this._textLength(evt);
            var width;
            if (bounds.width === 0) {
                width = parentBoundary.width < minWidth ? minWidth : parentBoundary.width;
                evt.target.parentNode.style.width = width + "px";
                evt.target.parentNode.style.left = conCenterX - width / 2 - fontSize / 4 + "px";
            }
            else {
                if (bounds.width <= (nodeWidth * curZoomfactor))
                    width = bounds.width < minWidth ? minWidth : bounds.width;
                else if (bounds.width >= (nodeWidth * curZoomfactor))
                    width = bounds.width > minWidth ? bounds.width : minWidth;
                else
                    width = nodeWidth < minWidth ? minWidth : (nodeWidth * curZoomfactor);
                evt.target.parentNode.style.width = width + "px";
                evt.target.parentNode.style.left = conCenterX - (width / 2) + "px";
            }
            if (bounds.height === 0) {
                evt.target.style.height = fontSize + "px";
                evt.target.parentNode.style.top = conCenterY - fontSize / 2 + 'px';
            }
            else {
                if (this._selectedItem) {
                    var node = this.nameTable[this._selectedItem];
                    if (node.type === "text") {
                        var label = this._currentLabel;
                    }
                }
            }


            this._updateEditor(evt, evt.target.parentNode, evt.target, nodeWidth, fontSize, label);

        },
        _updateEditor: function (evt, div, textBox, nodeWidth, fontSize, label, shape) {
            var offsetX, offsetY;
            var elHeight;
            var bounds = this._textLength(evt, label);
            var curZoomfactor = (this.model.labelRenderingMode != "svg" || (shape && shape.type === "text")) ? this._currZoom : 1;
            var minWidth = 50;
            var x = this._boundingBox.x;
            var y = this._boundingBox.y;
            var width = this._boundingBox.width;
            var height = this._boundingBox.height;
            var str = textBox.value;
            var line = str.split('\n');
            if (!shape)
                shape = this.activeTool.selectedObject;
            if (shape && shape.parent) {
                var node = this.nameTable[shape.parent];
            }
            if (this._nodeUnderMouse) {
                this.old = this._nodeUnderMouse;
                var type = this._nodeUnderMouse.name.match("_attribute") ? "attribute" : (this._nodeUnderMouse.name.match("_method") ? "method" : (this._nodeUnderMouse.name.match("_member") ? "member" : this._nodeUnderMouse.name.match("_header_classifier") ? "header" : "null"));
            }
            if (this.old)
                var type = this.old.name.match("_attribute") ? "attribute" : (this.old.name.match("_method") ? "method" : (this.old.name.match("_member") ? "member" : this.old.name.match("_header_classifier") ? "header" : "null"));
            if (type && type != "null")
                var temp = bounds.width > nodeWidth ? bounds.width : nodeWidth;
            else
                var temp = nodeWidth < bounds.width ? nodeWidth : bounds.width;
            if (this._browserInfo.name === "mozilla") temp += 2;
            var elWidth = temp < minWidth ? minWidth : temp;
            div.style.width = elWidth + "px";
            if (evt)
                offsetX = (elWidth - width) / 2;
            else
                offsetX = (elWidth - width * curZoomfactor) / 2;
            if (node && node.isLane && label && label.horizontalAlignment == "stretch" && label.textOverflow && label.rotateAngle != 0)
                div.style.left = x - offsetX - fontSize - width / 4 + "px";
            else
                div.style.left = x - offsetX - fontSize / 4 + "px";
            if (line.length > 1 || bounds.width != nodeWidth) {
                if (shape && shape.type != "umlclassifier")
                    textBox.style.height = '0';
                elHeight = (this._browserInfo.name === "mozilla") ? textBox.scrollHeight - 5 : textBox.scrollHeight - 4;
            }
            else
                elHeight = fontSize;
            var offset = $(textBox).offset();
            var canvasOffset = $(this._canvas).offset();
            var canvasHeight = $(this._canvas).height();
            if (!canvasHeight)
                canvasHeight = this._getCanvasHeight(this._canvas, canvasHeight);
            if (offset.top - canvasOffset.top + Number(elHeight) > canvasHeight) {
                elHeight = elHeight - ((offset.top - canvasOffset.top + Number(elHeight)) - (canvasHeight));
                if (this._browserInfo.name === "mozilla")
                    elHeight = elHeight - 7;
                else
                    elHeight = elHeight - 6;
            }
            textBox.style.height = elHeight + "px";
            var top = 0;
            if (evt) {
                offsetY = (elHeight - height) / 2;
                top = y - offsetY * curZoomfactor;
            }
            else {
                if (node && node.isSwimlane && label && label.horizontalAlignment == "stretch" && label.textOverflow && label.rotateAngle == 0)
                    offsetY = (elHeight - height * curZoomfactor) / 2 + label.fontSize;
                else
                    offsetY = (elHeight - height * curZoomfactor) / 2;
                top = y - offsetY - 3 * curZoomfactor;
            }

            div.style.top = top + "px";
            this._boundingBox = new ej.datavisualization.Diagram.Rectangle(x - offsetX, top, elWidth, elHeight);
        },
        _getCanvasHeight: function (canvas, canvasHeight) {
            var height = canvasHeight, element = canvas;
            while (height <= 0) {
                element = element.parentNode;
                if (element) {
                    height = $(element).height();
                }
            }
            return height;
        },
        _textLength: function (evt, label) {
            var temp = document.createElement("div");
            var textElement = document.getElementById(this.element[0].id + "_editBox");
            var attr = {
                "id": this.element[0].id + "_editBoxHiddenDiv",
                "style": "position : absolute; width : auto; height : auto;" +
                    "font-size:" + textElement.style.fontSize + "px;font-family:" + textElement.style.fontFamily + ";word-wrap: break-word;white-space:pre-wrap;",
            };
            if (label) {
                attr.style = "position : absolute; width : auto; height : auto;" + "font-weight:" + (label.bold ? "bold" : "normal") + ";font-style:" + (label.italic ? "italic" : "normal") + ";text-decoration:" + (label.textDecoration) + ";font-size:" + label.fontSize + "px;font-family:" + label.fontFamily + ";word-wrap: break-word;white-space:pre-wrap;";
            }
            ej.datavisualization.Diagram.Util.attr(temp, attr);
            if (evt) {
                temp.appendChild(document.createTextNode(evt.target.value));
            } else {
                temp.appendChild(document.createTextNode(textElement.value));
            }
            document.body.appendChild(temp);
            var bounds = temp.getBoundingClientRect();
            document.body.removeChild(temp);
            return bounds;
        },
        _endEdit: function (keyCode) {
            var args, entry, label, prevWidth, prevHeight;
            var editBox = document.getElementById(this.element[0].id + "_editBox");
            if (editBox) {
                var shape = this._findNode(editBox.getAttribute("containerName"));;
                if (this.activeTool.name === "textTool")
                    shape = this.activeTool.selectedObject;
                else if (!shape) {
                    for (var i = 0; i < this.selectionList.length; i++) {
                        var mNode = this.selectionList[i];
                        if (typeof mNode.labels.length != "undefined" && mNode.labels.length > 0 && mNode.labels[0].mode === ej.datavisualization.Diagram.LabelEditMode.Edit)
                            shape = this.selectionList[i];
                    }
                }
                if (shape) {
                    this._isEditing = false;
                    var label;
                    if (shape.type == "text") label = shape.textBlock;
                    else {
                        label = this.activeTool.getLabelUnderMouse();
                        if (!label) label = shape.labels[0];
                    }
                    if (shape.type == "umlclassifier")
                        editBox.value = ej.datavisualization.Diagram.ClassifierHelper.getEditboxValue(editBox.value, shape, this);
                    if (label) var prevText = label.text;
                    if (shape._type == "node" && (!shape.width || !shape.height) && this.nameTable[shape.name]) {
                        prevWidth = shape._width;
                        prevHeight = shape._height;
                        shape.labels[0].text = editBox.value;
                        this._getNodeDimension(shape);
                    }
                    if (shape.type == "umlclassifier")
                        shape = ej.datavisualization.Diagram.ClassifierHelper.getClassifierNodeDimension(shape, this);
                    var tempKeyCode;
                    if (keyCode) {
                        tempKeyCode = keyCode.keyDownEventArgs.keyCode === 27 ? "ESC" : String.fromCharCode(keyCode.keyDownEventArgs.keyCode);
                    }
                    if (editBox.value != prevText)
                        args = this._raiseEvent("textChange", { element: this.getNode(shape), label: label, value: editBox.value, keyCode: tempKeyCode });
                    if (!args) {
                        if (shape && shape.type !== undefined && shape.type === "text") {
                            var oldText = prevText;
                            shape.textBlock.text = editBox.value;
                            shape.textBlock.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                            if (!this._findNode(shape.name)) {
                                if (editBox.value !== "") {
                                    var height = Number(editBox.style.height.substring(0, editBox.style.height.length - 2));
                                    if (shape.height < height) {
                                        shape.offsetY = (shape.offsetY - (shape.height / 2)) + (height / 2);
                                        shape.height = height;
                                    }
                                    if (this.selectionList.length > 0)
                                        this._clearSelection(true);
                                    if (this.tools["move"]._outOfBoundsDrag(shape)) {
                                        this.add(shape);
                                        var parent = this.nameTable[shape.parent];
                                        if (parent && parent.isLane) {
                                            var move = this._moveOnLane(shape, parent);
                                            if (!move.proceedX)
                                                this.updateNode(shape.name, { offsetX: shape.offsetX + move.x });
                                            if (!move.proceedY)
                                                this.updateNode(shape.name, { offsetY: shape.offsetY + move.y });
                                            //delete this._preventDocking;

                                            this._updateNodeMargin(shape);
                                            ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this);
                                            this._disableSwimlaneUptate = true;
                                            ej.datavisualization.Diagram.canvasHelper._updateCollectionChange(this, parent);
                                            if (parent.isLane) {
                                                var swimlane = this._getSwimlane(parent);
                                                if (swimlane) {
                                                    this._updateChildAdjacentConnectors(swimlane, true);
                                                    delete this._disableSwimlaneUptate;
                                                    ej.datavisualization.Diagram.canvasHelper._updateLastPhase(this, swimlane);
                                                    ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this, swimlane);
                                                }
                                            }
                                        }
                                    }
                                }
                                this.activeTool.selectedObject = null;
                            } else {
                                //delete this._preventDocking;
                                ej.datavisualization.Diagram.DiagramContext.update(shape, this);
                                entry = { type: "labelchanged", shape: shape, previousLabelValue: oldText, updatedLabelValue: editBox.value, category: "internal" };
                                this.addHistoryEntry(entry);
                                //entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.TextChangeCmd(shape, shape.textBlock.text, editBox.value));
                                //this.historyManager.addHistoryEntry(entry);
                            }
                        } else if (shape != undefined && !(shape.type == "pseudoGroup")) {
                            if (label != undefined) {
                                this._comparePropertyValues(label, "text", { text: editBox.value });
                                prevText = prevText ? prevText : label.text;
                                if (prevText != editBox.value) {
                                    if (this._newLabelCreated) {
                                        label.text = editBox.value;
                                        entry = { type: "labelcollectionchanged", shape: shape, label: label, isUndo: true, category: "internal" };
                                    }
                                    else entry = { type: "labelchanged", shape: shape, previousLabelValue: label.text, updatedLabelValue: editBox.value, index: shape.labels.indexOf(label), category: "internal" };
                                    this.addHistoryEntry(entry);
                                    //entry = new ej.datavisualization.Diagram.HistoryEntry(new ej.datavisualization.Diagram.LabelChangeCmd(shape, label.text, editBox.value));
                                    //this.historyManager.addHistoryEntry(entry);
                                }
                                label.text = editBox.value;
                                label.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                                ej.datavisualization.Diagram.DiagramContext.updateLabel(shape, label, this);
                                if (shape.isPhase) {
                                    if ((shape.name).split("phaseStack")[1])
                                        var phase = this.nameTable[(shape.name).split("phaseStack")[1]];
                                    if (phase && phase.label)
                                        phase.label.text = editBox.value;
                                }
                                this.activeTool.selectedObject = null;
                            }
                            else if (shape.labels.length == 0) {
                                label = ej.datavisualization.Diagram.Label();
                                label.text = editBox.value;
                                label.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                                label._parent = shape.name;
                                shape.labels.push(label);
                                ej.datavisualization.Diagram.DiagramContext.addNodeLabel(shape, label, null, this);
                            }
                            if (this.activeTool.activeLabel) this.activeTool.activeLabel = null;
                        }
                        if (shape.shape && shape.shape.type == "umlclassifier")
                            shape = ej.datavisualization.Diagram.ClassifierHelper.getUMLConnectorValue(shape, editBox.value, label);
                        if (shape._type == "node" && (!shape.width || !shape.height) && this.nameTable[shape.name]) {
                            ej.datavisualization.Diagram.DiagramContext.update(shape, this);
                            if (shape.parent) ej.datavisualization.Diagram.DiagramContext.update(this.nameTable[shape.parent], this);

                        }

                        if (shape.type == "umlclassifier") {
                            shape.labels[0].text = "";
                            ej.datavisualization.Diagram.DiagramContext.update(shape, this);
                        }
                        if (shape.shape && shape.shape.type == "umlclassifier")
                            ej.datavisualization.Diagram.DiagramContext.update(shape, this);
                    }
                    else {
                        if (shape._width && prevWidth) shape._width = prevWidth;
                        if (shape._height && prevHeight) shape._height = prevHeight;
                        if (shape && shape.type === "text") {
                            ej.datavisualization.Diagram.DiagramContext.update(shape, this);
                        }
                        else {
                            label = this.activeTool.activeLabel ? this.activeTool.activeLabel : (shape.labels.length > 0 ? shape.labels[0] : null);
                            if (label != undefined) {
                                label.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                                ej.datavisualization.Diagram.DiagramContext.updateLabel(shape, label, this);
                            }
                        }
                        if (this.activeTool) {
                            this.activeTool.activeLabel = null;
                            this.activeTool.selectedObject = null;
                        }
                    }
                }
                this._off($(editBox), "focusout", this._editboxfocusout);
                this._off($(editBox), "keyup", this._editBoxKeyUp);
                this._off($(editBox), "input", this._editBoxTextChange);
                var element = $("#" + this.element[0].id + "_editBoxDiv")[0];
                if (element)
                    element.parentNode.removeChild(element);
                if (this._svg) {
                    if (this.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                        this._hideShowSVGLabels(label, shape, true);
                    } else {
                        var htmlLayer = this._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                        if (htmlLayer) {
                            if (shape.type === "text")
                                var lblEle = $(htmlLayer).find("#" + shape.name + "_shape_lblbg")[0];
                            else {
                                if (label)
                                    var lblEle = $(htmlLayer).find("#" + shape.name + "_" + label.name + "_lblbg")[0];
                            }
                            if (lblEle) {
                                lblEle.style.display = "block";
                            }
                        }
                    }
                    if (shape)
                        this._updateQuad(shape);
                }
            }
            if (keyCode && keyCode.keyDownEventArgs && keyCode.keyDownEventArgs.keyCode === 27)
                this.element[0].focus();
            delete this._newLabelCreated;
        },
        _getSwimlane: function (lane) {
            var swimlane;
            lane = typeof (lane) === "string" ? this.nameTable[lane] : lane;
            var laneStack = this.nameTable[lane.parent];
            if (laneStack)
                swimlane = this.nameTable[laneStack.parent];
            return swimlane
        },
        _setLabelEditing: function (label) {
            var success;
            if (label) {
                if (label.readOnly) {
                    label.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                    success = false;
                }
                else {
                    if (this._currentLabel)
                        this._currentLabel.mode = ej.datavisualization.Diagram.LabelEditMode.View;
                    label.mode = ej.datavisualization.Diagram.LabelEditMode.Edit;
                    this._currentLabel = label;
                    success = true;
                }
                return success;
            }
        },
        _isInternalTool: function (tool) {
            if (tool instanceof ej.datavisualization.Diagram.SelectTool || tool instanceof ej.datavisualization.Diagram.ConnectionEditTool || tool instanceof ej.datavisualization.Diagram.MoveTool || tool instanceof ej.datavisualization.Diagram.ResizeTool
                || tool instanceof ej.datavisualization.Diagram.LabelMoveTool || tool instanceof ej.datavisualization.Diagram.LabelResizeTool || tool instanceof ej.datavisualization.Diagram.LabelRotateTool
                || tool instanceof ej.datavisualization.Diagram.PhaseTool || tool instanceof ej.datavisualization.Diagram.RotateTool || (tool instanceof ej.datavisualization.Diagram.PanTool && (this.tool() & ej.datavisualization.Diagram.Tool.SingleSelect) && (this.tool() & ej.datavisualization.Diagram.Tool.ZoomPan)))
                return true;
            else
                return false;
        },
        _updateNodeMargin: function (node) {
            if (node.parent != "") {
                var group = this.nameTable[node.parent];
                if (group && group.container && group.container.type == "canvas") {
                    var groupBounds = ej.datavisualization.Diagram.Util.bounds(group);
                    var bounds1 = ej.datavisualization.Diagram.Util.bounds(node);
                    var bounds = ej.datavisualization.Diagram.Geometry.rect([bounds1.topLeft, bounds1.topRight, bounds1.bottomRight, bounds1.bottomLeft]);
                    node.marginLeft = bounds.x - (groupBounds.x + group.paddingLeft);
                    var right = (groupBounds.x + group.width) - (bounds.x + bounds.width) - group.paddingRight;
                    (right < 0) ? node.marginRight = 0 : node.marginRight = right;
                    node.marginTop = bounds.y - (groupBounds.y + group.paddingTop);
                    var bottom = (groupBounds.y + group.height) - (bounds.y + bounds.height) - group.paddingBottom;
                    (bottom < 0) ? node.marginBottom = 0 : node.marginBottom = bottom;
                    if (group.isLane) {
                        var left = 0, top = 0;
                        if (group.orientation === "horizontal") {
                            left = 50, top = 0;
                        }
                        else {
                            left = 0, top = 50;
                        }
                        node.marginLeft = node.marginLeft >= left ? node.marginLeft : left;
                        node.marginTop = node.marginTop >= top ? node.marginTop : top;
                    }
                }
            }
            if ((node.type == "pseudoGroup" || node.name == "multipleSelection") && node.children.length > 0) {
                var child;
                for (var i = 0; i < node.children.length; i++) {
                    child = this.nameTable[this._getChild(node.children[i])];
                    if (child) {
                        this._updateNodeMargin(child);
                    }
                }
            }
        },
        _raisePropertyChange: function (resource) {
            if (resource) {
                if (this._isSizingCommand)
                    resource.cause = ej.datavisualization.Diagram.ActionType.Size;
                else if (this._isUndo)
                    resource.cause = ej.datavisualization.Diagram.ActionType.HistoryChange;
                else if (this._isTouchedEvent)
                    resource.cause = ej.datavisualization.Diagram.ActionType.Touch;
                this._raiseEvent("propertyChange", resource);
            }
        },
        _updateAdjacentEdges: function (node, connTable) {
            var i, len;
            if (node.inEdges && node.inEdges.length > 0) {
                for (i = 0, len = node.inEdges.length; i < len; i++) {
                    connTable[node.inEdges[i]] = this.nameTable[node.inEdges[i]];
                }
            }
            if (node.outEdges && node.outEdges.length > 0) {
                for (i = 0, len = node.outEdges.length; i < len; i++) {
                    connTable[node.outEdges[i]] = this.nameTable[node.outEdges[i]];
                }
            }
        },
        _translate: function (node, dx, dy, nameTable, isContainer, connectorTable) {
            if (dx || dy) {
                if (!node.segments) {
                    if (!connectorTable) { var init = true; }
                    var connectorTable = connectorTable || {};
                    this._updateAdjacentEdges(node, connectorTable);
                    node.offsetX += dx;
                    node.offsetY += dy;
                    if (!this._parentNode && this.activeTool.name != "phase") this._parentNode = node;
                    if ((node._type === "group" || node.type === "pseudoGroup") && !isContainer) {
                        var nodes = this._getChildren(node.children);
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[this._getChild(nodes[i])];
                            if (child) {
                                this._translate(child, dx, dy, nameTable, undefined, connectorTable);
                                if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], this);
                            }
                        }
                        if (node.type != "group" && node.container)
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                        if (!this._isUndo)
                            this._updateNodeFromGraph(node);
                    }
                    if (node != this.activeTool.helper) {
                        //this._updateAssociatedConnectorEnds(node, nameTable);
                        if (this.nameTable[node.name]) this._updateQuad(node);
                        ej.datavisualization.Diagram.DefautShapes.translateBPMNAnnotationShape(node, dx, dy, null, this);
                        if (!this._isUndo)
                            this._updateNodeFromGraph(node);
                    }
                    if (this._parentNode == node) delete this._parentNode;
                    if (init && !this._preventDocking && node != this.activeTool.helper && !this._disableSegmentChange) {
                        for (var i in connectorTable) {
                            var child = this.nameTable[i];
                            if (child) {
                                if (node.isSwimlane || ((node.type == "pseudoGroup" || node.type == "group") && !this._containsChild(node, child)))
                                    ej.datavisualization.Diagram.Util._translateLine(child, dx, dy, child);
                                this._dock(child, this.nameTable);
                                if (this._isLayoutRoute)
                                    this._routeEdge(child);
                                if (child.annotation) ej.datavisualization.Diagram.DefautShapes.updateAnnotationProperties(child, this);
                            }
                        }
                    }
                } else {
                    ej.datavisualization.Diagram.Util._translateLine(node, dx, dy, node);
                    this._dock(node, nameTable);
                    ej.datavisualization.Diagram.Util.updateBridging(node, this);
                    this._updateConnectorBridging(node);
                }
            }
            else return false;
        },
        _containsChild: function (group, child) {
            if (group.children && group.children.length > 0) {
                var children = this._getChildren(group.children);
                for (var i = 0; i < children.length; i++) {
                    var connector = this._collectionContains(child.name, children);
                    if (!connector) {
                        var subgroup = this._getChild(children[i]);
                        if (subgroup && subgroup.children)
                            this._containsChild(subgroup, child);
                    }
                    else return true;

                }
            }
        },
        _translatePort: function (node, port, dx, dy) {
            port.offset["x"] = port.offset["x"] + dx / node.width;
            port.offset["y"] = port.offset["y"] + dy / node.height;
            ej.datavisualization.Diagram.DiagramContext.updatePort(node, port, this);
            var panel = this._adornerSvg;
            this._updateAssociatedConnectorEnds(node, this.nameTable, true);
        },
        _translateLabel: function (node, label, dx, dy) {
            var preventLabelupdate = false;
            if (node && node.segments && label.relativeMode === "segmentpath" && ej.datavisualization.Diagram.Util.isAllowDragLimit(node)) {
                preventLabelupdate = true;
            }
            if (!preventLabelupdate) {
                var clnLabel = $.extend(true, {}, label);
                label.margin["left"] += dx;
                label.margin["top"] += dy;
                label.margin["right"] -= dx;
                label.margin["bottom"] -= dy;
                if (label.horizontalAlignment == "center") label.margin["right"] = 0;
                if (label.verticalAlignment == "center") label.margin["bottom"] = 0;
                ej.datavisualization.Diagram.DiagramContext.updateLabel(node, label, this);
                this._comparePropertyValues(node, "labels", clnLabel);
            }
        },
        translateLabel: function (node, label, dx, dy) {
            if (node) {
                if (node.segments && label.relativeMode === "segmentpath" && !ej.datavisualization.Diagram.Util.isAllowDragLimit(node)) {
                    var clnLabel = $.extend(true, {}, label);
                    label.margin["left"] += dx;
                    label.margin["top"] += dy;
                    label.margin["right"] -= dx;
                    label.margin["bottom"] -= dy;
                    if (label.horizontalAlignment == "center") label.margin["right"] = 0;
                    if (label.verticalAlignment == "center") label.margin["bottom"] = 0;
                    ej.datavisualization.Diagram.DiagramContext.updateLabel(node, label, this);
                    this._comparePropertyValues(node, "labels", clnLabel);
                }
                else {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    label.offset["x"] += dx / bounds.width;
                    label.offset["y"] += dy / bounds.height;
                    ej.datavisualization.Diagram.DiagramContext.updateLabel(node, label, this);
                }
            }
        },
        _rotate: function (node, angle, nameTable) {
            if (!node.segments && angle) {
                node.rotateAngle += angle;
                node.rotateAngle %= 360;
                if (node.rotateAngle < 0) node.rotateAngle += 360;
                if ((node._type === "group" || node.type === "pseudoGroup")) {
                    var matrix = ej.Matrix.identity();
                    var child, pinx, piny;
                    ej.Matrix.rotate(matrix, angle, node.offsetX, node.offsetY);
                    var nodes = this._getChildren(node.children);
                    var child;
                    for (var i = 0; i < nodes.length; i++) {
                        child = nameTable[nodes[i]];
                        if (child) {
                            if (!(child.segments)) {
                                this._rotate(child, angle, nameTable);
                                pinx = child.offsetX;
                                piny = child.offsetY;
                                var actualpt = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(pinx, piny));
                                this._translate(child, actualpt.x - pinx, actualpt.y - piny, nameTable);
                                this._updateAssociatedConnectorEnds(child, nameTable);
                            } else {
                                if (!child.sourceNode)
                                    this._setEndPoint(child, ej.Matrix.transform(matrix, child.sourcePoint), false);
                                if (!child.targetNode)
                                    this._setEndPoint(child, ej.Matrix.transform(matrix, child.targetPoint), true);
                            }
                            if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], this);
                        }
                    }
                    ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                }
                if (node.parent) {
                    this._updateParentBounds(node.parent);
                }
                if (node != this.activeTool.helper)
                    this._updateQuad(node);
                this._updateAssociatedConnectorEnds(node, nameTable);
            }
        },

        _raiseOffsetPropertyChange: function (shape, offsetX, offsetY, interaction) {
            if (shape && !shape.segments) {
                offsetX = offsetX ? offsetX : 0;
                offsetY = offsetY ? offsetY : 0;
                if (offsetX != shape.offsetX)
                    this._comparePropertyValues(shape, "offsetX", { offsetX: offsetX }, interaction);
                if (offsetY != shape.offsetY)
                    this._comparePropertyValues(shape, "offsetY", { offsetY: offsetY }, interaction);
            }
            else {
                offsetX = offsetX ? offsetX : 0;
                offsetY = offsetY ? offsetY : 0;
                this._comparePropertyValues(shape, "sourcePoint", { sourcePoint: { x: shape.sourcePoint.x + offsetX, y: shape.sourcePoint.y + offsetY } }, interaction);
                this._comparePropertyValues(shape, "targetPoint", { targetPoint: { x: shape.targetPoint.x + offsetX, y: shape.targetPoint.y + offsetY } }, interaction);
            }
        },
        _raiseSizePropertyChange: function (shape, delWidth, delHeight, interaction) {
            if (shape && delHeight && delWidth) {
                var height = shape.height * delHeight;
                var width = shape.width * delWidth;
                if (height != shape.height) {
                    this._comparePropertyValues(shape, "height", { height: height }, interaction);
                    this._comparePropertyValues(shape, "offsetY", { offsetY: shape.offsetY + (height - shape.height) }, interaction);
                }
                if (width != shape.width) {
                    this._comparePropertyValues(shape, "width", { width: width }, interaction);
                    this._comparePropertyValues(shape, "offsetX", { offsetX: shape.offsetX + (width - shape.width) / 2 }, interaction);
                }
            }
        },

        scale: function (node, sw, sh, pivot, nameTable, skipScalOnChild, updateMinMax, isHelper) {
            if ((sw && sw != 1) || (sh && sh != 1) || node.isPhase) {
                if (!node.container) {
                    var matrix = ej.Matrix.identity();
                    if (!node.segments) {
                        if ((node._type === "group" || node.type === "pseudoGroup") && !this._scalePseudoGroup) {
                            if (node.type != "bpmn" || (node.width * sw >= 1 && node.height * sh >= 1)) {
                                var oldOffsetX = { x: node.offsetX, y: node.offsetY }
                                var nodes = this._getChildren(node.children);
                                var child;
                                for (var i = 0; i < nodes.length; i++) {
                                    child = nameTable[nodes[i]];
                                    if (child && (node.type != "bpmn" || ej.datavisualization.Diagram.Util.canResize(child))) {
                                        this.scale(child, sw, sh, pivot, nameTable);
                                        if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                            ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], this);
                                    }
                                }
                                if (node.type == "bpmn")
                                    ej.datavisualization.Diagram.Util._updateBPMNProperties(node, this, nameTable, true);
                                if (node.children.length <= 0) {
                                    ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                                    ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                                    ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                                    var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                                    var width = node.width ? node.width * sw : node._width * sw;
                                    var height = node.height ? node.height * sh : node._height * sh;
                                    if (width > 1) {
                                        if (node.width) {
                                            if (width != node.width) node._scaled = true;
                                            node.width = width;
                                            node.offsetX = newPosition.x;
                                        } else {
                                            if (width != node._width) node._scaled = true;
                                            node.maxWidth = (node.parent && nameTable[node.parent].width != node.maxWidth) ? nameTable[node.parent].width : width;
                                            node.offsetX = newPosition.x - (node._width * sw - node._width) / 2;
                                        }
                                    }
                                    if (height > 1) {
                                        if (node.height) {
                                            if (height != node.height) node._scaled = true;
                                            node.height = height;
                                            node.offsetY = newPosition.y;
                                        } else {
                                            if (height != node._height) node._scaled = true;
                                            node.maxHeight = (node.parent && nameTable[node.parent].height > height) ? nameTable[node.parent].height : height;
                                            node.offsetY = newPosition.y - (node._height * sh - node._height) / 2;
                                        }
                                    }
                                }
                                if (node.type === "pseudoGroup") {
                                    this._scalePseudoGroup = true;
                                    this.scale(node, sw, sh, pivot, nameTable);
                                    delete this._scalePseudoGroup;
                                }
                                else {
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                                }
                                if (node != this.activeTool.helper) ej.datavisualization.Diagram.DefautShapes.translateBPMNAnnotationShape(node, 1 / sw, 1 / sh, oldOffsetX, this);
                            }
                        } else {
                            ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                            ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                            ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                            var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                            var width = node.width * sw;
                            var height = node.height * sh;

                            if (node.maxWidth != 0)
                                width = Math.min(node.maxWidth, width);
                            if (node.minWidth != 0)
                                width = Math.max(node.minWidth, width);
                            if (node.maxHeight != 0)
                                height = Math.min(node.maxHeight, height)
                            if (node.minHeight != 0)
                                height = Math.max(node.minHeight, height);

                            if (width > 0) {
                                if (width != node.width) {
                                    node._scaled = true;
                                }
                                if (width != node.maxWidth && width != node.minWidth) {
                                    node.width = width;
                                    node.offsetX = newPosition.x;
                                    for (var i = 0; i < node.labels.length; i++) {
                                        node.labels[i].width = node.labels[i].width * sw;
                                    }
                                }
                            }

                            if (height > 0) {
                                if (height != node.height) {
                                    node._scaled = true;
                                }
                                if (height != node.maxHeight && height != node.minHeight) {
                                    node.height = height;
                                    node.offsetY = newPosition.y;
                                    for (var i = 0; i < node.labels.length; i++) {
                                        node.labels[i].height = node.labels[i].height * sh;
                                    }
                                }
                            }
                        }
                        if (node.parent) {
                            this._updateParentBounds(node.parent);
                        }
                        ej.datavisualization.Diagram.Util._updateBPMNProperties(node, this, nameTable, true);
                        if (!(this.activeTool.name == "resize" && this.activeTool.inAction && this.selectionList[0] &&
                            this.selectionList[0].type != "pseudoGroup" && this.selectionList[0].type != "group"))
                            this._updateAssociatedConnectorEnds(node, nameTable);
                        if (node != this.activeTool.helper)
                            this._updateQuad(node);
                    } else {
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        for (var i = 0; i < node.segments.length; i++) {
                            var segment = node.segments[i];
                            for (var j = 0; j < segment.points.length; j++) {
                                segment.points[j] = ej.Matrix.transform(matrix, segment.points[j]);
                                if (i == 0 && j == 0 && !node.sourceNode) {
                                    segment._startPoint = segment.points[0];
                                    segment._endPoint = segment.points[segment.points.length - 1];
                                    ej.datavisualization.Diagram.Util._setLineEndPoint(node, ej.Matrix.transform(matrix, node.sourcePoint), false);
                                }
                                if (i == node.segments.length - 1 && j == segment.points.length - 1 && !node.targetNode) {
                                    segment._startPoint = segment.points[0];
                                    segment._endPoint = segment.points[segment.points.length - 1];
                                    node.targetPoint = segment._endPoint;
                                }
                            }
                            segment._startPoint = segment.points[0];
                            segment._endPoint = segment.points[segment.points.length - 1];
                            if (segment.type == "orthogonal") {
                                if (segment.length || segment.length === 0)
                                    segment.length = segment._length = ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                                else
                                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, node.segments[i - 1], node.segments[i + 1], node.sourcePoint, node.targetPoint);
                            } else {
                                if (segment.point) {
                                    segment.point = segment._endPoint;
                                }
                                segment._point = segment._endPoint;
                            }

                        }
                        if (node.sourceNode || node.targetNode)
                            this._dock(node, nameTable);
                    }
                } else {
                    switch (node.container.type) {
                        case "canvas":
                            var newSize = {};
                            var matrix = ej.Matrix.identity();
                            ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                            ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                            ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                            newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                            width = node.width * sw;
                            height = node.height * sh;

                            if (updateMinMax) {
                                node.minHeight = height;
                                node.minWidth = width;
                            }
                            newSize.width = width;
                            newSize.height = height;
                            if (newSize && newSize.width > 1) {
                                var x = node.offsetX - node.width / 2;
                                if (node.width != newSize.width) node._scaled = true;
                                node.width = newSize.width;
                                node.offsetX = node._isBpmn ? newPosition.x : x + node.width / 2;
                            }
                            if (newSize && newSize.height > 1) {
                                var y = node.offsetY - node.height / 2;
                                if (node.height != newSize.height) node._scaled = true;
                                node.height = newSize.height;
                                node.offsetY = node._isBpmn ? newPosition.y : y + node.height / 2;
                            }

                            break;
                        case "stack":
                            var matrix = ej.Matrix.identity();
                            ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                            ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                            ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                            newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                            var marginLeft = 0;
                            var marginRight = 0;
                            if (sw != 0) {
                                marginLeft = node.marginLeft;
                                marginRight = node.marginRight;
                            }
                            width = (node.width * sw) - (marginLeft + marginRight);
                            height = (node.height * sh) - (node.marginTop + node.marginBottom);
                            newSize = { height: node.height, width: node.width }
                            if (this._resizeStack) {
                                node.width = width;
                                node.height = height;

                                node.offsetX = newPosition.x;
                                node.offsetY = newPosition.y;
                            }
                            break;
                    }
                }
            }
        },
        _updateParentBounds: function (node) {
            node = this.nameTable[this._getChild(node)];
            if (node && node.type != "bpmn" && !node.container) {
                ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                ej.datavisualization.Diagram.DiagramContext.update(node, this);
                if (node.parent) {
                    this._updateParentBounds(node.parent);
                }
            }
        },
        _dock: function (connector, nameTable, updateSelection) {
            if (!this._preventDocking && !this._disableSegmentChange && (!this._layoutInAction || !this._isAnimating)) {
                var length = connector.segments.length;
                var srcPointslength = connector.segments[0].points.length;
                var targetPointslength = connector.segments[connector.segments.length - 1].points.length;
                if (this._preventSegmentAdjusting) connector._preventSegmentAdjusting = true;
                ej.datavisualization.Diagram.Util.dock(connector, nameTable, this);
                delete connector._preventSegmentAdjusting;
                if (length != connector.segments.length && this._svg) {
                    ej.datavisualization.Diagram.Util._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort, this);
                    ej.datavisualization.Diagram.DiagramContext._refreshSegments(connector, this);
                }
                if (this.selectionList[0] == connector) {
                    if (updateSelection || srcPointslength != connector.segments[0].points.length || targetPointslength != connector.segments[connector.segments.length - 1].points.length) {
                        ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.selectionList[0], this._adornerSvg, this._currZoom);
                    }
                }
                this._updateQuad(connector);
            }
        },

        _updateChildAdjacentConnectors: function (node, dock) {
            var childTable = this._getChildTable(node, {});
            for (var child in childTable) {
                var childNode = this.nameTable[child];
                if (childNode && childNode.segments && node.children.indexOf(child) == -1) {
                    if (!dock)
                        childNode._staticLength = true;
                    this._dock(childNode, this.nameTable);
                    delete childNode._staticLength;
                    ej.datavisualization.Diagram.DiagramContext.update(childNode, this);
                }
            }
        },

        _setEndPoint: function (connector, point, isTarget) {
            ej.datavisualization.Diagram.Util._setLineEndPoint(connector, point, isTarget);
            this._updateQuad(connector);
        },
        _updateAssociatedConnectorEnds: function (node, nameTable, translatePort) {
            var i, len;
            var connector;
            if (!node.segments && (node.inEdges.length || node.outEdges.length)) {
                //Finding the segment points to avoid calculating path points multiple times to dock every edge
                var nodeToNode = this._isNodeToNodeConnection(node);
                var nodeToDock = node;
                if (node.type == "bpmn" && node._type == "group") {
                    nodeToDock = typeof node.children[0] == "object" ? node.children[0] : this.nameTable[node.children[0]];
                }
                if (nodeToNode) {
                    var segmentPoints = ej.datavisualization.Diagram.Util._findSegmentPoints(nodeToDock);
                }
                var childTable = {};
                if (this._parentNode) {
                    childTable = this._getChildTable(this._parentNode, {});
                }
                for (i = 0, len = node.inEdges.length; i < len; i++) {
                    connector = nameTable[node.inEdges[i]];
                    if (connector && !(this._parentNode && childTable[connector.sourceNode])) {
                        if (!connector.targetPadding) {
                            nodeToDock._segmentPoints = segmentPoints;
                        }
                        else delete nodeToDock._segmentPoints;
                        this._dock(connector, nameTable);
                        if (translatePort)
                            ej.datavisualization.Diagram.DiagramContext.update(connector, this);
                    }
                }
                for (i = 0, len = node.outEdges.length; i < len; i++) {
                    connector = nameTable[node.outEdges[i]];
                    if (connector && !(this._parentNode && childTable[connector.targetNode])) {
                        if (!connector.sourcePadding) { nodeToDock._segmentPoints = segmentPoints; }
                        else delete nodeToDock._segmentPoints;
                        this._dock(connector, nameTable);
                        if (translatePort)
                            ej.datavisualization.Diagram.DiagramContext.update(connector, this);
                    }
                }
                delete nodeToDock._segmentPoints;
            }
        },
        _isNodeToNodeConnection: function (node) {
            var i, len;
            if (node.inEdges.length) {
                for (i = 0, len = node.inEdges.length; i < len; i++) {
                    if (this.nameTable[node.inEdges[i]] && !this.nameTable[node.inEdges[i]].targetPort && (node.type != "bpmn" || this.nameTable[node.inEdges[i]].segments[0].type != "orthogonal")) return true;
                }
            }
            if (node.outEdges.length) {
                for (i = 0, len = node.outEdges.length; i < len; i++) {
                    if (this.nameTable[node.outEdges[i]] && !this.nameTable[node.outEdges[i]].sourcePort && (node.type != "bpmn" || this.nameTable[node.outEdges[i]].segments[this.nameTable[node.outEdges[i]].segments.length - 1].type != "orthogonal")) return true;
                }
            }
        },
        _updateChildBounds: function (node, nameTable) {
            var offX, offY;
            if (node.width == 0 && node.height == 0) {
                offX = node.offsetX;
                offY = node.offsetY;
                ej.datavisualization.Diagram.Util._updateGroupBounds(node, this);
                this._translate(node, offX - node.offsetX, offY - node.offsetY, nameTable);
            }
            else {
                offX = node.offsetX;
                offY = node.offsetY;
                var childBounds = ej.datavisualization.Diagram.Util._getChildrenBounds(node, this);
                node.offsetX = (childBounds.x + childBounds.width * node.pivot.x);
                node.offsetY = (childBounds.y + childBounds.height * node.pivot.y);
                var dx = offX - node.offsetX;
                var dy = offX - node.offsetY;
                this._translate(node, dx, dy, nameTable);
                var deltaWidth = node.width / childBounds.width;
                var deltaHeight = node.height / childBounds.height;
                this.scale(node, deltaWidth, deltaHeight, node.pivot, nameTable);;
                this._translate(node, offX - node.offsetX, offY - node.offsetY, nameTable);
            }
        },
        _isLastChildOfParent: function (object) {
            var parent = this.nameTable[object.parent], child;
            if (parent.children) {
                for (var i = 0; i < parent.children.length; i++) {
                    child = this.nameTable[this._getChild(parent.children[i])];
                    if (child && child.name == object.name && i == parent.children.length - 1) {
                        return true;
                    }
                }
            }
            return false;
        },
        _updateQuad: function (object) {
            if (this._spatialSearch && this.nameTable[object.name]) {
                var type = this.getObjectType(object), skip = false;
                if (object.isPhase || object.isLane || object._isHeader || object.isLaneStack || object.isPhaseStack || object._isInternalShape || object.type == "pseudoGroup") skip = true;
                if (object.parent && this.nameTable[object.parent]) {
                    var parent = this.nameTable[object.parent];
                    if (parent.isPhaseStack || parent.isSwimlane) skip = true;
                    if (parent.type != "bpmn" && this._isLastChildOfParent(object)) this._updateQuad(parent);
                }
                if (this._selectedSymbol != null)
                    if (this._selectedSymbol.isLane && object.isLane && !object.parent) {
                        skip = false;
                    }
                if (this._disableUpdateQuad)
                    skip = true;
                if (!skip && !object._connectorType) {
                    this._spatialSearch._isRouting = ej.datavisualization.Diagram.Util.canRouteDiagram(this);
                    if (this._spatialSearch._isRouting) {
                        var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this);
                        this._spatialSearch._viewPortWidth = viewPort.width || 1000;
                        this._spatialSearch._viewPortHeight = viewPort.height || 1000;
                    }
                    ej.datavisualization.Diagram.SpatialUtil._updateQuad(this, this._spatialSearch, object);
                    if (this._spatialSearch._isRouting) {
                        delete this._spatialSearch._isRouting;
                        delete this._spatialSearch._viewPortWidth;
                        delete this._spatialSearch._viewPortHeight;
                    }
                }
            }
        },
        _sliceDockLines: function (list) {
            var list1 = $.extend({}, list);
            var child = null;
            for (var i in list1) {
                child = this.nameTable[this._getChild(list1[i])];
                if (child && child.segments) {
                    if (child.sourceNode || child.targetNode) {
                        list.pop(child.name);
                    }
                }
            }
        },
        _canExecute: function () {
            if (this._isEditing && (this._currentCommand == "delete" || this._currentCommand == "cut" || this._currentCommand == "focusToPreviousItem" ||
                this._currentCommand == "undo" || this._currentCommand == "redo" || this._currentCommand == "focusToNextItem" || this._currentCommand == "selectFocusedItem" ||
                this._currentCommand == "selectAll" || this._currentCommand == "copy" || this._currentCommand == "paste" || this._currentCommand.match("nudge")))
                return false;
            if (this._currentCommand == "endEdit" && !this._isEditing) return false;
            return true;
        },

        _setItemDraggable: function (container) {
            var diagram = this;
            var perventAddingConnector = false;
            this._canDragGlobally = true;
            $(container).ejDraggable({
                clone: true,
                helper: function (event) {
                    this._selectedSymbol = null;
                    this._isDragged = false;
                    var svg = diagram._renderItemContainer("diagram_clone", document.body);
                    svg.document.setAttribute("drag", "true");
                    if (diagram.activeTool && diagram.activeTool.selectedObject && !diagram.activeTool.helper) {
                        var item = $.extend(true, {}, diagram.activeTool.selectedObject);
                        diagram._updateChildren(item);
                        diagram.edgeTable = {};
                        diagram.edgeTable = diagram._getEdgeTable(item, diagram.edgeTable);
                        this._updateSelectedItem(item, item.isSwimlane);
                        this._selectedSymbol = item;
                        this._isDragged = false;
                        this._targetId = diagram._id;
                        var bounds = ej.datavisualization.Diagram.Util.bounds(item);
                        this.cursorAt = { top: 105, left: 105 };
                        var node = ej.datavisualization.Diagram.NodeType({ offsetX: item.offsetX, offsetY: item.offsetY, width: 100, height: 100, shape: "path", opacity: 0.5, pathData: "M49.955,50.7915L1.74601,99L98.164,99zM1,1.83699L1,98.332L49.2477,50.0843zM99,1.74699L50.662,50.0845L99,98.422zM1.57701,1L49.9548,49.3773L98.332,1zM0,0L100,0L100,100L0,100z " }, diagram);
                        node = diagram._getNewNode(node);
                        ej.datavisualization.Diagram.SvgContext.renderNode(node, svg, null, true, diagram);
                    }
                    var helper = document.getElementById("diagram_clone_paletteItem");
                    $(helper).addClass("dragClone");
                    $(helper).css("display", "none");
                    return $(helper);
                },
                drag: function (evt) {
                    var diagramElement = $(evt.target).parents(".e-datavisualization-diagram");
                    if (diagramElement.length) {
                        var diagram = $("#" + diagramElement.attr("id")).ejDiagram("instance");
                        if ((this.model._isDragged || this.model._targetId != diagram._id) && this.model._selectedSymbol) {
                            if (!this.model._isDragged && this.model._targetId != diagram._id) {
                                var instance = $("#" + this.model._targetId).ejDiagram("instance");
                                instance._delete(instance.nameTable[this.model._selectedSymbol.name]);
                                perventAddingConnector = false;
                                var cur = instance._historyList.currentEntry;
                                var pre = cur.previous;
                                cur.object = pre.undoObject.node;
                                if (pre.undoObject.childTable) cur.childTable = pre.undoObject.childTable;
                                if (pre.undoObject.edgeTable) cur.edgeTable = pre.undoObject.edgeTable;
                                instance.removeHistoryEntry(pre);
                            }
                            else if (this.model._targetId != diagram._id) {
                                if (diagram.edgeTable) delete diagram.edgeTable;
                                perventAddingConnector = false;
                            }
                            this.model._isDragged = true;
                            diagram._selectedSymbol = this.model._selectedSymbol;
                            diagram._isNodeEnters = true;
                            var item = diagram._selectedSymbol;
                            var scale = diagram._currZoom;
                            var offset = $("#" + diagram.element[0].id).offset();
                            var coor = diagram._isTouchEvent(evt.event);
                            var x = ((coor ? coor.pageX : evt.event.pageX) + diagram._hScrollOffset - offset.left) / scale;
                            var y = ((coor ? coor.pageY : evt.event.pageY) + diagram._vScrollOffset - offset.top) / scale;
                            if (!item.segments)
                                this.model._translate(item, x - item.offsetX / scale, y - item.offsetY / scale);
                            else
                                this.model._translate(item, x - (item.sourcePoint.x + item.targetPoint.x) / 2 * scale, y - (item.sourcePoint.y + item.targetPoint.y) / 2 * scale);
                            if (this.model._isDragged && diagram.edgeTable && diagram.nameTable[item.name] && !perventAddingConnector && item.type != "pseudoGroup") {
                                for (var conn in diagram.edgeTable) {
                                    if (!diagram.nameTable[conn]) diagram.add(diagram.edgeTable[conn]);
                                    else {
                                        var connector = diagram.nameTable[conn];
                                        connector.sourceNode = diagram.edgeTable[conn].sourceNode;
                                        connector.sourcePort = diagram.edgeTable[conn].sourcePort;
                                        connector.targetNode = diagram.edgeTable[conn].targetNode;
                                        connector.targetPort = diagram.edgeTable[conn].targetPort;
                                    }
                                }
                                diagram._clearSelection(true);
                                diagram._addSelection(diagram.nameTable[item.name], true);
                                perventAddingConnector = true;
                            }
                        }
                        this.helper.css("display", "none");
                    }
                    else if (this.model._selectedSymbol) {
                        var diagram = $("#" + this.model._targetId).ejDiagram("instance");
                        diagram._delete(diagram.nameTable[this.model._selectedSymbol.name]);
                        perventAddingConnector = false;
                        if (!this.model._isDragged) {
                            var cur = diagram._historyList.currentEntry;
                            var pre = cur.previous;
                            cur.object = pre.undoObject.node;
                            if (pre.undoObject.childTable) cur.childTable = pre.undoObject.childTable;
                            if (pre.undoObject.edgeTable) cur.edgeTable = pre.undoObject.edgeTable;
                            diagram.removeHistoryEntry(pre);
                        }
                        this.helper.css("display", "block");
                        this.model._isDragged = true;
                    }
                    $('html,body').css('cursor', 'no-drop');
                },
                dragStop: function (evt, ui) {
                    var diagramElement = $(evt.target).parents(".e-datavisualization-diagram");
                    if (diagramElement) {
                        var diagram = $("#" + diagramElement.attr("id")).ejDiagram("instance");
                        if (this.model._isDragged && this.model._targetId == diagram._id) {
                            var cur = diagram._historyList.currentEntry;
                            var pre = cur.previous;
                            cur.undoObject.node = pre.object;
                            if (pre.childTable) cur.undoObject.childTable = pre.childTable;
                            if (pre.edgeTable) cur.undoObject.edgeTable = pre.edgeTable;
                            diagram.removeHistoryEntry(pre);
                        }
                        diagram._selectedSymbol = null;
                        delete diagram._isNodeEnters;

                    }
                    $(this.helper).remove();
                    $('html,body').css('cursor', 'default');
                },
                _translate: function (item, dx, dy) {
                    if (!item.segments) {
                        item.offsetX += dx;
                        item.offsetY += dy;
                        if (item.type == "pseudoGroup" || item.type == "group") {
                            for (var i = 0; i < item.children.length; i++)
                                this._translate(item.children[i], dx, dy);
                        }
                    }
                    else {
                        ej.datavisualization.Diagram.Util._translateLine(item, dx, dy, item);
                    }
                },
                _updateSelectedItem: function (item, isSwimlane) {
                    if (item.type == "pseudoGroup" || item.type == "group") {
                        for (var i = 0; i < item.children.length; i++) {
                            if (typeof item.children[i] === "string")
                                item.children[i] = diagram.nameTable[diagram._getChild(item.children[i])];
                            this._updateSelectedItem(item.children[i], isSwimlane);
                        }
                    }
                    if (!isSwimlane) {
                        if (!item.segments) {
                            for (var i = 0; i < item.inEdges.length; i++) {
                                var edge = diagram.findNode(item.inEdges[i]);
                                if (diagram.model.selectedItems.children.indexOf(edge) == -1) item.inEdges.splice(i, 1);
                            }
                            for (var i = 0; i < item.outEdges.length; i++) {
                                var edge = diagram.findNode(item.outEdges[i]);
                                if (diagram.model.selectedItems.children.indexOf(edge) == -1) item.outEdges.splice(i, 1);
                            }
                        }
                        else
                            item.sourceNode = item.targetNode = item.sourcePort = item.targetPort = "";
                    }
                }
            });
        },

        _renderItemContainer: function (id, content) {
            var container = document.createElement("div");
            var bounds = { width: 100, height: 100 };
            var attr = { "id": id + "_paletteItem", "draggable": "true", "height": bounds.height + "px", "width": bounds.width + "px", "style": "padding: 4; height:" + (bounds.height + 1) + "px;width:" + (bounds.width + 1) + "px;-ms-touch-action: none;touch-action: none;" };
            ej.datavisualization.Diagram.Util.attr(container, attr);
            content.appendChild(container);
            this._setItemDraggable(container);
            return this._renderAnchor(container, id, bounds);
        },
        _renderAnchor: function (container, id, itemSize) {
            var anchor = document.createElement("div");
            var attr = { "id": id + "_anchor", "height": itemSize.height + "px", "class": "e-anchor" };
            ej.datavisualization.Diagram.Util.attr(anchor, attr);
            container.appendChild(anchor);
            return this._renderSvg(anchor, id, itemSize);
        },
        _renderSvg: function (anchor, id, itemSize) {
            var parent;
            var wrapper = document.createElement("div");
            var attr = { "id": id + "_svgWrapper", "class": "e-svg-container", "style": "width:" + itemSize.width + "px;height:" + itemSize.height + "px;" };
            ej.datavisualization.Diagram.Util.attr(wrapper, attr);
            attr = {
                "id": id + "_svg", "width": itemSize.width, "height": itemSize.height,
                "version": "1.1", "xlink": "http://www.w3.org/1999/xlink"
            };
            var svg = new ej.datavisualization.Diagram.Svg(attr);
            wrapper.appendChild(svg.document);
            anchor.appendChild(wrapper);
            return svg;
        },
        //#endregion
    });
    ej.datavisualization.Diagram.Locale = {};

    ej.datavisualization.Diagram.Locale["default"] = {
        cut: "Cut",
        copy: "Copy",
        paste: "Paste",
        undo: "Undo",
        redo: "Redo",
        selectAll: "Select All",
        grouping: "Grouping",
        group: "Group",
        ungroup: "Ungroup",
        order: "Order",
        bringToFront: "Bring To Front",
        moveForward: "Move Forward",
        sendBackward: "Send Backward",
        sendToBack: "Send To Back"
    }

    ej.datavisualization.Diagram.Locale["en-US"] = {
        cut: "Cut",
        copy: "Copy",
        paste: "Paste",
        undo: "Undo",
        redo: "Redo",
        selectAll: "Select All",
        grouping: "Grouping",
        group: "Group",
        ungroup: "Ungroup",
        order: "Order",
        bringToFront: "Bring To Front",
        moveForward: "Move Forward",
        sendBackward: "Send Backward",
        sendToBack: "Send To Back"
    }

    $.fn.pinchDiagram = function (rootgroup, map) {
        var startTouches = [],
            handleTouchStart = function (evt) {
                var touches = evt.touches;
                if (touches.length >= 2) {
                    for (var i = 0; i < touches.length; i++) {
                        var touch = touches[i]
                            , found = false;
                        for (var j = 0; j < startTouches.length; j++) {
                            var startTouch = startTouches[j];
                            if (touch.identifier === startTouch.identifier) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            var touchCopy = $.extend({}, touch);
                            startTouches.push(touchCopy);
                        }
                    }
                }
                evt.preventDefault();
            },
            getDistance = function (touch1, touch2) {
                var x = touch2.pageX - touch1.pageX,
                    y = touch2.pageY - touch1.pageY;
                return Math.sqrt((x * x) + (y * y));
            },
            handleTouchEnd = function (evt) {
                var changedTouches = evt.changedTouches;
                for (var i = 0; i < changedTouches.length; i++) {
                    var changedTouch = changedTouches[i];
                    for (var j = 0; j < startTouches.length; j++) {
                        var startTouch = startTouches[j];
                        if (startTouch.identifier === changedTouch.identifier) {
                            var idx = startTouches.indexOf(startTouch);
                            startTouches.splice(idx, 1);
                        }
                    }
                }
                evt.preventDefault();
            },
            updateTouch = function (dstTouch, srcTouch) {
                dstTouch.pageX = srcTouch.pageX;
                dstTouch.pageY = srcTouch.pageY;
            },
            handleTouchMove = function (evt) {
                evt.preventDefault();
                var touches = evt.touches, z;
                if (touches.length >= 2) {
                    var touch0 = touches[0]
                        , touch1 = touches[1]
                        , startTouch0 = startTouches[0]
                        , startTouch1 = startTouches[1];
                    z = getDistance(touch0, touch1) / getDistance(startTouch0, startTouch1);
                    var focusPoint = map._mousePosition(evt, false);
                    ej.datavisualization.Diagram.ZoomUtil.zoomPan(map, z, 0, 0, focusPoint, true, true);
                    updateTouch(startTouch0, touch0);
                    updateTouch(startTouch1, touch1);
                }
            };
        this[0].addEventListener('touchstart', handleTouchStart, false);
        this[0].addEventListener('touchend', handleTouchEnd, false);
        this[0].addEventListener('touchmove', handleTouchMove, false);
    };
    //#endregion
})(jQuery, Syncfusion);;
(function ($, ej) {
    "use strict";
    ej.MatrixTypes = { Identity: 0, Translation: 1, Scaling: 2, Unknown: 4 };
    ej.MatrixDefaults = { m11: 1, m12: 0, m21: 0, m22: 1, offsetX: 0, offsetY: 0, type: ej.MatrixTypes.Identity };
    ej.Matrix = {
        identity: function () {
            return $.extend(true, {}, ej.MatrixDefaults);
        },
        multiply: function (matrix1, matrix2) {
            var type = matrix1.type;
            var type2 = matrix2.type;
            if (type2 == ej.MatrixTypes.Identity) {
                return;
            }
            if (type == ej.MatrixTypes.Identity) {
                matrix1.m11 = matrix2.m11;
                matrix1.m12 = matrix2.m12;
                matrix1.m21 = matrix2.m21;
                matrix1.m22 = matrix2.m22;
                matrix1.offsetX = matrix2.offsetX;
                matrix1.offsetY = matrix2.offsetY;
                matrix1.type = matrix2.type;
                return;
            }
            if (type2 == ej.MatrixTypes.Translation) {
                matrix1.offsetX += matrix2.offsetX;
                matrix1.offsetY += matrix2.offsetY;
                if (type != ej.MatrixTypes.Unknown) {
                    matrix1.type |= ej.MatrixTypes.Translation;
                }
                return;
            }
            if (type != ej.MatrixTypes.Translation) {
                var num = type << 4 | type2;
                switch (num) {
                    case 34:
                        matrix1.m11 *= matrix2.m11;
                        matrix1.m22 *= matrix2.m22;
                        return;
                    case 35:
                        matrix1.m11 *= matrix2.m11;
                        matrix1.m22 *= matrix2.m22;
                        matrix1.offsetX = matrix2.offsetX;
                        matrix1.offsetY = matrix2.offsetY;
                        matrix1.type = (ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling);
                        return;
                    case 36: break;
                    default:
                        {
                            switch (num) {
                                case 50:
                                    matrix1.m11 *= matrix2.m11;
                                    matrix1.m22 *= matrix2.m22;
                                    matrix1.offsetX *= matrix2.m11;
                                    matrix1.offsetY *= matrix2.m22;
                                    return;
                                case 51:
                                    matrix1.m11 *= matrix2.m11;
                                    matrix1.m22 *= matrix2.m22;
                                    matrix1.offsetX = matrix2.m11 * matrix1.offsetX + matrix2.offsetX;
                                    matrix1.offsetY = matrix2.m22 * matrix1.offsetY + matrix2.offsetY;
                                    return;
                                case 52: break;
                                default:
                                    switch (num) {
                                        case 66:
                                        case 67:
                                        case 68: break;
                                        default: return;
                                    }
                                    break;
                            }
                            break;
                        }
                }
                var result = this.identity();
                this._setMatrix(result, matrix1.m11 * matrix2.m11 + matrix1.m12 * matrix2.m21,
                    matrix1.m11 * matrix2.m12 + matrix1.m12 * matrix2.m22, matrix1.m21 * matrix2.m11 + matrix1.m22 * matrix2.m21,
                    matrix1.m21 * matrix2.m12 + matrix1.m22 * matrix2.m22,
                    matrix1.offsetX * matrix2.m11 + matrix1.offsetY * matrix2.m21 + matrix2.offsetX, matrix1.offsetX * matrix2.m12 + matrix1.offsetY * matrix2.m22 + matrix2.offsetY);
                if (result.m21 || result.m12) {
                    result.type = ej.MatrixTypes.Unknown;
                }
                else {
                    if (result.m11 && result.m11 != 1.0 || result.m22 && result.m22 != 1.0) {
                        result.type = ej.MatrixTypes.Scaling;
                    }
                    if (result.offsetX || result.offsetY) {
                        result.type |= ej.MatrixTypes.Translation;
                    }
                    if ((result.type & (ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling)) == ej.MatrixTypes.Identity) {
                        result.type = ej.MatrixTypes.Identity;
                    }
                }
                matrix1.m11 = result.m11;
                matrix1.m12 = result.m12;
                matrix1.m21 = result.m21;
                matrix1.m22 = result.m22;
                matrix1.offsetX = result.offsetX;
                matrix1.offsetY = result.offsetY;
                matrix1.type = result.type;
                return;
            }
            var offsetX = matrix1.offsetX;
            var offsetY = matrix1.offsetY;
            matrix1.m11 = matrix2.m11;
            matrix1.m12 = matrix2.m12;
            matrix1.m21 = matrix2.m21;
            matrix1.m22 = matrix2.m22;
            matrix1.offsetX = matrix2.offsetX;
            matrix1.offsetY = matrix2.offsetY;
            matrix1.type = matrix2.type;
            matrix1.offsetX = offsetX * matrix2.m11 + offsetY * matrix2.m21 + matrix2.offsetX;
            matrix1.offsetY = offsetX * matrix2.m12 + offsetY * matrix2.m22 + matrix2.offsetY;
            if (type2 == ej.MatrixTypes.Unknown) {
                matrix1.type = ej.MatrixTypes.Unknown;
                return;
            }
            matrix1.type = (ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling);
        },
        transform: function (matrix, point) {
            var pt = this._multiplyPoint(matrix, point.x, point.y);
            return { x: Math.round(pt.x * 100) / 100, y: Math.round(pt.y * 100) / 100 };
        },
        rotate: function (matrix, angle, centerX, centerY) {
            angle %= 360.0;
            this.multiply(matrix, this._createRotationRadians(angle * 0.017453292519943295, centerX ? centerX : 0, centerY ? centerY : 0));
        },
        scale: function (matrix, scaleX, scaleY, centerX, centerY) {
            this.multiply(matrix, this._createScaling(scaleX, scaleY, centerX ? centerX : 0, centerY ? centerY : 0));
        },
        translate: function (matrix, offsetX, offsetY) {
            if (matrix.type & ej.MatrixTypes.Identity) {
                this._setMatrix(matrix, 1.0, 0.0, 0.0, 1.0, offsetX, offsetY, ej.MatrixTypes.Translation);
                return;
            }
            if (matrix.type & ej.MatrixTypes.Unknown) {
                matrix.offsetX += offsetX;
                matrix.offsetY += offsetY;
                return;
            }
            matrix.offsetX += offsetX;
            matrix.offsetY += offsetY;
            matrix.type |= ej.MatrixTypes.Translation;
        },
        _createScaling: function (scaleX, scaleY, centerX, centerY) {
            var result = this.identity();
            this._setMatrix(result, scaleX, 0.0, 0.0, scaleY, centerX - scaleX * centerX, centerY - scaleY * centerY,
                !(centerX || centerY) ? ej.MatrixTypes.Scaling : ej.MatrixTypes.Scaling | ej.MatrixTypes.Translation);
            return result;
        },
        _createRotationRadians: function (angle, centerX, centerY) {
            var result = this.identity();
            var num = Math.sin(angle);
            var num2 = Math.cos(angle);
            var offsetX = centerX * (1.0 - num2) + centerY * num;
            var offsetY = centerY * (1.0 - num2) - centerX * num;
            this._setMatrix(result, num2, num, -num, num2, offsetX, offsetY, ej.MatrixTypes.Unknown);
            return result;
        },
        _multiplyPoint: function (matrix, x, y) {
            switch (matrix.type) {
                case ej.MatrixTypes.Identity: break;
                case ej.MatrixTypes.Translation:
                    x += matrix.offsetX;
                    y += matrix.offsetY;
                    break;
                case ej.MatrixTypes.Scaling:
                    x *= matrix.m11;
                    y *= matrix.m22;
                    break;
                case ej.MatrixTypes.Translation | ej.MatrixTypes.Scaling:
                    x *= matrix.m11;
                    x += matrix.offsetX;
                    y *= matrix.m22;
                    y += matrix.offsetY;
                    break;
                default:
                    var num = y * matrix.m21 + matrix.offsetX;
                    var num2 = x * matrix.m12 + matrix.offsetY;
                    x *= matrix.m11;
                    x += num;
                    y *= matrix.m22;
                    y += num2;
                    break;
            }
            return { x: x, y: y };
        },
        _setMatrix: function (matrix, m11, m12, m21, m22, offsetX, offsetY, type) {
            matrix.m11 = m11;
            matrix.m12 = m12;
            matrix.m21 = m21;
            matrix.m22 = m22;
            matrix.offsetX = offsetX;
            matrix.offsetY = offsetY;
            matrix.type = type || ej.MatrixTypes.Identity;
        }
    };
})(jQuery, Syncfusion);;
/**
* @fileOverview Plugin to style the Html Button elements
* @copyright Copyright Syncfusion Inc. 2001 - 2020. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej) {
    "use strict";
    //#region HitTesting
    ej.datavisualization.Diagram.HitTesting = {
        _getResizeHandleCenter: function (shape, position, scale) {
            if (!scale) scale = 1;
            var corners = this.bounds(shape);
            var center = ej.datavisualization.Diagram.Point(0, 0);
            switch (position) {
                case "topleft":
                    center = corners.topLeft;
                    break;
                case "topcenter":
                    center = corners.top;
                    break;
                case "topright":
                    center = corners.topRight;
                    break;
                case "middleleft":
                    center = corners.left;
                    break;
                case "middleright":
                    center = corners.right;
                    break;
                case "bottomleft":
                    center = corners.bottomLeft;
                    break;
                case "bottomcenter":
                    center = corners.bottom;
                    break;
                case "bottomright":
                    center = corners.bottomRight;
                    break;
                case "pivot":
                    center = ej.datavisualization.Diagram.Point(shape.offsetX, shape.offsetY);
                    break;
                case "rotate":
                    var thumbHeight = 20;
                    var dist = 20 / scale; //distance between element top and rotator thumb
                    var pt = ej.datavisualization.Diagram.Point(shape.offsetX, (shape.offsetY - shape.height * shape.pivot.y) - thumbHeight / 2 - dist);
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, shape.rotateAngle, shape.offsetX, shape.offsetY);
                    center = ej.Matrix.transform(matrix, pt);
                    break;
            }
            return center;
        },
        findResizeHandleAtPoint: function (node, point) {
            var resizeDirection = null;
            if (node) {
                var center;
                var success;
                var directions = ["topleft", "topcenter", "topright", "middleleft", "middleright", "bottomleft", "bottomcenter", "bottomright"];
                for (var i = 0, len = directions.length; i < len; i++) {
                    center = this._getResizeHandleCenter(node, directions[i]);
                    if (center !== ej.datavisualization.Diagram.Point(0, 0)) {
                        success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(center.x, center.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                        if (success) {
                            resizeDirection = directions[i];
                            break;
                        }
                    }
                }
            }
            return resizeDirection;
        },
        findRotationHandleAtPoint: function (node, point, scale) {
            var center = this._getResizeHandleCenter(node, "rotate", scale);
            var success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(center.x, center.y), 10); // right now 7 is default handle radius size, need to give as constant variable
            if (success) {
                return true;
            }
            return false;
        },
        findPivotHandleAtPoint: function (node, point) {
            var center = this._getResizeHandleCenter(node, "pivot");
            var success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(center.x, center.y), 7); // right now 7 is default handle radius size, need to give as constant variable
            if (success) {
                return true;
            }
            return false;
        },
        findEndPointHandleAtPoint: function (connector, point) {
            var endPointHandle = null;
            if (connector) {
                var success;
                var points = connector.line.points;
                var pt = points[points.length - 1];
                success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt.x, pt.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                if (success) {
                    endPointHandle = "targetEndPoint";
                }
                if (!success) {
                    pt = points[0];
                    success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt.x, pt.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                    if (success) {
                        endPointHandle = "sourceEndPoint";
                    }
                }
                if (!success && connector.line.type === "bezier") {
                    pt = connector.line._point1;
                    success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt.x, pt.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                    if (success) {
                        endPointHandle = "bezierpoint1";
                    }
                    if (!success) {
                        var pt1 = connector.line._point2;
                        success = ej.datavisualization.Diagram.Geometry.checkPointOnCircle(point, ej.datavisualization.Diagram.Point(pt1.x, pt1.y), 7); // right now 7 is default handle radius size, need to give as constant variable
                        if (success) {
                            endPointHandle = "bezierpoint2";
                        }
                    }
                }
            }
            return endPointHandle;
        }
    };
    //#endregion

    ej.datavisualization.Diagram.LayoutUtil = {
        expandSubTree: function (diagram, node, reference, isAnimate, select, bringIntoView, collapse) {
            if (!diagram._isAnimating) {
                var zoom = diagram.model.scrollSettings.currentZoom;
                var hOffset = node.offsetX * zoom - diagram.model.scrollSettings.viewPortWidth / 2 - diagram.model.scrollSettings.horizontalOffset;
                if (node.offsetY * zoom < diagram.model.scrollSettings.verticalOffset || node.offsetY * zoom > (diagram.model.scrollSettings.verticalOffset + diagram.model.scrollSettings.viewPortHeight - 3 * node.height * zoom))
                    diagram.update({ scrollSettings: { verticalOffset: node.offsetY - diagram.model.scrollSettings.viewPortHeight / 2 } });
                var i = 0;
                if (hOffset != 0 && bringIntoView) {
                    diagram._preventScrollerUpdate = true;
                    var panningAnimation = setInterval(function () {
                        if (i < 4)
                            diagram.update({ scrollSettings: { horizontalOffset: diagram.model.scrollSettings.horizontalOffset + hOffset / 4 } });
                        i++;
                        if (i == 5) {
                            clearInterval(panningAnimation);
                            delete diagram._preventScrollerUpdate;
                            if ((collapse !== false || !node.isExpanded) && node.outEdges.length)
                                ej.datavisualization.Diagram.LayoutUtil.expand(diagram, node, reference, isAnimate, select);
                            else
                                ej.datavisualization.Diagram.ScrollUtil._setScrollContentSize(diagram);

                        }
                    }, 25);
                }
                else {
                    delete diagram._preventScrollerUpdate;
                    if ((collapse !== false || !node.isExpanded) && node.outEdges.length)
                        this.expand(diagram, node, reference, isAnimate, select);
                    else
                        ej.datavisualization.Diagram.ScrollUtil._setScrollContentSize(diagram);
                }
            }
        },
        _updateVisiblity: function (diagram, node, opacity) {
            for (var k = 0; k < node.outEdges.length; k++) {
                var edge = node.outEdges[k];
                edge = diagram.findNode(edge);
                var targetNode = diagram.findNode(edge.targetNode);
                edge.opacity = targetNode.opacity = opacity / 100;
                ej.datavisualization.Diagram.DiagramContext.updateNodeStyle(targetNode, diagram);
                ej.datavisualization.Diagram.DiagramContext.updateConnectorStyle(edge, diagram);
                if (targetNode.isExpanded && targetNode.outEdges.length) this._updateVisiblity(diagram, targetNode, opacity);
            }
        },
        expand: function (diagram, node, reference, isAnimate, select) {
            if (reference === undefined) {
                reference = node.name;
            }
            var temp = diagram.model.layout.fixedNode;
            diagram.model.layout.fixedNode = reference;
            var selectedItem = diagram.selectionList[0] ? diagram.selectionList[0].name : "";
            if (selectedItem)
                diagram._clearSelection(true);
            if (!isAnimate)
                diagram.layout();
            else if (!diagram._isAnimating) {
                node._updateExpander = true;
                diagram._updateEdgeCollection();

                //Expand or collapse the sub tree
                if (node.isExpanded) {
                    diagram._collapseChildren(node); node.isExpanded = false;
                } else { diagram._expandChildren(node); node.isExpanded = true; }
                diagram._isAnimating = true;
                //Layout the nodes
                var objects = ej.datavisualization.Diagram.Layout.doLayout(diagram, false);

                var i = 0;

                if (objects.length) {
                    $(".ej-d-connector").attr("opacity", 0);
                    $(".ej-d-icon-template").attr("opacity", 0);
                    diagram._layoutInAction = true;
                    var leftTimer = setInterval(function () {
                        i++;
                        if (i < 5) {
                            //Move the objects towards the corresponding direction
                            for (var l = 0; l < objects.length; l++) {
                                var obj = diagram.nameTable[objects[l].object];
                                diagram._disableSegmentChange = true;
                                diagram.updateNode(obj.name, { offsetX: obj.offsetX + objects[l].diff / 4, offsetY: obj.offsetY + objects[l].diffy / 4 });
                                diagram._disableSegmentChange = false;
                            }
                        }
                        if (i == 5) {
                            clearInterval(leftTimer);
                            delete diagram._layoutInAction;
                            //update the connectors
                            var layout = diagram._internalLayout;
                            if (layout) {
                                for (i = 0; i < layout._firstLevelNodes.length; i++) {
                                    ej.datavisualization.Diagram.HierarchicalLayout._updateConnectors(layout,
                                        layout._firstLevelNodes[i],
                                        1);
                                }
                            }
                            delete diagram._internalLayout;
                            $(".ej-d-connector").attr("opacity", 1);
                            $(".ej-d-icon-template").attr("opacity", 1);
                            if (selectedItem || select) diagram._addSelection(diagram.findNode(selectedItem || reference), !select);
                            diagram._isAnimating = false;
                            delete diagram._preventScrollerUpdate;
                            ej.datavisualization.Diagram.ScrollUtil._setScrollContentSize(diagram);
                        }
                    }, 50);
                }
                else {
                    //update the connectors
                    var layout = diagram._internalLayout;
                    if (layout) {
                        for (i = 0; i < layout._firstLevelNodes.length; i++) {
                            ej.datavisualization.Diagram.HierarchicalLayout._updateConnectors(layout,
                                layout._firstLevelNodes[i],
                                1);
                        }
                    }
                    if (selectedItem || select) diagram._addSelection(diagram.findNode(selectedItem || reference), !select);
                    diagram._isAnimating = false;
                    delete diagram._internalLayout;
                }

                //Update the opacity of the expanded or collapsed sub tree
                var opacity = 0;
                var current = this;
                if (node.isExpanded) {
                    current._updateVisiblity(diagram, node, 0)
                    var settimer = setInterval(function () {
                        if (node.isExpanded) {
                            if (opacity <= 100)
                                current._updateVisiblity(diagram, node, opacity)
                            if (opacity == 120) {
                                clearInterval(settimer);
                            }
                            opacity += 5;
                        }
                    }, 25);
                }
                ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
            }
            diagram.model.layout.fixedNode = temp;
        }
    };

    //#region Util
    ej.datavisualization.Diagram.Util = {

        convertPathToArray: function (string) {
            var pathSegList = [], pathDataList = this.parsePathData(string);
            if (pathDataList.length > 0) {
                for (var i = 0; i < pathDataList.length; i++) {
                    var pathArray = pathDataList[i];
                    var startChar = pathArray[0];
                    switch (startChar.toLowerCase()) {
                        case "m":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, x: pathArray[j], y: pathArray[j + 1] });
                                j = j + 1;
                                if (startChar === "m")
                                    startChar = "l";
                                else if (startChar === "M")
                                    startChar = "L";
                            }
                            break;
                        case "l":
                        case "t":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, x: pathArray[j], y: pathArray[j + 1] });
                                j = j + 1;
                            }
                            break;
                        case "h":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, x: pathArray[j] });
                            }
                            break;
                        case "v":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, y: pathArray[j] });
                            }
                            break;
                        case "z":
                            pathSegList.push({ pathSegTypeAsLetter: startChar });
                            break;
                        case "c":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, x1: pathArray[j], y1: pathArray[j + 1], x2: pathArray[j + 2], y2: pathArray[j + 3], x: pathArray[j + 4], y: pathArray[j + 5] });
                                j = j + 5;
                            }
                            break;
                        case "s":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, x2: pathArray[j], y2: pathArray[j + 1], x: pathArray[j + 2], y: pathArray[j + 3] });
                                j = j + 3;
                            }
                            break;
                        case "q":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, x1: pathArray[j], y1: pathArray[j + 1], x: pathArray[j + 2], y: pathArray[j + 3] });
                                j = j + 3;
                            }
                            break;
                        case "a":
                            for (var j = 1; j < pathArray.length; j++) {
                                pathSegList.push({ pathSegTypeAsLetter: startChar, r1: pathArray[j], r2: pathArray[j + 1], angle: pathArray[j + 2], largeArcFlag: this.parseArcFlag(pathArray[j + 3]), sweepFlag: this.parseArcFlag(pathArray[j + 4]), x: pathArray[j + 5], y: pathArray[j + 6] });
                                j = j + 6;
                            }
                            break;
                    }
                }
            }
            return pathSegList;
        },
        _getImageAlignment: function (option) {
            if (option) {
                switch (option.toLowerCase()) {
                    case "xminymin":
                        return "xMinYMin";
                    case "xminymid":
                        return "xMinYMid";
                    case "xminymax":
                        return "xMinYMax";
                    case "xmidymin":
                        return "xMidYMin";
                    case "xmidymid":
                        return "xMidYMid";
                    case "xmidymax":
                        return "xMidYMax";
                    case "xmaxymin":
                        return "xMaxYMin";
                    case "xmaxymid":
                        return "xMaxYMid";
                    case "xmaxymax":
                        return "xMaxYMax";
                    case "none":
                        return "none";
                }
            }
            return "none";
        },
        parseArcFlag: function (char) {
            var flag;
            if (char === "0" || char === 0)
                flag = false;
            else if (char === "1" || char === 1)
                flag = true;
            return flag;
        },

        parsePathData: function (pathData) {
            var tokenizer = /([a-z]+)|([+-]?(?:\d+\.?\d*|\.\d+))/gi, match, current, commands = [];
            tokenizer.lastIndex = 0;
            var isExponential = false;
            while (match = tokenizer.exec(pathData)) {
                if (match[1] === "e") {
                    var s1 = "";
                    isExponential = true;
                }
                else if (match[1]) {
                    if (match[1].toLowerCase() === "zm") {
                        if (current)
                            commands.push(current);
                        commands.push(["Z"]);
                        current = [match[1].substring(1, 2)]
                    }
                    else {
                        if (current)
                            commands.push(current);
                        current = [match[1]];
                    }
                    isExponential = false;
                }
                else {
                    if (!current)
                        current = [];
                    if (!isExponential)
                        current.push(Number(match[2]));
                    isExponential = false;
                }
            }
            if (current) commands.push(current);
            return commands;
        },

        pathSegArrayAsString: function (pathSegArray) {
            var string = "";
            for (var i = 0; i < pathSegArray.length; i++) {
                var pathSeg = pathSegArray[i];
                if (i === 0)
                    string += this.pathToString(pathSeg);
                else
                    string += " " + this.pathToString(pathSeg);
            }
            return string;
        },
        canEnablePointerEvents: function (node, diagram) {
            var temp = node;
            var enabled;
            if (diagram) {
                while (temp) {
                    if (temp.segments)
                        enabled = temp.constraints & ej.datavisualization.Diagram.ConnectorConstraints.PointerEvents;
                    else
                        enabled = temp.constraints & ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                    if (!enabled) return enabled;
                    temp = typeof temp.parent == "string" ? diagram.nameTable[temp.parent] : temp;
                }

            }
            return true;
        },
        isClassifier: function (evt) {
            var className = typeof evt.target.className == "string" ? evt.target.className : evt.target.className.baseVal;
            if ($(evt.target).hasClass("ej-d-classifier") || className.indexOf("ej-d-classifier") > -1)
                return true;
            else
                return false;
        },
        pathToString: function (pathSeg) {
            var string;
            switch (pathSeg.pathSegTypeAsLetter) {
                case "Z":
                case "z":
                    string = pathSeg.pathSegTypeAsLetter;
                    break;
                case "M":
                case "m":
                case "L":
                case "l":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.x + " " + pathSeg.y;
                    break;
                case "C":
                case "c":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.x1 + " " + pathSeg.y1 + " " + pathSeg.x2 + " " + pathSeg.y2 + " " + pathSeg.x + " " + pathSeg.y;
                    break;
                case "Q":
                case "q":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.x1 + " " + pathSeg.y1 + " " + pathSeg.x + " " + pathSeg.y;
                    break;
                case "A":
                case "a":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.r1 + " " + pathSeg.r2 + " " + pathSeg.angle + " " + (pathSeg.largeArcFlag ? "1" : "0") + " " + (pathSeg.sweepFlag ? "1" : "0") + " " + pathSeg.x + " " + pathSeg.y;
                    break;
                case "H":
                case "h":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.x;
                    break;
                case "V":
                case "v":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.y;
                    break;
                case "S":
                case "s":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.x2 + " " + pathSeg.y2 + " " + pathSeg.x + " " + pathSeg.y;
                    break;
                case "T":
                case "t":
                    string = pathSeg.pathSegTypeAsLetter + " " + pathSeg.x + " " + pathSeg.y;
            }
            return string;
        },

        findPortByName: function (node, portName) {
            var port;
            if (node) {
                if (node.ports) {
                    for (var i = 0, len = node.ports.length; i < len; i++) {
                        port = node.ports[i];
                        if (port.name === portName) {
                            return port;
                        }
                    }
                }
                if (node._ports) {
                    for (var i = 0, len = node._ports.length; i < len; i++) {
                        port = node._ports[i];
                        if (port.name === portName) {
                            return port;
                        }
                    }
                }
            }
            return null;
        },
        attr: function (element, attributes) {
            for (var atr in attributes) {
                element.setAttribute(atr.toString(), attributes[atr]);
            }
        },
        removeChildFromGroup: function (array, item) {
            var index = array.indexOf(item);
            if (index < 0) {
                for (var i = 0; i < array.length; i++) {
                    if (typeof (array[i]) === "object" && typeof (item) === "string") {
                        if (array[i].name === item) {
                            index = i;
                            break;
                        }
                    }
                }
            }
            if (index >= 0)
                array.splice(index, 1);
        },
        removeFromCollection: function (diagram, array, item) {
            if (diagram) {
                var item = diagram.nameTable[diagram._getChild(item)];
                for (var i = 0; i < array.length; i++) {
                    var child = diagram.nameTable[diagram._getChild(array[i])];
                    if (child.name === item.name) {
                        array.splice(i, 1);
                    }
                }
            }
        },
        removeItem: function (array, item) {
            var index = array.indexOf(item);
            if (index >= 0)
                array.splice(index, 1);
        },
        clear: function (array) {
            while (array.length > 0) {
                array.pop();
            }
        },
        getChild: function (child) {
            if (child) {
                if (typeof (child) == "object") {
                    return child.name;
                } else {
                    return child;
                }
            }
        },
        randomId: function () {
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
            var id = "";
            //get 4 random chars
            for (var i = 0; i < 4; i++) {
                var num = ej.getRandomValue(0, chars.length - 1);
                id += chars.substring(num, num + 1);
            }
            return id;
        },
        htmlEncode: function (html) {
            var str = html.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, '\'');
            return str;
        },
        canMove: function (node) {
            if (this.canSelect(node)) {
                if (node.segments) {
                    return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Drag;
                } else if (node._type == "label")
                    return node.constraints & ej.datavisualization.Diagram.LabelConstraints.Draggable;
                else
                    return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Drag;
            }
        },

        canRouteDiagram: function (diagram) {
            return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Routing;
        },

        canRouteConnector: function (connector, diagram) {
            if (connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Routing) {
                return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Routing;
            }
            else if (connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.InheritRouting) {
                return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Routing;
            }
        },

        canMoveLabel: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragLabel;
            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.DragLabel;
        },
        canRotate: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Rotate;
            } else if (node._type == "label")
                return node.constraints & ej.datavisualization.Diagram.LabelConstraints.Rotatable;
            else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Rotate;
        },
        canShowTooltip: function (node, diagram) {
            if (node.segments) {
                var inherit = node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.InheritTooltip;
            } else
                var inherit = node.constraints & ej.datavisualization.Diagram.NodeConstraints.InheritTooltip;
            if (inherit) {
                return diagram.model.tooltip;
            } return node.tooltip;
        },
        canSelect: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Select;
            } else if (node._type == "label")
                return node.constraints & ej.datavisualization.Diagram.LabelConstraints.Selectable;
            else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Select;
        },
        enableLayerOption: function (node, option, diagram) {
            var count = 0;
            var objectCount = 0;
            var layers = diagram.model.layers;
            var visible, i, layerOption;
            if (layers && layers.length === 0)
                return true;
            for (i = 0; layers && i < layers.length; i++) {
                if (option === "active" && layers[i][option]) {
                    count++;
                    layerOption = layers[i];
                } else {
                    if (node && layers[i].objects && (layers[i].objects.indexOf(node.name) > -1) || diagram._isParent(node, layers[i].objects)) {
                        count++;
                        visible = layers[i][option];
                        if (layers[i][option]) {
                            objectCount++;
                        }
                    }
                }
            }
            if (option === "active") {
                if (count === 1) {
                    return layerOption;
                }
                else
                    return false;
            } else {
                if (count === 1) {
                    return (option !== "lock") ? visible : !visible;
                }
                else if (count > 1 && objectCount > 0)
                    return true;
                else
                    return true;
            }

        },
        canBridge: function (connector, diagram) {
            if (connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Bridging) {
                return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Bridging;
            }
            else if (connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.InheritBridging) {
                return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Bridging;
            }
        },
        canBridgeObstacle: function (connector, diagram) {
            if (connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.BridgeObstacle) {
                return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.BridgeObstacle;
            }
        },
        canCrispEdges: function (node, diagram) {
            if (node.segments) {
                if (node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.CrispEdges) {
                    return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.CrispEdges;
                }
                else if (diagram && node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.InheritCrispEdges) {
                    return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.CrispEdges;
                }
            } else {
                if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.CrispEdges) {
                    return node.constraints & ej.datavisualization.Diagram.NodeConstraints.CrispEdges;
                }
                else if (diagram && node.constraints & ej.datavisualization.Diagram.NodeConstraints.InheritCrispEdges) {
                    return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.CrispEdges;
                }
            }
        },
        canAllowPan: function (node) {
            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.AllowPan;
        },
        canAllowDrop: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.AllowDrop;
            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.AllowDrop;
        },
        isAllowDragLimit: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragLimit;
            }
        },
        canDelete: function (node) {
            if (node.segments) {
                return node.constraints & ej.datavisualization.Diagram.ConnectorConstraints.Delete;
            } else
                return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Delete;
        },
        isPageEditable: function (diagram) {
            if (diagram) {
                return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.UserInteraction;
            }
        },
        canFloatElements: function (diagram) {
            if (diagram) return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.FloatElements;
        },

        canEnableAPIMethods: function (diagram) {
            if (diagram && diagram._enableAPIMethods) {
                return diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.APIUpdate;
            }
        },

        canDoMultipleSelection: function (diagram) {
            if (diagram && this.isPageEditable(diagram)) {
                return diagram.tool() & ej.datavisualization.Diagram.Tool.MultipleSelect;
            }
        },
        canDoSingleSelection: function (diagram) {
            if (diagram && this.isPageEditable(diagram)) {
                return diagram.tool() & ej.datavisualization.Diagram.Tool.SingleSelect;
            }
        },
        canMoveOutofBoundary: function (diagram) {
            if (diagram.model.pageSettings.boundaryConstraints != "infinity")
                return true;
            return false;
        },
        _getPseudoGroupConstraints: function (diagram, node, selectionlist) {
            var pseudoGroupConstraints;
            if (selectionlist && selectionlist.type === "pseudoGroup") {
                if (selectionlist.children.indexOf(node.name) >= 0 || node.name === selectionlist.name)
                    if (diagram.model.selectedItems.getConstraints) {
                        var getConstraints = diagram.model.selectedItems.getConstraints;
                        if (typeof getConstraints == "string")
                            getConstraints = ej.util.getObject(getConstraints, window);
                    }
                if (getConstraints && $.isFunction(getConstraints))
                    pseudoGroupConstraints = getConstraints();
                else {
                    if (selectionlist.children) {
                        pseudoGroupConstraints = ej.datavisualization.Diagram.NodeConstraints.Default;
                        for (var i = 0; i < selectionlist.children.length; i++) {
                            var nodes = diagram.nameTable[diagram._getChild(selectionlist.children[i])];
                            if (nodes) {
                                var nodeConstraints = nodes.constraints;
                                if (!(nodeConstraints & ej.datavisualization.Diagram.NodeConstraints.Resize))
                                    pseudoGroupConstraints = pseudoGroupConstraints & ~ej.datavisualization.Diagram.NodeConstraints.Resize;
                                if (!(nodeConstraints & ej.datavisualization.Diagram.NodeConstraints.Rotate))
                                    pseudoGroupConstraints = pseudoGroupConstraints & ~ej.datavisualization.Diagram.NodeConstraints.Rotate;
                                if (!(nodeConstraints & ej.datavisualization.Diagram.NodeConstraints.Drag))
                                    pseudoGroupConstraints = pseudoGroupConstraints & ~ej.datavisualization.Diagram.NodeConstraints.Drag;
                            }
                        }
                    }
                }
            }

            return pseudoGroupConstraints;
        },
        canPanning: function (diagram) {
            if (diagram) {
                return (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableX) || (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableY);
            }
        },
        canZooming: function (diagram) {
            if (diagram) {
                return (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Zoomable);
            }
        },
        canUndo: function (diagram) {
            if (diagram) {
                return (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.Undoable);
            }
        },
        canZoomTextEditor: function (diagram) {
            if (diagram) return (diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.ZoomTextEditor);
        },
        canMultiSelectOnLane: function (node) {
            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.MultiSelect;
        },
        canMultiSelectOnNode: function (node) {
            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
        },
        canEnableTooltip: function (diagram) {
            if (diagram.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.Tooltip)
                return true;
            else
                return false;
        },
        canDragHelper: function (diagram) {
            return diagram.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.DragOnEmptySpace ? true : false;
        },
        canShowResizeThumbs: function (diagram) {
            return diagram.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.AutoHideThumbs;
        },
        canDrawStackHighlighter: function (diagram, node, overNode) {
            if (ej.datavisualization.Diagram.Util.canMoveOutofBoundary(diagram)) {
                if (diagram && node && overNode) {
                    var laneStack = diagram.nameTable[overNode.parent];
                    if (laneStack && laneStack.isLaneStack) {
                        var swimlane = diagram.nameTable[laneStack.parent];
                        if (swimlane && swimlane.isSwimlane) {
                            var swimlaneBounds = this.bounds(swimlane);
                            var size = diagram.activeTool._getPageBounds();
                            if (swimlane.orientation === "horizontal") {
                                if ((node.height + swimlaneBounds.bottom >= size.height) || (node.width - swimlane.width + swimlaneBounds.right > size.width)) {
                                    diagram.activeTool.updateCursor("not-allowed");
                                    diagram._notAllow = true;
                                    return false;
                                }
                            }
                            else {
                                if ((node.width + swimlaneBounds.right >= size.width) || (node.height - swimlane.height + swimlaneBounds.bottom > size.height)) {
                                    diagram.activeTool.updateCursor("not-allowed");
                                    diagram._notAllow = true;
                                    return false;
                                }
                            }
                        }
                    }

                }
            }
            return true;
        },
        canDragSourceEnd: function (connector) {
            return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragSourceEnd;
        },
        canDragTargetEnd: function (connector) {
            return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragTargetEnd;
        },
        canDragSegmentThumbs: function (connector) {
            return connector.constraints & ej.datavisualization.Diagram.ConnectorConstraints.DragSegmentThumb;
        },
        isTargetConnected: function (connector) {
            return connector.targetNode ? true : false;
        },
        isSourceConnected: function (connector) {
            return connector.sourceNode ? true : false;
        },
        bounds: function (object, excludeRotation) {
            var rect = {};
            if (object) {
                if (object.segments) {
                    for (var i = 0; i < object.segments.length; i++) {
                        var segment = object.segments[i];
                        if (i == 0) {
                            if (segment.points)
                                rect = ej.datavisualization.Diagram.Geometry.rect(segment.points);
                        }
                        else
                            rect = ej.datavisualization.Diagram.Geometry.union(rect, ej.datavisualization.Diagram.Geometry.rect(segment.points));
                        if (rect.width == 0) { rect.width = object.lineWidth; rect.x -= object.lineWidth / 2; }
                        if (rect.height == 0) { rect.height = object.lineWidth; rect.y -= object.lineWidth / 2; }
                    }
                }
                else if (object._type == "node" || object._type === "group" || object.type == "umlclassifier" || object._type == "pseudoGroup") {
                    var width = object.width ? object.width : object._width || 0;
                    var height = object.height ? object.height : object._height || 0;
                    rect = { x: object.offsetX - width * object.pivot.x, y: object.offsetY - height * object.pivot.y, width: width, height: height };
                }
                else
                    rect = object;
            }
            else
                rect = ej.datavisualization.Diagram.Rectangle();
            if (rect) {
                var bounds = {};
                rect.x = Math.round(rect.x * 100) / 100;
                rect.y = Math.round(rect.y * 100) / 100;
                rect.width = Math.round(rect.width * 100) / 100;
                rect.height = Math.round(rect.height * 100) / 100;
                bounds["width"] = rect.width;
                bounds["height"] = rect.height;
                bounds["x"] = bounds["left"] = rect.x;
                bounds["right"] = rect.x + rect.width;
                bounds["y"] = bounds["top"] = rect.y;
                bounds["bottom"] = rect.y + rect.height;
                bounds["center"] = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
                bounds["topLeft"] = { x: rect.x, y: rect.y };
                bounds["topCenter"] = { x: rect.x + rect.width / 2, y: rect.y };
                bounds["topRight"] = { x: rect.x + rect.width, y: rect.y };
                bounds["middleLeft"] = { x: rect.x, y: rect.y + rect.height / 2 };
                bounds["middleRight"] = { x: rect.x + rect.width, y: rect.y + rect.height / 2 };
                bounds["bottomLeft"] = { x: rect.x, y: rect.y + rect.height };
                bounds["bottomCenter"] = { x: rect.x + rect.width / 2, y: rect.y + rect.height };
                bounds["bottomRight"] = { x: rect.x + rect.width, y: rect.y + rect.height };
                if (object && object.rotateAngle && !excludeRotation) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    bounds.topLeft = ej.Matrix.transform(matrix, bounds.topLeft);
                    bounds.topCenter = ej.Matrix.transform(matrix, bounds.topCenter);
                    bounds.topRight = ej.Matrix.transform(matrix, bounds.topRight);
                    bounds.middleLeft = ej.Matrix.transform(matrix, bounds.middleLeft);
                    bounds.middleRight = ej.Matrix.transform(matrix, bounds.middleRight);
                    bounds.bottomLeft = ej.Matrix.transform(matrix, bounds.bottomLeft);
                    bounds.bottomCenter = ej.Matrix.transform(matrix, bounds.bottomCenter);
                    bounds.bottomRight = ej.Matrix.transform(matrix, bounds.bottomRight);
                    var rbounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                    bounds.x = bounds.left = rbounds.x;
                    bounds.y = bounds.top = rbounds.y;
                    bounds.right = rbounds.x + rbounds.width;
                    bounds.bottom = rbounds.y + rbounds.height;
                    bounds.center = ej.datavisualization.Diagram.Point(rbounds.x + rbounds.width / 2, rbounds.y + rbounds.height / 2);
                }
                bounds["points"] = [bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft];
                return bounds;
            }
            return rect;
        },
        _swapBounds: function (object, bounds) {
            var object, bounds;
            bounds = bounds;
            if (object.rotateAngle) {
                if (object.rotateAngle < 45) { }
                else if (object.rotateAngle <= 135) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    var temp;
                    temp = bounds["topCenter"];
                    bounds["topCenter"] = bounds["middleLeft"];
                    bounds["middleLeft"] = bounds["bottomCenter"];
                    bounds["bottomCenter"] = bounds["middleRight"];
                    bounds["middleRight"] = temp;
                    temp = bounds["topLeft"];
                    bounds["topLeft"] = bounds["bottomLeft"];
                    bounds["bottomLeft"] = bounds["bottomRight"];
                    bounds["bottomRight"] = bounds["topRight"];
                    bounds["topRight"] = temp;
                }
                else if (object.rotateAngle <= 225) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    var temp;
                    temp = bounds["topCenter"];
                    bounds["topCenter"] = bounds["bottomCenter"];
                    bounds["bottomCenter"] = temp;
                    temp = bounds["middleLeft"];
                    bounds["middleLeft"] = bounds["middleRight"];
                    bounds["middleRight"] = temp;
                    temp = bounds["bottomLeft"];
                    bounds["bottomLeft"] = bounds["topLeft"];
                    bounds["topLeft"] = temp;
                    temp = bounds["bottomRight"];
                    bounds["bottomRight"] = bounds["topRight"];
                    bounds["topRight"] = temp;
                }
                else if (object.rotateAngle <= 315) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, object.rotateAngle, object.offsetX, object.offsetY);
                    var temp;
                    temp = bounds["topCenter"];
                    bounds["topCenter"] = bounds["middleRight"];
                    bounds["middleRight"] = bounds["bottomCenter"];
                    bounds["bottomCenter"] = bounds["middleLeft"];
                    bounds["middleLeft"] = temp;
                    temp = bounds["topRight"];
                    bounds["topRight"] = bounds["bottomRight"];
                    bounds["bottomRight"] = bounds["bottomLeft"];
                    bounds["bottomLeft"] = bounds["topLeft"];
                    bounds["topLeft"] = temp;
                }
                bounds["points"] = [bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft];
                return bounds;
            }
        },
        canResize: function (node, dir) {
            if (node._type !== "label") {
                if (dir) {
                    switch (dir) {
                        case "n-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorth;
                        case "s-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouth;
                        case "e-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeEast;
                        case "w-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeWest;
                        case "se-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast;
                        case "ne-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast;
                        case "sw-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest;
                        case "nw-resize":
                            return node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest;
                    }
                }
                else
                    return node.constraints & ej.datavisualization.Diagram.NodeConstraints.Resize;
            }
            else
                return node.constraints & ej.datavisualization.Diagram.LabelConstraints.Resizable;
        },
        canConnect: function (node, isPort) {
            var connect = null;
            if (node) {
                if (isPort) {
                    connect = node.constraints & ej.datavisualization.Diagram.PortConstraints.Connect;
                }
                else if (!node.segments)
                    connect = node.constraints & ej.datavisualization.Diagram.NodeConstraints.Connect;
            }
            return connect;
        },
        _initializeSegments: function (connector, defaultType) {
            if (connector.segments && connector.segments.length <= 1) {
                if (!connector.segments.length) {
                    connector.segments.push(ej.datavisualization.Diagram.Segment({ type: defaultType || "straight" }));
                }
                var first = connector.segments[0];
                switch (first.type) {
                    case "straight":
                        if (!first.point) { first._point = connector.targetPoint; }
                        else if (first.point.x != connector.targetPoint.x || first.point.y != connector.targetPoint.y) {
                            //Need to add a method
                            connector.segments.push({ type: first.type || "straight" });
                        }
                        break;
                    case "orthogonal":
                        if (first.length && first.direction) {
                            ej.datavisualization.Diagram.Util._addOrthogonalPoints(first, null, null, connector.sourcePoint, connector.targetPoint);
                            if (first._endPoint.x != connector.targetPoint.x || first._endPoint.y != connector.targetPoint.y) {
                                connector.segments.push({ type: first.type || "straight" });
                            }
                        }
                        else {
                            first._length = first.length || 20;
                            first._direction = first.direction || "auto";
                        }
                        break;
                    case "bezier":
                        if (!first.point) first._point = connector.targetPoint;
                        else if (first.point.x != connector.targetPoint.x || first.point.y != connector.targetPoint.y) {
                            //Need to add a method
                            connector.segments.push({ type: first.type || "straight" });
                        }
                        break;
                }
            }
            var startPoint = connector.sourcePoint;
            var prev = null;
            var next = null;
            var runAngle;
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                segment._startPoint = startPoint;
                next = connector.segments[i + 1];
                segment = connector.segments[i] = ej.datavisualization.Diagram.Segment(connector.segments[i]);
                if (segment.type == "orthogonal") {
                    segment._direction = segment.direction || "auto";
                    segment._length = segment.length || 20;
                    runAngle = ej.datavisualization.Diagram.Util._addOrthogonalPoints(connector.segments[i], prev, next, connector.sourcePoint, connector.targetPoint, runAngle);
                    startPoint = connector.segments[i]._endPoint;
                    if (!segment.length || !segment.direction) {
                        break;
                    }
                }
                else if (segment.type == "straight") {
                    segment.points.push(startPoint);
                    segment.points.push(connector.segments[i].point || connector.targetPoint);
                    segment._point = segment._endPoint = connector.segments[i].point || connector.targetPoint;
                    runAngle = ej.datavisualization.Diagram.Geometry.findAngle(startPoint, segment._endPoint);
                    startPoint = connector.segments[i]._endPoint;
                    if (!segment.point) {
                        break;
                    }
                }
                else if (segment.type == "bezier") {
                    segment._point = segment._endPoint = connector.segments[i].point || connector.targetPoint;
                    segment.points.push(startPoint);
                    segment.points.push(connector.segments[i].point || connector.targetPoint);
                    runAngle = ej.datavisualization.Diagram.Geometry.findAngle(startPoint, segment._endPoint);
                    ej.datavisualization.Diagram.Util._updateBezierPoints(segment);
                    startPoint = connector.segments[i]._endPoint;
                    if (!segment.point) {
                        break;
                    }
                }
                else {
                    var segment = ej.datavisualization.Diagram.Segment({ type: "orthogonal" });
                    segment._direction = "auto";
                    segment._length = 20;
                    segment._startPoint = startPoint;
                    segment._endPoint = connector.targetPoint;
                    connector.segments.push(segment);
                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, prev, null, connector.sourcePoint, connector.targetPoint, runAngle);
                    break;
                }
                prev = connector.segments[i];
            }
            if (startPoint.x != connector.targetPoint.x || startPoint.y != connector.targetPoint.y) {
                var segment = ej.datavisualization.Diagram.Segment({ type: (prev ? prev.type : defaultType) || "straight", });
                segment._startPoint = startPoint;
                segment._endPoint = connector.targetPoint;
                if (segment.type == "orthogonal") {
                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, prev, null, connector.sourcePoint, connector.targetPoint, runAngle);
                }
                else {
                    segment._point = connector.targetPoint;
                    segment.points.push(startPoint);
                    segment.points.push(connector.targetPoint);
                    if (segment.type == "bezier") { this._updateBezierPoints(segment); }
                }
                connector.segments.push(segment);
            }
        },
        _getDockableBPMNNode: function (node, connector, nameTable, isTarget) {
            var segment = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            if (node && node.type == "bpmn")
                if (segment.type == "orthogonal") {
                    return node;
                } else if (node._type == "group")
                    node = (typeof node.children[0] == "object") ? node.children[0] : nameTable[node.children[0]];
            return node;
        },
        dock: function (connector, nameTable, diagram) {
            var targetNode, targetPort = null, sourceNode, sourcePort = null;
            var srcDecoratorSize = connector._srcDecoratorSize, tarDecoratorSize = connector._tarDecoratorSize;
            if (connector.sourcePadding) connector._srcDecoratorSize += connector.sourcePadding;
            if (connector.targetPadding) connector._tarDecoratorSize += connector.targetPadding
            targetNode = nameTable[connector.targetNode];
            if (targetNode)
                targetPort = connector._targetPortLocation || this.findPortByName(targetNode, connector.targetPort);
            sourceNode = nameTable[connector.sourceNode];
            if (sourceNode)
                sourcePort = connector._sourcePortLocation || this.findPortByName(sourceNode, connector.sourcePort);
            var sourceConnected = this.isSourceConnected(connector);
            var targetConnected = this.isTargetConnected(connector);
            if (!sourcePort) {
                sourceNode = this._getDockableBPMNNode(sourceNode, connector, nameTable, false);
                if (sourceNode && sourceNode.connectorPadding) connector._srcDecoratorSize += sourceNode.connectorPadding;
            } else if (sourcePort.connectorPadding) connector._srcDecoratorSize += sourcePort.connectorPadding;
            if (!targetPort) {
                targetNode = this._getDockableBPMNNode(targetNode, connector, nameTable, true);
                if (targetNode && targetNode.connectorPadding) connector._tarDecoratorSize += targetNode.connectorPadding;
            } else if (targetPort.connectorPadding) connector._tarDecoratorSize += targetPort.connectorPadding;
            if (targetConnected && sourceConnected && targetPort && sourcePort) {
                this._dockPortToPort(connector, targetNode, targetPort, sourceNode, sourcePort);
            }
            else if (targetConnected && targetPort) {
                if (sourceConnected) {
                    if (connector.segments.length == 1) {
                        this._dockNode(connector, sourceNode, null, targetConnected, sourceConnected);
                        this._dockPortToNode(connector, targetNode, targetPort, sourceNode, sourcePort, true);
                    }
                    else {
                        this._dockNode(connector, sourceNode, null, targetConnected, sourceConnected);
                        this._updateIntermediateSegments(connector);
                        this._dockPortToPoint(connector, targetNode, targetPort, true);
                        this._updatePreviousSegment(connector);
                    }
                }
                else {
                    this._dockPortToPoint(connector, targetNode, targetPort, true);
                    this._updatePreviousSegment(connector);
                }
            }
            else if (sourceConnected && sourcePort) {
                if (targetConnected) {
                    if (connector.segments.length == 1) {
                        this._dockNode(connector, targetNode, null, targetConnected, sourceConnected);
                        this._dockPortToNode(connector, sourceNode, sourcePort, targetNode, targetPort, false);
                    }
                    else {
                        this._dockPortToPoint(connector, sourceNode, sourcePort, false);
                        this._updateIntermediateSegments(connector);
                        this._dockNode(connector, targetNode, null, targetConnected, sourceConnected);
                        this._updatePreviousSegment(connector);
                    }
                }
                else {
                    this._dockPortToPoint(connector, sourceNode, sourcePort, false);
                    this._updateIntermediateSegments(connector);
                }
            }
            else if (targetConnected && sourceConnected) {
                if (targetNode && sourceNode)
                    this._dockNode(connector, targetNode, sourceNode, targetConnected, sourceConnected, diagram);
            }
            else if (targetConnected) {
                this._dockNode(connector, targetNode, null, targetConnected, sourceConnected);

            }
            else if (sourceConnected) {
                this._dockNode(connector, sourceNode, null, targetConnected, sourceConnected);
            }
            this._adjustEndPoint(connector, sourceNode, sourcePort, targetNode, targetPort);
            connector._srcDecoratorSize = srcDecoratorSize;
            connector._tarDecoratorSize = tarDecoratorSize;
        },
        _dockPortToPort: function (connector, targetNode, targetPort, sourceNode, sourcePort) {
            if (connector.segments.length == 1) {
                var portLocation;
                if (targetNode)
                    var targetBounds = this.bounds(targetNode, true);
                if (sourceNode)
                    var sourceBounds = this.bounds(sourceNode, true);
                var matrix;
                var first = connector.segments[0];
                var last = connector.segments[connector.segments.length - 1];
                var segment = connector.segments[0];
                if (segment.type !== "orthogonal") {
                    if (targetPort) {
                        portLocation = this._getPortPosition(targetPort, targetBounds, undefined, targetNode);
                        if (targetNode.rotateAngle) {
                            matrix = ej.Matrix.identity();
                            ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                            portLocation = ej.Matrix.transform(matrix, portLocation);
                        }
                        this._setLineEndPoint(connector, portLocation, true);
                    }
                    if (sourcePort) {
                        portLocation = this._getPortPosition(sourcePort, sourceBounds, undefined, sourceNode);

                        if (sourceNode.rotateAngle) {
                            matrix = ej.Matrix.identity();
                            ej.Matrix.rotate(matrix, sourceNode.rotateAngle, sourceNode.offsetX, sourceNode.offsetY);
                            portLocation = ej.Matrix.transform(matrix, portLocation);
                        }
                        this._setLineEndPoint(connector, portLocation, false);
                    }
                    if (segment.type === "bezier")
                        this._updateBezierPoints(segment, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds);
                } else {
                    var targetPortLocation = connector._targetPortLocation || this._getPortPosition(targetPort, targetBounds, undefined, targetNode);
                    var sourcePortLocation = connector._sourcePortLocation || this._getPortPosition(sourcePort, sourceBounds, undefined, sourceNode);
                    var targetDirection = this._swapDirection(targetNode.rotateAngle, this._getDirection(targetBounds, targetPortLocation));
                    var sourceDirection = this._swapDirection(sourceNode.rotateAngle, this._getDirection(sourceBounds, sourcePortLocation));
                    if (sourceNode.rotateAngle) {
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, sourceNode.rotateAngle, sourceNode.offsetX, sourceNode.offsetY);
                        sourcePortLocation = ej.Matrix.transform(matrix, sourcePortLocation);
                    }
                    if (targetNode.rotateAngle) {
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                        targetPortLocation = ej.Matrix.transform(matrix, targetPortLocation);
                    }
                    this._constructSegements(connector, first, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection);
                    this._setLineEndPoint(connector, first.points[0], false);
                    this._setLineEndPoint(connector, first.points[first.points.length - 1], true);
                }
            }
            else {
                this._dockPortToPoint(connector, sourceNode, sourcePort, false);
                this._updateIntermediateSegments(connector);
                this._dockPortToPoint(connector, targetNode, targetPort, true);
                this._updatePreviousSegment(connector);
            }
        },
        _dockPortToNode: function (connector, targetNode, targetPort, sourceNode, sourcePort, isTarget) {
            var first = connector.segments[0];
            var last = connector.segments[connector.segments.length - 1];
            if (targetNode)
                var targetBounds = this.bounds(targetNode, true);
            if (sourceNode)
                var sourceBounds = this.bounds(sourceNode, true);
            var matrix;
            var segment = isTarget ? last : first;
            if (segment.type !== "orthogonal") {
                var portLocation = this._getPortPosition(targetPort, targetBounds, undefined, targetNode);
                matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                portLocation = ej.Matrix.transform(matrix, portLocation);
                //segment._endPoint = portLocation;
                this._setLineEndPoint(connector, portLocation, isTarget);
            }
            else {
                var targetPortLocation = (isTarget ? connector._targetPortLocation : connector._sourcePortLocation) || this._getPortPosition(targetPort, targetBounds, undefined, targetNode);
                var targetDirection = this._swapDirection(targetNode.rotateAngle, this._getDirection(targetBounds, targetPortLocation));
                matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                targetPortLocation = ej.Matrix.transform(matrix, targetPortLocation);
                var sourcePortLocation;
                if (!isTarget) {
                    sourcePortLocation = connector.targetPoint;
                }
                else {
                    sourcePortLocation = connector.sourcePoint;
                }
                var sourceDirection;
                if (sourceNode) {
                    sourceDirection = this._getDirection(sourceBounds, sourcePortLocation);
                }
                else sourceDirection = "top";
                if (sourceDirection) {
                    targetBounds = this.bounds(targetNode);
                    if (sourceNode)
                        sourceBounds = this.bounds(sourceNode);
                    else sourceBounds = { left: sourcePortLocation.x, right: sourcePortLocation.x, top: sourcePortLocation.y, bottom: sourcePortLocation.y };
                    if (isTarget) {
                        this._setLineEndPoint(connector, targetPortLocation, true);
                        this._constructSegements(connector, last, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection);
                    }
                    else {
                        this._setLineEndPoint(connector, targetPortLocation, false);
                        this._constructSegements(connector, first, sourceBounds, sourcePortLocation, sourceDirection, targetBounds, targetPortLocation, targetDirection);
                    }
                }
            }
        },
        _dockPortToPoint: function (connector, targetNode, targetPort, isTarget) {
            var first = connector.segments[0];
            var last = connector.segments[connector.segments.length - 1];
            var segment = isTarget ? last : first;
            if (segment.type !== "orthogonal") {
                this._dockPortToNode(connector, targetNode, targetPort, null, null, isTarget);
            }
            else {
                var targetBounds = this.bounds(targetNode, true);
                var targetPortLocation = (isTarget ? connector._targetPortLocation : connector._sourcePortLocation) || this._getPortPosition(targetPort, targetBounds, undefined, targetNode);
                var targetDirection = this._swapDirection(targetNode.rotateAngle, this._getDirection(targetBounds, targetPortLocation));
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                targetPortLocation = ej.Matrix.transform(matrix, targetPortLocation);
                var sourcePortLocation;

                if (!isTarget) {
                    sourcePortLocation = first._endPoint;
                }
                else {
                    sourcePortLocation = last._startPoint;
                }
                var sourceBounds = this.bounds(ej.datavisualization.Diagram.Rectangle(sourcePortLocation.x, sourcePortLocation.y, 0, 0));
                targetBounds = this.bounds(targetNode);
                var sourceDirection = "top";
                if (isTarget) {
                    this._setLineEndPoint(connector, targetPortLocation, true);
                    this._pointsFromNodeToPoint(connector, last, targetDirection, targetBounds, targetNode.rotateAngle, targetPortLocation, sourcePortLocation, true); //{(connector, last, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection);
                }
                else {
                    this._setLineEndPoint(connector, targetPortLocation, false);
                    this._pointsFromNodeToPoint(connector, first, targetDirection, targetBounds, targetNode.rotateAngle, targetPortLocation, sourcePortLocation, false);
                }
            }
        },
        _containsminSpaceBetweenNode: function (diagram, sourceNode, targetNode) {
            var state = false;
            if (diagram && diagram.minSpaceBetweenNode && sourceNode && targetNode) {
                if (diagram.minSpaceBetweenNode && diagram.minSpaceBetweenNode.length > 0) {
                    for (var i = 0; i < diagram.minSpaceBetweenNode; i++) {
                        if (diagram.minSpaceBetweenNode[i] === sourceNode.name)
                            return true;
                        if (diagram.minSpaceBetweenNode[i] === targetNode.name)
                            return true;
                    }
                }
            }
            return state;
        },
        _dockNode: function (connector, targetNode, sourceNode, targetConnected, sourceConnected, diagram) {
            var startsegment, endsegment;
            var minSpace = connector._srcDecoratorSize + connector._tarDecoratorSize;
            minSpace = this._containsminSpaceBetweenNode(diagram, sourceNode, targetNode) ? 0 : minSpace;
            if (connector.segments.length == 1) {
                startsegment = endsegment = connector.segments[0];
            }
            else {
                startsegment = connector.segments[0];
                endsegment = connector.segments[connector.segments.length - 1];
            }
            if (targetConnected && sourceConnected && !connector.targetPort && !connector.sourcePort) {
                if (connector.segments.length == 1) {
                    if (connector.segments[0].type == "orthogonal") {
                        var sourceBounds = this.bounds(sourceNode);
                        var targetBounds = this.bounds(targetNode);
                        this._swapBounds(sourceNode, sourceBounds);
                        this._swapBounds(targetNode, targetBounds);
                        var srcPoint, tarPoint, srcDirection, tarDirection;
                        ////Test top side.
                        if (sourceBounds.y - minSpace >= targetBounds.bottom) {
                            srcPoint = sourceBounds.topCenter;
                            srcDirection = "top";
                            tarPoint = targetBounds.bottomCenter;
                            tarDirection = "bottom";
                        }
                        ////Test bottom side.
                        else if (sourceBounds.bottom + minSpace <= targetBounds.y) {
                            tarPoint = targetBounds.topCenter;
                            tarDirection = "top";
                            srcPoint = sourceBounds.bottomCenter;
                            srcDirection = "bottom";
                        }
                        if ((sourceBounds.bottom + minSpace > targetBounds.y) && (sourceBounds.y < targetBounds.bottom + minSpace)) {
                            if (sourceBounds.right + minSpace < targetBounds.x || (targetBounds.right >= sourceBounds.x - minSpace && sourceBounds.x > targetBounds.x)) {
                                ////rightleft
                                srcPoint = sourceBounds.middleRight;
                                srcDirection = "right";
                                tarPoint = targetBounds.middleLeft;
                                tarDirection = "left";
                            }
                            else {
                                if (targetBounds.right + minSpace < sourceBounds.x || (sourceBounds.right >= targetBounds.x - minSpace && sourceBounds.x < targetBounds.x)) {
                                    srcPoint = sourceBounds.middleLeft;
                                    srcDirection = "left";
                                    tarPoint = targetBounds.middleRight;
                                    tarDirection = "right";
                                }
                                else if (sourceBounds.x <= targetBounds.x) {
                                    srcPoint = sourceBounds.middleLeft;
                                    srcDirection = "left";
                                    tarPoint = targetBounds.middleLeft;
                                    tarDirection = "left";
                                    ////left left
                                }
                                else if (sourceBounds.x <= targetBounds.right) {
                                    ////right right
                                    srcPoint = sourceBounds.middleRight;
                                    srcDirection = "right";
                                    tarPoint = targetBounds.middleRight;
                                    tarDirection = "right";
                                }
                                else {
                                    ////left right
                                    srcPoint = sourceBounds.middleLeft;
                                    srcDirection = "left";
                                    tarPoint = targetBounds.middleRight;
                                    tarDirection = "right";
                                }
                            }
                        }
                        var targetPoint;
                        targetPoint = this._findEndPoint(srcDirection, srcPoint, sourceNode) || sourceBounds.center;
                        srcPoint = this._findIntersection(sourceNode, sourceBounds, connector, srcPoint, targetPoint, false) || srcPoint;
                        targetPoint = this._findEndPoint(tarDirection, tarPoint, targetNode) || targetBounds.center;
                        tarPoint = this._findIntersection(targetNode, targetBounds, connector, tarPoint, targetPoint, true) || tarPoint;
                        this._setLineEndPoint(connector, srcPoint, false);
                        this._setLineEndPoint(connector, tarPoint, true);
                        if (connector.segments[0].type == "orthogonal") {
                            this._constructSegements(connector, connector.segments[0], targetBounds, connector.targetPoint, tarDirection, sourceBounds, connector.sourcePoint, srcDirection);
                            connector.segments[0]._direction = srcDirection;
                        }
                    }
                    else {
                        if (targetNode) {
                            targetBounds = this.bounds(targetNode);
                            this._swapBounds(targetNode, targetBounds);
                            if (sourceNode) {
                                sourceBounds = this.bounds(sourceNode);
                                this._swapBounds(sourceNode, sourceBounds);
                                this._setLineEndPoint(connector, sourceBounds.center, false);
                                this._setLineEndPoint(connector, targetBounds.center, true);
                                this._dockBounds(connector, sourceNode, sourceBounds, false);
                            }
                            this._setLineEndPoint(connector, targetBounds.center, true);
                            this._dockBounds(connector, targetNode, targetBounds, true);
                        }
                        if (connector.segments[0].type == "bezier") {
                            this._updateBezierPoints(connector.segments[0]);
                        }
                    }
                }
                else {
                    this._dock(connector, startsegment, sourceNode, null, false);
                    this._updateIntermediateSegments(connector);
                    if (connector.segments.length == 1) {
                        this._dock(connector, startsegment, sourceNode, targetNode, false);
                        this._dock(connector, endsegment, targetNode, sourceNode, true);
                    }
                    else {
                        this._dock(connector, endsegment, targetNode, null, true);
                        this._updatePreviousSegment(connector);
                    }
                }
            }
            else if (targetConnected && !connector.targetPort) {
                this._dock(connector, endsegment, targetNode, sourceNode, true);
                this._updatePreviousSegment(connector);
            }
            else if (sourceConnected && !connector.sourcePort) {
                this._dock(connector, startsegment, targetNode, sourceNode, false);
                this._updateIntermediateSegments(connector);
            }
        },
        _adjustEndPoint: function (connector, sourceNode, sourcePort, targetNode, targetPort) {
            if (connector.sourcePadding || connector.targetPadding || sourcePort && sourcePort.connectorPadding || targetPort && targetPort.connectorPadding) {
                var length = 0;
                var targetBounds = targetNode ? this.bounds(targetNode) : null;
                var sourceBounds = sourceNode ? this.bounds(sourceNode) : null;
                if (sourceNode) {
                    var endPoint;
                    var segment = connector.segments[0];
                    if (segment.type !== "orthogonal") endPoint = segment.type !== "bezier" ? segment._endPoint : segment._point1;
                    else endPoint = segment.points[1];
                    if (sourcePort) length = connector.sourcePadding + sourcePort.connectorPadding;
                    var sourcePortLocation = this._adjustPoint(segment._startPoint, endPoint, true, length);
                    this._setLineEndPoint(connector, sourcePortLocation, false);
                    if (segment.type == "bezier") this._updateBezierPoints(segment, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds);
                }
                if (targetNode) {
                    var startPoint;
                    var segment = connector.segments[connector.segments.length - 1];
                    if (segment.type !== "orthogonal") startPoint = segment.type !== "bezier" ? segment._startPoint : segment._point2;
                    else startPoint = segment.points[segment.points.length - 2];
                    if (targetPort) length = connector.targetPadding + targetPort.connectorPadding;
                    var targetPortLocation = this._adjustPoint(startPoint, segment._endPoint, false, length);
                    this._setLineEndPoint(connector, targetPortLocation, true);
                    if (segment.type == "bezier") this._updateBezierPoints(segment, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds);
                }
            }
        },
        _findEndPoint: function (direction, point, node) {
            var targetPoint;
            switch (direction) {
                case "top":
                    targetPoint = { x: point.x, y: point.y + Math.max(node.width, node.height) };
                    break;
                case "bottom":
                    targetPoint = { x: point.x, y: point.y - Math.max(node.width, node.height) };
                    break;
                case "left":
                    targetPoint = { y: point.y, x: point.x + Math.max(node.width, node.height) };
                    break;
                case "right":
                    targetPoint = { y: point.y, x: point.x - Math.max(node.width, node.height) };
                    break;
            }
            return targetPoint;
        },
        _dock: function (connector, line, targetNode, sourceNode, isTarget) {
            var sourceBounds;
            if (targetNode) {
                var node = targetNode;
                var point = isTarget ? line._startPoint : line._endPoint;
                sourceBounds = this.bounds(targetNode);
                this._swapBounds(targetNode, sourceBounds);
                if (!isTarget) {
                    if (line.type == "orthogonal" && connector.segments[1] && connector.segments[1].type == "orthogonal") {
                        if (connector.segments[0]._isInternal && ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line._endPoint)) {
                            this._insertSegmentAtSourceEnd(connector, line, sourceBounds, targetNode, isTarget);
                        }
                        else if (ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line._endPoint)) {
                            this._removeFirstSegment(connector, line, sourceBounds, targetNode, isTarget);
                        }
                        else {
                            var dockPoint, dockDirection;;
                            switch (line.direction) {
                                case "left":
                                    dockDirection = "left";
                                    dockPoint = sourceBounds.middleLeft;
                                    break;
                                case "right": dockDirection = "right";
                                    dockPoint = sourceBounds.middleRight;
                                    break;
                                case "top": dockDirection = "top";
                                    dockPoint = sourceBounds.topCenter;
                                    break;
                                case "bottom": dockDirection = "bottom";
                                    dockPoint = sourceBounds.bottomCenter;
                                    break;
                            }
                            line.points = [];
                            var targetPoint = this._findEndPoint(dockDirection, dockPoint, targetNode) || sourceBounds.center;
                            dockPoint = this._findIntersection(targetNode, sourceBounds, connector, dockPoint, targetPoint, isTarget) || dockPoint;
                            line.points.push(dockPoint);
                            line.points.push(line._endPoint);
                            this._setLineEndPoint(connector, dockPoint, isTarget);
                        }
                    }
                    else {
                        this._dockNodeToPoint(connector, line._endPoint, targetNode, isTarget);
                    }
                }
                else {
                    if (line.type == "orthogonal") {
                        var second = connector.segments[connector.segments.length - 2];
                        if (second && second.type == "orthogonal") {
                            if (line.points.length > 2 &&
                                ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line.points[line.points.length - 2])) {
                                var removePreSegment = false;
                                if (second.direction == "top" || second.direction == "bottom") {
                                    if (second._endPoint.x >= sourceBounds.left && second._endPoint.x <= sourceBounds.right) {
                                        this._removeLastSegment(connector, line, second, targetNode, sourceNode, isTarget); return;
                                    }
                                    else {
                                        second._length = second.length = Math.abs(second._startPoint.y - sourceBounds.middleLeft.y);;
                                        if (second.length == 0) {
                                            removePreSegment = true;
                                        }
                                        else {
                                            if (second.length < 0) {
                                                second._length = second.length *= -1;
                                                second._direction = second.direction = (second.direction == "top") ? "bottom" : "top";
                                            }
                                            connector.targetPoint = second._endPoint.x > sourceBounds.right ? sourceBounds.middleRight : sourceBounds.middleLeft;
                                        }
                                    }
                                }
                                else {
                                    if (second._endPoint.y >= sourceBounds.top && second._endPoint.y <= sourceBounds.bottom) {
                                        this._removeLastSegment(connector, line, second, targetNode, sourceNode, isTarget); return;
                                    }
                                    else {
                                        second._length = second.length = Math.abs(second._startPoint.x - sourceBounds.topCenter.x);;
                                        if (second.length == 0) removePreSegment = true;
                                        else {
                                            if (second.length < 0) {
                                                second._length = second.length *= -1;
                                                second._direction = second.direction = (second.direction == "left") ? "right" : "left";
                                            }
                                            connector.targetPoint = second._endPoint.y > sourceBounds.bottom ? sourceBounds.bottomCenter : sourceBounds.topCenter;
                                        }
                                    }
                                }
                                if (removePreSegment) {
                                    connector.segments.splice(connector.segments.length - 2, 1);
                                    this._dock(connector, line, targetNode, sourceNode, isTarget);
                                    return;
                                }
                                connector.targetPoint = this._findIntersection(targetNode, sourceBounds, connector, connector.targetPoint, sourceBounds.center, isTarget) || connector.targetPoint;
                                this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
                                line._direction = this._getOrthoDirection(line._startPoint, line._endPoint, second);
                                this._setLineEndPoint(connector, connector.targetPoint, isTarget);
                            }
                            else if (ej.datavisualization.Diagram.Geometry.containsPoint(sourceBounds, line._startPoint)) {
                                var diflength = second.direction == "left" || second.direction == "right" ? node.width / 2 : node.height / 2;
                                second._length = second.length -= diflength + 30;
                                if (second.length == 0) {
                                    connector.segments.splice(connector.segments.length - 2, 1);
                                    this._dock(connector, line, targetNode, sourceNode, isTarget);
                                    return;
                                }
                                if (second.direction == "left" || second.direction == "right")
                                    connector.targetPoint = second.direction == "right" ? sourceBounds.middleLeft : sourceBounds.middleRight;
                                else
                                    connector.targetPoint = second.direction == "bottom" ? sourceBounds.topCenter : sourceBounds.bottomCenter;
                                connector.targetPoint = this._findIntersection(targetNode, sourceBounds, connector, connector.targetPoint, sourceBounds.center, isTarget) || connector.targetPoint;
                                this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
                                line._direction = this._getOrthoDirection(line._startPoint, line._endPoint, second);
                                this._setLineEndPoint(connector, connector.targetPoint, isTarget);
                            }
                            else {
                                this._dockNodeToPoint(connector, point, targetNode, isTarget);
                            }
                        } else {
                            this._dockNodeToPoint(connector, point, targetNode, isTarget);
                        }
                    }
                    else { this._dockNodeToPoint(connector, point, targetNode, isTarget); }
                }
            }
        },
        _removeLastSegment: function (connector, line, second, targetNode, sourceNode, isTarget) {
            connector.segments.splice(connector.segments.length - 1, 1);
            second.length = second._length = null;
            second.direction = null;
            second._direction = line._direction;
            this._dock(connector, second, targetNode, sourceNode, isTarget);
        },
        _insertSegmentAtSourceEnd: function (connector, line, sourceBounds, sourceNode, isTarget) {
            var second = connector.segments[1];
            var third = connector.segments[2];
            if (connector.segments[0].direction == "left" || connector.segments[0].direction == "right") {
                var orientation = "horizontal";
                connector.sourcePoint = second.direction == "top" ? sourceBounds.topCenter : sourceBounds.bottomCenter;
                if (second && (second.length || second.length === 0))
                    second._length = second.length = Math.max(Math.abs(connector.sourcePoint.y - second._endPoint.y), 25);
                if (third && (third.length || third.length === 0)) {
                    third.length = third._length = Math.abs(sourceBounds.topCenter.x - third._endPoint.x);
                }
            }
            else {
                var orientation = "vertical";
                connector.sourcePoint = second.direction == "left" ? sourceBounds.middleLeft : sourceBounds.middleRight;
                if (second && (second.length || second.length === 0))
                    second._length = second.length = Math.max(Math.abs(connector.sourcePoint.x - second._endPoint.x), 25);
                if (third && (third.length || third.length === 0)) {
                    third.length = third._length = Math.abs(sourceBounds.middleRight.y - third._endPoint.y);
                }
            }
            //Updating adjacent segments
            if (connector.segments[3] && (connector.segments[3].length || connector.segments[3].length == 0)) {
                var value = second.direction == "bottom" || second.direction == "right" ? second.length : -second.length;
                connector.segments[3].length = connector.segments[3]._length = orientation == "vertical" ?
                    Math.abs(connector.sourcePoint.x + value - connector.segments[3]._endPoint.x) :
                    Math.abs(connector.sourcePoint.y + value - connector.segments[3]._endPoint.y);
                if (connector.segments[3].length < 0) {
                    var value = second.direction == "bottom" || second.direction == "right" ? second.length : -second.length;
                    connector.segments[3].length = connector.segments[3]._length = orientation == "vertical" ?
                        Math.abs(connector.sourcePoint.x + value - connector.segments[3]._endPoint.x) :
                        Math.abs(connector.sourcePoint.y + value - connector.segments[3]._endPoint.y);
                }
            }
            connector.segments.splice(0, 1);
            connector.sourcePoint = this._findIntersection(sourceNode, sourceBounds, connector, connector.sourcePoint, sourceBounds.center, isTarget) || connector.sourcePoint;
            this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
            this._setLineEndPoint(connector, connector.sourcePoint, isTarget);
        },
        _removeFirstSegment: function (connector, line, sourceBounds, sourceNode, isTarget) {
            var newLength, firstSegLength;
            var direction = connector.segments[1].direction || this._getBezierDirection(connector.segments[1].points[0], connector.segments[1].points[1]);
            if (direction == "left" || direction == "right") {
                var length = line._endPoint.y - sourceBounds.middleRight.y;
                connector.segments[0].direction = connector.segments[0]._direction = length >= 0 ? "bottom" : "top";
                connector.segments[0].length = connector.segments[0]._length = Math.abs(length);
                var actualdist = direction == "right" ? connector.segments[1]._endPoint.x - sourceBounds.right :
                    sourceBounds.left - connector.segments[1]._endPoint.x;
                connector.sourcePoint = direction == "left" ? sourceBounds.middleLeft : sourceBounds.middleRight;
                newLength = Math.abs(connector.sourcePoint.x - connector.segments[0]._startPoint.x);
                firstSegLength = Math.abs(connector.sourcePoint.y - connector.segments[0]._endPoint.y);
            }
            else {
                if (connector.segments[0].length || connector.segments[0].length == 0) {
                    var length = line._endPoint.x - sourceBounds.bottomCenter.x;
                    connector.segments[0].direction = connector.segments[0]._direction = length >= 0 ? "right" : "left";
                    connector.segments[0].length = connector.segments[0]._length = Math.abs(length);
                }
                var actualdist = direction == "bottom" ? connector.segments[1]._endPoint.y - sourceBounds.bottom :
                    sourceBounds.top - connector.segments[1]._endPoint.y;
                connector.sourcePoint = direction == "top" ? sourceBounds.topCenter : sourceBounds.bottomCenter;
                newLength = Math.abs(connector.sourcePoint.y - connector.segments[0]._startPoint.y);
                firstSegLength = Math.abs(connector.sourcePoint.x - connector.segments[0]._endPoint.x);
            }
            if (connector.segments[1] && (connector.segments[1].length || connector.segments[1].length === 0)) {
                connector.segments[1]._length = connector.segments[1].length = actualdist - 25;
                if (connector.segments[1]._length < 0) {
                    connector.segments.splice(0, 2);
                    if (connector.segments[0].length || connector.segments[0].length === 0)
                        connector.segments[0].length = connector.segments[0]._length = newLength;
                    var newSegment = ej.datavisualization.Diagram.Segment({ type: "orthogonal", length: firstSegLength, direction: direction });
                }
            }
            if (!newSegment) {
                newSegment = ej.datavisualization.Diagram.Segment({ type: "orthogonal", length: 25, direction: direction });
            }
            var segments = [newSegment];
            newSegment._isInternal = true;
            connector.segments = segments.concat(connector.segments);
            connector.sourcePoint = this._findIntersection(sourceNode, sourceBounds, connector, connector.sourcePoint, sourceBounds.center, isTarget) || connector.sourcePoint;
            this._updateConnectorSegments(connector, connector.sourcePort, connector.targetPort);
            this._setLineEndPoint(connector, connector.sourcePoint, isTarget);
        },
        _dockNodeToPoint: function (connector, fixedPoint, node, isTarget) {
            var line, sourceBounds, segment;
            line = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            if (line.type != "orthogonal") {
                sourceBounds = this.bounds(node);
                this._swapBounds(node, sourceBounds);
                this._setLineEndPoint(connector, sourceBounds.center, isTarget);
                this._dockBounds(connector, node, sourceBounds, isTarget);
            }
            else {
                sourceBounds = this.bounds(node);
                this._swapBounds(node, sourceBounds);
                var dockPoint, dockDirection, targetDirection;
                var point = fixedPoint;
                if (connector.segments.length > 1) {
                    var prev = connector.segments[connector.segments.length - 2];
                    var left = Math.abs(point.x - sourceBounds.left);
                    var right = Math.abs(point.x - sourceBounds.right);
                    var top = Math.abs(point.y - sourceBounds.top);
                    var bottom = Math.abs(point.y - sourceBounds.bottom);
                    if (prev && isTarget) {
                        var horizontal = prev.direction == "left" || prev.direction == "right";
                        var vertical = prev.direction == "top" || prev.direction == "bottom";
                    }
                    line = !isTarget ? connector.segments[0] : connector.segments[connector.segments.length - 1];
                    if ((line.points.length == 2 || !prev) && line.type == "orthogonal") {
                        horizontal = vertical = false;
                    }
                    var targetPoint;
                    if (sourceBounds.bottom < point.y && !horizontal) {
                        dockDirection = "bottom";
                        targetDirection = "top";
                        dockPoint = sourceBounds.bottomCenter;
                    }
                    else if (sourceBounds.y > point.y && !horizontal) {
                        dockDirection = "top";
                        targetDirection = "bottom";
                        dockPoint = sourceBounds.topCenter;
                    }
                    else if (sourceBounds.right < point.x && !vertical) {
                        dockDirection = "right";
                        targetDirection = "left";
                        dockPoint = sourceBounds.middleRight;
                    }
                    else if (sourceBounds.x > point.x && !vertical) {
                        dockDirection = "left";
                        targetDirection = "right";
                        dockPoint = sourceBounds.middleLeft;
                    }
                    else {
                        var min = left;
                        dockPoint = sourceBounds.middleLeft;
                        dockDirection = "left";
                        targetDirection = "right";
                        if (min >= right && right != 0) {
                            dockPoint = sourceBounds.middleRight;
                            dockDirection = "right";
                            targetDirection = "left";
                            min = right;
                        }
                        if (min > top && top != 0) {
                            dockPoint = sourceBounds.topCenter;
                            dockDirection = "top";
                            targetDirection = "bottom";
                            min = top;
                        }
                        if (min > bottom && bottom != 0) {
                            dockPoint = sourceBounds.bottomCenter;
                            dockDirection = "bottom";
                            targetDirection = "top";
                            min = bottom;
                        }
                    }
                }
                else {
                    dockPoint = sourceBounds.center;
                    dockDirection = this._getBezierDirection(fixedPoint, dockPoint);
                    switch (dockDirection) {
                        case "left":
                            targetDirection = "right";
                            break;
                        case "right":
                            targetDirection = "left";
                            break;
                        case "top":
                            targetDirection = "bottom";
                            break;
                        case "bottom":
                            targetDirection = "top";
                            break;
                    }
                }
                if (dockPoint) {
                    if (isTarget || connector.segments.length == 1) {
                        segment = connector.segments[connector.segments.length - 1];
                        if (segment.type == "orthogonal") {
                            segment._direction = isTarget ? dockDirection : targetDirection;
                        }
                    }
                    else { segment = connector.segments[0]; }
                    targetPoint = this._findEndPoint(dockDirection, dockPoint, node) || sourceBounds.center;
                    dockPoint = this._findIntersection(node, sourceBounds, connector, dockPoint, targetPoint, isTarget) || dockPoint;
                    isTarget ? connector.targetPoint = dockPoint : connector.sourcePoint = dockPoint;
                    if (connector.segments.length != 1)
                        this._addOrthogonalPoints(segment, !isTarget ? null : connector.segments[connector.segments.length - 2], !isTarget ? connector.segments[1] : null, connector.sourcePoint, connector.targetPoint);
                    this._setLineEndPoint(connector, dockPoint, isTarget);
                }
            }
        },
        _getDockSegment: function (connector, line, rotateAngle, bounds, isTarget, direction) {
            var segment; var segments = this._getEdges(rotateAngle, bounds);
            {
                var direction = "", segment, intersecSeg;
                //var line = connector.line;
                var length = ej.datavisualization.Diagram.Geometry.distance(line._startPoint, line._endPoint);
                if (isTarget)
                    intersecSeg = ej.datavisualization.Diagram.LineSegment(line.points[line.points.length - 2], line.points[line.points.length - 1]);
                else {
                    if (length > 5) {
                        intersecSeg = ej.datavisualization.Diagram.LineSegment(line._startPoint, line._endPoint);
                    }
                    else {
                        intersecSeg = ej.datavisualization.Diagram.LineSegment(line._startPoint, connector.segments[1] ? connector.segments[1]._endPoint : connector.targetPoint);
                    }
                }
                if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.left)) {
                    segment = segments.left;
                    direction = "left";
                }
                else if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.top)) {
                    segment = segments.top;
                    direction = "top";
                }
                else if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.right)) {
                    segment = segments.right;
                    direction = "right";
                }
                else if (ej.datavisualization.Diagram.Geometry.intersectSegment(intersecSeg, segments.bottom)) {
                    segment = segments.bottom;
                    direction = "bottom";
                }
            }
            direction = this._swapDirection(rotateAngle, direction);
            if (segment) {
                return { "dockPoint": ej.datavisualization.Diagram.Geometry.midPoint(segment), "direction": direction };
            }
            return null;
        },
        _dockBounds: function (connector, node, bounds, isTarget) {
            var line;
            line = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            var strPt = line._startPoint;
            var endPt = line._endPoint || line.point;
            if (line.type == "bezier" && (line.point1 || line.point2)) {
                if (isTarget) strPt = line._point2;
                else endPt = line._point1;
            }
            var intersection = this._findIntersection(node, bounds, connector, strPt, endPt, isTarget);
            if (intersection) {
                this._setLineEndPoint(connector, intersection, isTarget);
                if (line.type === "bezier") {
                    this._updateBezierPoints(line);
                }
            }
        },
        _findIntersection: function (node, bounds, connector, strPt, endPt, isTarget) {
            var segmentPoints, length;
            var line = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            var pad = node.connectorPadding;
            pad += isTarget ? connector.targetPadding : connector.sourcePadding;
            if (line.type == "orthogonal") {
                strPt = { x: strPt.x, y: strPt.y };
                if (strPt.x == endPt.x) if (strPt.y < endPt.y) strPt.y -= pad + 5; else strPt.y += pad + 5;
                if (strPt.y == endPt.y) if (strPt.x < endPt.x) strPt.x -= pad + 5; else strPt.x += pad + 5;
            }
            var angle;
            var point = isTarget || line.type == "orthogonal" ? strPt : endPt;
            if (line.type != "orthogonal") {
                if (isTarget) {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(strPt, endPt);
                    endPt = ej.datavisualization.Diagram.Geometry.transform({ x: endPt.x, y: endPt.y }, angle, Math.max(node.width / 2, node.height / 2));
                }
                else {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(endPt, strPt);
                    strPt = ej.datavisualization.Diagram.Geometry.transform({ x: strPt.x, y: strPt.y }, angle, Math.max(node.width / 2, node.height / 2));
                }
            }
            if (node._shape === "ellipse") {
                var thisSegment = ej.datavisualization.Diagram.LineSegment(strPt, endPt);
                intersection = this._getEllipseIntersectCoords(node, thisSegment, connector, point, isTarget);
                return intersection;
            }
            else if (node._shape === "polygon" && !(node.type == "bpmn" && line.type == "orthogonal")) {
                segmentPoints = [];
                if (!node._segmentPoints) {
                    segmentPoints = this._findSegmentPoints(node, connector, isTarget);
                } else segmentPoints = node._segmentPoints;

                if (node.rotateAngle) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                }
                length = segmentPoints.length;
                var pts = [];
                for (var i = 0; i < length; i++) {
                    var pt1 = ej.datavisualization.Diagram.Point(segmentPoints[i].x + (node.offsetX - node.width * node.pivot.x), segmentPoints[i].y + (node.offsetY - node.height * node.pivot.y));
                    if (node.rotateAngle != 0) {
                        pt1 = ej.Matrix.transform(matrix, pt1);
                    }
                    if (node.connectorPadding || connector.sourcePadding || connector.targetPadding) {
                        var x = node.offsetX == pt1.x ? 0 : (node.offsetX < pt1.x ? 1 : -1);
                        var y = node.offsetY == pt1.y ? 0 : (node.offsetY < pt1.y ? 1 : -1);
                        pt1 = pad ? ej.datavisualization.Diagram.Geometry.translate(pt1, x * pad, y * pad) : pt1;
                    }
                    pts[i] = pt1;
                }
                segmentPoints = pts;
            }
            else if (node.pathData && node._shape === "path" && !(node.type == "bpmn" && line.type == "orthogonal")) {
                if (!node._segmentPoints) {
                    var pts = this._findSegmentPoints(node, connector, isTarget);
                }
                segmentPoints = pts || node._segmentPoints;
                if (((node.pathData.split("m").length - 1) + (node.pathData.split("M").length - 1)) == 1) segmentPoints[segmentPoints.length] = segmentPoints[0];
                length = segmentPoints.length;
            }
            else {
                if (node.connectorPadding || connector.sourcePadding || connector.targetPadding) {
                    var rect = ej.datavisualization.Diagram.Rectangle(bounds.x - pad, bounds.y - pad, node.width + 2 * pad, node.height + 2 * pad);
                    bounds = this.bounds(rect);
                }
                segmentPoints = bounds.points;
                segmentPoints[segmentPoints.length] = segmentPoints[0];
                length = bounds.points.length;
            }
            var thisSegment = ej.datavisualization.Diagram.LineSegment(strPt, endPt);
            var intersection = this._getIntersectionPoints(thisSegment, segmentPoints, true, point);
            return intersection;
        },
        _getIntersectionPoints: function (thisSegment, segmentPoints, minimal, point) {
            var i;
            var length = segmentPoints.length;
            var segment = ej.datavisualization.Diagram.LineSegment(segmentPoints[0], segmentPoints[1]);
            var intersection = ej.datavisualization.Diagram.Geometry.intersectSegment(thisSegment, segment);
            if (intersection) {
                if (!minimal) return intersection;
                var min = ej.datavisualization.Diagram.Geometry.distance(intersection, point);
            }
            //if (intersection)
            if (isNaN(min) || min > 0) {
                for (i = 1; i < length - 1; i++) {
                    segment = ej.datavisualization.Diagram.LineSegment(segmentPoints[i], segmentPoints[i + 1]);
                    var intersect = ej.datavisualization.Diagram.Geometry.intersectSegment(thisSegment, segment);
                    if (intersect) {
                        if (!minimal) return intersect;
                        var dist = ej.datavisualization.Diagram.Geometry.distance(intersect, point);
                        if (isNaN(min) || min > dist) { min = dist; intersection = intersect; }
                        if (min >= 0 && min <= 1)
                            break;
                    }
                }
            }
            return intersection;
        },

        _findSegmentPoints: function (node, connector, isTarget) {
            var pts = [];
            if (node._shape == "path") {
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                document.body.appendChild(svg);
                var pathNode = document.createElementNS('http://www.w3.org/2000/svg', "path");
                pathNode.setAttributeNS(null, "d", node._absolutePath || node.pathData);
                svg.appendChild(pathNode);
                var pathBounds = (!node._absoluteBounds || node._scaled || node._absolutePath) ? pathNode.getBBox() : node._absoluteBounds;
                var pad = node.connectorPadding;
                if (connector)
                    pad += isTarget ? connector.targetPadding : connector.sourcePadding;
                if (pad || !node._absolutePath || node._scaled) {
                    var pathData = ej.datavisualization.Diagram.Geometry.updatePath(-pad, -pad, node.width + 2 * pad, node.height + 2 * pad, node._absolutePath || node.pathData, null, pathBounds, pad ? null : node);
                    pathNode.setAttributeNS(null, "d", pathData);
                    if ((node._scaled && !pad) || !node._absolutePath) {
                        node._absolutePath = pathData;
                        node._scaled = false;
                    }
                } else pathNode.setAttributeNS(null, "d", node._absolutePath);
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                var pathLength = pathNode.getTotalLength();
                for (var sample, sampleLength = 0; sampleLength <= pathLength; sampleLength += 10) {
                    sample = pathNode.getPointAtLength(sampleLength);
                    var pt1 = { x: node.offsetX - node.width * node.pivot.x + sample.x, y: node.offsetY - node.height * node.pivot.y + sample.y };
                    if (node.rotateAngle != 0) {
                        pt1 = ej.Matrix.transform(matrix, pt1);
                    }
                    pts.push(pt1);
                }
                document.body.removeChild(svg);
            }
            else if (node._shape == "polygon") {
                var length = node.points.length;
                for (var i = 0; i < length; i++) pts[i] = node.points[i];
                ej.datavisualization.Diagram.Geometry.updatePolygonPoints(node, pts);
                pts[pts.length] = pts[0];
            } else return null;
            return pts;
        },
        _getEdges: function (rotateAngle, bounds) {
            var points = bounds.points;
            var segments = {};
            var angle = rotateAngle % 360;
            var temp;
            segments.left = ej.datavisualization.Diagram.LineSegment(points[3], points[0]);
            segments.top = ej.datavisualization.Diagram.LineSegment(points[0], points[1]);
            segments.right = ej.datavisualization.Diagram.LineSegment(points[1], points[2]);
            segments.bottom = ej.datavisualization.Diagram.LineSegment(points[2], points[3]);
            if (angle < 0) {
                angle += 360;
            }
            if (angle > 315 || angle < 45) {
            }
            else if (angle < 135) {
                temp = segments.top;
                segments.top = segments.left;
                segments.left = segments.bottom;
                segments.bottom = segments.right;
                segments.right = temp;
            }
            else if (angle < 225) {
                temp = segments.top;
                segments.top = segments.bottom;
                segments.bottom = temp;
                temp = segments.left;
                segments.left = segments.right;
                segments.right = temp;
            }
            else {
                temp = segments.bottom;
                segments.bottom = segments.left;
                segments.left = segments.top;
                segments.top = segments.right;
                segments.right = temp;
            }
            return segments;
        },
        _pointsFromNodeToPoint: function (connector, segment, direction, bounds, angle, point, endPoint, isTarget) {
            var dir, num;
            var minSpace = isTarget ? connector._tarDecoratorSize : connector._srcDecoratorSize;
            var points = [];
            points.push(point);
            var straight;
            straight = (point.y == endPoint.y && (direction == "left" && endPoint.x < point.x || direction == "right" && endPoint.x > point.x)) ||
                (point.x == endPoint.x && (direction == "top" && endPoint.y < point.y || direction == "bottom" && endPoint.y > point.y));
            //if (angle == 0)
            //if (!straight && !isTarget) straight = point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom;
            if (!straight) {
                if (direction == "top" || direction == "bottom") {
                    if (direction == "top" && endPoint.y < point.y && endPoint.y > point.y - minSpace || direction == "bottom" && endPoint.y > point.y && endPoint.y < point.y + minSpace) {
                        var y = direction == "top" ? bounds.top - minSpace : bounds.bottom + minSpace;
                        points.push({ x: point.x, y: y });
                        points.push({ x: point.x + (endPoint.x - point.x) / 2, y: y });
                        points.push({ x: point.x + (endPoint.x - point.x) / 2, y: endPoint.y });
                    }
                    else if (Math.abs(point.x - endPoint.x) > minSpace && (direction == "top" && endPoint.y < point.y || direction == "bottom" && endPoint.y > point.y)) {
                        //twosegments
                        points.push({ x: point.x, y: endPoint.y });
                    }
                    else if ((direction == "top" && endPoint.y < point.y) || (direction == "bottom" && endPoint.y > point.y)) {
                        if (Math.abs(point.x - endPoint.x) <= minSpace && (segment.points.length > 2)) {
                            //three segments
                            var y = direction == "top" ? bounds.top - minSpace : bounds.bottom + minSpace;                          
                            points.push({ x: point.x, y: y });
                            points.push({ x: endPoint.x, y: y });
                        }
                        else
                            endPoint.x = point.x;
                    }
                    else if (Math.abs(point.x - endPoint.x) <= minSpace || ((endPoint.x < bounds.left || endPoint.x > bounds.right) && endPoint.y != point.y)) {
                        //three segments
                        var y = direction == "top" ? bounds.top - minSpace : bounds.bottom + minSpace;
                        points.push({ x: point.x, y: y });
                        points.push({ x: endPoint.x, y: y });
                    }
                    else {
                        //four segments
                        var y = direction == "top" ? bounds.top - minSpace : bounds.bottom + minSpace;
                        var x = (endPoint.x < point.x) ? bounds.left - minSpace : bounds.right + minSpace;
                        points.push({ x: point.x, y: y });
                        points.push({ x: x, y: y });
                        points.push({ x: x, y: endPoint.y });
                    }
                }
                else {
                    if (direction == "left" && endPoint.x < point.x && endPoint.x > point.x - minSpace || direction == "right" && endPoint.x > point.x && endPoint.x < point.x + minSpace) {
                        var x = direction == "left" ? bounds.left - minSpace : bounds.right + minSpace;
                        points.push({ x: x, y: point.y });
                        points.push({ x: x, y: point.y + (endPoint.y - point.y) / 2 });
                        points.push({ x: endPoint.x, y: point.y + (endPoint.y - point.y) / 2 });
                    }
                    else if (Math.abs(point.y - endPoint.y) > minSpace && (direction == "left" && endPoint.x < point.x || direction == "right" && endPoint.x > point.x)) {
                        points.push({ x: endPoint.x, y: point.y });
                        //twosegments
                    }
                    else if ((direction == "left" && endPoint.x < point.x) || (direction == "right" && endPoint.x > point.x)) {
                        if (Math.abs(point.y - endPoint.y) <= minSpace && (segment.points.length > 2)) {
                            //three segments
                            var x = direction == "left" ? bounds.left - minSpace : bounds.right + minSpace;
                            points.push({ x: x, y: point.y });
                            points.push({ x: x, y: endPoint.y });
                        }
                        else
                            endPoint.y = point.y;
                    }
                    else if (Math.abs(point.y - endPoint.y) <= minSpace || ((endPoint.y < bounds.top || endPoint.y > bounds.bottom) && endPoint.x != point.x)) {
                        //three segments
                        var x = direction == "left" ? bounds.left - minSpace : bounds.right + minSpace;
                        points.push({ x: x, y: point.y });
                        points.push({ x: x, y: endPoint.y });
                    }
                    else {
                        //four segments
                        var y = (endPoint.y < point.y) ? bounds.top - minSpace : bounds.bottom + minSpace;
                        var x = direction == "left" ? bounds.left - minSpace : bounds.right + minSpace;
                        points.push({ x: x, y: point.y });
                        points.push({ x: x, y: y });
                        points.push({ x: endPoint.x, y: y });
                    }
                }
            }
            points.push(endPoint);
            if (isTarget) points.reverse();
            segment._startPoint = points[0];
            segment._endPoint = points[points.length - 1];
            segment.points = points;
            if (segment.direction) {
                if (segment.direction == "left" || segment.direction == "right") {
                    segment.length = segment._length = Math.abs(segment._startPoint.x - segment._endPoint.x);
                    if (segment._startPoint.x < segment._endPoint.x) segment._direction = segment.direction = "right"; else segment._direction = segment.direction = "left";
                }
                else {
                    segment.length = segment._length = Math.abs(segment._startPoint.y - segment._endPoint.y);
                    if (segment._startPoint.y < segment._endPoint.y) segment._direction = segment.direction = "bottom"; else segment._direction = segment.direction = "top";
                }
            }
        },
        _constructSegements: function (connector, segment, targetBounds, targetPortLocation, targetDirection, sourceBounds, sourcePortLocation, sourceDirection) {
            var points, reverse;
            if (sourceDirection === "right") {
                if (targetDirection === "left") {
                    points = this._rightToLeft(connector, segment, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, false);
                }
                else if (targetDirection === "right") {
                    points = this._rightToRight(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                else if (targetDirection === "top") {
                    points = this._rightToTop(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, false);
                }
                else if (targetDirection === "bottom") {
                    points = this._rightToBottom(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, false);
                }
            }
            if (sourceDirection === "left") {
                if (targetDirection === "right") {
                    points = this._rightToLeft(connector, segment, sourceBounds, sourcePortLocation, targetBounds, targetPortLocation, true);
                    reverse = true;
                }
                if (targetDirection === "left") {
                    points = this._leftToLeft(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                if (targetDirection === "top") {
                    points = this._leftToTop(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, false);
                }
                if (targetDirection === "bottom") {
                    points = this._leftToBottom(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, false);
                }
            }
            if (sourceDirection === "top") {
                if (targetDirection === "left") {
                    points = this._leftToTop(connector, sourceBounds, sourcePortLocation, targetBounds, targetPortLocation, true);
                    reverse = true;
                }
                if (targetDirection === "right") {
                    points = this._rightToTop(connector, sourceBounds, sourcePortLocation, targetBounds, targetPortLocation, true);
                    reverse = true;
                }
                if (targetDirection === "top") {
                    points = this._topToTop(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
                if (targetDirection === "bottom") {
                    points = this._topToBottom(connector, segment, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, false);
                }
            }
            if (sourceDirection === "bottom") {
                if (targetDirection === "left") {
                    points = this._leftToBottom(connector, sourceBounds, sourcePortLocation, targetBounds, targetPortLocation, true);
                    reverse = true;
                }
                if (targetDirection === "right") {
                    points = this._rightToBottom(connector, sourceBounds, sourcePortLocation, targetBounds, targetPortLocation, true);
                    reverse = true;
                }
                if (targetDirection === "top") {
                    points = this._topToBottom(connector, segment, sourceBounds, sourcePortLocation, targetBounds, targetPortLocation, true);
                    reverse = true;
                }
                if (targetDirection === "bottom") {
                    points = this._bottomToBottom(connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation);
                }
            }
            if (reverse) {
                points.reverse();
            }
            var point1 = points[points.length - 1];
            var point2 = points[points.length - 2];
            while (points.length > 2 && point1.x == point2.x && point1.y == point2.y) {
                points.splice(points.length - 1, 1);
                point1 = points[points.length - 1];
                point2 = points[points.length - 2];
            }
            point1 = points[0];
            point2 = points[1];
            while (points.length > 2 && point1.x == point2.x && point1.y == point2.y) {
                points.splice(0, 1);
                point1 = points[0];
                point2 = points[1];
            }
            segment._startPoint = points[0];
            segment._endPoint = points[points.length - 1];
            segment.points = points;
            //this._setPoints(connector.line, points);
        },
        _updateIntermediateSegments: function (connector) {
            var startPoint = connector.segments[0]._endPoint;
            var prev = connector.segments[0];
            var length = prev.points.length;
            var next = null;
            var runAngle;
            if (connector.segments[1]) {
                var segment = connector.segments[1];
                segment._startPoint = startPoint;
                if (segment.type == "orthogonal" && (segment.length || segment.length === 0)) {
                    if (segment.direction == "left" || segment.direction == "right") {
                        if (connector.segments[2]) {
                            if (connector.segments[2].length || connector.segments[2].length === 0) {
                                if (connector.segments[2].direction == "top")
                                    connector.segments[2].length += segment._startPoint.y - segment._endPoint.y;
                                else
                                    connector.segments[2].length -= segment._startPoint.y - segment._endPoint.y;
                                if (connector.segments[2].length < 0) {
                                    connector.segments[2].length *= -1;
                                    connector.segments[2].direction = connector.segments[2]._direction = connector.segments[2]._direction == "bottom" ? "top" : "bottom";
                                }
                                connector.segments[2]._length = connector.segments[2].length;
                            }
                        }
                        segment._endPoint.y = segment._startPoint.y;
                    }
                    else {
                        if (connector.segments[2]) {
                            if (connector.segments[2].length || connector.segments[2].length === 0) {
                                if (connector.segments[2].direction == "left")
                                    connector.segments[2].length += segment._startPoint.x - segment._endPoint.x;
                                else
                                    connector.segments[2].length -= segment._startPoint.x - segment._endPoint.x;
                                if (connector.segments[2].length < 0) {
                                    connector.segments[2].length *= -1;
                                    connector.segments[2].direction = connector.segments[2]._direction = connector.segments[2]._direction == "right" ? "left" : "right";
                                }
                                connector.segments[2]._length = connector.segments[2].length;
                            }
                        }
                        segment._endPoint.x = segment._startPoint.x;
                    }
                    if (connector.sourcePort && prev.points.length > 2) {
                        if (segment.direction == "left" || segment.direction == "right") {
                            if (prev.points[prev.points.length - 1].y == prev.points[prev.points.length - 2].y) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                                if (segment.points.length == 2) {
                                    segment._endPoint.y = segment._startPoint.y;
                                }
                            }
                        }
                        else {
                            if (prev.points[prev.points.length - 1].x == prev.points[prev.points.length - 2].x) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                                if (segment.points.length == 2) {
                                    segment._endPoint.x = segment._startPoint.x;
                                }
                            }
                        }
                    }
                    if (segment.length || segment.length === 0)
                        segment.length = segment._length = ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment.points[1]);
                    if (segment.length > 0)
                        segment.direction = segment._direction = this._getBezierDirection(segment._startPoint, segment._endPoint) || segment._direction;
                    this._addOrthogonalPoints(segment, prev, connector.segments[2], connector.sourcePoint, connector.targetPoint);
                    if (connector.segments[2])
                        this._addOrthogonalPoints(connector.segments[2], connector.segments[1], connector.segments[3], connector.sourcePoint, connector.targetPoint);
                }
                else if (segment.type == "orthogonal" && segment.length === null) {
                    if (connector.sourcePort && prev.points.length > 2) {
                        if (segment._direction == "left" || segment._direction == "right") {
                            if (prev.points[prev.points.length - 1].y == prev.points[prev.points.length - 2].y) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                            }
                        }
                        else {
                            if (prev.points[prev.points.length - 1].x == prev.points[prev.points.length - 2].x) {
                                segment._startPoint = segment.points[0] = prev.points[prev.points.length - 2];
                                prev.points.splice(prev.points.length - 1, 1);
                                prev._endPoint = prev.points[prev.points.length - 1];
                            }
                        }
                    }
                    segment._startPoint = segment.points[0] = connector.segments[0]._endPoint;
                    this._addOrthogonalPoints(connector.segments[1], connector.segments[0], null, connector.sourcePoint, connector.targetPoint);
                }
                else {
                    segment._startPoint = segment.points[0] = connector.segments[0]._endPoint;
                    if (segment.type == "bezier") {
                        this._updateBezierPoints(segment);
                    }
                }
            }
        },
        _updatePreviousSegment: function (connector) {
            var previousSegment = connector.segments[connector.segments.length - 2];
            var current = connector.segments[connector.segments.length - 1];
            if (previousSegment) {
                if (previousSegment.type == "orthogonal" && current.points.length > 2) {
                    var update = false;
                    var direction = previousSegment.points.length == 2 ? previousSegment.direction :
                        ej.datavisualization.Diagram.Util._getBezierDirection(previousSegment.points[previousSegment.points.length - 2],
                            previousSegment.points[previousSegment.points.length - 1]);
                    if (direction == "left" || direction == "right") {
                        if (current.points[0].y == current.points[1].y) {
                            update = true;
                            var dif = current.points[1].x - current.points[0].x;
                            current.points.splice(0, 1);
                            current._startPoint = current.points[0];
                            previousSegment._endPoint = current.points[0];
                        }
                    }
                    else {
                        if (current.points[0].x == current.points[1].x) {
                            update = true;
                            current.points.splice(0, 1);
                            current._startPoint = current.points[0];
                            previousSegment._endPoint = current.points[0];
                        }
                    }
                }
                previousSegment._endPoint = current._startPoint;
                previousSegment.points[previousSegment.points.length - 1] = current._startPoint;
                if (previousSegment.type == "orthogonal" && update) {
                    previousSegment._length = previousSegment.length = ej.datavisualization.Diagram.Geometry.distance(previousSegment._startPoint, previousSegment._endPoint);
                    if (previousSegment._length > 0)
                        previousSegment._direction = previousSegment.direction = this._getBezierDirection(previousSegment._startPoint, previousSegment._endPoint);
                    if (connector.segments.length > 2 || !connector.sourcePort)
                        this._addOrthogonalPoints(previousSegment, connector.segments[connector.segments.length - 3], current, connector.sourcePoint, connector.targetPoint);
                }
                else {
                    previousSegment.point = current._startPoint;
                }
            }
        },
        _initConnectionEnds: function (connector, diagram) {
            if (connector.segments && connector.segments[0] && connector.segments[0].type == "orthogonal" && connector.segments[0].length) {
                var port, bounds;
                if (connector.sourceNode) {
                    var srcNode = diagram.nameTable[connector.sourceNode];
                    if (srcNode) {
                        bounds = ej.datavisualization.Diagram.Util.bounds(srcNode, true);
                        if (connector.sourcePort) {
                            port = ej.datavisualization.Diagram.Util.findPortByName(diagram.nameTable[connector.sourceNode], connector.sourcePort);
                            connector.sourcePoint = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds, undefined, srcNode);
                        }
                        else {
                            var line = connector.segments[0];
                            switch (line.direction) {
                                case "left":
                                    connector.sourcePoint = bounds.middleLeft;
                                    break;
                                case "right":
                                    connector.sourcePoint = bounds.middleRight;
                                    break;
                                case "top":
                                    connector.sourcePoint = bounds.topCenter;
                                    break;
                                case "bottom":
                                    connector.sourcePoint = bounds.bottomCenter;
                                    break;
                            }
                        }
                    }
                }
                if (connector.targetNode) {
                    var trgNode = diagram.nameTable[connector.targetNode];
                    if (trgNode) {
                        bounds = ej.datavisualization.Diagram.Util.bounds(trgNode, true);
                        if (connector.targetPort) {
                            port = ej.datavisualization.Diagram.Util.findPortByName(diagram.nameTable[connector.targetNode], connector.targetPort);
                            connector.targetPoint = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds, undefined, trgNode);
                        }
                        else {
                            var line = connector.segments[0];
                            switch (line.direction) {
                                case "left":
                                    connector.targetPoint = bounds.middleLeft;
                                    break;
                                case "right":
                                    connector.targetPoint = bounds.middleRight;
                                    break;
                                case "top":
                                    connector.targetPoint = bounds.topCenter;
                                    break;
                                case "bottom":
                                    connector.targetPoint = bounds.bottomCenter;
                                    break;
                            }
                        }
                    }
                }
            }
            else {
                if (connector.sourceNode) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(diagram.nameTable[connector.sourceNode], true);
                    if (connector.sourcePort) {
                        port = ej.datavisualization.Diagram.Util.findPortByName(diagram.nameTable[connector.sourceNode], connector.sourcePort);
                        connector.sourcePoint = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds, undefined, diagram.nameTable[connector.sourceNode]);
                    }
                    else
                        connector.sourcePoint = bounds.center;
                }
                if (connector.targetNode) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(diagram.nameTable[connector.targetNode], true);
                    if (connector.targetPort) {
                        port = ej.datavisualization.Diagram.Util.findPortByName(diagram.nameTable[connector.targetNode], connector.targetPort);
                        connector.targetPoint = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds, undefined, diagram.nameTable[connector.targetNode]);
                    }
                    else
                        connector.targetPoint = bounds.center;
                }
            }
        },
        _swapDirection: function (rotateAngle, direction) {
            var dir;
            var angle = rotateAngle % 360;
            if (angle < 0) {
                angle += 360;
            }
            var dirs;
            if (angle > 315 || angle < 45) {
                dir = direction;
            }
            else if (angle < 135) {
                dirs = { left: "top", top: "right", right: "bottom", bottom: "left" };
                dir = dirs[direction];
            }
            else if (angle < 225) {
                dirs = { left: "right", top: "bottom", right: "left", bottom: "top" };
                dir = dirs[direction];
            }
            else {
                dirs = { left: "bottom", top: "left", right: "top", bottom: "right" };
                dir = dirs[direction];
            }
            return dir;
        },
        _getEllipseIntersectCoords: function (node, connectorSeg, connector, point, isTarget) {
            var segmentPoints = [], intersection;
            var pad = node.connectorPadding;
            if (connector) pad += isTarget ? connector.targetPadding : connector.sourcePadding;
            if (!pad) pad = 0;
            var rx = node.width / 2;
            var ry = node.height / 2;
            //var cx = node.offsetX - node.width * node.pivot.x - pad;
            //var cy = node.offsetY - node.height * node.pivot.y - pad;
            var matrix = ej.Matrix.identity();
            ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
            //Convert Top Round Side to Path
            var topArchPath = "M " + (node.offsetX - node.width * node.pivot.x - pad) + ", " + (node.offsetY) + " A " + rx + " " + ry + " 0 0 " + 1 + " " + (node.offsetX + node.width * (1 - node.pivot.x) + pad) + ", " + (node.offsetY) +
                " A " + rx + " " + ry + " 0 0 " + 1 + " " + (node.offsetX - node.width * node.pivot.x - pad) + ", " + (node.offsetY) + "z";
            var path = document.createElementNS('http://www.w3.org/2000/svg', "path");
            path.setAttributeNS(null, "d", topArchPath);
            var len = path.getTotalLength(), pts = [], pt1, pt2, coor;
            for (var i = 0; i < len; i = i + 3) {
                var pathSeg = path.getPointAtLength(i);
                if (node.rotateAngle != 0) {
                    pathSeg = ej.Matrix.transform(matrix, pathSeg);
                }
                pts[pts.length] = pathSeg;
            }
            if (pts[pts.length - 1] != path.getPointAtLength(len)) pts[pts.length] = path.getPointAtLength(len);
            segmentPoints = pts;
            intersection = this._getIntersectionPoints(connectorSeg, segmentPoints, true, point);
            return intersection;
        },
        _rightToLeft: function (connector, segment, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, swap) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (swap) {
                tarExtension = connector._srcDecoratorSize;
                srcExtension = connector._tarDecoratorSize;
            }
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var min = srcExtension + tarExtension;
            if (targetPortLocation.x > sourcePortLocation.x) {
                if (sourcePortLocation.y != targetPortLocation.y) {
                    if ((sourcePortLocation.x) > targetBounds.left) {
                        x = sourceBounds.right + srcExtension;
                        y = sourcePortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetPortLocation.y > sourceBounds.top) {
                            y = targetPortLocation.y;
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetPortLocation.y <= sourceBounds.top) {
                            x = targetBounds.right + tarExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            y = targetBounds.top - tarExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            x = targetBounds.left - tarExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            y = targetPortLocation.y;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                        }
                    }
                    else {
                        if (!segment.direction && segment.length != undefined) x = sourceBounds.right + segment.length;
                        else if (targetBounds.left - sourceBounds.right > 0) x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        else x = sourceBounds.right + srcExtension;
                        y = sourcePortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetPortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                //5 segment
                if (Math.abs(targetBounds.top - sourceBounds.bottom) < min || Math.abs(targetBounds.bottom - sourceBounds.top) < min) {
                    if ((sourcePortLocation.x) > targetBounds.right) {
                        x = sourcePortLocation.x + srcExtension;
                        y = sourcePortLocation.y;
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                        y = sourcePortLocation.y;
                    }
                }
                else {
                    x = sourceBounds.right + srcExtension;
                    y = sourcePortLocation.y;
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if ((targetBounds.top - sourceBounds.bottom) >= min) {
                    y = targetBounds.top - tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else if (sourcePortLocation.y > targetPortLocation.y) {
                    if ((sourceBounds.top - targetBounds.bottom) < min) {
                        if (targetBounds.left > sourceBounds.right) y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2
                        else y = Math.min((targetBounds.top - tarExtension), (sourceBounds.top - srcExtension));
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    if (targetBounds.left > sourceBounds.right) y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                    else y = Math.max((targetBounds.bottom + tarExtension), (sourceBounds.bottom + srcExtension));
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                x = targetBounds.left - tarExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
                y = targetPortLocation.y;
                points.push(ej.datavisualization.Diagram.Point(x, y));
            }
            points.push(targetPortLocation);
            return points;
        },
        _rightToRight: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (targetBounds.right >= sourceBounds.left) {
                if (sourcePortLocation.y >= targetBounds.top - tarExtension && sourcePortLocation.y <= targetBounds.bottom + tarExtension) {
                    x = sourcePortLocation.x + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourcePortLocation.y >= targetBounds.center.y) {
                        if (sourcePortLocation.x > targetBounds.left) {
                            if (sourcePortLocation.y > targetPortLocation.y) {
                                y = targetBounds.bottom + tarExtension;
                            }
                            else {
                                y = targetBounds.top - tarExtension;
                            }
                        }
                        else {
                            y = targetBounds.top - tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else if (targetBounds.right < sourceBounds.right) {
                    x = sourceBounds.right + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    //points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
                } else {
                    x = targetPortLocation.x + tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    //points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
                }
            }
            else {
                x = sourcePortLocation.x + srcExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (targetPortLocation.y >= sourceBounds.top - srcExtension && targetPortLocation.y <= sourceBounds.bottom + srcExtension) {
                    if (targetPortLocation.y <= sourceBounds.center.y) {
                        y = sourceBounds.top - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = sourceBounds.bottom + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
            points.push(targetPortLocation);
            return points;
        },
        _rightToTop: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, swap) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (swap) {
                tarExtension = connector._srcDecoratorSize;
                srcExtension = connector._tarDecoratorSize;
            }
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var min = srcExtension + tarExtension;
            if (targetPortLocation.x >= sourcePortLocation.x + srcExtension) {
                if ((sourcePortLocation.y + srcExtension) >= targetPortLocation.y && targetBounds.height !== 0) {
                    if (targetBounds.left <= sourceBounds.right) {
                        x = targetBounds.right + tarExtension;
                    }
                    else if ((targetBounds.left - sourceBounds.right) > min) {
                        x = sourceBounds.right + srcExtension;
                    }
                    else {
                        x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.top - tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            else {
                if (sourceBounds.bottom + srcExtension > targetBounds.top - tarExtension) {
                    if ((sourcePortLocation.x + srcExtension) <= targetBounds.right) {
                        x = targetBounds.right + tarExtension;
                    }
                    else {
                        x = sourceBounds.right + srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourceBounds.top >= targetBounds.top) {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                    }
                    else if (sourceBounds.top >= targetBounds.top - tarExtension)
                        y = targetBounds.top - tarExtension - srcExtension;
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    x = sourcePortLocation.x + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if ((targetBounds.top - sourceBounds.bottom) < min && targetBounds.height !== 0) {
                        if ((sourceBounds.left - targetBounds.right) >= min) {
                            y = sourceBounds.bottom + srcExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            x = sourceBounds.left - srcExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                            y = targetBounds.top - tarExtension;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                        }
                        else {
                            y = targetBounds.top - (targetBounds.top - sourceBounds.bottom) / 2;
                            points.push(ej.datavisualization.Diagram.Point(x, y));
                        }
                    }
                    else {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _rightToBottom: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, swap) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (swap) {
                tarExtension = connector._srcDecoratorSize;
                srcExtension = connector._tarDecoratorSize;
            }
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var min = srcExtension + tarExtension;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                if (sourcePortLocation.y <= targetBounds.bottom + tarExtension) {
                    if (targetBounds.left > (sourceBounds.right + srcExtension)) {
                        x = sourcePortLocation.x + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if ((sourceBounds.right + srcExtension) > targetPortLocation.x) {
                        x = sourcePortLocation.x + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((sourceBounds.top - targetBounds.bottom) > min) {
                            y = targetBounds.bottom + tarExtension;
                        }
                        else {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = sourcePortLocation.y;
                    }
                }
            }
            else {
                if (sourcePortLocation.y <= targetBounds.bottom) {
                    if ((sourceBounds.right + srcExtension) > targetBounds.right) {
                        x = sourceBounds.right + srcExtension;
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.bottom + tarExtension;
                    if (y <= (sourceBounds.bottom + srcExtension)) {
                        y = sourceBounds.bottom + srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    if ((targetBounds.bottom + tarExtension) < sourceBounds.top - srcExtension) {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((sourceBounds.top - targetBounds.bottom) < min) {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = sourceBounds.bottom + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _leftToLeft: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var min = srcExtension + tarExtension;
            if (targetPortLocation.x - tarExtension >= sourcePortLocation.x - srcExtension) {
                x = sourceBounds.left - srcExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (sourcePortLocation.y > targetPortLocation.y) {
                    if ((targetPortLocation.y + tarExtension) >= sourceBounds.top) {
                        y = sourceBounds.top - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((targetBounds.left - sourceBounds.right) > min) {
                            x = targetBounds.left - tarExtension;
                        }
                        else {
                            x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetPortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetPortLocation.x;
                    }
                }
                else {
                    if ((sourceBounds.bottom + srcExtension) < targetPortLocation.y) {
                        y = targetPortLocation.y;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetPortLocation.x;
                    }
                    else {
                        y = sourceBounds.bottom + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((targetBounds.left - sourceBounds.right) > min) {
                            x = targetBounds.left - tarExtension;
                        }
                        else {
                            x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                if (targetPortLocation.y > sourcePortLocation.y) {
                    if (sourcePortLocation.y > (targetBounds.top - tarExtension)) {
                        if ((sourceBounds.left - targetBounds.right) < min) {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                        else {
                            x = sourceBounds.left - srcExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.top - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if ((targetBounds.bottom + tarExtension) >= sourcePortLocation.y) {
                        if ((sourceBounds.left - targetBounds.right) < min) {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                        else {
                            x = sourceBounds.left - srcExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.left - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                x = targetBounds.left - tarExtension;
                points.push(ej.datavisualization.Diagram.Point(x, y));
            }
            points.push(ej.datavisualization.Diagram.Point(x, targetPortLocation.y));
            points.push(targetPortLocation);
            return points;
        },
        _leftToTop: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, swap) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (swap) {
                tarExtension = connector._srcDecoratorSize;
                srcExtension = connector._tarDecoratorSize;
            }
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            if (sourcePortLocation.x <= targetPortLocation.x) {
                if (sourcePortLocation.y > targetPortLocation.y && targetBounds.left <= sourceBounds.left) {
                    x = targetBounds.left - tarExtension;
                }
                else {
                    x = sourceBounds.left - srcExtension;
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (sourceBounds.bottom <= targetBounds.top) {
                    if ((sourceBounds.bottom + srcExtension) < targetBounds.top - tarExtension) {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                    }
                    else if (targetPortLocation.x < sourceBounds.right) {
                        y = sourceBounds.bottom + (targetBounds.top - sourceBounds.bottom) / 2;
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                }
                else {
                    if (sourceBounds.top - srcExtension >= targetBounds.top - tarExtension) {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
            }
            else {
                if (targetPortLocation.y <= (sourcePortLocation.y + srcExtension)) {
                    if (sourceBounds.left - srcExtension > targetBounds.right + tarExtension) {
                        x = sourceBounds.left - srcExtension;
                    }
                    else {
                        if (targetBounds.right + tarExtension >= sourceBounds.left - srcExtension) {
                            x = targetBounds.left - tarExtension;
                        }
                        else {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.top - tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _leftToBottom: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, swap) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            y = sourcePortLocation.y;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (swap) {
                tarExtension = connector._srcDecoratorSize;
                srcExtension = connector._tarDecoratorSize;
            }
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var min = srcExtension + tarExtension;
            if (sourcePortLocation.x - srcExtension <= targetPortLocation.x) {
                if (targetBounds.left <= sourcePortLocation.x && sourcePortLocation.y <= targetBounds.top) {
                    x = targetBounds.left - tarExtension;
                }
                else {
                    x = sourceBounds.left - srcExtension;
                }
                points.push(ej.datavisualization.Diagram.Point(x, y));
                if (targetBounds.bottom + tarExtension < sourceBounds.top - srcExtension) {
                    if ((sourceBounds.top - targetBounds.bottom) < min) {
                        y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                else {
                    if (targetBounds.bottom < sourceBounds.bottom) {
                        y = sourceBounds.bottom + srcExtension;
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            else {
                if (!(sourcePortLocation.y - srcExtension > targetPortLocation.y)) {
                    if (targetBounds.right >= sourceBounds.left) {
                        x = targetBounds.left - tarExtension;
                    }
                    else if ((sourceBounds.left - targetBounds.right) < min) {
                        x = sourceBounds.left - (sourceBounds.left - targetBounds.right) / 2;
                    }
                    else {
                        x = sourceBounds.left - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.bottom + tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _topToTop: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            x = sourcePortLocation.x;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var min = srcExtension + tarExtension;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                if (targetPortLocation.y - tarExtension >= sourcePortLocation.y - srcExtension) {
                    y = sourceBounds.top - srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetPortLocation.x <= sourceBounds.right) {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetBounds.height !== 0) {
                            if ((targetBounds.top - sourceBounds.bottom) > min) {
                                y = targetBounds.top - tarExtension;
                            }
                            else {
                                y = sourceBounds.bottom + (targetBounds.top - sourceBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (targetBounds.left <= sourcePortLocation.x) {
                        if ((sourceBounds.top - targetBounds.bottom) > min) {
                            y = sourceBounds.top - srcExtension;
                        }
                        else {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.left - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.top - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                if (targetPortLocation.y - tarExtension >= sourcePortLocation.y - srcExtension) {
                    y = sourceBounds.top - srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetPortLocation.x >= sourceBounds.left) {
                        x = sourceBounds.left - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (targetBounds.height !== 0) {
                            if ((targetBounds.top - sourceBounds.bottom) > min) {
                                y = targetBounds.top - tarExtension;
                            }
                            else {
                                y = sourceBounds.bottom + (targetBounds.top - sourceBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (targetBounds.right >= sourcePortLocation.x) {
                        if ((sourceBounds.top - targetBounds.bottom) > min) {
                            y = sourceBounds.top - srcExtension;
                        }
                        else {
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.top - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        if (targetBounds.height !== 0) {
                            y = targetBounds.top - tarExtension;
                        }
                        else {
                            y = targetPortLocation.y;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            x = targetPortLocation.x;
            points.push(ej.datavisualization.Diagram.Point(x, y));
            points.push(targetPortLocation);
            return points;
        },
        _topToBottom: function (connector, segment, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation, swap) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            x = sourcePortLocation.x;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (swap) {
                tarExtension = connector._srcDecoratorSize;
                srcExtension = connector._tarDecoratorSize;
            }
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var minSpace = srcExtension + tarExtension;
            if (targetPortLocation.x > sourcePortLocation.x) {
                if (sourceBounds.top >= targetBounds.bottom) {
                    if ((sourceBounds.top - targetBounds.bottom) > 0) {
                        if (segment.length != undefined && !segment.direction)
                            y = targetBounds.bottom + segment.length;
                        else if (sourceBounds.top - targetBounds.bottom > 0)
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        else
                            y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((targetBounds.left - sourceBounds.right) >= minSpace) {
                            x = sourceBounds.right + srcExtension;
                        }
                        else {
                            x = sourceBounds.right + (targetBounds.left - sourceBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (targetBounds.top < sourceBounds.top) {
                        if (targetBounds.left >= (sourceBounds.right + srcExtension)) {
                            y = sourceBounds.top - srcExtension;
                        }
                        else {
                            y = targetBounds.top - tarExtension;
                        }
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetBounds.left >= (sourceBounds.right + srcExtension)) {
                        x = sourceBounds.right + srcExtension;
                    }
                    else {
                        x = targetBounds.right + tarExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    y = targetBounds.bottom + tarExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            }
            else if (targetPortLocation.x < sourcePortLocation.x) {
                if (sourceBounds.top >= targetBounds.bottom) {
                    if ((sourceBounds.top - targetBounds.bottom) > 0) {
                        if (segment.length != undefined && !segment.direction)
                            y = targetBounds.bottom + segment.length;
                        else if (sourceBounds.top - targetBounds.bottom > 0)
                            y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                        else
                            y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if ((sourceBounds.left - targetBounds.right) >= minSpace) {
                            x = sourceBounds.left - srcExtension;
                        }
                        else {
                            x = targetBounds.right + (sourceBounds.left - targetBounds.right) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (sourceBounds.left - srcExtension >= (targetBounds.right + tarExtension)) {
                        y = sourceBounds.top - srcExtension;
                    }
                    else {
                        y = sourceBounds.top - srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourceBounds.left >= (targetBounds.right + tarExtension) || ((sourceBounds.right + srcExtension) < (targetBounds.right + tarExtension))) {
                        x = targetBounds.right + tarExtension;
                    }
                    else {
                        x = sourceBounds.right + srcExtension;
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (sourceBounds.left >= (targetBounds.right + tarExtension)) {
                        y = targetBounds.bottom + tarExtension;
                    }
                    else {
                        if (targetBounds.bottom <= sourceBounds.bottom) {
                            y = sourceBounds.bottom + srcExtension;
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                    }
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                }
                points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            }
            points.push(targetPortLocation);
            return points;
        },
        _bottomToBottom: function (connector, targetBounds, targetPortLocation, sourceBounds, sourcePortLocation) {
            var points = [];
            var x, y;
            points.push(sourcePortLocation);
            x = sourcePortLocation.x;
            var srcExtension = connector._srcDecoratorSize;
            var tarExtension = connector._tarDecoratorSize;
            if (sourceBounds.width == 0) srcExtension = 0;
            if (targetBounds.width == 0) tarExtension = 0;
            var minSpace = srcExtension + tarExtension;
            if (targetPortLocation.x >= sourcePortLocation.x) {
                if (sourceBounds.bottom + srcExtension >= targetBounds.bottom + srcExtension) {
                    y = sourceBounds.bottom + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if ((targetPortLocation.x) < sourceBounds.right) {
                        x = sourceBounds.right + srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (sourceBounds.top - srcExtension >= targetBounds.bottom + tarExtension) {
                            if ((sourceBounds.top - targetBounds.bottom) >= minSpace) {
                                y = targetBounds.bottom + tarExtension;
                            }
                            else {
                                y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (sourcePortLocation.x > targetBounds.left) {
                        if ((targetBounds.bottom - sourceBounds.bottom) >= minSpace) {
                            y = sourceBounds.bottom + srcExtension;
                        }
                        else {
                            y = sourceBounds.bottom + (targetBounds.bottom - sourceBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.left - tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            else {
                if (sourceBounds.bottom + srcExtension >= targetBounds.bottom + srcExtension) {
                    y = sourceBounds.bottom + srcExtension;
                    points.push(ej.datavisualization.Diagram.Point(x, y));
                    if (targetPortLocation.x > sourceBounds.left) {
                        x = sourceBounds.left - srcExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        if (sourceBounds.top - srcExtension >= targetBounds.bottom + tarExtension) {
                            if ((sourceBounds.top - targetBounds.bottom) >= minSpace) {
                                y = targetBounds.bottom + tarExtension;
                            }
                            else {
                                y = targetBounds.bottom + (sourceBounds.top - targetBounds.bottom) / 2;
                            }
                        }
                        else {
                            y = targetBounds.bottom + tarExtension;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
                else {
                    if (sourcePortLocation.x < targetBounds.right) {
                        if ((targetBounds.bottom - sourceBounds.bottom) >= minSpace) {
                            y = sourceBounds.bottom + srcExtension;
                        }
                        else {
                            y = sourceBounds.bottom + (targetBounds.bottom - sourceBounds.bottom) / 2;
                        }
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        x = targetBounds.right + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                    else {
                        y = targetBounds.bottom + tarExtension;
                        points.push(ej.datavisualization.Diagram.Point(x, y));
                    }
                }
            }
            points.push(ej.datavisualization.Diagram.Point(targetPortLocation.x, y));
            points.push(targetPortLocation);
            return points;
        },
        _addOrthogonalPoints: function (line, prev, next, sourcePt, endPt, runAngle) {
            var points = [];
            var strt = prev ? prev._endPoint : sourcePt;
            points.push(strt);
            if (!line._direction) line._direction = this._getOrthoDirection(strt, endPt, prev);
            if (line._direction === "auto" && !prev && !next)
                line._direction = this._getBezierDirection(strt, endPt);
            var angle = (!runAngle && runAngle != 0) ? this._directionToAngle(line._direction || this._getBezierDirection(strt, endPt)) : runAngle;
            var direction = line._direction;
            var angles = { "right": 0, "left": 180, "top": 270, "bottom": 90, "auto": 90 };
            if (direction == "left" || direction == "right" || direction == "top" || direction == "bottom") {
                angle = angles[direction];
            }
            else {
                switch (direction) {
                    case "straight":
                        angle = 1 - 1;
                        break;
                    case "clockWise90":
                        angle += 91 - 1;
                        break;
                    case "opposite":
                        angle += 181 - 1;
                        break;
                    case "antiClockWise90":
                        angle += 271 - 1;
                        break;
                }
            }
            if ((line.length || line.length == 0) && line.direction) {
                var ctrlPoint1 = ej.datavisualization.Diagram.Geometry.transform(strt, angle || 0, line._length);
                ctrlPoint1.x = Math.round(ctrlPoint1.x * 100) / 100;
                ctrlPoint1.y = Math.round(ctrlPoint1.y * 100) / 100;
                points.push(ctrlPoint1);
                line._endPoint = ctrlPoint1;
                if (next) {
                    next._startPoint = line._endPoint;
                    if (next.points) {
                        next.points[0] = line._endPoint;
                        if (next.type == "bezier") {
                            this._updateBezierPoints(next);
                        }
                    }
                }
            }
            else {
                if (strt.x != endPt.x && strt.y != endPt.y || (prev && prev._startPoint.x == endPt.x)) {
                    var extra = 20;
                    var tempx = endPt.x - (ctrlPoint1 ? ctrlPoint1.x : strt.x);
                    var tempy = endPt.y - (ctrlPoint1 ? ctrlPoint1.y : strt.y);
                    tempx = Math.abs(tempx) <= 0.0001 ? 0 : tempx;
                    tempy = Math.abs(tempy) <= 0.0001 ? 0 : tempy;
                    var ptsCount;
                    var twoPt;
                    switch (angle) {
                        case 0: if (endPt.x < strt.x) break;
                            twoPt = Math.abs(strt.x - endPt.x) < 30;
                            break;
                        case 180: if (endPt.x > strt.x) break;
                            twoPt = Math.abs(strt.x - endPt.x) < 30;
                            break;
                        case 90: if (endPt.y < strt.y) break; twoPt = Math.abs(strt.y - endPt.y) < 30; break;
                        case 270: if (endPt.y > strt.y) break;
                            twoPt = Math.abs(strt.y - endPt.y) < 30;
                            break;
                    }
                    if (!prev) {
                        if (twoPt) {
                            extra = (angle == 90 || angle == 270) ? Math.abs(strt.y - endPt.y) : Math.abs(strt.x - endPt.x);
                            ptsCount = 2;
                            if (extra < 10) { extra += 20; ptsCount = 3 }
                        }
                        else ptsCount = 3;
                        if (ptsCount != 2 || (Math.abs(tempy) > 1 && Math.abs(tempx) > 1))
                            var ctrlPoint1 = ej.datavisualization.Diagram.Geometry.transform(strt, angle, extra);
                    }
                    else ptsCount = (prev && prev._startPoint.x == endPt.x) ? 3 : (tempx == 0 || tempy == 0) ? 2 : 3;
                    if (ptsCount == 3) {
                        var direction = line._direction == "auto" ? prev ? prev._direction == "left" || prev.direction == "right" ? "left" : "top" : "bottom" : line._direction;
                        if ((direction == "left" || direction == "right") || tempy == 0) {
                            tempy = tempy > 0 ? tempy : -tempy;
                            var ctrlPoint2 = ej.datavisualization.Diagram.Geometry.transform(ctrlPoint1 || strt, 90, endPt.y - (ctrlPoint1 ? ctrlPoint1.y : strt.y));
                        }
                        else {
                            tempx = tempx > 0 ? tempx : -tempx;
                            var ctrlPoint2 = ej.datavisualization.Diagram.Geometry.transform(ctrlPoint1 || strt, 0, endPt.x - (ctrlPoint1 ? ctrlPoint1.x : strt.x));
                        }
                    }
                    if (ctrlPoint1) {
                        ctrlPoint1.x = Math.round(ctrlPoint1.x * 100) / 100;
                        ctrlPoint1.y = Math.round(ctrlPoint1.y * 100) / 100;
                        points.push(ctrlPoint1);
                    }
                    if (ctrlPoint2) {
                        ctrlPoint2.x = Math.round(ctrlPoint2.x * 100) / 100;
                        ctrlPoint2.y = Math.round(ctrlPoint2.y * 100) / 100;
                        points.push(ctrlPoint2);
                    }
                }
                line._direction = this._getBezierDirection(points[points.length - 1], endPt);
                points.push(endPt);
                line._endPoint = endPt;
                if (next) {
                    next._startPoint = line._endPoint;
                    if (!next.points) next.points = [];
                    next.points[0] = line._endPoint;
                    if (next.type == "bezier") {
                        this._updateBezierPoints(next);
                    }
                }
            }
            line.points = points;
            return angle;
        },
        _getOrthoDirection: function (src, point, prev) {
            if (!prev) {
                if (src.y < point.y) {
                    return "bottom";
                }
                else if (src.y > point.y) {
                    return "top";
                }
                else if (src.x < point.x) {
                    return "right";
                }
                else if (src.x > point.x) {
                    return "left";
                }
            }
            else {
                var tar = point;
                if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y) && (prev && (prev._direction == "left" || prev._direction == "right"))) {
                    return src.x < tar.x ? "right" : "left";
                }
                else {
                    return src.y < tar.y ? "bottom" : "top";
                }
            }
        },
        _directionToAngle: function (direction) {
            var angles = { "right": 0, "left": 180, "top": 270, "bottom": 90, "auto": 90 };
            return angles[direction];
        },
        _resetOrthogonalPoints: function (line) {
            var points = [];
            points.push(line.sourcePoint);
            points.push(line.targetPoint);
            line.points = [];
            line.sourcePoint = points[0];
            line.points.push(points[0]);
            var ctrlPoints = this._constructOrthogonalPoints(points[0], points[1]);
            line.points.push(ctrlPoints[0]);
            line.points.push(ctrlPoints[1]);
            line.targetPoint = points[1];
            line.points.push(points[1]);
        },
        _updateBezierPoints: function (line, targetNode, targetPort, targetBounds, sourceNode, sourcePort, sourceBounds) {
            var bounds;
            var angles = { "right": 0, "left": 180, "top": 270, "bottom": 90 };
            if (line.vector1 || line.vector2) {
                if (line.vector1) {
                    line._point1 = ej.datavisualization.Diagram.Geometry.transform(line._startPoint, line.vector1.angle, line.vector1.distance);
                }
                if (line.vector2) {
                    line._point2 = ej.datavisualization.Diagram.Geometry.transform(line._endPoint, line.vector2.angle, line.vector2.distance);
                }
            }
            if ((line.point1 == null && !line.vector1) || (line.point2 == null && !line.vector2)) {
                var target = line._endPoint;
                var source = line._startPoint;
                var dir;
                var matrix;
                if (!sourcePort)
                    dir = this._getBezierDirection(source, target);
                else {
                    bounds = sourceBounds;
                    source = this._getPortPosition(sourcePort, bounds);
                    if (sourceNode.rotateAngle !== 0) {
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, sourceNode.rotateAngle, sourceNode.offsetX, sourceNode.offsetY);
                        source = ej.Matrix.transform(matrix, source);
                    }
                    dir = this._getDirection(bounds, source, true);
                }
                if (!line.vector1)
                    line._point1 = line.point1 || this._getBezierAdjPoint(angles[dir], line._startPoint, line._endPoint);
                if (!targetPort) {
                    dir = this._getBezierDirection(target, source);
                }
                else {
                    bounds = targetBounds;
                    target = this._getPortPosition(targetPort, bounds);
                    if (targetNode.rotateAngle !== 0) {
                        matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, targetNode.rotateAngle, targetNode.offsetX, targetNode.offsetY);
                        target = ej.Matrix.transform(matrix, target);
                    }
                    dir = this._getDirection(bounds, target, true);
                }
                if (!line.vector2)
                    line._point2 = line.point2 || this._getBezierAdjPoint(angles[dir], line._endPoint, line._startPoint);
            }
        },
        _getBezierDirection: function (src, tar) {
            if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y)) {
                return src.x < tar.x ? "right" : "left";
            }
            else {
                return src.y < tar.y ? "bottom" : "top";
            }
        },

        _findDocAngle: function (s, e) {
            var r = { x: e.x, y: s.y };
            var sr = this.findLength(s, r);
            var re = this.findLength(r, e);
            var es = this.findLength(e, s);
            var ang = Math.asin(re / es);
            ang = isNaN(ang) ? 0 : ang;
            ang = ang * 180 / Math.PI;
            if (s.x < e.x) {
                if (s.y < e.y) {

                }
                else {
                    ang = 360 - ang;
                }
            }
            else {
                if (s.y < e.y) {
                    ang = 180 - ang;
                }
                else {
                    ang = 180 + ang;
                }
            }
            return ang;

        },
        _getDirection: function (bounds, point, excludeBounds) {
            var center = bounds.center, fourty5, one35, two25, three15, dir, angle;
            if (excludeBounds) {
                //earlier implementation only for bezeir connector to get the bezeir angle.
                var points = bounds.points;
                var part = excludeBounds ? 45 : (180 / (2 + 2 / (bounds.height / bounds.width)));
                fourty5 = part;
                one35 = (180 - part);
                two25 = one35 + (2 * part);
                three15 = 360 - part;
                angle = ej.datavisualization.Diagram.Geometry.findAngle(point, center);
                if (angle > fourty5 && angle < one35) {
                    dir = "top";
                }
                else if (angle > one35 && angle < two25) {
                    dir = "right";
                }
                else if (angle > two25 && angle < three15) {
                    dir = "bottom";
                }
                else {
                    dir = "left";
                }
            }
            else {
                //source code have been derived from WPF source to get the dock angle.
                angle = this._findDocAngle(center, point);
                fourty5 = this._findDocAngle(center, bounds.bottomRight);
                one35 = this._findDocAngle(center, bounds.bottomLeft);
                two25 = this._findDocAngle(center, bounds.topLeft);
                three15 = this._findDocAngle(center, bounds.topRight);
                if (angle > two25 && angle < three15) {
                    dir = "top";
                }
                else if (angle >= fourty5 && angle < one35) {
                    dir = "bottom";
                }
                else if (angle >= one35 && angle <= two25) {
                    dir = "left";
                }
                else if (angle >= three15 || angle < fourty5) {
                    dir = "right";
                }
            }
            return dir;
        },
        _getBezierAdjPoint: function (angle, srcEnd, tarEnd) {
            var distance = 60;
            var endAdj = ej.datavisualization.Diagram.Point(0, 0);
            var dir;
            if (angle > 45 && angle < 135) {
                dir = "Bottom";
            }
            else if (angle > 135 && angle < 225) {
                dir = "Left";
            }
            else if (angle > 225 && angle < 315) {
                dir = "Top";
            }
            else {
                dir = "Right";
            }
            switch (dir) {
                case "Right":
                    distance = Math.min(Math.abs(srcEnd.x - tarEnd.x) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x + distance, srcEnd.y);
                    break;
                case "Bottom":
                    distance = Math.min(Math.abs(srcEnd.y - tarEnd.y) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x, srcEnd.y + distance);
                    break;
                case "Left":
                    distance = Math.min(Math.abs(srcEnd.x - tarEnd.x) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x - distance, srcEnd.y);
                    break;
                case "Top":
                    distance = Math.min(Math.abs(srcEnd.y - tarEnd.y) * 0.45, distance);
                    endAdj = ej.datavisualization.Diagram.Point(srcEnd.x, srcEnd.y - distance);
                    break;
            }
            return endAdj;
        },
        _setLineEndPoint: function (connector, point, isTarget, dock) {
            var line = connector;
            point.x = Math.round(point.x * 100) / 100;
            point.y = Math.round(point.y * 100) / 100;
            if (isTarget) {
                var lastsegment = connector.segments[connector.segments.length - 1];
                line.targetPoint = point;
                if (lastsegment.type != "orthogonal") {
                    if (lastsegment.point) {
                        lastsegment.point = point;
                    }
                    lastsegment._point = point;
                }
                lastsegment.points[lastsegment.points.length - 1] = point;
                lastsegment._endPoint = point;
            }
            else {
                line.sourcePoint = point;
                var first = connector.segments[0];
                first.points[0] = point;
                first._startPoint = point;
                if (first.type == "orthogonal" && !connector.sourcePort && !connector._staticLength) {
                    if ((first.length || first.length === 0) && first.direction) {
                        if (first.points.length == 2) {
                            if (first._direction == "left" || first._direction == "right") {
                                first._endPoint.y = first._startPoint.y;
                                var length = Math.abs(first._startPoint.x - first._endPoint.x);
                            }
                            else {
                                first._endPoint.x = first._startPoint.x;
                                var length = Math.abs(first._startPoint.y - first._endPoint.y);
                            }
                            connector.segments[0]._length = length;
                            connector.segments[0].length = connector.segments[0]._length;
                            connector.segments[0].direction = connector.segments[0]._direction;
                        }
                    }
                }
            }
            var segment = isTarget ? connector.segments[connector.segments.length - 1] : connector.segments[0];
            if (segment.type === "orthogonal" && ((!isTarget && !connector.sourcePort) || isTarget && !connector.targetPort) && (!(connector.sourceNode && connector.targetNode) || connector.segments.length > 1)) {
                segment.points = [];
                this._addOrthogonalPoints(segment, isTarget ? connector.segments[connector.segments.length - 2] : null,
                    isTarget ? null : connector.segments[1], connector.sourcePoint, connector.targetPoint);
            }
            else if (segment.type === "bezier") {
                this._updateBezierPoints(segment);
            }
        },
        _setBezierPoint: function (segment, point, whichpoint) {
            if (whichpoint === "bezierpoint1") {
                if (segment.vector1) {
                    segment.vector1 = {
                        distance: ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, point),
                        angle: ej.datavisualization.Diagram.Geometry.findAngle(segment._startPoint, point),
                    };
                    segment._point1 = point;
                }
                else
                    segment.point1 = segment._point1 = point;
            }
            else {
                if (segment.vector2) {
                    segment.vector2 = {
                        distance: ej.datavisualization.Diagram.Geometry.distance(segment._endPoint, point),
                        angle: ej.datavisualization.Diagram.Geometry.findAngle(segment._endPoint, point),
                    };
                    segment._point2 = point;
                }
                else
                    segment.point2 = segment._point2 = point;
            }
        },
        _setPoints: function (line, points) {
            line.sourcePoint = line.points[0] = points[0];
            line.targetPoint = line.points[line.points.length - 1] = points[points.length - 1];
            line.points = points;
            if (line.type === "bezier") {
                line.point1 = points[2] || line.point1;
                line.point2 = points[3] || line.point2;
                if (!line.point1)
                    line._point1 = line.point1;
                if (!line.point2)
                    line._point2 = line.point2;
                this._updateBezierPoints(line);
            }
        },
        _updateConnectorSegments: function (connector, ignoreSource, ignoreTarget, diagram) {
            var runAngle;
            var startPoint = connector.sourcePoint;
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                var prev = connector.segments[i - 1];
                var next = connector.segments[i + 1];
                segment._startPoint = prev ? prev._endPoint : startPoint;
                if (!(i == 0 && ignoreSource) && !(i == connector.segments.length - 1 && ignoreTarget)) {
                    if (segment.type == "orthogonal")
                        runAngle = ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, prev, next, connector.sourcePoint, connector.targetPoint, runAngle);
                    else {
                        runAngle = ej.datavisualization.Diagram.Geometry.findAngle(startPoint, segment._endPoint);
                        if (segment.type == "bezier") {
                            this._updateBezierPoints(segment);
                        }
                    }
                }
                startPoint = segment._endPoint;
            }
            if (diagram) {
                diagram._dock(connector, diagram.nameTable);
            }
        },
        _translateLine: function (connector, dx, dy) {
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                for (var j = 0; j < segment.points.length; j++) {
                    if (j == 0) {
                        segment._startPoint = segment.points[j] = ej.datavisualization.Diagram.Geometry.translate(segment.points[j], dx, dy);
                        if (i == 0) {
                            connector.sourcePoint = segment._startPoint;
                        }
                    }
                    else if (j == segment.points.length - 1) {
                        segment._endPoint = segment.points[j] = ej.datavisualization.Diagram.Geometry.translate(segment.points[j], dx, dy);
                        if (i == connector.segments.length - 1)
                            connector.targetPoint = segment._endPoint;
                    }
                    else segment.points[j] = ej.datavisualization.Diagram.Geometry.translate(segment.points[j], dx, dy);
                }
                if (segment.type === ej.datavisualization.Diagram.Segments.Bezier) {
                    segment._point1 = ej.datavisualization.Diagram.Geometry.translate(segment._point1, dx, dy);
                    segment._point2 = ej.datavisualization.Diagram.Geometry.translate(segment._point2, dx, dy);
                    if (segment.point1) { segment.point1 = segment._point1; }
                    if (segment.point2) { segment.point2 = segment._point2; }
                    if (segment.point) {
                        segment.point = segment._endPoint;
                    }
                    segment._point = segment._endPoint;
                }
                else if (segment.type == "straight") {
                    if (segment.point) {
                        segment.point = segment._endPoint;
                    }
                    segment._point = segment._endPoint;
                }
            }
        },
        _adjustPoint: function (source, target, isStart, length) {
            var pt = isStart ? { x: source.x, y: source.y } : { x: target.x, y: target.y };
            if (source.x == target.x) {
                if (source.y < target.y && isStart || source.y > target.y && !isStart)
                    pt.y += length;
                else pt.y -= length;
            }
            else if (source.y == target.y) {
                if (source.x < target.x && isStart || source.x > target.x && !isStart)
                    pt.x += length;
                else pt.x -= length;
            }
            else {
                var angle;
                if (isStart) {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(source, target);
                    pt = ej.datavisualization.Diagram.Geometry.transform(source, angle, length);
                }
                else {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(target, source);
                    pt = ej.datavisualization.Diagram.Geometry.transform(target, angle, length);
                }
            }
            return pt;
        },
        _getIconPosition: function (icon, bounds, bExcludeBoundsLocation) {
            if (icon) {
                var marginX, marginY;
                marginX = icon.margin.left - icon.margin.right;
                marginY = icon.margin.top - icon.margin.bottom;
                var offsetX = icon.offset.x;
                var offsetY = icon.offset.y;
                if (bExcludeBoundsLocation) {
                    var point = ej.datavisualization.Diagram.Point(bounds.width * offsetX + marginX, bounds.height * offsetY + marginY);
                    if (point.x > bounds.width || point.y > bounds.height)
                        var point = ej.datavisualization.Diagram.Point(bounds.width * offsetX, bounds.height * offsetY);
                    return point;
                }

                else {
                    var x = bounds.center.x - bounds.width / 2 + (bounds.width * offsetX) + marginX;
                    var y = bounds.center.y - bounds.height / 2 + (bounds.height * offsetY) + marginY;
                    return ej.datavisualization.Diagram.Point(x, y);
                }
            }
        },
        _rBounds: function (object, rotateAngle) {
            var rect = {};
            if (object) {
                rect.x = object.x;
                rect.y = object.y;
                rect.width = object.width;
                rect.height = object.height;
                rect.rotateAngle = rotateAngle;
            }
            else
                rect = ej.datavisualization.Diagram.Rectangle();
            if (rect) {
                var bounds = {};
                rect.x = Math.round(rect.x * 100) / 100;
                rect.y = Math.round(rect.y * 100) / 100;
                rect.width = Math.round(rect.width * 100) / 100;
                rect.height = Math.round(rect.height * 100) / 100;
                bounds["width"] = rect.width;
                bounds["height"] = rect.height;
                bounds["x"] = bounds["left"] = rect.x;
                bounds["right"] = rect.x + rect.width;
                bounds["y"] = bounds["top"] = rect.y;
                bounds["bottom"] = rect.y + rect.height;
                bounds["center"] = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
                bounds["topLeft"] = { x: rect.x, y: rect.y };
                bounds["topCenter"] = { x: rect.x + rect.width / 2, y: rect.y };
                bounds["topRight"] = { x: rect.x + rect.width, y: rect.y };
                bounds["middleLeft"] = { x: rect.x, y: rect.y + rect.height / 2 };
                bounds["middleRight"] = { x: rect.x + rect.width, y: rect.y + rect.height / 2 };
                bounds["bottomLeft"] = { x: rect.x, y: rect.y + rect.height };
                bounds["bottomCenter"] = { x: rect.x + rect.width / 2, y: rect.y + rect.height };
                bounds["bottomRight"] = { x: rect.x + rect.width, y: rect.y + rect.height };
                if (rect && rect.rotateAngle) {
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, rect.rotateAngle, rect.x + rect.width / 2, rect.y + rect.height / 2);
                    bounds.topLeft = ej.Matrix.transform(matrix, bounds.topLeft);
                    bounds.topCenter = ej.Matrix.transform(matrix, bounds.topCenter);
                    bounds.topRight = ej.Matrix.transform(matrix, bounds.topRight);
                    bounds.middleLeft = ej.Matrix.transform(matrix, bounds.middleLeft);
                    bounds.middleRight = ej.Matrix.transform(matrix, bounds.middleRight);
                    bounds.bottomLeft = ej.Matrix.transform(matrix, bounds.bottomLeft);
                    bounds.bottomCenter = ej.Matrix.transform(matrix, bounds.bottomCenter);
                    bounds.bottomRight = ej.Matrix.transform(matrix, bounds.bottomRight);
                    var rbounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                    bounds.x = bounds.left = rbounds.x;
                    bounds.y = bounds.top = rbounds.y;
                    bounds.right = rbounds.x + rbounds.width;
                    bounds.bottom = rbounds.y + rbounds.height;
                    bounds.center = ej.datavisualization.Diagram.Point(rbounds.x + rbounds.width / 2, rbounds.y + rbounds.height / 2);
                    bounds.width = -(bounds.topLeft.x) + bounds.right
                    bounds.height = -(bounds.topRight.y) + bounds.bottom
                }
                bounds["points"] = [bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft];
                return bounds;
            }
            return rect;
        },
        _getLabelPosition: function (label, bounds, offset, isheaderY, isheaderX, text) {
            if (text) {
                var lBounds = text.getBBox();
                var rBounds = this._rBounds(lBounds, label.rotateAngle)
            }
            var x = bounds.width * (offset ? offset.x : label.offset.x);
            var y = bounds.height * (offset ? offset.y : label.offset.y);
            if (label.horizontalAlignment == "left")
                x += label.margin.left;
            else if (label.horizontalAlignment == "right")
                x -= label.margin.right;
            else
                x += label.margin.left - label.margin.right + (isheaderX ? -(((rBounds ? rBounds.width : bounds.width) / 2)) : 0);
            if (label.verticalAlignment == "top")
                y += label.margin.top;
            else if (label.verticalAlignment == "bottom")
                y -= label.margin.bottom;
            else
                y += label.margin.top - label.margin.bottom + (isheaderY ? label.fontSize / 2 : 0);
            return ej.datavisualization.Diagram.Point(x, y);
        },
        _getPortPosition: function (port, bounds, bExcludeBoundsLocation, node) {
            if (port) {
                var marginX = ((port.margin.left) ? (port.margin.left) : 0) + ((port.margin.right) ? (port.margin.right) : 0);
                var marginY = ((port.margin.top) ? (port.margin.top) : 0) + ((port.margin.bottom) ? (port.margin.bottom) : 0);
                var portX = port.offset.x;
                var portY = port.offset.y;
                if(node){
                var flip = node.flip !== "none" ? node.flip : node._flip;
                if ( flip && flip !== ej.datavisualization.Diagram.FlipDirection.None) {
                    if (flip === ej.datavisualization.Diagram.FlipDirection.Horizontal) {
                        portX = 1 - port.offset.x;
                    } else if (flip === ej.datavisualization.Diagram.FlipDirection.Vertical) {
                        portY = 1 - port.offset.y;
                    } else if (flip === ej.datavisualization.Diagram.FlipDirection.Both) {
                        portX = 1 - port.offset.x;
                        portY = 1 - port.offset.y;
                    }
                }
            }
                if (bExcludeBoundsLocation) {
                    return ej.datavisualization.Diagram.Point(bounds.width * port.offset.x + marginX, bounds.height * port.offset.y + marginY);
                }
                else {
                    var x = bounds.center.x - bounds.width / 2 + (bounds.width * portX) + marginX;
                    var y = bounds.center.y - bounds.height / 2 + (bounds.height * portY) + marginY;
                    return ej.datavisualization.Diagram.Point(x, y);
                }
            }
        },
        flipConnector: function (connector, flip) {
            if (flip && flip !== ej.datavisualization.Diagram.FlipDirection.None) {
                if (!connector.sourceNode && !connector.targetNode) {
                    if (flip == ej.datavisualization.Diagram.FlipDirection.Horizontal) {
                        var point1 = { x: connector.targetPoint.x, y: connector.sourcePoint.y };
                        var point2 = { x: connector.sourcePoint.x, y: connector.targetPoint.y };
                    } else if (flip == ej.datavisualization.Diagram.FlipDirection.Vertical) {
                        var point1 = { x: connector.sourcePoint.x, y: connector.targetPoint.y };
                        var point2 = { x: connector.targetPoint.x, y: connector.sourcePoint.y };
                    } else if (flip == ej.datavisualization.Diagram.FlipDirection.Both) {
                        var point1 = connector.targetPoint;
                        var point2 = connector.sourcePoint;
                    }
                    if (point1 && point2) {
                        this._setLineEndPoint(connector, point1, false);
                        this._setLineEndPoint(connector, point2, true);
                    }
                }
            }
        },
        _translate: function (node, dx, dy, nameTable, isContainer, diagram) {
            // if (ej.datavisualization.Diagram.Util.canMove(node))
            {
                if (!node.segments) {
                    node.offsetX += dx;
                    node.offsetY += dy;
                    if (node._type === "group" && !isContainer) {
                        var nodes = diagram._getChildren(node.children);
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[nodes[i]];
                            this._translate(child, dx, dy, nameTable, null, diagram);
                            if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], diagram);
                        }
                        if (node._type != "group" && node.container)
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                    }
                } else {
                    ej.datavisualization.Diagram.Util._translateLine(node, dx, dy, node);
                }
            }
        },
        scale: function (node, sw, sh, pivot, nameTable, skipScalOnChild, updateMinMax, isHelper, diagram) {
            if (!node.container) {
                var matrix = ej.Matrix.identity();
                if (!node.segments) {
                    if (node._type === "group") {
                        var nodes = diagram._getChildren(node.children);
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[nodes[i]];
                            if (child) {
                                this.scale(child, sw, sh, pivot, nameTable, undefined, undefined, undefined, diagram);
                                if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], diagram);
                            }
                        }
                        ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                    } else {
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        var width = node.width * sw;
                        var height = node.height * sh;
                        if (width > 1) {
                            node.width = width;
                            node.offsetX = newPosition.x;
                        }
                        if (height > 1) {
                            node.height = height;
                            node.offsetY = newPosition.y;
                        }
                    }
                } else {
                    ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                    for (var i = 0; i < node.segments.length; i++) {
                        var segment = node.segments[i];
                        for (var j = 0; j < segment.points.length; j++) {
                            segment.points[j] = ej.Matrix.transform(matrix, segment.points[j]);
                            if (i == 0 && j == 0 && !node.sourceNode) {
                                segment._startPoint = segment.points[0];
                                segment._endPoint = segment.points[segment.points.length - 1];
                                ej.datavisualization.Diagram.Util._setLineEndPoint(node, ej.Matrix.transform(matrix, node.sourcePoint), false);
                            }
                            if (i == node.segments.length - 1 && j == segment.points.length - 1 && !node.targetNode) {
                                segment._startPoint = segment.points[0];
                                segment._endPoint = segment.points[segment.points.length - 1];
                                node.targetPoint = segment._endPoint;
                            }
                        }
                        segment._startPoint = segment.points[0];
                        segment._endPoint = segment.points[segment.points.length - 1];
                        if (segment.type == "orthogonal") {
                            if (segment.length || segment.length === 0)
                                segment.length = segment._length = ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                            else
                                ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, node.segments[i - 1], node.segments[i + 1], node.sourcePoint, node.targetPoint);
                        } else {
                            if (segment.point) {
                                segment.point = segment._endPoint;
                            }
                            segment._point = segment._endPoint;
                        }
                    }
                }
            }
            else {
                switch (node.container.type) {
                    case "canvas":
                        var newSize = {};
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        width = node.width * sw;
                        height = node.height * sh;
                        if (updateMinMax) {
                            node.minHeight = height;
                            node.minWidth = width;
                        }
                        if (isHelper != true)
                            newSize = diagram._getMinMaxSize(node, width, height);
                        else {
                            newSize.width = width;
                            newSize.height = height;
                        }
                        if (newSize && newSize.width > 1) {
                            var x = node.offsetX - node.width / 2;
                            node.width = newSize.width;
                            node.offsetX = x + node.width / 2;
                        }
                        if (newSize && newSize.height > 1) {
                            var y = node.offsetY - node.height / 2;
                            node.height = newSize.height;
                            node.offsetY = y + node.height / 2;
                        }
                        break;
                    case "stack":
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                        ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                        ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                        newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                        width = (node.width * sw) - (node.marginLeft + node.marginRight);
                        height = (node.height * sh) - (node.marginTop + node.marginBottom);
                        newSize = diagram._getMinMaxSize(node, width, height);
                        if (newSize.width > 1) {
                            x = node.offsetX - node.width / 2;
                            node.width = newSize.width - node.marginLeft;
                            node.offsetX = x + node.width / 2 + (node.marginLeft);
                        }
                        if (newSize.height > 1) {
                            y = node.offsetY - node.height / 2;
                            node.height = newSize.height - node.marginTop;
                            node.offsetY = y + node.height / 2 + (node.marginTop);
                        }
                        ej.datavisualization.Diagram.SvgContext._alignOnStack(node, diagram);
                        break;
                }
            }
        },
        _getIntersectingElement: function (diagram, bounds) {
            var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(diagram._spatialSearch, bounds);
            var elements = [];
            for (var i = 0; i < quads.length; i++) {
                var quad = quads[i];
                if (quad.objects.length > 0) {
                    for (var j = 0; j < quad.objects.length; j++) {
                        var quadNode = quad.objects[j];
                        if (quadNode.visible) {
                            var nodebounds = ej.datavisualization.Diagram.Util.bounds(quadNode);
                            if (ej.datavisualization.Diagram.Geometry.intersectsRect(bounds, nodebounds)) {
                                quadNode = diagram._sortByZIndex(quadNode, true);
                                elements.push(quadNode);
                            }
                        }
                    }
                }
            }
            return elements;
        },
        _getIntersectingNodeElement: function (diagram, bounds) {
            var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(diagram._spatialSearch, bounds);
            var elements = [];
            for (var i = 0; i < quads.length; i++) {
                var quad = quads[i];
                if (quad.objects.length > 0) {
                    for (var j = 0; j < quad.objects.length; j++) {
                        var quadNode = quad.objects[j];
                        if (quadNode.visible) {
                            var nodebounds = ej.datavisualization.Diagram.Util.bounds(quadNode);
                            if (ej.datavisualization.Diagram.Geometry.intersectsRect(bounds, nodebounds)) {
                                quadNode = diagram._sortByZIndex(quadNode, true);
                                if (!quadNode.segments)
                                    elements.push(quadNode);
                            }
                        }
                    }
                }
            }
            return elements;
        },
        _updateChildBounds: function (node, diagram) {
            var offX, offY, dx, dy;
            dx = node.width;
            dy = node.height;
            offX = node.offsetX;
            offY = node.offsetY;
            var childBounds = ej.datavisualization.Diagram.Util._getChildrenBounds(node, diagram);
            node.offsetX = childBounds.x + childBounds.width / 2;
            node.offsetY = childBounds.y + childBounds.height / 2;
            node.height = childBounds.height;
            node.width = childBounds.width;
            var deltaWidth = dx / node.width;
            var deltaHeight = dy / node.height;
            this.scale(node, deltaWidth, deltaHeight, node.pivot, diagram.nameTable, null, null, null, diagram);
            this._translate(node, offX - node.offsetX, offY - node.offsetY, diagram.nameTable, null, diagram);
        },
        _updateGroupBounds: function (node, diagram, needUpdate, angleChange) {
            var exWidth, exHeight, exOffX, exOffY;
            if (node && !node.container) {
                if (node && ((node.type === "pseudoGroup") || (node.children && node.children.length > 0))) {
                    exWidth = node.width;
                    exHeight = node.height;
                    exOffX = node.offsetX;
                    exOffY = node.offsetY;
                    if (angleChange)
                        this._updateRotateAngle(node, diagram.nameTable);
                    var bounds = this._getChildrenBounds(node, diagram, needUpdate);
                    var x = bounds.x + bounds.width * node.pivot.x;
                    var y = bounds.y + bounds.height * node.pivot.y;
                    var newposition = { x: x, y: y };
                    if (node.rotateAngle && (!diagram._isNodeInitializing || diagram._isGroupNode)) {
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, node.rotateAngle);
                        newposition = ej.Matrix.transform(matrix, newposition);
                    }
                    if (bounds) {
                        node.offsetX = newposition.x;
                        node.offsetY = newposition.y;
                        node.width = bounds.width;
                        node.height = bounds.height;
                    }
                    if (needUpdate) {
                        var child = null;
                        if (node.children && node.children.length > 0) {
                            for (var k = 0; k < node.children.length; k++) {
                                if (diagram._getChild(node.children[k]))
                                    child = diagram.nameTable[diagram._getChild(node.children[k])];
                                if (child) {
                                    if (child._type === "group" || (child.children && child.children.length > 0)) {
                                        this._updateGroupBounds(child, diagram, needUpdate);
                                    }
                                }
                            }
                        }
                        //update the initial size of the group
                        if (exWidth && exWidth != node.width)
                            diagram.scale(node, exWidth / node.width, 1, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), diagram.nameTable, undefined, undefined, undefined, diagram);
                        if (exHeight && exHeight != node.height)
                            diagram.scale(node, 1, exHeight / node.height, new ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), diagram.nameTable, undefined, undefined, undefined, diagram);
                        //update the initial offset of the group
                        if (exOffX && exOffX != node.offsetX)
                            diagram._translate(node, exOffX - node.offsetX, 1, diagram.nameTable, undefined);
                        if (exOffX && exOffY != node.offsetY)
                            diagram._translate(node, 1, exOffY - node.offsetY, diagram.nameTable, undefined);
                    }
                }
            }
        },
        _getChildrenBounds: function (group, diagram, needUpdate) {
            var children = diagram._getChildren(group.children), rect,
                bounds = ej.datavisualization.Diagram.Rectangle(), child;
            if (children.length > 0) {
                child = diagram.nameTable[children[0]];
                if (child)
                    bounds = this._rotateChildBounds(child, group, diagram);
            }
            for (var i = 0, len = children.length; i < len; i++) {
                child = diagram.nameTable[children[i]];
                if (child && (diagram.selectedItem || !child._isInternalShape)) {
                    if (child._type === "group") {
                        this._updateGroupBounds(child, diagram, needUpdate);
                        rect = this._rotateChildBounds(child, group, diagram);
                    } else
                        rect = this._rotateChildBounds(child, group, diagram);
                }
                if (rect)
                    bounds = ej.datavisualization.Diagram.Geometry.union(bounds, rect);
            }
            return bounds;
        },
        _updateRotateAngle: function (node, nameTable) {
            if (node.offsetX == 0 && node.offsetY == 0 && node.width == 0 && node.height == 0) {
                for (var i = 0; i < node.children.length; i++) {
                    var child = nameTable[node.children[i]];
                    if (child && !child.segments && !node.rotateAngle) {
                        node.rotateAngle = child.rotateAngle;
                        return;
                    }
                }
            }
        },
        _rotateChildBounds: function (child, group, diagram) {
            if (child.segments || ((group.rotateAngle || child.rotateAngle) && (!diagram._isNodeInitializing || diagram._isGroupNode))) {
                var bounds = this.bounds(child);
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, -group.rotateAngle);
                var topleft = ej.Matrix.transform(matrix, bounds.topLeft);
                var topright = ej.Matrix.transform(matrix, bounds.topRight);
                var bottomLeft = ej.Matrix.transform(matrix, bounds.bottomLeft);
                var bottomRight = ej.Matrix.transform(matrix, bounds.bottomRight);
                var x = Math.min(topleft.x, topright.x, bottomLeft.x, bottomRight.x);
                var y = Math.min(topleft.y, topright.y, bottomLeft.y, bottomRight.y);
                return {
                    x: x,
                    width: Math.max(topleft.x, topright.x, bottomLeft.x, bottomRight.x) - x,
                    y: y,
                    height: Math.max(topleft.y, topright.y, bottomLeft.y, bottomRight.y) - y
                };
            }
            return {
                x: child.offsetX - (child.width || child._width) * child.pivot.x, y: child.offsetY - (child.height || child._height) * child.pivot.y,
                width: child.width || child._width, height: child.height || child._height
            };
        },

        _emptyBridging: function (intersects, diagram) {
            if (intersects && intersects.length > 0 && diagram) {
                var i, line;
                for (i = 0; i < intersects.length; i++) {
                    line = diagram.nameTable[diagram._getChild(intersects[i])];
                    if (line) {
                        for (var m = 0; m < line.segments.length; m++) {
                            var segmentBridges = line.segments[m]._bridges;
                            for (var n = 0; n < segmentBridges.length; n++) {
                                segmentBridges.splice(n, 1);
                            }
                        }
                        ej.datavisualization.Diagram.DiagramContext.update(line, diagram);
                    }

                }
            }
        },
        updateBridging: function (connector, diagram, intersectingConnectors) {
            var bounds, bounds1;
            var lstBridge = [];
            if (intersectingConnectors && intersectingConnectors.length) {
                if (connector.segments.length > 0) {
                    for (var m = 0; m < connector.segments.length; m++) {
                        var segmentBridges = connector.segments[m]._bridges;
                        for (var n = 0; n < segmentBridges.length; n++) {
                            if (segmentBridges[n]._target == intersectingConnectors[0].name)
                                segmentBridges.splice(n, 1);
                            else if (this.findLength(segmentBridges[n].startPoint, segmentBridges[n].endPoint) > intersectingConnectors[0].bridgeSpace) {
                                if (diagram.nameTable[segmentBridges[n]._target]) intersectingConnectors.push(diagram.nameTable[segmentBridges[n]._target]);
                                segmentBridges.splice(n, 1);
                            }
                        }
                    }
                }
            }
            else if (connector.segments.length > 0) {
                for (var m = 0; m < connector.segments.length; m++) {
                    connector.segments[m]._bridges = [];
                }
            }
            if (!intersectingConnectors)
                this._emptyBridging(connector._intersects, diagram)
            connector._intersects = [];
            if (diagram.pluginName!=="ejSymbolPalette") {
            if (ej.datavisualization.Diagram.Util.canBridge(connector, diagram)) {
                var points1 = this.getPoints(connector);
                var bridgeSpacing = connector.bridgeSpace;
                var bridgeDirection = diagram.bridgeDirection();
                var count = -1;
                bounds = intersectingConnectors && diagram.boundaryTable[connector.name] ? diagram.boundaryTable[connector.name] : ej.datavisualization.Diagram.Util.bounds(connector);
                diagram.boundaryTable[connector.name] = bounds;

                var child;
                if (intersectingConnectors && intersectingConnectors.length > 0) {
                    var list = [];
                    for (var i = 0; i < intersectingConnectors.length; i++) {
                        child = diagram.nameTable[diagram._getChild(intersectingConnectors[i])];
                        if (child)
                            list.push(child);
                    }
                }

                var quads = list ? list : diagram._getConnectors();
                if (quads.length > 0) {
                    for (var q = 0; q < quads.length; q++) {
                        var connector1 = quads[q];
                        if (ej.datavisualization.Diagram.Util.canBridgeObstacle(connector1, diagram)) {
                            if ((connector && connector.segments && connector.segments.length > 0 && connector.segments[0].type != "bezier") && (connector1 && connector1.segments && connector1.segments.length > 0 && connector1.segments[0].type != "bezier") &&
                                (connector1.segments && connector1.visible) && connector.name !== connector1.name) {
                                bounds1 = diagram.boundaryTable[connector1.name] ? diagram.boundaryTable[connector1.name] : ej.datavisualization.Diagram.Util.bounds(connector1);
                                diagram.boundaryTable[connector1.name] = bounds1;
                                if (ej.datavisualization.Diagram.Geometry.intersectsRect(bounds, bounds1)) {
                                    var points2 = this.getPoints(connector1);
                                    var intersectPts = this.interSect(points1, points2, false, diagram, true);
                                    connector._intersects.push(connector1.name);
                                    /* Start For Loop */
                                    if (intersectPts.length > 0) {
                                        for (var i = 0; i < intersectPts.length; i++) {
                                            var fullLength = 0;
                                            var segmentIndex = 0;
                                            var length = 0;
                                            var pointIndex = 0;
                                            var obj = this.getLengthAtFractionPoint(connector, intersectPts[i]);
                                            length = obj.lengthAtFractionPt, fullLength = obj.fullLength, segmentIndex = obj.segmentIndex, pointIndex = obj.pointIndex;
                                            if (segmentIndex < 0) {
                                                continue;
                                            }
                                            if (connector.segments[0]) {
                                                var startBridge, endBridge;
                                                var fractLength = (length - (bridgeSpacing / 2)) / fullLength;
                                                startBridge = this.getPointAtLength((length - (bridgeSpacing / 2)), points1);
                                                fractLength = (length + (bridgeSpacing / 2)) / fullLength;
                                                endBridge = this.getPointAtLength((length + (bridgeSpacing / 2)), points1);
                                                if (ej.datavisualization.Diagram.Geometry.isEmptyPoint(endBridge))
                                                    endBridge = startBridge;
                                                var start, end;
                                                if (segmentIndex === 0) {
                                                    start = connector.sourcePoint;
                                                }
                                                else {
                                                    start = connector.segments[segmentIndex - 1]._endPoint;
                                                }
                                                if (connector.segments[segmentIndex].type === "straight")
                                                    end = connector.segments[segmentIndex]._point;
                                                else
                                                    end = connector.segments[segmentIndex].points[pointIndex];
                                                var angle = this._findAngle(start, end);
                                                if (lstBridge.length > segmentIndex && lstBridge[segmentIndex] != null) {
                                                    var fixedPoint;
                                                    if (segmentIndex === 0) {
                                                        fixedPoint = connector.sourcePoint;
                                                    }
                                                    else {
                                                        fixedPoint = connector.segments[segmentIndex - 1]._endPoint;
                                                    }
                                                    var fix = Math.abs(this.findLength(fixedPoint, endBridge));
                                                    var var1 = 0;
                                                    var insertAt = -1;
                                                    count = -1;
                                                    for (var k = 0; k < lstBridge[segmentIndex].bridges.length; k++) {
                                                        count++;
                                                        var arcSeg = lstBridge[segmentIndex].bridges[k];
                                                        var1 = Math.abs(this.findLength(fixedPoint, arcSeg.endPoint));
                                                        if (fix < var1) {
                                                            insertAt = count;
                                                            break;
                                                        }
                                                    }
                                                    if (insertAt >= 0) {
                                                        var paths;
                                                        paths = this.createSegment(startBridge, endBridge, angle, bridgeDirection, pointIndex, connector, diagram);
                                                        paths._target = connector1.name;
                                                        lstBridge[segmentIndex].bridges.splice(insertAt, 0, paths);
                                                        lstBridge[segmentIndex].bridges.join();
                                                        lstBridge[segmentIndex].bridgeStartPoint.splice(insertAt, 0, startBridge);
                                                        lstBridge[segmentIndex].bridgeStartPoint.join();
                                                        lstBridge[segmentIndex].segmentIndex = segmentIndex;
                                                    }
                                                    else {
                                                        var paths = this.createSegment(startBridge, endBridge, angle, bridgeDirection, pointIndex, connector, diagram);
                                                        paths._target = connector1.name;
                                                        lstBridge[segmentIndex].bridges.push(paths);
                                                        lstBridge[segmentIndex].bridgeStartPoint.push(startBridge);
                                                        lstBridge[segmentIndex].segmentIndex = segmentIndex;
                                                    }
                                                }
                                                else {
                                                    if (!isNaN(startBridge.x) && !isNaN(startBridge.y) && !ej.datavisualization.Diagram.Geometry.isEmptyPoint(endBridge)) {
                                                        var arcs = this.createSegment(startBridge, endBridge, angle, bridgeDirection, pointIndex, connector, diagram);
                                                        arcs._target = connector1.name;
                                                        var stPoints = [];
                                                        var edPoints = [];
                                                        stPoints.push(startBridge);
                                                        edPoints.push(endBridge);
                                                        if (lstBridge.length < segmentIndex + 1) {
                                                        }
                                                        lstBridge[segmentIndex] = $.extend(true, {}, ej.datavisualization.Diagram.BridgeSegments, {});
                                                        lstBridge[segmentIndex].bridges.push(arcs);
                                                        lstBridge[segmentIndex].bridgeStartPoint = stPoints;
                                                        lstBridge[segmentIndex].segmentIndex = segmentIndex;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    /* End For Loop */
                                }
                            }
                        }
                    }
                }
                if (intersectingConnectors && intersectingConnectors.length) {
                    if (connector.segments.length > 0) {
                        for (var m = 0; m < connector.segments.length; m++) {
                            var segment = connector.segments[m];
                            var segmentBridges = connector.segments[m]._bridges;
                            if (!lstBridge[m]) {
                                lstBridge[m] = $.extend(false, {}, ej.datavisualization.Diagram.BridgeSegments);
                                lstBridge[m].segmentIndex = m;
                            }
                            lstBridge[m].bridges = lstBridge[m].bridges.concat(segmentBridges).sort(function (a, b) {
                                if (segment._startPoint.x != segment._endPoint.x)
                                    return segment._startPoint.x < segment._endPoint.x ? a.startPoint.x - b.startPoint.x : b.startPoint.x - a.startPoint.x;
                                else
                                    return segment._startPoint.y < segment._endPoint.y ? a.startPoint.y - b.startPoint.y : b.startPoint.y - a.startPoint.y;
                            });
                            lstBridge[m].bridgeStartPoint = lstBridge[m].bridges.map(function (e) { return e.startPoint });
                            connector.segments[m]._bridges = [];
                        }
                    }
                }
                if (lstBridge.length != 0) {
                    for (var i = 0; i < lstBridge.length; i++) {
                        var bridge = lstBridge[i];
                        if (!bridge)
                            continue;
                        for (var k = 1; k < bridge.bridges.length; k++) {
                            if (this.findLength(bridge.bridges[k].endPoint, bridge.bridges[k - 1].endPoint) < bridgeSpacing) {
                                bridge.bridges[k - 1].endPoint = bridge.bridges[k].endPoint;
                                var subBridge = bridge.bridges[k - 1];
                                var arc = diagram.getBridgeSegment(subBridge.startPoint, subBridge.endPoint, subBridge.angle, bridgeSpacing, subBridge.sweep);
                                bridge.bridges[k - 1].path = arc;
                                if (intersectingConnectors && intersectingConnectors.length && bridge.bridges[k - 1]._target == intersectingConnectors[0].name)
                                    bridge.bridges[k - 1]._target = bridge.bridges[k]._target;
                                bridge.bridges.splice(k, 1);
                                bridge.bridgeStartPoint.splice(k, 1);
                                k--;
                            }
                        }
                        var pre = connector.sourcePoint;
                        for (var j = 0; j < bridge.bridges.length; j++) {
                            var subBridge = bridge.bridges[j];
                            var preventChecking = true;
                            for (var k = 0; intersectingConnectors && k < intersectingConnectors.length; k++)
                                if (subBridge._target == intersectingConnectors[k].name)
                                    preventChecking = false;
                            if (!preventChecking) {
                                var end;
                                if (connector.segments[bridge.segmentIndex].type === "straight")
                                    end = connector.segments[bridge.segmentIndex]._endPoint;
                                else if (connector.segments[bridge.segmentIndex].type === "orthogonal")
                                    end = connector.segments[bridge.segmentIndex].points[subBridge.segmentPointIndex];
                                if (segmentIndex != 0)
                                    pre = connector.segments[bridge.segmentIndex]._endPoint;
                                var rectPoints = [];
                                rectPoints.push(ej.datavisualization.Diagram.Point(end.x - bridgeSpacing, end.y - bridgeSpacing));
                                rectPoints.push(ej.datavisualization.Diagram.Point(end.x + bridgeSpacing, end.y + bridgeSpacing));
                                var rect = ej.datavisualization.Diagram.Geometry.rect(rectPoints);
                                rectPoints = [];
                                rectPoints.push(ej.datavisualization.Diagram.Point(pre.x - bridgeSpacing, pre.y - bridgeSpacing));
                                rectPoints.push(ej.datavisualization.Diagram.Point(pre.x + bridgeSpacing, pre.y + bridgeSpacing));
                                var rect1 = ej.datavisualization.Diagram.Geometry.rect(rectPoints);
                                if (!ej.datavisualization.Diagram.Geometry.containsPoint(rect, bridge.bridgeStartPoint[j]) &&
                                    !ej.datavisualization.Diagram.Geometry.containsPoint(rect1, subBridge.endPoint)) {
                                    connector.segments[bridge.segmentIndex]._bridges.push(subBridge);
                                    pre = subBridge.endPoint;
                                }
                            }
                            else {
                                connector.segments[bridge.segmentIndex]._bridges.push(subBridge);
                                pre = subBridge.endPoint;
                            }
                        }
                    }
                }
                }
            }
        },
        createSegment: function (start, end, angle, bridgeDirection, segmentPointIndex, connector, diagram) {
            var arc, sweep;
            //var pathSegment = ej.datavisualization.Diagram.Util.cloneObject(ej.datavisualization.Diagram.PathSegment);
            var pathSegment = $.extend(false, {}, ej.datavisualization.Diagram.PathSegment);
            sweep = this.sweepDirection(angle, bridgeDirection, connector, diagram);
            arc = diagram.getBridgeSegment(start, end, angle, connector.bridgeSpace, sweep);
            pathSegment.path = arc;
            pathSegment.startPoint = start;
            pathSegment.endPoint = end;
            pathSegment.angle = angle;
            pathSegment.segmentPointIndex = segmentPointIndex;
            pathSegment.sweep = sweep;
            return pathSegment;
        },
        sweepDirection: function (angle, bridgeDirection, connector, diagram) {
            var angle1 = Math.abs(angle);
            if (bridgeDirection === "top" || bridgeDirection === "bottom") {
                var sweep = 1;
                if (angle1 >= 0 && angle1 <= 90) {
                    sweep = 0;
                }
            }
            else if (bridgeDirection === "right" || bridgeDirection === "left") {
                var sweep = 1;
                if (angle < 0 && angle >= -180) {
                    sweep = 0;
                }
            }
            if (bridgeDirection === "right" || bridgeDirection === "bottom") {
                if (sweep === 0)
                    sweep = 1;
                else
                    sweep = 0;
            }
            return sweep;
        },
        getPointAtLength: function (length, pts) {
            var run = 0;
            var pre = null;
            var found = ej.datavisualization.Diagram.Point(0, 0);
            for (var i = 0; i < pts.length; i++) {
                var pt = pts[i];
                if (!pre) {
                    pre = pt;
                    continue;
                }
                else {
                    var l = this.findLength(pre, pt);
                    if (run + l > length) {
                        var r = length - run;
                        var deg = this.findAngle(pre, pt);
                        var x = r * Math.cos(deg * Math.PI / 180);
                        var y = r * Math.sin(deg * Math.PI / 180);
                        found = ej.datavisualization.Diagram.Point(pre.x + x, pre.y + y);
                        break;
                    }
                    else {
                        run += l;
                    }
                }
                pre = pt;
            }
            return found;
        },
        getLengthAtFractionPoint: function (connector, pointAt) {
            var confirm = 100, fullLength = 0, segmentIndex = -1, count = 0, lengthAtFractionPt = 0, pointIndex = -1;
            if (connector.segments === null)
                return 0;
            var segments = connector.segments;
            var pt1 = connector.sourcePoint;
            var previouspt2 = pt1;
            for (var i = 0; i < connector.segments.length; i++) {
                var points = [];
                var segment1 = connector.segments[i];
                for (var j = 0; j < segment1.points.length; j++) {
                    var point2 = segment1.points[j];
                    points.push(point2);
                }
                for (var j = 0; j < points.length; j++) {
                    var pt2 = points[j];
                    var suspect = this.getSlope(pt2, pt1, pointAt, connector);
                    if (suspect < confirm) {
                        confirm = suspect;
                        lengthAtFractionPt = fullLength + this.findLength(pointAt, previouspt2);
                        segmentIndex = count;
                        pointIndex = j;
                    }
                    fullLength += this.findLength(pt2, pt1);
                    pt1 = pt2;
                    previouspt2 = pt2;
                }
                count++;
            }
            return { "lengthAtFractionPt": lengthAtFractionPt, "fullLength": fullLength, "segmentIndex": segmentIndex, "pointIndex": pointIndex };
        },
        getSlope: function (startPt, endPt, point, connector) {
            var three = 3.0;
            var delX = Math.abs(startPt.x - endPt.x);
            var delY = Math.abs(startPt.y - endPt.y);
            var lhs = ((point.y - startPt.y) / (endPt.y - startPt.y));
            var rhs = ((point.x - startPt.x) / (endPt.x - startPt.x));
            if (!isFinite(lhs) || !isFinite(rhs) || isNaN(lhs) || isNaN(rhs)) {
                if (startPt.x === endPt.x) {
                    if (startPt.y === endPt.y) {
                        return 10000;
                    }
                    else if (((startPt.y > point.y) && (point.y > endPt.y)) || ((startPt.y < point.y) && (point.y < endPt.y))) {
                        return Math.abs(startPt.x - point.x);
                    }
                    else {
                        return 10000;
                    }
                }
                else if (startPt.y == endPt.y) {
                    if (((startPt.x > point.x) && (point.x > endPt.x)) || ((startPt.x < point.x) && (point.x < endPt.x))) {
                        return Math.abs(startPt.y - point.y);
                    }
                    else {
                        return 10000;
                    }
                }
                else {
                    return 10000;
                }
            }
            else if (connector.segments.length > 0) {
                if ((startPt.x >= point.x && point.x >= endPt.x) || (startPt.x <= point.x && point.x <= endPt.x) || delX < three) {
                    if ((startPt.y >= point.y && point.y >= endPt.y) || (startPt.y <= point.y && point.y <= endPt.y) || delY < three) {
                        return Math.abs(lhs - rhs);
                    }
                    else {
                        return 10000;
                    }
                }
                else {
                    return 10000;
                }
            }
            else {
                return 10000;
            }
        },
        getPoints: function (connector) {
            var points = [];
            // points.push(connector.sourcePoint);
            if (connector.segments.length > 0) {
                for (var i = 0; i < connector.segments.length; i++) {
                    var segment = connector.segments[i];
                    if (segment.type === "straight" || segment.type === "bezier") {
                        if (i === 0)
                            points.push(connector.sourcePoint);
                        if (segment._point)
                            points.push(segment._point);
                    }
                    else if (segment.type === "orthogonal") {
                        for (var j = 0; j < connector.segments[i].points.length; j++) {
                            points.push(connector.segments[i].points[j]);
                        }
                    }
                }
            }
            return points;
        },
        interSect: function (points1, points2, self, diagram, zOrder) {
            if (self && points2.length >= 2) {
                points2.splice(0, 1);
                points2.splice(0, 1);
            }
            var points = [];
            var bridgeDirection = diagram.bridgeDirection();
            for (var i = 0; i < points1.length - 1; i++) {
                var pt = this.interSect1(points1[i], points1[i + 1], points2, diagram, zOrder, bridgeDirection);
                if (pt.length > 0) {
                    for (var k = 0; k < pt.length; k++) {
                        points.push(pt[k]);
                    }
                }
                if (self && points2.length >= 1) {
                    points2.splice(0, 1);
                }
            }
            return points;
        },
        checkforHorizontalLine: function (angle) {
            var temp = 0;
            var ang = Math.abs(angle);
            if (ang > 90) {
                temp = 180 - ang;
            }
            else {
                temp = ang;
            }
            return temp;
        },
        interSect1: function (startPoint, endPoint, points, diagram, zOrder, bridgeDirection) {
            var points1 = [];
            for (var i = 0; i < points.length - 1; i++) {
                var point = this.interSect2(startPoint, endPoint, points[i], points[i + 1]);
                if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(point)) {
                    var angle = this._findAngle(startPoint, endPoint);
                    var angle1 = this._findAngle(points[i], points[i + 1]);
                    angle = this.checkforHorizontalLine(angle);
                    angle1 = this.checkforHorizontalLine(angle1);
                    if (bridgeDirection === "left" || bridgeDirection === "right") {
                        if (angle > angle1) {
                            points1.push(point);
                        }
                    }
                    else if (bridgeDirection === "top" || bridgeDirection === "bottom") {
                        if (angle < angle1) {
                            points1.push(point);
                        }
                    }
                    if ((angle === angle1 && zOrder) || diagram._autoConnectEndPoint) {
                        points1.push(point);
                    }
                }
            }
            return points1;
        },
        interSect2: function (start1, end1, start2, end2) {
            var lineUtil1 = ej.datavisualization.Diagram.LineUtil(start1.x, start1.y, end1.x, end1.y);
            var lineUtil2 = ej.datavisualization.Diagram.LineUtil(start2.x, start2.y, end2.x, end2.y);
            var line3 = this.interSect3(lineUtil1, lineUtil2);
            if (line3.enabled) {
                return line3.intersectPt;
            }
            else {
                return ej.datavisualization.Diagram.Point(0, 0);
            }
        },
        interSect3: function (lineUtil1, lineUtil2) {
            var point = ej.datavisualization.Diagram.Point(0, 0);
            var l1 = lineUtil1;
            var l2 = lineUtil2;
            var d = (l2.y2 - l2.y1) * (l1.x2 - l1.x1) - (l2.x2 - l2.x1) * (l1.y2 - l1.y1);
            var n_a = (l2.x2 - l2.x1) * (l1.y1 - l2.y1) - (l2.y2 - l2.y1) * (l1.x1 - l2.x1);
            var n_b = (l1.x2 - l1.x1) * (l1.y1 - l2.y1) - (l1.y2 - l1.y1) * (l1.x1 - l2.x1);
            if (d == 0)
                return { enabled: false, intersectPt: point };
            var ua = n_a / d;
            var ub = n_b / d;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                point.x = l1.x1 + (ua * (l1.x2 - l1.x1));
                point.y = l1.y1 + (ua * (l1.y2 - l1.y1));
                return { enabled: true, intersectPt: point };
            }
            return { enabled: false, intersectPt: point };
        },
        findLength: function (startPt, endPt) {
            try {
                var length = Math.sqrt(((startPt.x - endPt.x) * (startPt.x - endPt.x)) + ((startPt.y - endPt.y) * (startPt.y - endPt.y)));
                return length;
            }
            catch (e) {
                throw e;
            }
        },
        _findAngle: function (startPt, endPt) {
            var xDiff = startPt.x - endPt.x; var yDiff = startPt.y - endPt.y;
            return Math.atan2(yDiff, xDiff) * (180 / Math.PI);
        },
        findAngle: function (startPt, endPt) {
            if (ej.datavisualization.Diagram.Geometry.isEqualPoint(startPt, endPt))
                return 0;
            var r = ej.datavisualization.Diagram.Point(endPt.x, startPt.y);
            var sr = this.findLength(startPt, r);
            var re = this.findLength(r, endPt);
            var es = this.findLength(endPt, startPt);
            var ang = Math.asin(re / es);
            ang = ang * 180 / Math.PI;
            if (startPt.x < endPt.x) {
                if (startPt.y < endPt.y) {
                }
                else {
                    ang = 360 - ang;
                }
            }
            else {
                if (startPt.y < endPt.y) {
                    ang = 180 - ang;
                }
                else {
                    ang = 180 + ang;
                }
            }
            return ang;
        },
        _mapPalettePhase: function (item) {
            var sPoint, ePoint;
            if (item.orientation && item.orientation == "horizontal") {
                sPoint = { x: 0, y: 0 };
                ePoint = { x: 40, y: 0 };
            }
            else {
                sPoint = { x: 0, y: 0 };
                ePoint = { x: 0, y: 40 };
            }
            var phase = ej.datavisualization.Diagram.Connector({
                name: item ? item.name : ej.datavisualization.Diagram.Util.randomId(),
                segments: [{ type: "straight" }], sourcePoint: { x: sPoint.x, y: sPoint.y }, targetPoint: { x: ePoint.x, y: ePoint.y },
                lineWidth: item.lineWidth ? item.lineWidth : 1,
                lineDashArray: item.lineDashArray ? item.lineDashArray : null,
                lineColor: item.lineColor ? item.lineColor : "#606060",
                targetDecorator: { shape: "none" },
                isPhase: true,
                orientation: item.orientation ? item.orientation : "horizontal",
                labels: item.label ? [item.label] : [],
                paletteItem: item.paletteItem ? item.paletteItem : null,
            });
            return phase;
        },
        _updateShapeProperties: function (options) {
            options._type = "node";
            if (!options.shape.type) options.shape.type = "rectangle";
            switch (options.shape.type) {
                case "rectangle":
                    options.type = "basic";
                    options._shape = options.shape.type;
                    if (options.shape.cornerRadius)
                        options.cornerRadius = options.shape.cornerRadius;
                    break;
                case "ellipse":
                    options.type = "basic";
                    options._shape = options.shape.type;
                    break;
                case "path":
                    options.type = "basic";
                    options._shape = options.shape.type;
                    options.pathData = options.shape.pathData;
                    break;
                case "polygon":
                    options.type = "basic";
                    options._shape = options.shape.type;
                    options.points = options.shape.points;
                    break;
                case "image":
                    options.type = "image";
                    options._shape = options.shape.type;
                    options.source = options.shape.src;
                    break;
                case "native":
                    options.type = "native";
                    options._shape = options.shape.type;
                    options.templateId = options.shape.templateId;
                    break;
                case "text":
                    options.type = "text";
                    options._shape = options.shape.type;
                    options.textBlock = options.shape.textBlock;
                    break;
                case "html":
                    options.type = "html";
                    options._shape = options.shape.type;
                    options.templateId = options.shape.templateId;
                    break;
                default:
                    break;
            }
        },
        _refreshParentGroup: function (node, diagram) {
            var parentObj = diagram.nameTable[node.parent];
            if (parentObj) {
                this._updateGroupBounds(parentObj, diagram);
                var parent = parentObj.parent ? document.getElementById(parentObj.parent) : diagram._diagramLayer;
                ej.datavisualization.Diagram.DiagramContext.renderGroup(parentObj, diagram);
                var cause = diagram._isUndo ? ej.datavisualization.Diagram.GroupChangeCause.HistoryChange : ej.datavisualization.Diagram.GroupChangeCause.Unknown;
                diagram._raiseGroupChangeEvent(node, undefined, parentObj, cause);
            }
        },
        intersectsWith: function (rect, point1, point2) {
            var point = point1;
            var success = ((((rect.x < point.x) && (point.x < (rect.x + rect.width)))
                && (rect.y < point.y)) && (point.y < (rect.y + rect.height)));
            return success;
        },
        _findOffsetOnConnector: function (connector, handle, offset, diagram) {
            var length = 0;
            var lengths = [];
            //find connector length
            for (var i = 0; i < connector.segments.length; i++) {
                lengths[i] = [];
                for (var j = 0; j < connector.segments[i].points.length - 1; j++) {
                    length += ej.datavisualization.Diagram.Geometry.distance(connector.segments[i].points[j], connector.segments[i].points[j + 1]);
                    lengths[i][j] = length;
                }
            }
            var targetNode = connector.sourceNode && handle.offset == 0 && diagram.nameTable[connector.sourceNode] ||
                connector.targetNode && handle.offset == 1 && diagram.nameTable[connector.targetNode];
            var bnds = targetNode ? this.bounds(targetNode) : null;
            var offset = handle.segmentOffset || 0;
            var prevLength, targetSegment, angle, pt;
            //offset length
            var offLength = length * offset;
            for (var i = 0; i < lengths.length; i++) {
                for (var j = 0; j < lengths[i].length; j++) {
                    //segment where offset lies 
                    if (lengths[i][j] >= offLength) {
                        targetSegment = connector.segments[i];
                        angle = ej.datavisualization.Diagram.Geometry.findAngle(targetSegment.points[j], connector.segments[i].points[j + 1]);
                        pt = ej.datavisualization.Diagram.Geometry.transform(targetSegment.points[j], angle, offLength - (prevLength || 0));
                        var endPt;
                        if (targetNode) {
                            if (this.intersectsWith(bnds, pt) && !ej.datavisualization.Diagram.Geometry.containsRect(bnds, this.bounds(connector))) {
                                var direction = handle.offset == 0 ? this._getBezierDirection(targetSegment.points[j], connector.segments[i].points[j + 1])
                                    : this._getBezierDirection(targetSegment.points[j + 1], connector.segments[i].points[j]);
                                endPt = handle.offset == 0 ? targetSegment.points[j + 1] : targetSegment.points[j];
                                var skip = false;
                                switch (direction) {
                                    case "top":
                                        if (bnds.y > endPt.y)
                                            pt.y = bnds.top;
                                        else {
                                            skip = true;
                                        }
                                        break;
                                    case "bottom":
                                        if (bnds.bottom < endPt.y)
                                            pt.y = bnds.bottom;
                                        else {
                                            skip = true;
                                        }
                                        break;
                                    case "right":
                                        if (bnds.right < endPt.x)
                                            pt.x = bnds.right;
                                        else {
                                            skip = true;
                                        }
                                        break;
                                    case "left":
                                        if (bnds.left > endPt.x)
                                            pt.x = bnds.left;
                                        else {
                                            skip = true;
                                        }
                                        break;
                                }
                                if (skip) {
                                    offLength = handle.offset == 1 ? (prevLength || 0) : lengths[i][j];
                                    prevLength = handle.offset == 0 ? lengths[i][j] : (lengths[i][j - 2] || (
                                        lengths[i - 1] && lengths[i - 1].length > 1 ? lengths[i - 1][lengths[i - 1].length - 1] : lengths[i - 2] && lengths[i - 2][lengths[i - 2].length - 1]) || 0);
                                    handle.offset == 0 ? i = i : !j ? i -= 2 : j -= 2;
                                    continue;
                                }
                            } return { segment: i, point: j, offset: { x: pt.x, y: pt.y } };
                        }
                        else return { segment: i, point: j, offset: { x: pt.x, y: pt.y } };
                    }
                    prevLength = lengths[i][j];
                }
            }
        },
        _alignLabelOnSegments: function (node, label, diagram, obj) {
            var angle = obj.angle % 360;
            obj.angle %= 360;
            var fourty5 = 45;
            var one35 = 135;
            var two25 = 225;
            var three15 = 315;
            var bnds;
            if (label.segmentOffset == 0 && node.sourceNode || label.segmentOffset == 1 && node.targetNode) {
                var source = label.segmentOffset == 0 && node.sourceNode ? diagram.nameTable[node.sourceNode] : diagram.nameTable[node.targetNode];
                if (source) bnds = this.bounds(source);
                if (bnds) {
                    var part = 180 / (2 + 2 / (bnds.height / bnds.width));
                    fourty5 = part;
                    one35 = (180 - part);
                    two25 = one35 + (2 * part);
                    three15 = 360 - part;
                }
            }
            var hAlign, vAlign;
            switch (label.alignment) {
                case "before":
                    if (obj.angle >= fourty5 && obj.angle <= one35) { hAlign = "right"; vAlign = label.segmentOffset == 0.5 ? "center" : "top" }
                    else if (obj.angle >= two25 && obj.angle <= three15) { hAlign = "left"; vAlign = label.segmentOffset == 0.5 ? "center" : "bottom" }
                    else if (obj.angle > fourty5 && obj.angle < two25) { vAlign = "top"; hAlign = label.segmentOffset == 0.5 ? "center" : "right" }
                    else { vAlign = "bottom"; hAlign = (label.segmentOffset == 0.5) ? "center" : "left" }
                    break
                case "after":
                    if (obj.angle >= fourty5 && obj.angle <= one35) { hAlign = "left"; vAlign = label.segmentOffset == 0.5 ? "center" : "top" }
                    else if (obj.angle >= two25 && obj.angle <= three15) { hAlign = "right"; vAlign = label.segmentOffset == 0.5 ? "center" : "bottom" }
                    else if (obj.angle > fourty5 && obj.angle < two25) { vAlign = "bottom"; hAlign = label.segmentOffset == 0.5 ? "center" : "right" }
                    else { vAlign = "top"; hAlign = label.segmentOffset == 0.5 ? "center" : "left" }
                    break;
                case "center":
                    hAlign = "center";
                    vAlign = "center";
                    break;
            }
            if (label.boundaryConstraints && (label.segmentOffset == 0 || label.segmentOffset == 1)) {
                var length, direction;
                if (node.segments.length > 1)
                    var segment = node.segments[node.segments.length - 1];
                length = segment ? segment.points.length : node.segments[0].points.length;
                if (node.labels[0].name == label.name)
                    direction = ej.datavisualization.Diagram.Util._getBezierDirection(node.segments[0].points[0], node.segments[0].points[1]);
                else {
                    segment = segment ? segment : node.segments[0];
                    direction = ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[length - 2], segment.points[length - 1]);
                }
                switch (direction) {
                    case "left":
                        hAlign = label.segmentOffset == 0 ? "right" : "left";
                        break;
                    case "right":
                        hAlign = label.segmentOffset == 0 ? "left" : "right";
                        break;
                    case "bottom":
                        vAlign = label.segmentOffset == 0 ? "top" : "bottom";
                        break;
                    case "top":
                        vAlign = label.segmentOffset == 0 ? "bottom" : "top";
                        break;
                }

            }
            return { hAlign: hAlign, vAlign: vAlign };
        },
        getObjectType: function (element) {
            if (element) {
                if (element.segments) return "connector";
                else if (element.type == "bpmn" && element.container) return "group";
                else if ((element._type === "node" || element.type == "bpmn" || element.type == "basic" || element.type == "flow" || element.type == "arrow")) return "node";
                else if (element.type === "text" || element.type === "image" || element.type === "native" || element.type === "html") return "node";
                else if (element._type != "group" && element.type == "pseudoGroup") return "pseudoGroup";
                else if (element._type === "group" || element.isLane || element.isSwimlane) return "group";
                else if (element.isSwimlane) return "swimlane";
                else return null;
            }
            return null;
        },
        _canBeTarget: function (diagram, node) {
            if (node) {
                if (diagram.activeTool.helper && diagram.activeTool.helper._name) {
                    if (diagram.activeTool.helper._name === node.name)
                        return false;
                }
            }
            return true;
        },


        getLabelbounds: function (diagram, node, label, isZoomLabel) {
            var element;

            if (label) {
                if (diagram.model.labelRenderingMode === "svg") {
                    if (diagram._svg) {
                        var bounds, layerBounds, elementBounds;
                        element = diagram._svg.document.getElementById(node.name + "_" + label.name);
                        layerBounds = diagram._svg.document.getBoundingClientRect();
                        if (element) {
                            elementBounds = element.getBoundingClientRect();
                            bounds = { x: elementBounds.left, y: elementBounds.top, width: elementBounds.width, height: elementBounds.height };
                            var labelCenter = diagram.tools["labelMove"].getCenterOfLabel(label, label.segmentOffset, bounds);
                            return {
                                x: elementBounds.left - layerBounds.left,
                                y: elementBounds.top - layerBounds.top,
                                width: elementBounds.right - elementBounds.left,
                                height: elementBounds.bottom - elementBounds.top,
                                centerX: labelCenter.x,
                                centerY: labelCenter.y
                            };
                        }
                    }
                }
                else {
                    if (diagram._svg) {
                        var htmlLayer = diagram._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                        var layerBounds = htmlLayer.getBoundingClientRect();
                        var layerleft = layerBounds.left;
                        var layertop = layerBounds.top;
                        element = $(htmlLayer).find("#" + node.name + "_" + label.name)[0];;
                        if (element) {
                            if (isZoomLabel) {
                                var elementBounds = element.getBoundingClientRect();
                                var elementleft = ((elementBounds.left - layerleft) / diagram.model.scrollSettings.currentZoom) + (layerleft + diagram.model.scrollSettings.horizontalOffset);
                                var elementtop = ((elementBounds.top - layertop) / diagram.model.scrollSettings.currentZoom) + (layertop + diagram.model.scrollSettings.verticalOffset);
                                var width = elementBounds.width / diagram.model.scrollSettings.currentZoom;
                                var height = elementBounds.height / diagram.model.scrollSettings.currentZoom;

                                layerleft += diagram.model.scrollSettings.horizontalOffset;
                                layertop += diagram.model.scrollSettings.verticalOffset;
                            } else {
                                var elementBounds = element.getBoundingClientRect();
                                var elementleft = elementBounds.left - layerleft;
                                var elementtop = elementBounds.top - layertop;
                                var width = elementBounds.width;
                                var height = elementBounds.height;
                            }
                            return ej.datavisualization.Diagram.Rectangle((elementleft - layerleft), (elementtop - layertop), width, height);
                        }
                    }
                }
            }
        },
        _updateBpmnChild: function (options, diagram) {
            switch (options.shape) {
                case "event":
                    options = ej.datavisualization.Diagram.DefautShapes._getBPMNEventShape(options, diagram);
                    break;
                case "gateway":
                    options = ej.datavisualization.Diagram.DefautShapes._getBPMNGatewayShape(options, diagram);
                    break;
                case "dataobject":
                    options = ej.datavisualization.Diagram.DefautShapes._getBPMNDataShape(options, diagram);
                    break;
                case "activity":
                    options = ej.datavisualization.Diagram.DefautShapes._getBPMNActivityShape(options, diagram);
                    break;
                case "group":
                    options = ej.datavisualization.Diagram.DefautShapes._getBPMNGroupShape(options, diagram);
                    break;
            }
            return ej.datavisualization.Diagram.DefautShapes.initBPMNAnnotationShape(options, diagram);
        },
        _getUndoObject: function (diagram, node) {
            var childTable = {};
            var childTable = diagram._getChildTable(node, childTable);
            diagram.activeTool._undoObject = $.extend(true, {}, { node: node, childTable: childTable });
        },
        _getRedoObject: function (diagram, node) {
            var childTable = {};
            var childTable = diagram._getChildTable(node, childTable);
            diagram.activeTool._redoObject = $.extend(true, {}, { node: node, childTable: childTable });
        },
        _collectionContains: function (name, coll) {
            for (var i = 0; i < coll.length; i++) {
                if (typeof (coll[i]) === "string" && coll[i] === name) {
                    return true;
                }
                else if (coll[i].name === name) {
                    return true;
                }
            }
        },
        _updateActivityChildOffset: function (node, offset, diagram) {
            if (node.children && node.children.length > 0) {
                for (var i = 0; i < node.children.length; i++) {
                    node.children[i].offsetX = offset.x;
                    node.children[i].offsetY = offset.y;
                    this._updateActivityChildOffset(node.children[i], offset, diagram);
                }
            }
        },
        _updateBPMNProperties: function (node, diagram, nameTable, isScaling) {
            switch (node.shape) {
                case "activity":
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                    var offsetX = node.offsetX, offsetY = node.offsetY;
                    var children = diagram._getChildren(node.children);
                    for (var i = 0; i < children.length; i++) {
                        var child = typeof children[i] == "object" ? children[i] : nameTable[children[i]];
                        if (isScaling && i == 0) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(child, true);
                            offsetX = child.offsetX, offsetY = child.offsetY;
                        }
                        if (i == 0) {
                            child.pathData = child._absolutePath = ej.datavisualization.Diagram.DefautShapes._updateRoundedRectanglePath(node, 12);
                            if (node.subProcess.type == "transaction") {
                                var innerRect = { x: 3, y: 3, width: node.width - 3, height: node.height - 3 };
                                child.pathData = child._absolutePath += ej.datavisualization.Diagram.DefautShapes._updateRoundedRectanglePath(innerRect, 12)
                            }
                            delete child._absoluteBounds;
                        }
                        if (isScaling && ej.datavisualization.Diagram.Util.canResize(child)) continue;
                        var addInfo = child.addInfo;
                        if (addInfo && addInfo.offset) {
                            var offset = ej.datavisualization.Diagram.Point(bounds.x + bounds.width * addInfo.offset.x, bounds.y + bounds.height * addInfo.offset.y);
                            addInfo.margin = ej.datavisualization.Diagram.Margin(addInfo.margin ? addInfo.margin : {});
                            if (addInfo.hAlign) {
                                offset.x += addInfo.margin.left - addInfo.margin.right;
                                offset.x = addInfo.hAlign == "left" ? offset.x + addInfo.margin.right : (addInfo.hAlign == "right" ? offset.x - addInfo.margin.left : offset.x);
                            }
                            if (addInfo.vAlign) {
                                offset.y += addInfo.margin.top - addInfo.margin.bottom;
                                offset.y = addInfo.vAlign == "top" ? offset.y + addInfo.margin.bottom : (addInfo.vAlign == "bottom" ? offset.y - addInfo.margin.top : offset.y);
                            }
                            if (node.rotateAngle) {
                                var matrix = ej.Matrix.identity();
                                ej.Matrix.rotate(matrix, node.rotateAngle, offsetX, offsetY);
                                offset = ej.Matrix.transform(matrix, offset);
                            }
                            child.offsetX = offset.x;
                            child.offsetY = offset.y;
                            this._updateActivityChildOffset(child, offset, diagram);
                        }
                    }
                    break;
                case "group":
                    node.pathData = node._absolutePath = ej.datavisualization.Diagram.DefautShapes._updateRoundedRectanglePath(node, 15);
                    node._scaled = false;
                    break;
                case "annotation":
                    var connector;
                    for (var i = 0; i < node.outEdges.length; i++) {
                        var edge = diagram.nameTable[node.outEdges[i]];
                        if (edge._isAnnotationLine) {
                            connector = edge;
                            break;
                        }
                    }
                    if (connector) ej.datavisualization.Diagram.DefautShapes.updateBPMNAnnotationShape(connector, node, null, null, diagram);
                    break;
                case "dataobject":
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                    var offsetX = node.offsetX, offsetY = node.offsetY;
                    var children = diagram._getChildren(node.children);
                    var pivot = node.pivot || { x: 0.5, y: 0.5 };
                    var x = node.offsetX ? node.offsetX - node.width * pivot.x : node.width * pivot.x;
                    var y = node.offsetY ? node.offsetY - node.height * pivot.y : node.height * pivot.y;
                    for (var i = 0; i < children.length; i++) {
                        var child = typeof children[i] == "object" ? children[i] : nameTable[children[i]];
                        if (isScaling && ej.datavisualization.Diagram.Util.canResize(child)) continue;
                        var addInfo = child.addInfo;
                        addInfo.margin = ej.datavisualization.Diagram.Margin(addInfo.margin ? addInfo.margin : {});
                        if (addInfo.offset) {
                            var offset = ej.datavisualization.Diagram.Point({})
                            offset.x = x + ((addInfo.offset.x * node.width)) + addInfo.margin.left - addInfo.margin.right;
                            offset.y = y + ((addInfo.offset.y * node.height)) + addInfo.margin.top - addInfo.margin.bottom;
                            if (node.rotateAngle) {
                                var matrix = ej.Matrix.identity();
                                ej.Matrix.rotate(matrix, node.rotateAngle, offsetX, offsetY);
                                offset = ej.Matrix.transform(matrix, offset);
                            }
                            child.offsetX = offset.x;
                            child.offsetY = offset.y;
                        }
                    }
                    break;
            }
        },
        indexOf: function (array, obj) {
            if (array != null && obj != null) {
                for (var i = 0; i < array.length; i++) {
                    if (array[i] == obj) {
                        return i;
                    }
                }
            }

            return -1;
        },
    };
    ej.datavisualization.Diagram.BridgeSegments = {
        bridges: [],
        bridgeStartPoint: [],
        segmentIndex: -1
    };
    ej.datavisualization.Diagram.PathSegment = {
        path: "",
        startPoint: { "x": 0, "y": 0 },
        endPoint: { "x": 0, "y": 0 },
        angle: 0,
        segmentPointIndex: -1,
        sweep: 1
    };
    ej.datavisualization.Diagram.LineUtil = function (x1, y1, x2, y2) {
        return { "x1": Number(x1) || 0, "y1": Number(y1) || 0, "x2": Number(x2) || 0, "y2": Number(y2) || 0 };
    };
    //#endregion
    //#region Geometry
    ej.datavisualization.Diagram.Geometry = {
        checkPointOnCircle: function (point, center, radius) {
            var r2 = Math.pow(radius, 2);
            var x2 = Math.pow((point.x - center.x), 2);
            var y2 = Math.pow((point.y - center.y), 2);
            if ((x2 + y2) <= r2) {
                return true;
            }
            return false;
        },
        rect: function (points) {
            var rectangle = ej.datavisualization.Diagram.Rectangle();
            if (arguments.length === 1) {
                var left = Number.MAX_VALUE;
                var top = Number.MAX_VALUE;
                var right = -Number.MAX_VALUE;
                var bottom = -Number.MAX_VALUE;
                var len = points.length;
                var x, y;
                for (var i = 0; i < len; i++) {
                    x = points[i].x;
                    y = points[i].y;
                    if (x < left) {
                        left = x;
                    }
                    if (x > right) {
                        right = x;
                    }
                    if (y < top) {
                        top = y;
                    }
                    if (y > bottom) {
                        bottom = y;
                    }
                }
                rectangle = ej.datavisualization.Diagram.Rectangle(left, top, right - left, bottom - top);
            }
            else if (arguments.length === 2) {
                var ptStart = ej.datavisualization.Diagram.Point(arguments[0]);
                var ptEnd = ej.datavisualization.Diagram.Point(arguments[1]);
                var swap;
                if (ptStart.x > ptEnd.x) {
                    swap = ptStart.x;
                    ptStart.x = ptEnd.x;
                    ptEnd.x = swap;
                }
                if (ptStart.y > ptEnd.y) {
                    swap = ptStart.y;
                    ptStart.y = ptEnd.y;
                    ptEnd.y = swap;
                }
                rectangle = ej.datavisualization.Diagram.Rectangle(ptStart.x, ptStart.y, ptEnd.x - ptStart.x, ptEnd.y - ptStart.y);
            }
            return rectangle;
        },
        union: function (rect1, rect2) {
            var x = Math.min(rect1.x, rect2.x);
            var y = Math.min(rect1.y, rect2.y);
            var width = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
            var height = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);
            return ej.datavisualization.Diagram.Rectangle(x, y, width - x, height - y);
        },
        distance: function (pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        },
        translate: function (pt1, dx, dy) {
            return ej.datavisualization.Diagram.Point(pt1.x + dx, pt1.y + dy);
        },
        intersectsRect: function (rect1, rect2) {
            return ((((rect2.x < (rect1.x + rect1.width)) && (rect1.x < (rect2.x + rect2.width)))
                && (rect2.y < (rect1.y + rect1.height))) && (rect1.y < (rect2.y + rect2.height)));
        },
        findAngle: function (point1, point2) {
            var angle = Math.atan2(point2.y - point1.y, point2.x - point1.x);
            angle = (180 * angle / Math.PI);
            angle %= 360;
            if (angle < 0) {
                angle += 360;
            }
            return angle;
        },
        intersectSegment: function (segment1, segment2) {
            var x1 = segment1.point1.x;
            var y1 = segment1.point1.y;
            var x2 = segment1.point2.x;
            var y2 = segment1.point2.y;
            var x3 = segment2.point1.x;
            var y3 = segment2.point1.y;
            var x4 = segment2.point2.x;
            var y4 = segment2.point2.y;
            var a1, a2, b1, b2, c1, c2, x, y;
            var r1, r2, r3, r4;
            var denom, offset, num;
            a1 = y2 - y1;
            b1 = x1 - x2;
            c1 = (x2 * y1) - (x1 * y2);
            r3 = ((a1 * x3) + (b1 * y3) + c1);
            r4 = ((a1 * x4) + (b1 * y4) + c1);
            if ((r3 !== 0) && (r4 !== 0) && this.sameSign(r3, r4)) {
                return null;
            }
            a2 = y4 - y3;
            b2 = x3 - x4;
            c2 = (x4 * y3) - (x3 * y4);
            r1 = (a2 * x1) + (b2 * y1) + c2;
            r2 = (a2 * x2) + (b2 * y2) + c2;
            if ((r1 !== 0) && (r2 !== 0) && (this.sameSign(r1, r2))) {
                return null;
            }
            denom = (a1 * b2) - (a2 * b1);

            if (denom === 0) {
                return null;
            }
            if (denom < 0) {
                offset = -denom / 2;
            }
            else {
                offset = denom / 2;
            }
            offset = 0;
            num = (b1 * c2) - (b2 * c1);
            if (num < 0) {
                x = (num - offset) / denom;
            }
            else {
                x = (num + offset) / denom;
            }
            num = (a2 * c1) - (a1 * c2);
            if (num < 0) {
                y = (num - offset) / denom;
            }
            else {
                y = (num + offset) / denom;
            }
            return ej.datavisualization.Diagram.Point(x, y);
        },
        updatePath: function (x, y, width, height, pathData, svg, bounds, appendBoundsTo) {
            var bBox, isInit;
            if (svg && svg.pathBounds) {
                isInit = true;
                bBox = bounds || svg.pathBounds(pathData);
            }
            else {
                if (appendBoundsTo && !appendBoundsTo._absolutePath) isInit = true; else isInit = false;
                bBox = bounds;
            }
            if (appendBoundsTo) appendBoundsTo._absoluteBounds = bBox;
            var newX = 0, newY = 0;
            var isResize = false;
            if (x.toString() !== bBox.x || y.toString() !== bBox.y) {
                newX = x - Number(bBox.x);
                newY = y - Number(bBox.y);
            }
            if (width !== bBox.width || height !== bBox.height) {
                newX = width / Number(bBox.width ? bBox.width : 1);
                newY = height / Number(bBox.height ? bBox.height : 1);
                isResize = true;
            }
            return ej.datavisualization.Diagram.Geometry.processPathData(pathData, newX, newY, isResize, bBox.x, bBox.y, x, y, isInit, svg);
        },
        processPathData: function (path, newX, newY, isResizing, oldX, oldY, offsetX, offsetY, isInit, svg) {
            var shape = document.createElementNS('http://www.w3.org/2000/svg', "path");
            shape.setAttribute("d", path);
            if (isInit) {
                svg = svg || new ej.datavisualization.Diagram.Svg({});
                path = svg.absolutePath(shape).getAttribute('d');
                shape.setAttribute("d", path);
            }
            var x0, y0, x1, y1, x2, y2, segs = ej.datavisualization.Diagram.Util.convertPathToArray(path);
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.pathSegTypeAsLetter;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
                if (isResizing) {
                    if (x != undefined) {
                        x = ej.datavisualization.Diagram.Geometry.scalePathData(x, newX, oldX, offsetX);
                        x = Number(x.toFixed(2));
                    }
                    if (y != undefined) {
                        y = ej.datavisualization.Diagram.Geometry.scalePathData(y, newY, oldY, offsetY);
                        y = Number(y.toFixed(2));
                    }
                    if (x1 != undefined) {
                        x1 = ej.datavisualization.Diagram.Geometry.scalePathData(x1, newX, oldX, offsetX);
                        x1 = Number(x1.toFixed(2));
                    }
                    if (y1 != undefined) {
                        y1 = ej.datavisualization.Diagram.Geometry.scalePathData(y1, newY, oldY, offsetY);
                        y1 = Number(y1.toFixed(2));
                    }
                    if (x2 != undefined) {
                        x2 = ej.datavisualization.Diagram.Geometry.scalePathData(x2, newX, oldX, offsetX);
                        x2 = Number(x2.toFixed(2));
                    }
                    if (y2 != undefined) {
                        y2 = ej.datavisualization.Diagram.Geometry.scalePathData(y2, newY, oldY, offsetY);
                        y2 = Number(y2.toFixed(2));
                    }
                }
                else {
                    if (x != undefined) {
                        x = (x + newX);
                    }
                    if (y != undefined) {
                        y = (y + newY);
                    }
                    if (x1 != undefined) {
                        x1 = (x1 + newX);
                    }
                    if (y1 != undefined) {
                        y1 = (y1 + newY);
                    }
                    if (x2 != undefined) {
                        x2 = (x2 + newX);
                    }
                    if (y2 != undefined) {
                        y2 = (y2 + newY);
                    }
                }
                var newSeg;
                switch (char) {
                    case 'M':
                        newSeg = { pathSegTypeAsLetter: "M", x: x, y: y };
                        break;
                    case 'L':
                        newSeg = { pathSegTypeAsLetter: "L", x: x, y: y };
                        break;
                    case 'H':
                        newSeg = { pathSegTypeAsLetter: "H", x: x };
                        break;
                    case 'V':
                        newSeg = { pathSegTypeAsLetter: "V", y: y };
                        break;
                    case 'C':
                        newSeg = { pathSegTypeAsLetter: "C", x: x, y: y, x1: x1, y1: y1, x2: x2, y2: y2 };
                        break;
                    case 'S':
                        newSeg = { pathSegTypeAsLetter: "S", x: x, y: y, x2: x2, y2: y2 };
                        break;
                    case 'Q':
                        newSeg = { pathSegTypeAsLetter: "Q", x: x, y: y, x1: x1, y1: y1 };
                        break;
                    case 'T':
                        newSeg = { pathSegTypeAsLetter: "T", x: x, y: y };
                        break;
                    case 'A':
                        var r1 = seg.r1, r2 = seg.r2;
                        if (isResizing) {
                            r1 = (r1 * newX);
                            r2 = (r2 * newY);
                        }
                        newSeg = { pathSegTypeAsLetter: "A", x: x, y: y, r1: r1, r2: r2, angle: seg.angle, largeArcFlag: seg.largeArcFlag, sweepFlag: seg.sweepFlag };
                        break;
                    case 'z':
                    case 'Z':
                        x = x0; y = y0;
                        newSeg = segs[i];
                        break;
                }
                if (newSeg)
                    segs[i] = newSeg;
                // Record the start of a subpath
                if (char === 'M' || char === 'm') x0 = x, y0 = y;
            }
            var pathData = ej.datavisualization.Diagram.Util.pathSegArrayAsString(segs);
            return pathData;
        },
        scalePathData: function (val, scaleFactor, oldOffset, newOffset) {
            if (val !== oldOffset) {
                if (newOffset !== oldOffset) {
                    val = (((val * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)))
                        + (newOffset - Number(oldOffset)));
                }
                else
                    val = ((Number(val) * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)));
            }
            else {
                if (newOffset !== oldOffset) {
                    val = newOffset;
                }
            }
            return val;
        },
        updatePolygonPoints: function (node, points) {
            if (node.points) {
                if (!points)
                    points = node.points;
                ej.datavisualization.Diagram.Geometry.scalePoints(points, node);
                var bounds = ej.datavisualization.Diagram.Geometry.rect(node.points);
                for (var i = 0, len = node.points.length; i < len; ++i) {
                    var point = ej.datavisualization.Diagram.Geometry.translate(points[i], -bounds.x, -bounds.y);
                    point = ej.datavisualization.Diagram.Geometry.translate(point, 0, 0);
                    points[i] = point;
                }
            }
        },
        scalePoints: function (points, node) {
            var bounds = ej.datavisualization.Diagram.Geometry.rect(node.points);
            if (bounds.width > 0 && bounds.height > 0) {
                var scaleX = node.width / bounds.width;
                var scaleY = node.height / bounds.height;
                for (var i = 0, len = node.points.length; i < len; ++i) {
                    points[i].x = points[i].x * scaleX;
                    points[i].y = points[i].y * scaleY;
                }
            }
        },
        sameSign: function (a, b) {
            return ((a * b) >= 0);
        },
        containsPoint: function (rect, point) {
            return ((((rect.x <= point.x) && (point.x <= (rect.x + rect.width)))
                && (rect.y <= point.y)) && (point.y <= (rect.y + rect.height)));
        },
        containsRect: function (rect, value) {
            return ((((rect.x <= value.x) && ((value.x + value.width) <= (rect.x + rect.width)))
                && (rect.y <= value.y)) && ((value.y + value.height) <= (rect.y + rect.height)));
        },
        inflate: function (rect, x, y) {
            rect.x -= x;
            rect.y -= y;
            rect.width += 2 * x;
            rect.height += 2 * y;
        },
        isEmptyRect: function (rect) {
            return rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0;
        },
        isEmptyPoint: function (point) {
            return point.x === 0 && point.y === 0;
        },
        isEqualPoint: function (point1, point2) {
            return (point1 && point2 && point1.x === point2.x && point1.y === point2.y);
        },
        isEmptySize: function (size) {
            return size.width === 0 && size.height === 0;
        },
        length: function (segment) {
            return ej.datavisualization.Diagram.Geometry.distance(segment.point1, segment.point2);
        },
        midPoint: function (segment) {
            return ej.datavisualization.Diagram.Point((segment.point1.x + segment.point2.x) / 2, (segment.point1.y + segment.point2.y) / 2);
        },
        transform: function (point, angle, length) {
            var pt = {};
            pt.x = Math.round((point.x + length * Math.cos(angle * Math.PI / 180)) * 100) / 100;
            pt.y = Math.round((point.y + length * Math.sin(angle * Math.PI / 180)) * 100) / 100;
            return pt;
        }
    };
    ej.datavisualization.Diagram.LineSegment = function (point1, point2) {
        return { "point1": point1, "point2": point2 };
    };
    ej.datavisualization.Diagram.Point = function (x, y) {
        return { "x": Number(x) || 0, "y": Number(y) || 0 };
    };
    ej.datavisualization.Diagram.Size = function (width, height) {
        return { "width": Number(width) || 0, "height": Number(height) || 0 };
    };
    ej.datavisualization.Diagram.Rectangle = function (x, y, width, height) {
        return { "x": Number(x) || 0, "y": Number(y) || 0, "width": Number(width) || 0, "height": Number(height) || 0 };
    };
    //#endregion
    //#region Enums
    ej.datavisualization.Diagram.ImageAlignment = {
        None: "none",
        XMinYMin: "xminymin",
        XMinYMid: "xminymid",
        XMinYMax: "xminymax",
        XMidYMin: "xmidymin",
        XMidYMid: "xmidymid",
        XMidYMax: "xmidymax",
        XMaxYMin: "xmaxymin",
        XMaxYMid: "xmaxymid",
        XMaxYMax: "xmaxymax"
    }
    ej.datavisualization.Diagram.ActiveTool = {
        None: "none",
        Drag: "drag",
        Draw: "draw"
    }
    ej.datavisualization.Diagram.ScaleConstraints = {
        None: "none",
        Stretch: "stretch",
        Meet: "meet",
        Slice: "slice"
    }
    ej.datavisualization.Diagram.KeyModifiers = {
        None: 0,
        Control: 1 << 0,
        Meta: 1 << 0,
        Alt: 1 << 1,
        Shift: 1 << 2
    };
    ej.datavisualization.Diagram.Keys = {
        None: "",
        Number0: 0,
        Number1: 1,
        Number2: 2,
        Number3: 3,
        Number4: 4,
        Number5: 5,
        Number6: 6,
        Number7: 7,
        Number8: 8,
        Number9: 9,
        A: 65,
        B: 66,
        C: 67,
        D: 68,
        E: 69,
        F: 70,
        G: 71,
        H: 72,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        M: 77,
        N: 78,
        O: 79,
        P: 80,
        Q: 81,
        R: 82,
        S: 83,
        T: 84,
        U: 85,
        V: 86,
        W: 87,
        X: 88,
        Y: 89,
        Z: 90,
        Left: 37,
        Up: 38,
        Right: 39,
        Down: 40,
        Escape: 27,
        Delete: 46,
        Tab: 9,
        Enter: 13,
    };
    ej.datavisualization.Diagram.LabelRenderingMode = {
        Html: "html",
        Svg: "svg"
    };
    ej.datavisualization.Diagram.TemplateType = {
        Html: "html",
        Svg: "svg"
    };
    ej.datavisualization.Diagram.DecoratorShapes = {
        None: "none",
        Arrow: "arrow",
        OpenArrow: "openarrow",
        Circle: "circle",
        Diamond: "diamond",
        Path: "path"
    };
    ej.datavisualization.Diagram.ConnectorType = {
        StraightLine: "straightLine",
        OrthogonalLine: "orthogonalLine",
        Polyline: "polyline",
    };
    ej.datavisualization.Diagram.ActionType = {
        Unknown: "unknown",
        Nudge: "nudge",
        Touch: "touch",
        Mouse: "mouse",
        Order: "order",
        Align: "align",
        Size: "size",
        HistoryChange: "historyChange"
    };
    ej.datavisualization.Diagram.dependentconnector = {
        dependent: 1,
        independent: 2
    }
    ej.datavisualization.Diagram.ContainerType = {
        Canvas: "canvas",
        Stack: "stack",
    };
    ej.datavisualization.Diagram.IconShapes = {
        Minus: "minus",
        Plus: "plus",
        ArrowUp: "arrowup",
        ArrowDown: "arrowdown",
        Template: "template",
        Path: "path",
        Image: "image",
        None: "none",
    };
    ej.datavisualization.Diagram.PortShapes = {
        X: "x",
        Circle: "circle",
        Square: "square",
        Path: "path"
    };
    ej.datavisualization.Diagram.TickAlignment = {
        LeftOrTop: "leftortop",
        RightOrBottom: "rightorbottom",
    },
        ej.datavisualization.Diagram.PortVisibility = {
            Visible: 1 << 0,
            Hidden: 1 << 1,
            Hover: 1 << 2,
            Connect: 1 << 3,
            Default: 1 << 3
        };
    ej.datavisualization.Diagram.TextAlign = {
        Left: "left",
        Center: "center",
        Right: "right",
        Justify: "justify"
    };
    ej.datavisualization.Diagram.HorizontalAlignment = {
        Left: "left",
        Center: "center",
        Right: "right",
        Stretch: "stretch"
    };
    ej.datavisualization.Diagram.Alignment = {
        Before: "before",
        After: "after",
        Center: "center"
    };
    ej.datavisualization.Diagram.LabelRelativeMode = {
        SegmentBounds: "segmentbounds",
        SegmentPath: "segmentpath"
    }
    ej.datavisualization.Diagram.LabelEditMode = {
        Edit: "edit",
        View: "view"
    };
    ej.datavisualization.Diagram.RelativeMode = {
        Object: "object",
        Mouse: "mouse"
    };
    ej.datavisualization.Diagram.TextWrapping = {
        NoWrap: "nowrap",
        Wrap: "wrap",
        WrapWithOverflow: "wrapwithoverflow",
    };
    ej.datavisualization.Diagram.VerticalAlignment = {
        Top: "top",
        Center: "center",
        Bottom: "bottom",
        Stretch: "stretch"
    };
    ej.datavisualization.Diagram.TextDecorations = {
        Underline: "underline",
        Overline: "overline",
        LineThrough: "line-through",
        None: "none"
    };
    ej.datavisualization.Diagram.PaletteConstraints = {
        HeaderVisibility: 1 << 1,
        Visible: 1 << 2,
        Expandable: 1 << 3,
        Default: 1 << 1 | 1 << 2 | 1 << 3
    };
    ej.datavisualization.Diagram.NodeConstraints = {
        None: 1 << 0,
        Select: 1 << 1,
        Delete: 1 << 2,
        Drag: 1 << 3,
        Rotate: 1 << 4,
        Connect: 1 << 5,
        ResizeNorthEast: 1 << 6,
        ResizeEast: 1 << 7,
        ResizeSouthEast: 1 << 8,
        ResizeSouth: 1 << 9,
        ResizeSouthWest: 1 << 10,
        ResizeWest: 1 << 11,
        ResizeNorthWest: 1 << 12,
        ResizeNorth: 1 << 13,
        Resize: 1 << 6 | 1 << 7 | 1 << 8 | 1 << 9 | 1 << 10 | 1 << 11 | 1 << 12 | 1 << 13,
        Shadow: 1 << 14,
        DragLabel: 1 << 15,
        AllowPan: 1 << 16,
        AspectRatio: 1 << 17,
        AllowDrop: 1 << 18,
        InheritTooltip: 1 << 19,
        MultiSelect: 1 << 20,
        PointerEvents: 1 << 21,
        PointerVisibility: 1 << 21,
        CrispEdges: 1 << 22,
        InheritCrispEdges: 1 << 23,
        Interaction: 1 << 1 | 1 << 3 | 1 << 4 | 1 << 6 | 1 << 7 | 1 << 8 | 1 << 9 | 1 << 10 | 1 << 11 | 1 << 12 | 1 << 13 | 1 < 21,
        Default: 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6 | 1 << 7 | 1 << 8 | 1 << 9 | 1 << 10 | 1 << 11 | 1 << 12 | 1 << 13 | 1 << 19 | 1 << 21 | 1 << 23
    };
    ej.datavisualization.Diagram.LabelConstraints = {
        None: 1 << 0,
        Selectable: 1 << 1,
        Draggable: 1 << 2,
        Resizable: 1 << 3,
        Rotatable: 1 << 4,
        All: 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4
    };
    ej.datavisualization.Diagram.HistoryChangeCause = {
        Undo: "undo",
        Redo: "redo",
        CustomAction: "customAction"
    };
    ej.datavisualization.Diagram.CollectionChangeCause = {
        ClipBoard: "clipBoard",
        Drop: "drop",
        HistoryChange: "historyChange",
        Unknown: "unknown",
    };
    ej.datavisualization.Diagram.GroupChangeCause = {
        Group: "group",
        Ungroup: "ungroup",
        Drop: "drop",
        HistoryChange: "historyChange",
        Unknown: "unknown"
    };
    ej.datavisualization.Diagram.SelectionChangeCause = {
        Keydown: "keydown",
        RubberBand: "rubberBand",
        Mouse: "mouse",
        Touch: "touch",
        Unknown: "unknown",
    };
    ej.datavisualization.Diagram.ScrollChangeCause = {
        Zoom: "zoom",
        Pan: "pan",
        Unknown: "unknown"
    };
    ej.datavisualization.Diagram.ConnectorConstraints = {
        None: 1 << 0,
        Select: 1 << 1,
        Delete: 1 << 2,
        Drag: 1 << 3,
        DragSourceEnd: 1 << 4,
        DragTargetEnd: 1 << 5,
        DragSegmentThumb: 1 << 6,
        Bridging: 1 << 7,
        DragLabel: 1 << 8,
        InheritBridging: 1 << 9,
        AllowDrop: 1 << 10,
        InheritTooltip: 1 << 11,
        PointerEvents: 1 << 12,
        PointerVisibility: 1 << 12,
        CrispEdges: 1 << 13,
        InheritCrispEdges: 1 << 14,
        DragLimit: 1 << 15,
        BridgeObstacle: 1 << 16,
        Routing: 1 << 17,
        InheritRouting: 1 << 18,
        Interaction: 1 << 1 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6 || 1 << 12,
        Default: 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6 | 1 << 9 | 1 << 11 | 1 << 12 | 1 << 14 | 1 << 16 | 1 << 18
    };
    ej.datavisualization.Diagram.PortConstraints = {
        None: 1 << 0,
        Connect: 1 << 1,
        ConnectOnDrag: 1 << 2,
    };
    ej.datavisualization.Diagram.SelectorConstraints = {
        None: 1 << 0,
        Rotator: 1 << 1,
        Resizer: 1 << 2,
        UserHandles: 1 << 3,
        Tooltip: 1 << 4,
        DragOnEmptySpace: 1 << 5,
        AutoHideThumbs: 1 << 6,
        All: 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4
    };
    ej.datavisualization.Diagram.UserHandlePositions = {
        TopLeft: "topleft",
        TopCenter: "topcenter",
        TopRight: "topright",
        MiddleLeft: "middleleft",
        MiddleRight: "middleright",
        BottomLeft: "bottomleft",
        BottomCenter: "bottomcenter",
        BottomRight: "bottomright"
    };
    ej.datavisualization.Diagram.SnapConstraints = {
        None: 0,
        SnapToHorizontalLines: 1,
        SnapToVerticalLines: 2,
        SnapToLines: 1 | 2,
        ShowHorizontalLines: 4,
        ShowVerticalLines: 8,
        ShowLines: 4 | 8,
        All: 1 | 2 | 4 | 8
    };
    ej.datavisualization.Diagram.PageOrientations = {
        Landscape: "landscape",
        Portrait: "portrait"
    };
    ej.datavisualization.Diagram.ScrollLimit = {
        Infinity: "infinity",
        Diagram: "diagram",
        Limited: "limited"
    };
    ej.datavisualization.Diagram.BoundaryConstraints = {
        Infinity: "infinity",
        Diagram: "diagram",
        Page: "page"
    };
    ej.datavisualization.Diagram.LayoutOrientations = {
        TopToBottom: "toptobottom",
        BottomToTop: "bottomtotop",
        LeftToRight: "lefttoright",
        RightToLeft: "righttoleft"
    };
    ej.datavisualization.Diagram.ObjectTypes = {
        Diagram: "diagram",
        Palette: "palette",
        Lane: "lane",
        Group: "group"
    };
    ej.datavisualization.Diagram.PaletteDefaults = {
        name: "",
        expanded: false,
        subControlId: null,
        items: [],
        constraints: ej.datavisualization.Diagram.PaletteConstraints.Default,
    };
    ej.datavisualization.Diagram.Palette = function (options) {
        options.items = options.items ? options.items.slice() : [];
        return $.extend(false, {}, ej.datavisualization.Diagram.PaletteDefaults, options);
    };
    ej.datavisualization.Diagram.Shapes = {
        Image: "image",
        Text: "text",
        Html: "html",
        Native: "native",
        Basic: "basic",
        Flow: "flow",
        Arrow: "arrow",
        BPMN: "bpmn",
    };
    ej.datavisualization.Diagram.ClipBoardChangeType = {
        All: "all",
        None: "none",
        Specific: "specific"
    };
    ej.datavisualization.Diagram.OverflowType = {
        Clip: "clip",
        Ellipsis: "ellipsis"
    };
    ej.datavisualization.Diagram.ShapeDefaults = {
        shape: "",
        source: "",
        pathData: "",
        textBlock: null,
        points: [],
        templateId: null,
        scale: "meet",
        contentAlignment: "xmidymid"
    };
    ej.datavisualization.Diagram.Shape = function (options) {
        if (options) {
            options.points = options.points ? options.points.slice() : [];
            if (options.type === "html") {
                if (typeof (options.html) === "string")
                    options.html = ej.datavisualization.Diagram.Util.htmlEncode(options.html);
            }
            if (options.type === "text") {
                options.textBlock = ej.datavisualization.Diagram.TextBlock(options.textBlock ? options.textBlock : {});
                options.fillColor = options.fillColor ? options.fillColor : "transparent";
                options.borderColor = options.borderColor ? options.borderColor : "transparent";
                options.borderWidth = options.borderWidth ? options.borderWidth : 0;
            }
            if (options.type == "image" || options.type == "native" || options.type === "text" || options.type === "html")
                options._shape = options.type;
            if (!options._type)
                options._type = options.type ? options.type : "node";
            if (!options._shape)
                options._shape = options.shape ? options.shape : "rectangle";
            options.points = options.points ? options.points.slice() : [];
        }

        return $.extend(false, {}, ej.datavisualization.Diagram.ShapeDefaults, options);
    };
    ej.datavisualization.Diagram.Segments = {
        Straight: "straight",
        Orthogonal: "orthogonal",
        Bezier: "bezier"
    };
    ej.datavisualization.Diagram.SegmentDefaults = {
        type: ej.datavisualization.Diagram.Segments.Straight,
        point: null,
        point1: null,
        point2: null,
        vector1: null,
        vector2: null,
        _point1: ej.datavisualization.Diagram.Point(),
        _point2: ej.datavisualization.Diagram.Point(),
        length: null, _length: null,
        _bridges: [],
        direction: null, _direction: null,
    };
    ej.datavisualization.Diagram.Segment = function (options) {
        var line = $.extend(true, {}, ej.datavisualization.Diagram.SegmentDefaults, options);
        line._bridges = line._bridges ? line._bridges.slice() : [];
        var points = [];
        line["points"] = points;
        if (line.type == "orthogonal") {
            line._length = line.length;
            line._direction = line.direction;
        }
        else {
            if (line.type == "bezier") {
                line._point1 = line.point1;
                line._point2 = line.point2;
            }
            if (line.point) {
                line._point = line.point;
            }
        }
        return line;
    };
    //#endregion


    ej.datavisualization.Diagram.DragLimitDefaults = {
        top: 10,
        left: 10,
        right: 10,
        bottom: 10
    };
    ej.datavisualization.Diagram.DragLimit = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.DragLimitDefaults, options);
    };

    //#region Margin
    ej.datavisualization.Diagram.MarginDefaults = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    };
    ej.datavisualization.Diagram.Margin = function (options) {
        options = options || {};
        return $.extend(false, {}, ej.datavisualization.Diagram.MarginDefaults, options);
    };
    ej.datavisualization.Diagram.PaddingDefaults = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    };
    ej.datavisualization.Diagram.Padding = function (options) {
        options = options || {};
        return $.extend(false, {}, ej.datavisualization.Diagram.PaddingDefaults, options);
    };

    ej.datavisualization.Diagram.EndPointHitPaddingDefaults = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    };
    ej.datavisualization.Diagram.EndPointHitPadding = function (options) {
        options = options || {};
        options.top = options.top || 0;
        options.left = options.left || 0;
        options.right = options.right || 0;
        options.bottom = options.bottom || 0;
        return options;
    };

    ej.datavisualization.Diagram.GestureDefaults = {
        key: ej.datavisualization.Diagram.Keys.None,
        keyModifiers: ej.datavisualization.Diagram.KeyModifiers.None
    };
    ej.datavisualization.Diagram.Gesture = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.GestureDefaults, options);
    };
    //#region Command
    ej.datavisualization.Diagram.CommandDefaults = {
        gesture: ej.datavisualization.Diagram.Gesture(),
        execute: null,
        canExecute: null,
        parameter: null
    };
    ej.datavisualization.Diagram.Command = function (options) {
        if (options.gesture) options.gesture = ej.datavisualization.Diagram.Gesture(options.gesture);
        if (!options.canExecute) options.canExecute = function (args) {
            return true;
        }
        if (!options.execute) options.execute = function (args) {
        }
        return $.extend(true, {}, ej.datavisualization.Diagram.CommandDefaults, options);
    };
    //#endregion
    //#region Tooltip
    ej.datavisualization.Diagram.TooltipDefaults = {
        templateId: "",
        relativeMode: "object",
        alignment: {
            horizontal: "center",
            vertical: "bottom",
        },
        margin: { left: 5, right: 5, top: 5, bottom: 5 },
        offset: null,
        delay: 0
    };
    ej.datavisualization.Diagram.Tooltip = function (options) {
        options.margin = options.margin || {};
        options.margin.top = options.margin.top !== undefined ? options.margin.top : 5;
        options.margin.left = options.margin.left !== undefined ? options.margin.left : 5;
        options.margin.right = options.margin.right !== undefined ? options.margin.right : 5;
        options.margin.bottom = options.margin.bottom !== undefined ? options.margin.bottom : 5;
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);

        options.alignment = options.alignment || {};
        if (options.alignment) {
            options.alignment.horizontal = options.alignment.horizontal ? options.alignment.horizontal : "center";
            options.alignment.vertical = options.alignment.vertical ? options.alignment.vertical : "bottom";
        }
        return $.extend(false, {}, ej.datavisualization.Diagram.TooltipDefaults, options);
    };
    ej.datavisualization.Diagram.BackgroundImageDefaults = {
        source: "",
        alignment: "xmidymid",
        scale: "meet"
    };
    ej.datavisualization.Diagram.BackgroundImage = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.BackgroundImageDefaults, options);
    };
    //#endregion
    //#region Path Util
    ej.datavisualization.Diagram.Path = function () {
        this._path = "";
    };
    ej.datavisualization.Diagram.Path.prototype = {
        moveTo: function (x, y) {
            this._path += "M" + x + "," + y; return this;
        },
        lineTo: function (x, y) {
            this._path += "L" + x + "," + y; return this;
        },
        cubicBezierTo: function (points, isSmooth) {
            if (isSmooth)
                this._path += "S";
            else
                this._path += "C";
            this._addPoints(points);
            return this;
        },
        quadraticBezierTo: function (points, isSmooth) {
            if (isSmooth)
                this._path += "T";
            else
                this._path += "Q";
            this._addPoints(points);
            return this;
        },
        ellipticalArcTo: function (rx, ry, xAngle, arcFlag, sweepFlag, x, y) {
            this._path += "A" + rx + "," + ry + " " + xAngle + " " + arcFlag + "," + sweepFlag + " " + x + "," + y;
            return this;
        },
        close: function () {
            this._path += "Z"; return this;
        },
        toString: function () {
            return this._path;
        },
        _addPoints: function (points) {
            var point;
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                this._path += point.x + ", " + point.y;
                if (i !== (points.length - 1))
                    this._path += " ";
            }
        }
    };
    //#endregion
    ej.datavisualization.Diagram.DecoratorDefaults = {
        shape: ej.datavisualization.Diagram.DecoratorShapes.Arrow,
        width: 8,
        height: 8,
        borderColor: "black",
        borderWidth: 1,
        fillColor: "black",
        pathData: "",
        cssClass: ""
    };
    ej.datavisualization.Diagram.Decorator = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.DecoratorDefaults, options);
    };
    //#endregion
    ej.datavisualization.Diagram.TextBlockDefaults = {
        readOnly: false,
        bold: false,
        italic: false,
        text: "",
        textDecoration: ej.datavisualization.Diagram.TextDecorations.None,
        fontSize: 12,
        fontFamily: "Arial",
        fontColor: "black",
        boundaryConstraints: true,
        segmentOffset: 0.5,
        offset: ej.datavisualization.Diagram.Point(0.5, 0.5),
        textAlign: ej.datavisualization.Diagram.TextAlign.Center,
        alignment: ej.datavisualization.Diagram.Alignment.Center,
        relativeMode: ej.datavisualization.Diagram.LabelRelativeMode.SegmentPath,
        horizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Center,
        verticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Center,
        wrapping: ej.datavisualization.Diagram.TextWrapping.WrapWithOverflow,
        margin: ej.datavisualization.Diagram.Margin(),
        padding: ej.datavisualization.Diagram.Padding(),
        textOverflow: false,
        overflowType: ej.datavisualization.Diagram.OverflowType.Ellipsis,
        mode: ej.datavisualization.Diagram.LabelEditMode.Edit,
        width: 50,
        rotateAngle: 0,
        opacity: 1,
        templateId: "",
        templateType: "html"
    };
    ej.datavisualization.Diagram.TextBlock = function (options) {
        options.offset = options.offset || {};
        options.offset = ej.datavisualization.Diagram.Point(options.offset.x !== undefined ? options.offset.x : 0.5, options.offset.y !== undefined ? options.offset.y : 0.5);
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);
        if (options.wrapText !== undefined) {
            if (options.wrapText) options.wrapping = "wrapwithoverflow";
            else options.wrapping = "nowrap";
        }
        return $.extend(false, {}, ej.datavisualization.Diagram.TextBlockDefaults, options);
    };
    ej.datavisualization.Diagram.LabelDefaults = $.extend(false, {}, ej.datavisualization.Diagram.TextBlockDefaults, {
        name: "",
        visible: true,
        borderColor: "transparent",
        borderWidth: 0,
        fillColor: "transparent",
        cssClass: "",
        hyperlink: "",
        dragLimit: ej.datavisualization.Diagram.DragLimit(),
        height: 0,
        constraints: ej.datavisualization.Diagram.LabelConstraints.None,
        _type: "label"
    });
    ej.datavisualization.Diagram.Label = function (options) {
        options.offset = options.offset || {};
        options.offset = ej.datavisualization.Diagram.Point(options.offset.x !== undefined ? options.offset.x : 0.5, options.offset.y !== undefined ? options.offset.y : 0.5);
        options.dragLimit = ej.datavisualization.Diagram.DragLimit(options.dragLimit);
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);
        options.padding = ej.datavisualization.Diagram.Margin(options.padding);
        var label = $.extend(false, {}, ej.datavisualization.Diagram.LabelDefaults, options);
        if (!label.name)
            label.name = "label_" + ej.datavisualization.Diagram.Util.randomId();
        return label;
    };
    //#endregion

    //#region serializationSettings
    ej.datavisualization.Diagram.serializationSettingsDefaults = {
        preventDefaultValues: false
    };
    ej.datavisualization.Diagram.serializationSettings = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.serializationSettingsDefaults, options);
    };
    //#endregion
    //#region ExportSettings
    ej.datavisualization.Diagram.ExportSettingsDefaults = {
        multiplePage: false,
        pageWidth: null,
        pageHeight: null,
        pageOrientation: "portrait",
        stretch: "none"
    };
    ej.datavisualization.Diagram.ExportSettings = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.ExportSettingsDefaults, options);
    };
    //#endregion

    //#layer settings
    ej.datavisualization.Diagram.LayersDefaults = {
        name: "",
        visible: true,
        print: true,
        active: false,
        lock: false,
        snap: false,
        objects: []
    }
    ej.datavisualization.Diagram.Layers = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.LayersDefaults, options);
    }
    //#endregion
    //#region PrintSettings
    ej.datavisualization.Diagram.PrintSettingsDefaults = {
        multiplePage: false,
        pageWidth: null,
        pageHeight: null,
        pageOrientation: "portrait",
        margin: { left: 0, top: 0, right: 0, bottom: 0 },
        region: "pageSettings"
    };
    ej.datavisualization.Diagram.PrintSettings = function (options) {
        options = options || {};
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);
        return $.extend(false, {}, ej.datavisualization.Diagram.PrintSettingsDefaults, options);
    };
    //#endregion

    ej.datavisualization.Diagram.FlipDirection = {
        Horizontal: "horizontal",
        Vertical: "vertical",
        Both: "both",
        None: "none"
    };
    ej.datavisualization.Diagram.IconDefaults = {
        shape: ej.datavisualization.Diagram.IconShapes.None,
        width: 15,
        height: 15,
        offset: { x: 0.5, y: 1 },
        borderColor: "#1a1a1a",
        borderWidth: 1,
        margin: ej.datavisualization.Diagram.Margin(),
        horizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Center,
        verticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Center,
        cornerRadius: 0,
        fillColor: "white",
        source: "",
        pathData: "",
        templateId: "",
    };
    ej.datavisualization.Diagram.expandIcon = function (options) {
        options.offset = options.offset || {};
        options.offset = ej.datavisualization.Diagram.Point(options.offset.x !== undefined ? options.offset.x : 0.5, options.offset.y !== undefined ? options.offset.y : 1);
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);
        return $.extend(false, {}, ej.datavisualization.Diagram.IconDefaults, options);
    };
    ej.datavisualization.Diagram.collapseIcon = function (options) {
        options.offset = options.offset || {};
        options.offset = ej.datavisualization.Diagram.Point(options.offset.x !== undefined ? options.offset.x : 0.5, options.offset.y !== undefined ? options.offset.y : 1);
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);
        return $.extend(false, {}, ej.datavisualization.Diagram.IconDefaults, options);
    };
    //#region Port
    ej.datavisualization.Diagram.PortDefaults = {
        name: "",
        visibility: ej.datavisualization.Diagram.PortVisibility.Default,
        constraints: ej.datavisualization.Diagram.PortConstraints.Connect,
        size: 8,
        offset: ej.datavisualization.Diagram.Point(0, 0),
        borderColor: "#1a1a1a",
        borderWidth: 1,
        fillColor: "white",
        shape: ej.datavisualization.Diagram.PortShapes.Square,
        pathData: "",
        connectorPadding: 0,
        cssClass: "",
        margin: ej.datavisualization.Diagram.Margin(),
        parent: ""
    };
    //#region Shadow
    ej.datavisualization.Diagram.ShadowDefaults = {
        distance: 5,
        angle: 45,
        opacity: 0.7
    };
    ej.datavisualization.Diagram.Shadow = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.ShadowDefaults, options);
    };
    ej.datavisualization.Diagram.Port = function (options) {
        options.offset = options.offset || {};
        options.offset = ej.datavisualization.Diagram.Point(options.offset.x ? options.offset.x : 0, options.offset.y ? options.offset.y : 0);
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);
        var port = $.extend(false, {}, ej.datavisualization.Diagram.PortDefaults, options);
        if (!port.name)
            port.name = "port_" + ej.datavisualization.Diagram.Util.randomId();
        return port;
    };
    //#endregion
    //#region Gradient
    ej.datavisualization.Diagram.StopDefaults = {
        color: "",
        offset: 0,
        opacity: 1
    };
    ej.datavisualization.Diagram.Stop = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.StopDefaults, options);
    };
    ej.datavisualization.Diagram.LinearGradientDefaults = {
        type: "linear",
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0,
        stops: []
    };
    ej.datavisualization.Diagram.LinearGradient = function (options) {
        options.stops = options.stops ? options.stops.slice() : [];
        for (var i = 0; options.stops && i < options.stops.length; i++) {
            options.stops[i] = ej.datavisualization.Diagram.Stop(options.stops[i]);
        }
        return $.extend(false, {}, ej.datavisualization.Diagram.LinearGradientDefaults, options);
    };
    ej.datavisualization.Diagram.RadialGradientDefaults = {
        type: "radial",
        cx: 0,
        cy: 0,
        fx: 0,
        fy: 0,
        r: 50,
        stops: []
    };
    ej.datavisualization.Diagram.RadialGradient = function (options) {
        options.stops = options.stops ? options.stops.slice() : [];
        for (var i = 0; i < options.stops.length; i++) {
            options.stops[i] = ej.datavisualization.Diagram.Stop(options.stops[i]);
        }
        return $.extend(false, {}, ej.datavisualization.Diagram.RadialGradientDefaults, options);
    };
    //#region Node
    ej.datavisualization.Diagram.NodeBaseDefaults = {
        name: "",
        width: 0,
        height: 0,
        offsetX: 0,
        offsetY: 0,
        visible: true,
        zOrder: -1,
        excludeFromLayout: false,
        constraints: ej.datavisualization.Diagram.NodeConstraints.Default,
        parent: "",
        labels: [],
        expandIcon: {
            shape: ej.datavisualization.Diagram.IconShapes.None,
            width: 13,
            height: 10,
            margin: ej.datavisualization.Diagram.Margin(),
            offset: { x: 0.5, y: 1 },
            borderColor: "#1a1a1a",
            borderWidth: 1,
            cornerRadius: 0,
            fillColor: "black",
            pathData: "",
            templateId: "",
        },
        collapseIcon: {
            shape: ej.datavisualization.Diagram.IconShapes.None,
            width: 13,
            height: 10,
            margin: ej.datavisualization.Diagram.Margin(),
            offset: { x: 0.5, y: 1 },
            borderColor: "#1a1a1a",
            borderWidth: 1,
            cornerRadius: 0,
            fillColor: "black",
            pathData: "",
            templateId: "",
        },
        ports: [],
        inEdges: [],
        outEdges: [],
        rotateAngle: 0,
        pivot: ej.datavisualization.Diagram.Point(0.5, 0.5),
        addInfo: {},
        marginLeft: 0,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0,
        horizontalAlign: ej.datavisualization.Diagram.HorizontalAlignment.Left,
        verticalAlign: ej.datavisualization.Diagram.VerticalAlignment.Top,
        minWidth: 0,
        maxWidth: 0,
        minHeight: 0,
        maxHeight: 0,
        connectorPadding: 0,
        cornerRadius: 0,
        paletteItem: null,
    };

    ej.datavisualization.Diagram.NodeBase = function (options) {
        var i;
        options.labels = options.labels ? options.labels.slice() : [];
        options.ports = options.ports ? options.ports.slice() : [];
        options.inEdges = options.inEdges ? options.inEdges.slice() : [];
        options.outEdges = options.outEdges ? options.outEdges.slice() : [];
        if (options.expandIcon)
            options.expandIcon = ej.datavisualization.Diagram.expandIcon(options.expandIcon ? options.expandIcon : {});
        if (options.collapseIcon)
            options.collapseIcon = ej.datavisualization.Diagram.collapseIcon(options.collapseIcon ? options.collapseIcon : {});
        if (options.labels)
            for (i = 0; i < options.labels.length; i++) {
                options.labels[i] = ej.datavisualization.Diagram.Label(options.labels[i]);
                if (ej.datavisualization.Diagram.Util.canMoveLabel(options)) {
                    options.labels[i].constraints = ej.datavisualization.Diagram.LabelConstraints.All
                        & ~ej.datavisualization.Diagram.LabelConstraints.Selectable
                }
                options.labels[i]._parent = options.name;
            }
        if (options.ports)
            for (i = 0; i < options.ports.length; i++) {
                options.ports[i].parent = options.name;
                options.ports[i] = ej.datavisualization.Diagram.Port(options.ports[i]);
            }
        options.paletteItem = ej.datavisualization.Diagram.PaletteItem(options.paletteItem ? options.paletteItem : {});
        return $.extend(false, {}, ej.datavisualization.Diagram.NodeBaseDefaults, options);
    };
    ej.datavisualization.Diagram.NodeDefaults = {
        fillColor: "white",
        borderColor: "black",
        borderWidth: 1,
        borderDashArray: "",
        opacity: 1,
        gradient: null,
        borderGradient: null,
        type: ej.datavisualization.Diagram.Shapes.Basic,
        flip: ej.datavisualization.Diagram.FlipDirection.None,
        isExpanded: true,
        shadow: ej.datavisualization.Diagram.Shadow(),
        cssClass: ""
    };
    ej.datavisualization.Diagram.Node = function (options) {
        options = options || {};
        options.pivot = options.pivot || {};
        options.pivot = ej.datavisualization.Diagram.Point(options.pivot.x !== undefined ? options.pivot.x : 0.5, options.pivot.y !== undefined ? options.pivot.y : 0.5);
        if (options.container && $.isEmptyObject(options.container)) {
            options.container = null;
        }
        if (options.linearGradient || options.radialGradient) options.gradient = options.linearGradient || options.radialGradient;
        if (options.gradient) {
            if (options.gradient.type === "linear") {
                options.gradient = ej.datavisualization.Diagram.LinearGradient(options.gradient);
            }
            else if (options.gradient.type === "radial") {
                options.gradient = ej.datavisualization.Diagram.RadialGradient(options.gradient);
            }
        }
        if (options.borderGradient) {
            if (options.borderGradient.type === "linear") {
                options.borderGradient = ej.datavisualization.Diagram.LinearGradient(options.borderGradient);
            }
            else if (options.borderGradient.type === "radial") {
                options.borderGradient = ej.datavisualization.Diagram.RadialGradient(options.borderGradient);
            }
        }
        if (options.shadow) {
            options.shadow = ej.datavisualization.Diagram.Shadow(options.shadow);
        }
        if (options.tooltip) {
            options.tooltip = ej.datavisualization.Diagram.Tooltip(options.tooltip);
        }
        if (options && !options.name) {
            options.name = "node_" + ej.datavisualization.Diagram.Util.randomId();
        }
        options.minWidth = options.minWidth ? options.minWidth : 0;
        options.minHeight = options.minHeight ? options.minHeight : 0;
        options.maxWidth = options.maxWidth ? options.maxWidth : 0;
        options.maxHeight = options.maxHeight ? options.maxHeight : 0;
        if (!options.width && !options._width) options._width = options.minWidth ? options.minWidth : options.maxWidth;
        if (!options.height && !options._height) options._height = options.minHeight ? options.minHeight : options.maxHeight;
        if (options._hidePorts)
            options.ports = [];
        return $.extend(false, {}, ej.datavisualization.Diagram.NodeDefaults, ej.datavisualization.Diagram.NodeBase(options), ej.datavisualization.Diagram.Shape(options));
    };
    //#endregion
    //#region Connector
    ej.datavisualization.Diagram.ConnectorDefaults = {
        name: "",
        visible: true,
        lineDashArray: "",
        targetDecorator:
        {
            shape: ej.datavisualization.Diagram.DecoratorShapes.Arrow,
            width: 8,
            height: 8,
            borderColor: "black",
            fillColor: "black",
            pathData: ""
        },
        sourceDecorator:
        {
            shape: ej.datavisualization.Diagram.DecoratorShapes.Arrow,
            width: 8,
            height: 8,
            borderColor: "black",
            fillColor: "black",
            pathData: ""
        },
        shape: undefined,
        segments: [ej.datavisualization.Diagram.Segment({ type: "straight" })],
        sourcePoint: ej.datavisualization.Diagram.Point(),
        targetPoint: ej.datavisualization.Diagram.Point(),
        lineColor: "black",
        lineWidth: 1,
        flip: ej.datavisualization.Diagram.FlipDirection.None,
        constraints: ej.datavisualization.Diagram.ConnectorConstraints.Default,
        opacity: 1,
        parent: "",
        labels: [],
        zOrder: -1,
        lineHitPadding: 10,
        addInfo: {},
        targetNode: null,
        targetPort: null,
        sourceNode: null,
        sourcePort: null,
        marginLeft: 0,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0,
        horizontalAlign: ej.datavisualization.Diagram.HorizontalAlignment.Left,
        verticalAlign: ej.datavisualization.Diagram.VerticalAlignment.Top,
        cornerRadius: 0,
        bridgeSpace: 10,
        sourcePadding: 0,
        targetPadding: 0,
        type: "connector",
        cssClass: "",
        _endPointHitPadding: ej.datavisualization.Diagram.EndPointHitPadding()
    };
    ej.datavisualization.Diagram.Connector = function (options) {
        options = options || {};
        options.labels = options.labels ? options.labels.slice() : [];
        options.segments = options.segments ? options.segments.slice() : [];
        options._endPointHitPadding = ej.datavisualization.Diagram.EndPointHitPadding(options.endPointHitPadding);
        options.sourcePoint = options.sourcePoint || {};
        options.sourcePoint = ej.datavisualization.Diagram.Point(options.sourcePoint.x !== undefined ? options.sourcePoint.x : 0.5, options.sourcePoint.y !== undefined ? options.sourcePoint.y : 0.5);
        options.targetPoint = options.targetPoint || {};
        options.targetPoint = ej.datavisualization.Diagram.Point(options.targetPoint.x !== undefined ? options.targetPoint.x : 0.5, options.targetPoint.y !== undefined ? options.targetPoint.y : 0.5);
        options.name = options.name ? options.name : ej.datavisualization.Diagram.Util.randomId();
        options.targetDecorator = ej.datavisualization.Diagram.Decorator(options.targetDecorator || {});
        options.sourceDecorator = ej.datavisualization.Diagram.Decorator((options.sourceDecorator && !$.isEmptyObject(options.sourceDecorator)) ? options.sourceDecorator : { shape: ej.datavisualization.Diagram.DecoratorShapes.None });
        options.segments = options.segments || [ej.datavisualization.Diagram.Segment({ type: "straight" })];
        options._srcDecoratorSize = Math.max(parseInt(options.sourceDecorator.height), parseInt(options.sourceDecorator.width)) + 5 * options.sourceDecorator.borderWidth;
        options._tarDecoratorSize = Math.max(parseInt(options.targetDecorator.height), parseInt(options.targetDecorator.width)) + 5 * options.targetDecorator.borderWidth;
        options._inlineDecorators = [];
        if (options.segments) {
            options.sourcePoint = options.sourcePoint || ej.datavisualization.Diagram.Point();
            options.targetPoint = options.targetPoint || ej.datavisualization.Diagram.Point();
            ej.datavisualization.Diagram.Util._initializeSegments(options, options.defaultType);
            ej.datavisualization.Diagram.Util.flipConnector(options, options.flip);

        }
        if (options.labels)
            for (var i = 0; i < options.labels.length; i++) {
                options.labels[i] = ej.datavisualization.Diagram.Label(options.labels[i]);
                if (ej.datavisualization.Diagram.Util.canMoveLabel(options)) {
                    options.labels[i].constraints = ej.datavisualization.Diagram.LabelConstraints.All
                        & ~ej.datavisualization.Diagram.LabelConstraints.Selectable
                }
                options.labels[i]._parent = options.name;
            }
        if (options.tooltip) {
            options.tooltip = ej.datavisualization.Diagram.Tooltip(options.tooltip);
        }
        options.paletteItem = ej.datavisualization.Diagram.PaletteItem(options.paletteItem ? options.paletteItem : {});
        return $.extend(false, {}, ej.datavisualization.Diagram.ConnectorDefaults, options);
    };
    //#endregion
    //#region Container
    ej.datavisualization.Diagram.ContainerDefaults = {
        type: ej.datavisualization.Diagram.ContainerType.Canvas,
        orientation: "vertical",
    };
    ej.datavisualization.Diagram.Container = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.ContainerDefaults, options);
    };
    // #endregion
    //#region Group
    ej.datavisualization.Diagram.GroupDefaults = {
        children: [],
        canUngroup: true,
        allowDrop: true,
        container: null,
        paddingLeft: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingBottom: 0,
        minWidth: 100,
        maxWidth: Number.POSITIVE_INFINITY,
        minHeight: 100,
        maxHeight: Number.POSITIVE_INFINITY,
        type: "group"
    };
    ej.datavisualization.Diagram.Group = function (options) {
        options = options ? options : {};
        options.children = options.children ? options.children.slice() : [];
        if (options.type == "bpmn") options = ej.datavisualization.Diagram.Node(options);
        options.minWidth = options.minWidth ? options.minWidth : 100;
        options.minHeight = options.minHeight ? options.minHeight : 100;
        options.maxWidth = options.maxWidth ? options.maxWidth : Number.POSITIVE_INFINITY;
        options.maxHeight = options.maxHeight ? options.maxHeight : Number.POSITIVE_INFINITY;
        options.container = options.container ? ej.datavisualization.Diagram.Container(options.container) : null;
        options.fillColor = options.fillColor ? options.fillColor : "transparent";
        options.borderColor = options.borderColor ? options.borderColor : "transparent";
        options = options || {};
        if (options.container && $.isEmptyObject(options.container)) {
            options.container = null;
        }
        if (options && !options.name) {
            options.name = "group_" + ej.datavisualization.Diagram.Util.randomId();
        }
        if (options.tooltip) {
            options.tooltip = ej.datavisualization.Diagram.Tooltip(options.tooltip);
        }
        if (options.type === "pseudoGroup") {
            options.minWidth = 0;
            options.minHeight = 0;
            options.maxHeight = 0;
            options.maxWidth = 0;
        }
        if (!options._type && !(options.type == "umlclassifier")) options._type = options.type ? options.type : "group";
        return $.extend(true, {}, ej.datavisualization.Diagram.NodeDefaults, ej.datavisualization.Diagram.GroupDefaults, ej.datavisualization.Diagram.NodeBase(options));
    };
    //#endregion
    //#region ZoomCommand
    ej.datavisualization.Diagram.ZoomCommand = {
        ZoomIn: 1,
        ZoomOut: 2
    };
    ej.datavisualization.Diagram.Zoom = function (options) {
        return $.extend(true, {}, { zoomFactor: 0.2, focusPoint: null, zoomCommand: ej.datavisualization.Diagram.ZoomCommand.ZoomIn }, options);
    };
    //#endregion
    ej.datavisualization.Diagram.DragState = {
        Starting: "starting",
        Dragging: "dragging",
        Completed: "completed"
    };
    ej.datavisualization.Diagram.ResizeState = {
        Starting: "starting",
        Resizing: "resizing",
        Completed: "completed"
    };
    ej.datavisualization.Diagram.DiagramConstraints = {
        None: 1 << 0,
        UserInteraction: 1 << 1,
        APIUpdate: 1 << 2,
        PageEditable: 1 << 1 | 1 << 2,
        Bridging: 1 << 3,
        Zoomable: 1 << 4,
        PannableX: 1 << 5,
        PannableY: 1 << 6,
        Pannable: 1 << 5 | 1 << 6,
        Undoable: 1 << 7,
        Resizable: 1 << 8,
        ZoomTextEditor: 1 << 9,
        FloatElements: 1 << 10,
        CrispEdges: 1 << 11,
        Routing: 1 << 12,
        Default: 1 << 1 | 1 << 2 | 1 << 4 | 1 << 5 | 1 << 6 | 1 << 7 | 1 << 8
    };
    ej.datavisualization.Diagram.BridgeDirection = {
        Top: "top",
        Bottom: "bottom",
        Left: "left",
        Right: "right"
    };
    ej.datavisualization.Diagram.Tool = {
        None: 1 << 0,
        SingleSelect: 1 << 1,
        MultipleSelect: 1 << 2,
        ZoomPan: 1 << 3,
        DrawOnce: 1 << 4,
        ContinuesDraw: 1 << 5
    };
    ej.datavisualization.Diagram.Region = {
        Content: "content",
        PageSettings: "pageSettings"
    };
    ej.datavisualization.Diagram.FileFormats = {
        JPG: "jpg",
        PNG: "png",
        BMP: "bmp",
        SVG: "svg"
    };
    ej.datavisualization.Diagram.ExportModes = {
        Download: "download",
        Data: "data"
    };
    ej.datavisualization.Diagram.FitMode = {
        Page: "page",
        Width: "width",
        Height: "height"
    };
    ej.datavisualization.Diagram.Stretch = {
        None: "none",
        Fill: "fill",
        Uniform: "uniform",
        UniformToFill: "uniformtofill"
    };
    ej.datavisualization.Diagram.shapeType = {
        Image: "image",
        Path: "path",
        Native: "native"
    };

    //#endregion
    //#region UserHandle
    ej.datavisualization.Diagram.UserHandleDefaults = {
        name: "",
        pathData: "",
        templateId: "",
        source: "",
        shape: ej.datavisualization.Diagram.shapeType.Path,
        borderColor: "",
        backgroundColor: "#2382c3",
        position: "",
        offset: ej.datavisualization.Diagram.Point(0.5, 1),
        margin: { left: 0, right: 0, top: 0, bottom: -25 },
        horizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Center,
        verticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Center,
        pathColor: "white",
        tool: "",
        size: 20,
        visible: true,
        enableMultiSelection: false
    };
    ej.datavisualization.Diagram.UserHandle = function (options) {
        return $.extend(true, {}, ej.datavisualization.Diagram.UserHandleDefaults, options);
    };
    //#endregion
    //#region Swimlane
    ej.datavisualization.Diagram.SwimLaneDefaults = {
        header: $.extend(true, {}, ej.datavisualization.Diagram.LabelDefaults, {
            text: "Title",
            borderColor: "black",
            fillColor: "#C7D4DF",
            horizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Stretch,
            verticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Stretch,
            width: 50,
            height: 50
        }),
        fillColor: "transparent",
        orientation: "vertical",
        type: "group",
        isSwimlane: true,
        offsetX: 100,
        offsetY: 100,
        minHeight: 100,
        maxHeight: Number.POSITIVE_INFINITY,
        minWidth: 100,
        maxWidth: Number.POSITIVE_INFINITY,
        height: 100,
        width: 100,
        lanes: [],
        phases: [],
        phaseSize: 20,
        constraints: ej.datavisualization.Diagram.NodeConstraints.Default | ej.datavisualization.Diagram.NodeConstraints.AllowDrop & ~(ej.datavisualization.Diagram.NodeConstraints.ResizeNorth |
            ej.datavisualization.Diagram.NodeConstraints.ResizeWest | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest |
            ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest),
        addInfo: {},
        cssClass: ""
    };
    ej.datavisualization.Diagram.SwimLane = function (options) {
        options = options || {};
        options.lanes = options.lanes ? options.lanes.slice() : [];
        options.phases = options.phases ? options.phases.slice() : [];
        if (options && !options.name) {
            options.name = "swimlane_" + ej.datavisualization.Diagram.Util.randomId();
        }
        if (options.tooltip) {
            options.tooltip = ej.datavisualization.Diagram.Tooltip(options.tooltip);
        }
        if (!options.header)
            options.header = {};
        options.header.height = options.header.height != undefined ? options.header.height : 50;
        options.header.width = options.header.width != undefined ? options.header.width : 50;

        return $.extend(true, {}, ej.datavisualization.Diagram.SwimLaneDefaults, options);
    };
    //#endregion  
    //#region Lane
    ej.datavisualization.Diagram.LaneDefaults = {
        header: $.extend(true, {}, ej.datavisualization.Diagram.LabelDefaults, {
            text: "Function",
            borderColor: "black",
            fillColor: "#C7D4DF",
            horizontalAlignment: ej.datavisualization.Diagram.HorizontalAlignment.Stretch,
            verticalAlignment: ej.datavisualization.Diagram.VerticalAlignment.Stretch,
            width: 50,
            height: 50
        }),
        name: "",
        children: [],
        isLane: true,
        orientation: "horizontal",
        fillColor: "#f5f5f5",
        labels: [],
        addInfo: {},
        minHeight: 100,
        minWidth: 100,
        maxHeight: Number.POSITIVE_INFINITY,
        maxWidth: Number.POSITIVE_INFINITY,
        constraints: ej.datavisualization.Diagram.NodeConstraints.Default | ej.datavisualization.Diagram.NodeConstraints.AllowDrop & ~ej.datavisualization.Diagram.NodeConstraints.Connect,
        cssClass: ""
    };
    ej.datavisualization.Diagram.Lane = function (options) {
        options = options || {};
        options.labels = options.labels ? options.labels.slice() : [];
        options.children = options.children ? options.children.slice() : [];
        if (options && !options.name) {
            options.name = "lane_" + ej.datavisualization.Diagram.Util.randomId();
        }
        if (options.tooltip) {
            options.tooltip = ej.datavisualization.Diagram.Tooltip(options.tooltip);
        }
        return $.extend(true, {}, ej.datavisualization.Diagram.LaneDefaults, options);
    };
    //#endregion  
    //#region phase
    ej.datavisualization.Diagram.PhaseDefaults = {
        name: "",
        type: "phase",
        offset: 100,
        lineWidth: 1,
        lineDashArray: "3,3",
        lineColor: "#606060",
        parent: "",
        fillColor: "white",
        orientation: "horizontal",
        label: { text: "Phase" }
    };
    ej.datavisualization.Diagram.Phase = function (options) {
        if (options.label) {
            options.label = ej.datavisualization.Diagram.Label(options.label);
            if (!options._UndoRedo && !options._isUndo)
                options.label.text = options.label.text ? options.label.text : "Phase"
        }
        return $.extend(true, {}, ej.datavisualization.Diagram.PhaseDefaults, options);
    };
    //#endregion 
    //#region paletteItem
    ej.datavisualization.Diagram.PaletteItemDefaults = {
        width: undefined,
        height: undefined,
        enableScale: true,
        previewHeight: undefined,
        previewWidth: undefined,
        wrapping: ej.datavisualization.Diagram.TextWrapping.NoWrap,
        label: null,
        margin: ej.datavisualization.Diagram.Margin({ left: 4, right: 4, top: 4, bottom: 4 })
    };
    ej.datavisualization.Diagram.PaletteItem = function (options) {
        options.margin = options.margin || {};
        options.margin.left = options.margin.left !== undefined ? options.margin.left : 4;
        options.margin.right = options.margin.right !== undefined ? options.margin.right : 4;
        options.margin.top = options.margin.top !== undefined ? options.margin.top : 4;
        options.margin.bottom = options.margin.bottom !== undefined ? options.margin.bottom : 4;
        options.margin = ej.datavisualization.Diagram.Margin(options.margin);
        return $.extend(false, {}, ej.datavisualization.Diagram.PaletteItemDefaults, options);
    };
    //#endregion 
    ej.datavisualization.Diagram.SwimLaneHelper = {
        //#region diagram
        _initSwimLane: function (obj, diagram, headAdded) {
            var canvas = null;
            var lanes = null;
            var obj = ej.datavisualization.Diagram.SwimLane(obj);
            obj.orientation = obj.orientation ? obj.orientation : "vertical";
            var phases = this._initphases(obj, diagram);
            lanes = this._initLanes(obj, diagram, headAdded);
            var childern = [];
            var header = null;
            if (!obj.header) {
                obj.header = { text: "", height: 0, fillColor: "white" };
            }
            if (obj.orientation === "horizontal") {
                var height = obj.header.height;
            } else {
                var width = obj.header.width;
            }
            if (obj.header) {
                header = ej.datavisualization.Diagram.Node({
                    _type: "node",
                    _isHeader: true,
                    name: obj.name + "_header_swimlane",
                    labels: [obj.header],
                    height: height ? height : 50,
                    width: width ? width : 50,
                    fillColor: obj.header.fillColor ? obj.header.fillColor : "white",
                    rotateAngle: 0,
                    constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
                    horizontalAlign: "stretch",
                    parent: obj.name,
                });
            }
            if (header) {
                diagram.nodes().push(header);
                diagram._nodes = $.extend(true, [], diagram.nodes());
                diagram.nameTable[header.name] = header;
                childern.push(header.name);
            }
            //var phaseNode = this._initPhaseNode(obj, diagram, childern);
            var seprtrValue = null;
            if (obj.phaseSize == 0)
                var seprtrValue = 0.001;
            else
                var seprtrValue = obj.phaseSize ? obj.phaseSize : 20;
            var PhaseStack = this._initPhaseStack(obj, diagram, childern, seprtrValue);
            var hAlign = null, vAlign = null;
            if (obj.orientation == "vertical")
                vAlign = "stretch";
            else
                hAlign = "stretch";
            var orientation, marginLeft = 0, marginTop = 0, minHeight = 0;
            if (obj.orientation == "horizontal") {
                orientation = "vertical";
                marginTop = (obj.header ? obj.header.height : 50) + seprtrValue;
                minHeight = 0;
            }
            else {
                orientation = "horizontal";
                marginTop = (obj.header ? obj.header.height : 50);
                marginLeft = (obj.phaseSize ? obj.phaseSize : seprtrValue);
                minHeight = (obj.header ? obj.header.height : 50) + seprtrValue;
            }
            var stack = ej.datavisualization.Diagram.Group({
                name: obj.name + "_stack",
                children: lanes,
                parent: obj.name,
                container: { type: ej.datavisualization.Diagram.ContainerType.Stack, orientation: orientation },
                horizontalAlign: "stretch",
                verticalAlign: "stretch",
                marginTop: marginTop,
                width: 10,
                height: 10,
                marginLeft: marginLeft,
                minHeight: minHeight,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default & ~
                    (ej.datavisualization.Diagram.NodeConstraints.Select | ej.datavisualization.Diagram.NodeConstraints.Connect),
            });
            var cW = 0, cH = 0;
            if (obj.orientation == "horizontal") {
                cW = obj.width;
                cH = 100;
            }
            else if (obj.orientation == "vertical") {
                cW = 100;
                cH = obj.height - header.height;
            }
            diagram.nodes().push(stack);
            diagram._nodes = $.extend(true, [], diagram.nodes());
            diagram.nameTable[stack.name] = stack;
            childern.push(stack.name);
            canvas = ej.datavisualization.Diagram.Group({
                name: obj.name ? obj.name : "",
                type: "group",
                addInfo: obj.addInfo ? obj.addInfo : {},
                parent: "",
                offsetX: obj.offsetX ? obj.offsetX : 100,
                offsetY: obj.offsetY ? obj.offsetY : 100,
                children: childern,
                zOrder: (obj.zOrder || obj.zOrder === 0) ? obj.zOrder : -1,
                fillColor: "transparent",
                labels: [{ mode: ej.datavisualization.Diagram.LabelEditMode.View }],
                container: { type: ej.datavisualization.Diagram.ContainerType.Canvas, },
                minHeight: cH ? cH : 100,
                maxHeight: obj.maxHeight ? obj.maxHeight : Number.POSITIVE_INFINITY,
                minWidth: cW ? cW : 100,
                maxWidth: obj.maxWidth ? obj.maxWidth : Number.POSITIVE_INFINITY,
                constraints: obj.constraints ? obj.constraints | ej.datavisualization.Diagram.NodeConstraints.AllowDrop : (ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.AllowDrop ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorth ^
                    ej.datavisualization.Diagram.NodeConstraints.ResizeWest ^ ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest ^
                    ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast ^ ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest),
                phaseSize: seprtrValue,
                cssClass: obj.cssClass
            });
            //diagram._setZorder(canvas);
            canvas.isSwimlane = true;
            //this.nodes().push(canvas);
            canvas.phases = phases;
            canvas.orientation = obj.orientation;
            if (canvas.orientation == "horizontal")
                canvas.constraints = canvas.constraints ^ ej.datavisualization.Diagram.NodeConstraints.ResizeEast ^ ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast;
            else
                canvas.constraints = canvas.constraints ^ ej.datavisualization.Diagram.NodeConstraints.ResizeSouth ^ ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast;
            return canvas;
        },
        _initPhaseStack: function (obj, diagram, children, seprtrValue) {
            var orientation = "horizontal", horizontalAlign = "left", verticalAlign = "top", isHoizon;
            if (orientation) {
                if (obj.orientation == "horizontal") {
                    orientation = "horizontal";
                    horizontalAlign = "stretch";
                    isHoizon = true;
                }
                else {
                    orientation = "vertical";
                    verticalAlign = "stretch";
                    isHoizon = false;
                }
            }
            var phaseStack = ej.datavisualization.Diagram.Group({
                name: obj.name + "phaseStack",
                container: { type: "stack", orientation: orientation },
                type: "group",
                parent: obj.name,
                offsetX: 0,
                offsetY: 0,
                minHeight: seprtrValue,
                maxHeight: seprtrValue,
                minWidth: seprtrValue,
                maxWidth: seprtrValue,
                marginTop: obj.header ? obj.header.height : 50,
                isPhaseStack: true,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect
                //horizontalAlign: horizontalAlign,
                //verticalAlign: verticalAlign,
            });
            var df = 0;
            var rotateAngle = 0;
            if (obj.phaseSize) {
                obj.phaseSize = obj.phaseSize < 1 ? 20 : obj.phaseSize;
            }
            var height, width;
            for (var i = 0; i < obj.phases.length; i++) {
                if (isHoizon) {
                    height = obj.phaseSize ? obj.phaseSize : 20;
                    width = obj.phases[i].offset - df;
                }
                else {
                    height = obj.phases[i].offset - df;
                    if (i == 0)
                        height = height - (obj.header ? obj.header.height : 50);//added swimlane header height
                    width = obj.phaseSize ? obj.phaseSize : 20;
                    if (obj.phases[i].label)
                        obj.phases[i].label.rotateAngle = 270;
                }
                var node = ej.datavisualization.Diagram.Node({
                    parent: obj.name + "phaseStack",
                    _isHeader: true,
                    name: "phaseStack" + obj.phases[i].name,
                    height: height, width: width,
                    labels: [obj.phases[i].label],
                    constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect
                });
                node.labels[0].name = "phaseStack" + obj.phases[i].name + "label",
                    node.labels[0].mode = ej.datavisualization.Diagram.LabelEditMode.View,
                    node.isPhase = true;
                df = obj.phases[i].offset;
                diagram.nameTable[node.name] = node;
                phaseStack.children.push(node.name);
                diagram.nodes().push(node);
                diagram._nodes = $.extend(true, [], diagram.nodes());
            }
            diagram.nodes().push(phaseStack);
            diagram._nodes = $.extend(true, [], diagram.nodes());
            children.push(phaseStack);
            diagram.nameTable[phaseStack.name] = phaseStack;
        },

        _setDefaultLaneProperties: function (obj) {
            obj.lanes = obj.lanes ? obj.lanes : [];
            obj.lanes.push(ej.datavisualization.Diagram.Lane({}))
        },

        _initLanes: function (obj, diagram, headAdded) {
            var lanes = [], lane = null;
            if (!obj.lanes || obj.lanes.length === 0) {
                this._setDefaultLaneProperties(obj);
            }
            if (obj.lanes) {
                for (var i = 0; i < obj.lanes.length; i++) {
                    if (jQuery.isEmptyObject(obj.lanes[i])) {
                        obj.lanes[i] = ej.datavisualization.Diagram.Lane();
                    }
                    obj.lanes[i]._laneHeader = obj.lanes[i]._laneHeader ? obj.lanes[i]._laneHeader : obj.lanes[i].header
                    lane = this._initLane(obj.lanes[i], obj, diagram, headAdded);
                    lanes.push(lane.name);
                    diagram.nodes().push(lane);
                    diagram._nodes = $.extend(true, [], diagram.nodes());
                    diagram.nameTable[lane.name] = lane;
                }
            }
            return lanes;
        },
        _initLane: function (laneobj, obj, diagram, headAdded) {
            var hAlign = null, vAlign = null;
            if (obj.orientation == "horizontal")
                hAlign = "stretch";
            else vAlign = "stretch";
            var success = false;
            var lane = ej.datavisualization.Diagram.Group({
                name: laneobj.name,
                addInfo: laneobj.addInfo ? laneobj.addInfo : {},
                type: "group",
                isLane: true,
                parent: obj.name + "_stack",
                offsetX: 0,
                offsetY: 0,
                borderColor: laneobj.borderColor ? laneobj.borderColor : "black",
                orientation: obj.orientation ? obj.orientation : "horizontal",
                fillColor: laneobj.fillColor,
                container: { type: ej.datavisualization.Diagram.ContainerType.Canvas, },
                horizontalAlign: hAlign ? hAlign : "left",
                verticalAlign: vAlign ? vAlign : "top",
                minHeight: laneobj.height ? laneobj.height : 100,
                maxHeight: laneobj.maxHeight ? laneobj.maxHeight : Number.POSITIVE_INFINITY,
                minWidth: laneobj.width ? laneobj.width : 100,
                maxWidth: laneobj.maxWidth ? laneobj.maxWidth : Number.POSITIVE_INFINITY,
                paddingTop: 20,
                paddingRight: 20,
                paddingBottom: 20,
                paddingLeft: 20,
                constraints: laneobj.constraints ? laneobj.constraints | ej.datavisualization.Diagram.NodeConstraints.AllowDrop : (ej.datavisualization.Diagram.NodeConstraints.Default | ej.datavisualization.Diagram.NodeConstraints.AllowDrop & ~ej.datavisualization.Diagram.NodeConstraints.Connect),
                cssClass: laneobj.cssClass
            });
            if (laneobj.labels && laneobj.labels.length > 0) {
                for (var h = 0; h < laneobj.labels.length; h++) {
                    laneobj.labels[h] = ej.datavisualization.Diagram.Label(laneobj.labels[h]);
                }
                lane.labels = laneobj.labels;
            }
            if (!headAdded) {
                var laneHeader = laneobj._laneHeader ? laneobj._laneHeader : null;
                var header = this._iniLaneHeader(laneobj, lane.name, obj, diagram, laneHeader);
                if (header) {
                    diagram.nodes().push(header);
                    diagram._nodes = $.extend(true, [], diagram.nodes());
                    diagram.nameTable[header.name] = header;
                    lane.children.push(header.name);
                }
            }
            var laneChildren;
            laneChildren = this._initChildren(laneobj, lane.name, diagram);
            for (var i = 0; i < laneChildren.length; i++) {
                lane.children.push(laneChildren[i]);
            }

            return lane;
        },
        _iniLaneHeader: function (headObj, parentName, obj, diagram, laneHeader) {
            var node = null;
            if (headObj.header) {
                node = ej.datavisualization.Diagram.Node({
                    _isHeader: true,
                    name: parentName + "_Headerr_",
                    type: "node",
                    labels: [obj.header],
                    height: laneHeader.height ? laneHeader.height : 50,
                    width: laneHeader.width ? laneHeader.width : 50,
                    fillColor: headObj.header.fillColor ? headObj.header.fillColor : "white",
                    rotateAngle: 0,
                    constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
                    marginLeft: -20,
                    marginTop: -20,
                    marginRight: -20,
                    marginBottom: -20,
                    parent: parentName,
                });
                if (obj.orientation && obj.orientation == "horizontal") {
                    node.verticalAlign = "stretch";
                    node.height = 1;
                    node.width = laneHeader.width ? laneHeader.width : 50;
                }
                else if (obj.orientation && obj.orientation == "vertical") {
                    node.horizontalAlign = "stretch";
                    node.labels[0].rotateAngle = 0;
                    node.height = laneHeader.width ? laneHeader.width : 50;
                    node.width = 1;
                }
            }
            return node;
        },
        _initChildren: function (laneObj, parentName, diagram) {
            var children = [], child = null;
            if (laneObj.children) {
                for (var i = 0; i < laneObj.children.length; i++) {
                    if (typeof laneObj.children[i] == "object") {
                        if (laneObj.type && laneObj.type === "bpmn")
                            child = laneObj.children[i]
                        else
                            child = this._initChild(laneObj.children[i], parentName, diagram);
                    }
                    else
                        child = diagram.nameTable[diagram._getChild(laneObj.children[i])];
                    if (child) {
                        if (!child.segments) {
                            if (child.children)
                                var childNodes = this._initChildren(child, child.name, diagram);
                            if (childNodes) child.children = childNodes;
                            diagram.nodes().push(child);
                            diagram._nodes = $.extend(true, [], diagram.nodes());
                        }
                        else {
                            diagram.connectors().push(child);
                            diagram._connectors = $.extend(true, [], diagram.connectors());
                        }
                        children.push(child.name);
                        diagram.nameTable[child.name] = child;
                    }
                }
            }
            return children;
        },
        _initChild: function (child, parentName, diagram) {
            var node = null;
            if (child && child.children && child.children.length > 0) {
                node = diagram._getNewGroup(ej.datavisualization.Diagram.NodeType(child, diagram))
            }
            else
                node = diagram._getNewNode(ej.datavisualization.Diagram.NodeType(child, diagram));
            node.parent = parentName;
            return node;
        },
        _swapPhaseSize: function (obj) {
            if (obj.phases.length > 0) {
                var phases = obj.phases, i, j, temp;
                for (i = 0; i < phases.length; i++) {
                    for (j = 0; j < (phases.length - i - 1); j++) {
                        if (phases[j].offset > phases[j + 1].offset) {
                            temp = phases[j];
                            phases[j] = phases[j + 1];
                            phases[j + 1] = temp;
                        }
                    }
                }
            }
        },
        _setSwimlaneSize: function (obj) {
            if (obj.phases.length > 0) {
                var phase;
                for (var i in obj.phases) {
                    phase = obj.phases[i];
                    if (obj.orientation === "horizontal") {
                        if (phase.offset > obj.width)
                            obj.width = phase.offset;
                    }
                    else {
                        if (phase.offset > obj.height)
                            obj.height = phase.offset;
                    }
                }
            }
        },
        _setLastPhaseSize: function (obj) {
            if (obj.phases.length > 0) {
                var lastPhase = obj.phases[obj.phases.length - 1];
                if (obj.orientation === "horizontal")
                    lastPhase.offset = obj.width;
                else
                    lastPhase.offset = obj.height;
            }
        },
        _NeedDefaultPhase: function (obj, offset) {
            if (obj.phases.length > 0)
                return false;
            return true;
        },
        _checkForDefPhase: function (obj) {
            if (obj.phases.length > 0)
                return false;
            return true;
        },
        _initphases: function (obj, diagram) {
            var phases = [];
            var phase = null, angle = 0;
            //if (!diagram.model.phases)
            //    diagram.model.phases = [];
            var offset = 0;

            if (obj.orientation === "vertical") {
                offset = obj.height;
                angle = 270;
            }
            else {
                offset = obj.width;
            }
            var defPhase = ej.datavisualization.Diagram.Phase({ name: obj.name + "defPhase", offset: offset, label: obj._lastPhase ? obj._lastPhase.labels[0] : { text: "Phase", rotateAngle: angle } });
            if (this._NeedDefaultPhase(obj))
                obj.phases.push(defPhase);
            else {
                this._swapPhaseSize(obj);
                this._setSwimlaneSize(obj);
                this._setLastPhaseSize(obj);
            }
            if (obj.phases && obj.phases.length > 0) {
                for (var i = 0; i < obj.phases.length; i++) {
                    phase = ej.datavisualization.Diagram.Phase(obj.phases[i]);
                    phase.parent = obj.name;
                    phase.orientation = obj.orientation;
                    //diagram.model.phases.push(phase);
                    diagram.nameTable[phase.name] = phase;
                    phases.push(phase.name);
                }
            }
            return phases;
        },
        //#endregion
        //#region palette
        _createSwimlane: function (obj, diagram, data, fromObject, header) { 
            var children = [], child = null, headAdded = false;
            var nameTable = data ? data.childTable : diagram.nameTable;
            var height = 500, width = 500;
            var headNode = null;
            var constraints = obj.constraints ? obj.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
            if (obj.children[0]) {
                var node = fromObject ? obj.children[0] : nameTable[diagram._getChild(obj.children[0])];
                if (!node)
                    node = header;
                if (typeof (node) === "string")
                    node = nameTable[node];
                headNode = { text: "Title", width: 50, fillColor: node.fillColor ? node.fillColor : obj.fillColor, height: 50 };

            } else headNode = { text: "Title", width: 50, fillColor: "white", height: 50 };

            if (!obj.orientation) {
                if (obj.container)
                    obj.orientation = obj.container.orientation;
            }
            var swlnHeight = 0;
            if (obj.orientation == "horizontal" && diagram._selectedSymbol) {
                height = obj.height ? obj.height : 100;
                width = obj.width ? obj.width : 650;
                swlnHeight = height;
            } else {
                height = obj.height ? obj.height : 650;
                width = obj.width ? obj.width : 100;
                swlnHeight = obj.height + headNode.height
            }
            if (obj.children.length > 1) {
                obj.children.splice(0, 1);
                children = obj.children;
            }

            var nSwimLane = {
                name: obj.name + ej.datavisualization.Diagram.Util.randomId(),
                header: headNode,
                fillColor: "white",
                isSwimlane: true,
                minWidth: width,
                minHeight: height,
                height: swlnHeight + 1,
                width: width + 1,
                maxHeight: height + Number.POSITIVE_INFINITY,
                maxWidth: width + Number.POSITIVE_INFINITY,
                offsetX: obj.offsetX,
                offsetY: obj.offsetY,
                orientation: obj.orientation ? obj.orientation : "horizontal",
                addInfo: obj.addInfo ? obj.addInfo : null,
                paletteItem: obj.paletteItem ? obj.paletteItem : null,
                lanes: [
                    {
                        name: obj.name,
                        addInfo: obj.addInfo ? obj.addInfo : {},
                        constraints: constraints,
                        header: {
                            text: (node.labels[0].text || node.labels[0].text === "") ? node.labels[0].text : "HEADER",
                            fontSize: node.labels[0].fontSize ? node.labels[0].fontSize : 11,
                            width: node.width ? node.width : 50,
                            height: node.height ? node.height : 50,
                            fillColor: node.fillColor,
                            bold: node.labels[0].bold ? true : false,
                            italic: node.labels[0].italic ? true : false,
                            fontFamily: node.labels[0].fontFamily ? node.labels[0].fontFamily : "Arial",
                            fontColor: node.labels[0].fontColor ? node.labels[0].fontColor : "black",
                        },
                        fillColor: obj.fillColor ? obj.fillColor : "white",
                        height: height,
                        width: width,
                        minHeight: height,
                        minWidth: width,
                        children: children ? children : [],
                        _laneHeader: obj._laneHeader ? obj._laneHeader : null
                    },
                ]
            };
            //var item = this._initSwimLane(ej.datavisualization.Diagram.SwimLane(nSwimLane), diagram, headAdded);
            var item = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, nSwimLane);
            return item;
        },
        _createDiagramLane: function (obj, nameTable) {
            var objLane = obj._lane ? obj._lane : null;
            var orientation = obj.orientation;
            var constraints = obj.constraints ? obj.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
            var lane = {
                children: [
                    {
                        name: obj.name + "_Headerr_",
                        height: objLane.header ? objLane.header.height : 50,
                        width: objLane.header ? objLane.header.width : 50,
                        fillColor: objLane.header ? objLane.header.fillColor : 50,
                        labels: objLane.header ? [objLane.header] : [],
                        horizontalAlign: orientation === "vertical" ? "stretch" : "left",
                        verticalAlign: orientation === "vertical" ? "top" : "stretch",
                    }
                ],
                container: { type: "canvas" },
                name: obj.name ? obj.name : ej.datavisualization.Diagram.Util.randomId(),
                minHeight: objLane.minHeight ? objLane.minHeight : 100,
                minWidth: objLane.minWidth ? objLane.minWidth : 100,
                maxHeight: Number.POSITIVE_INFINITY,
                maxWidth: Number.POSITIVE_INFINITY,
                borderColor: "black",
                constraints: constraints | ej.datavisualization.Diagram.NodeConstraints.AllowDrop & ~ej.datavisualization.Diagram.NodeConstraints.Connect,
                cssClass: objLane.cssClass ? objLane.cssClass : "",
                addInfo: objLane.addInfo ? objLane.addInfo : null,
                paletteItem: obj.paletteItem ? obj.paletteItem : null,
                fillColor: objLane.fillColor ? objLane.fillColor : "white",
                isLane: true,
                offsetX: obj.offsetX ? obj.offsetX : 100,
                offsetY: obj.offsetY ? obj.offsetY : 100,
                orientation: orientation ? orientation : "horizontal"
            };
            lane.children[0].labels[0].rotateAngle = orientation === "horizontal" ? 270 : 0;
            return lane;
        },
        _createPaletteLane: function (obj, nameTable) {
            var height = 0, width = 0, offsetX = 0, offsetY = 0, rotateAngle = 0, mleft = 0, mTop = 0, align = "left";
            var offx = 0, offY = 0;
            obj = ej.datavisualization.Diagram.Lane(obj);
            var constraints = obj.constraints ? obj.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
            if (obj.paletteItem && !obj.paletteItem.enableScale && !obj.paletteItem.width) {
                if (obj.orientation === "horizontal") {
                    offx += 2;
                }
            }
            if (obj.orientation == "horizontal") {
                height = obj.height ? obj.height : 50;
                width = 25;
                offsetX = 14 + offx;
                offsetY = height / 2 + 1;
                rotateAngle = 270;
                align = "left";
            }
            else if (obj.orientation == "vertical") {
                height = 25;
                width = obj.width ? obj.width : 50;
                offsetX = width / 2;
                offsetY = 15;
                align = "left";
            }
            var name = obj.header.text ? obj.header.text : "";
            var header = ej.datavisualization.Diagram.Node({
                name: obj.name + "_" + name,
                _type: "node",
                labels: [
                    { text: obj.header.text ? obj.header.text : "Function", fontSize: obj.header.fontSize ? obj.header.fontSize : 11, offset: { x: 0.5, y: .5 }, width: 100, rotateAngle: rotateAngle, }
                ],
                height: height,
                width: width,
                fillColor: obj.header.fillColor ? obj.header.fillColor : "white",
                //constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select,
                parent: obj.name,
                offsetX: offsetX,
                offsetY: offsetY,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
            });
            nameTable[header.name] = header;
            if (obj.orientation == "horizontal") {
                height = obj.height;
                width = obj.width - 25;
                offsetX = 25 + width / 2 + offx;
                offsetY = height / 2 + 1;
            }
            else if (obj.orientation == "vertical") {
                height = obj.height - 25;
                width = obj.width;
                offsetX = width / 2;
                offsetY = 25 + height / 2;
            }
            var content = ej.datavisualization.Diagram.Node({
                name: obj.name + "content",
                _type: "node",
                height: height,
                width: width,
                fillColor: obj.fillColor ? obj.fillColor : "white",
                //constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select,
                parent: obj.name,
                offsetX: offsetX,
                offsetY: offsetY,
            });
            content._laneHeader = obj.header;
            nameTable[content.name] = content;
            var group = ej.datavisualization.Diagram.Group({
                name: obj.name + "_group",
                addInfo: obj.addInfo ? obj.addInfo : {},
                height: obj.height,
                width: obj.width,
                header: obj.header ? obj.header : null,
                offsetX: obj.offsetX,
                offsetY: obj.offsetY,
                children: [header.name, content.name,],
                paletteItem: obj.paletteItem ? obj.paletteItem : null,
            });
            group._lane = obj;
            group.constraints = constraints;
            group.isLane = true;
            group.orientation = obj.orientation;
            return group;
        },
        //#endregion
        //#region Map swimlane
        _mapObject: function (diagram, node, type, childTable) {
            var obj;
            switch (type) {
                case "lane":
                    obj = this._mapLane(diagram, node);
                    break;
                case "phase":
                    obj = this._mapPhase(diagram, node);
                    break;
                case "swimlane":
                    obj = this._mapSwimlane(diagram, node, childTable);
                    break;
            }
            return obj;
        },
        //#region for mapping the Lane
        _mapLane: function (diagram, lane, childTable) {
            var nLane = ej.datavisualization.Diagram.Lane();
            this._mapLaneHeader(diagram, lane, nLane, childTable);
            this._mapChildren(diagram, lane, nLane, childTable);
            nLane.name = lane.name;
            nLane.labels = lane.labels;
            nLane.fillColor = lane.fillColor;
            nLane.orientation = lane.orientation;
            nLane.maxHeight = lane.maxHeight;
            nLane.maxWidth = lane.maxWidth;
            nLane.minHeight = lane.height > lane.minHeight ? lane.height : lane.minHeight;
            nLane.minWidth = lane.width > lane.minWidth ? lane.width : lane.minWidth;
            nLane.constraints = lane.constraints;
            nLane.addInfo = lane.addInfo ? lane.addInfo : {};
            if (lane.orientation === "horizontal") {
                nLane.height = lane.height;
                nLane.width = null;
            }
            else {
                nLane.height = null;
                nLane.width = lane.width;
            }
            return nLane;
        },
        _mapLaneHeader: function (diagram, orgobj, clObj, childTable) {
            if (orgobj.children[0])
                var head = diagram.nameTable[diagram._getChild(orgobj.children[0])];
            if (!head && childTable)
                var head = childTable[diagram._getChild(orgobj.children[0])];
            if (head) {
                //clObj.header.name = head.name;
                if (head.labels && head.labels[0]) {
                    if (head.name)
                        clObj.header.name = head.name;
                    clObj.header.text = head.labels[0].text;
                    clObj.header.fontColor = head.labels[0].fontColor;
                    clObj.header.fontSize = head.labels[0].fontSize;
                    clObj.header.fontFamily = head.labels[0].fontFamily;
                    clObj.header.bold = head.labels[0].bold;
                    clObj.header.italic = head.labels[0].italic;
                    clObj.header.textDecoration = head.labels[0].textDecoration;
                    clObj.header.rotateAngle = head.labels[0].rotateAngle;
                    clObj.header.textOverflow = head.labels[0].textOverflow;
                    clObj.header.overflowType = head.labels[0].overflowType;
                    if (head.labels[0].name) {
                        clObj.header._labelName = head.labels[0].name;
                    }
                }
                clObj.header.fillColor = head.fillColor;
                if (orgobj.orientation === "vertical") {
                    clObj.header.height = head.height;
                    clObj.header.width = null;
                }
                else {
                    clObj.header.height = null;
                    clObj.header.width = head.width;
                }
            }
        },
        _mapChildren: function (diagram, orgobj, clObj, childTable) {
            var child;
            if (orgobj.children && orgobj.children.length >= 2) {
                for (var i = 1; i < orgobj.children.length; i++) {
                    if (diagram._getChild(orgobj.children[i]))
                        child = diagram.nameTable[diagram._getChild(orgobj.children[i])];
                    if (childTable && !child)
                        child = childTable[diagram._getChild(orgobj.children[i])];
                    if (child) {
                        child.marginRight = 0;
                        child.marginBottom = 0;
                        clObj.children.push(child);
                    }
                }
            }
        },
        //#endregion 
        //#region for mapping the swimlane
        _mapSwimlane: function (diagram, swimlane, childTable) {
            var nSwimlane = ej.datavisualization.Diagram.SwimLane();
            this._mapSwimlaneHeader(diagram, swimlane, nSwimlane, childTable);
            this._mapLanes(diagram, swimlane, nSwimlane, childTable);
            this._mapPhases(diagram, swimlane, nSwimlane, childTable);
            nSwimlane.name = swimlane.name;
            nSwimlane.orientation = swimlane.orientation;
            nSwimlane.offsetX = swimlane.offsetX;
            nSwimlane.offsetY = swimlane.offsetY;
            nSwimlane.maxHeight = swimlane.maxHeight;
            nSwimlane.maxWidth = swimlane.maxWidth;
            nSwimlane.minHeight = swimlane.minHeight;
            nSwimlane.minWidth = swimlane.minWidth;
            if (nSwimlane.orientation === "horizontal")
                nSwimlane.minWidth = (swimlane.width && swimlane.minWidth && swimlane.width > swimlane.minWidth) ? swimlane.width : swimlane.minWidth;
            else
                nSwimlane.minWidth = swimlane.minWidth;
            nSwimlane.phaseSize = swimlane.phaseSize;
            nSwimlane.constraints = swimlane.constraints;
            nSwimlane.zOrder = swimlane.zOrder;
            nSwimlane.addInfo = swimlane.addInfo ? swimlane.addInfo : {};
            nSwimlane.height = swimlane.height;
            nSwimlane.width = swimlane.width;
            return nSwimlane;
        },
        _mapSwimlaneHeader: function (diagram, orgobj, clObj, childTable) {
            if (orgobj.children[0])
                var head = diagram.nameTable[diagram._getChild(orgobj.children[0])];
            if (!head && childTable)
                head = childTable[diagram._getChild(orgobj.children[0])];
            if (head) {
                if (head.labels && head.labels[0]) {
                    clObj.header.text = head.labels[0].text
                    clObj.header.fontColor = head.labels[0].fontColor
                    clObj.header.fontSize = head.labels[0].fontSize
                    clObj.header.fontFamily = head.labels[0].fontFamily
                    clObj.header.bold = head.labels[0].bold
                    clObj.header.italic = head.labels[0].italic
                    clObj.header.textDecoration = head.labels[0].textDecoration
                    clObj.header.textOverflow = head.labels[0].textOverflow
                    clObj.header.overflowType = head.labels[0].overflowType
                }
                clObj.header.fillColor = head.fillColor;
                clObj.header.height = head.height;
                clObj.header.width = head.width;
            }
        },
        _mapLanes: function (diagram, orgobj, clObj, childTable) {
            var laneStack, lane, nLane;
            if (orgobj.children[2] && diagram._getChild(orgobj.children[2]))
                laneStack = childTable ? childTable[diagram._getChild(orgobj.children[2])] : diagram.nameTable[diagram._getChild(orgobj.children[2])];
            if (laneStack && laneStack.children && laneStack.children.length > 0) {
                for (var i = 0; i < laneStack.children.length; i++) {
                    if (diagram._getChild(laneStack.children[i]))
                        lane = childTable ? childTable[diagram._getChild(laneStack.children[i])] : diagram.nameTable[diagram._getChild(laneStack.children[i])];
                    if (lane) {
                        nLane = this._mapLane(diagram, lane, childTable);
                        if (nLane) clObj.lanes.push(nLane);
                    }
                }

            }
        },
        _mapPhases: function (diagram, orgobj, clObj, childTable) {
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, orgobj, childTable);
            if (phases && phases.length > 0) {
                var length = phases.length;
                var nameTable = childTable ? childTable : diagram.nameTable;
                if (phases[phases.length - 1] && nameTable[phases[phases.length - 1]]) {
                    var lstPhse = nameTable[phases[phases.length - 1]];
                    if (!(lstPhse.name.split("defPhase").length > 1) && (lstPhse.offset != orgobj.width))
                        length++;
                }
                for (var i = 0; i < length; i++) {
                    var cphase = this._mapPhase(diagram, nameTable[diagram._getChild(phases[i])], childTable);
                    if (cphase) {
                        clObj.phases.push(cphase);
                    }
                }
                if (nameTable["phaseStack" + phases[phases.length - 1]])
                    clObj._lastPhase = this._mapPhase(diagram, nameTable["phaseStack" + phases[phases.length - 1]], childTable);
            }
        },
        //#endregion 
        //#region for mapping the Phase
        _mapPhase: function (diagram, phase, childTable) {
            var cphase;
            if (phase)
                cphase = childTable ? childTable[phase.name] : diagram.nameTable[phase.name];
            if (cphase)
                return cphase;
            else return null;
        },
        _getSwimLaneNode: function (node, selNode, isPhase, diagram) {
            if (node.isSwimlane) {
                if (isPhase) {
                    if (diagram.nameTable[diagram._getChild(node.children[2])].container.orientation == selNode.orientation)
                        return node;
                }
                else if (diagram.nameTable[diagram._getChild(node.children[2])].container.orientation != selNode.orientation)
                    return node;
            }
            if (node.parent) {
                var parent = diagram.nameTable[node.parent];
                if (parent) {
                    return this._getSwimLaneNode(parent, selNode, undefined, diagram);
                }
            }
            return null;
        }
        //#endregion 
        //#endregion 
    };
})(jQuery, Syncfusion);

;
/**
* @fileOverview Plugin to style the Html Button elements
* @copyright Copyright Syncfusion Inc. 2001 - 2020. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej) {
    "use strict";
    ej.datavisualization.Diagram.BasicShapes = {
        Rectangle: "rectangle",
        Ellipse: "ellipse",
        Path: "path",
        Polygon: "polygon",
        Triangle: "triangle",
        Plus: "plus",
        Star: "star",
        Pentagon: "pentagon",
        Heptagon: "heptagon",
        Octagon: "octagon",
        Trapezoid: "trapezoid",
        Decagon: "decagon",
        RightTriangle: "righttriangle",
        Cylinder: "cylinder"
    };
    ej.datavisualization.Diagram.FlowShapes = {
        Process: "process",
        Decision: "decision",
        Document: "document",
        PreDefinedProcess: "predefinedprocess",
        Terminator: "terminator",
        PaperTap: "papertap",
        DirectData: "directdata",
        SequentialData: "sequentialdata",
        Sort: "sort",
        MultiDocument: "multidocument",
        Collate: "collate",
        SummingJunction: "summingjunction",
        Or: "or",
        InternalStorage: "internalstorage",
        Extract: "extract",
        ManualOperation: "manualoperation",
        Merge: "merge",
        OffPageReference: "offpagereference",
        SequentialAccessStorage: "sequentialaccessstorage",
        Annotation1: "annotation1",
        Annotation2: "annotation2",
        Data: "data",
        Card: "card"
    };
    ej.datavisualization.Diagram.ArrowShapes = {
        None: "none",
        CircularArrow: "circulararrow",
        CurvedRightArrow: "curvedrightarrow",
        CurvedUpArrow: "curveduparrow",
        CurvedLeftArrow: "curvedleftarrow",
        CurvedDownArrow: "curveddownarrow",
        JumpingRightArrow: "jumpingrightarrow",
        JumpingLeftArrow: "jumpingleftarrow"
    };
    ej.datavisualization.Diagram.BPMNShapes = {
        Event: "event",
        Gateway: "gateway",
        Message: "message",
        DataObject: "dataobject",
        DataSource: "datasource",
        Activity: "activity",
        Group: "group"
    };

    ej.datavisualization.Diagram.BPMNEvents = {
        Start: "start",
        Intermediate: "intermediate",
        End: "end",
        NonInterruptingStart: "noninterruptingstart",
        NonInterruptingIntermediate: "noninterruptingintermediate",
        ThrowingIntermediate: "throwingintermediate"
    };

    ej.datavisualization.Diagram.BPMNTriggers = {
        None: "none",
        Message: "message",
        Timer: "timer",
        Escalation: "escalation",
        Link: "link",
        Error: "error",
        Compensation: "compensation",
        Signal: "signal",
        Multiple: "multiple",
        Parallel: "parallel",
        Cancel: "cancel",
        Conditional: "conditional",
        Terminate: "terminate"
    };

    ej.datavisualization.Diagram.BPMNGateways = {
        None: "none",
        Exclusive: "exclusive",
        Inclusive: "inclusive",
        Parallel: "parallel",
        Complex: "complex",
        EventBased: "eventbased",
        ExclusiveEventBased: "exclusiveeventbased",
        ParallelEventBased: "paralleleventbased",
    };

    ej.datavisualization.Diagram.BPMNDataObjects = {
        None: "none",
        Input: "input",
        Output: "output",
    };

    ej.datavisualization.Diagram.BPMNActivity = {
        None: "none",
        Task: "task",
        SubProcess: "subprocess",
    };

    ej.datavisualization.Diagram.BPMNLoops = {
        None: "none",
        Standard: "standard",
        ParallelMultiInstance: "parallelmultiinstance",
        SequenceMultiInstance: "sequencemultiinstance"
    };
    ej.datavisualization.Diagram.BPMNTasks = {
        None: "none",
        Service: "service",
        Receive: "receive",
        Send: "send",
        InstantiatingReceive: "instantiatingreceive",
        Manual: "manual",
        BusinessRule: "businessrule",
        User: "user",
        Script: "script",
        Parallel: "parallel",
    };

    ej.datavisualization.Diagram.BPMNSubProcessTypes = {
        None: "none",
        Transaction: "transaction",
        Event: "event"
    };

    ej.datavisualization.Diagram.BPMNBoundary = {
        Default: "default",
        Call: "call",
        Event: "event",
    };
    ej.datavisualization.Diagram.BPMNAnnotationDirections = {
        Top: "top",
        Left: "left",
        Right: "right",
        Bottom: "bottom"
    };
    ej.datavisualization.Diagram.BPMNFlows = {
        Sequence: "sequence",
        Association: "association",
        Message: "message"
    };
    ej.datavisualization.Diagram.BPMNSequenceFlows = {
        Normal: "normal",
        Conditional: "conditional",
        Default: "default"
    };
    ej.datavisualization.Diagram.BPMNMessageFlows = {
        Default: "default",
        InitiatingMessage: "initiatingmessage",
        NonInitiatingMessage: "noninitiatingmessage"
    };
    ej.datavisualization.Diagram.ClassifierShapes = {
        Package: "package",
        Class: "class",
        Interface: "interface",
        Enumeration: "enumeration",
        CollapsedPackage: "collapsedpackage",
        Inheritance: "inheritance",
        Association: "association",
        Aggregation: "aggregation",
        Composition: "composition",
        Realization: "realization",
        DirectedAssociation: "directedassociation",
        Dependency: "dependency"
    };
    ej.datavisualization.Diagram.AssociationFlows = {
        Default: "default",
        Directional: "directional",
        BiDirectional: "bidirectional"
    };
    ej.datavisualization.Diagram.UMLActivityShapes = {
        Action: "action",
        Decision: "decision",
        MergeNode: "mergenode",
        InitialNode: "initialnode",
        FinalNode: "finalnode",
        ForkNode: "forknode",
        JoinNode: "joinnode",
        TimeEvent: "timeevent",
        AcceptingEvent: "acceptingevent",
        SendSignal: "sendsignal",
        ReceiveSignal: "receivesignal",
        StructuredNode: "structurednode",
        Note: "note"
    };
    ej.datavisualization.Diagram.UMLActivityFlow = {
        Object: "object",
        Control: "control",
        Exception: "exception"
    };
    ej.datavisualization.Diagram.BPMNEventDefaults = {
        event: ej.datavisualization.Diagram.BPMNEvents.Start,
        trigger: ej.datavisualization.Diagram.BPMNTriggers.None,
        name: null,
        offset: ej.datavisualization.Diagram.Point(),
        ports: [],
        labels: []
    };
    ej.datavisualization.Diagram.BPMNGatewayDefaults = {
        gateway: ej.datavisualization.Diagram.BPMNGateways.None,
    };
    ej.datavisualization.Diagram.BPMNDataObject = function (options) {
        return $.extend(false, {}, { type: ej.datavisualization.Diagram.BPMNDataObjects.None, collection: false }, options);
    };
    ej.datavisualization.Diagram.BPMNDataObjectDefaults = {
        data: ej.datavisualization.Diagram.BPMNDataObject()
    };
    ej.datavisualization.Diagram.BPMNTaskDefaults = {
        loop: ej.datavisualization.Diagram.BPMNLoops.None,
        type: ej.datavisualization.Diagram.BPMNTasks.None,
        call: false,
        compensation: false,
        events: []
    };
    ej.datavisualization.Diagram.BPMNTask = function (options) {
        if (options)
            options.events = options.events ? options.events.slice() : [];
        return $.extend(false, {}, ej.datavisualization.Diagram.BPMNTaskDefaults, options);
    };
    ej.datavisualization.Diagram.BPMNSubProcessDefaults = {
        type: ej.datavisualization.Diagram.BPMNSubProcessTypes.None,
        event: ej.datavisualization.Diagram.BPMNEvents.Start,
        trigger: ej.datavisualization.Diagram.BPMNTriggers.Message,
        boundary: ej.datavisualization.Diagram.BPMNBoundary.Default,
        loop: ej.datavisualization.Diagram.BPMNLoops.None,
        adhoc: false,
        compensation: false,
        collapsed: true,
        events: [],
        processes: []
    };
    ej.datavisualization.Diagram.BPMNSubProcess = function (options) {
        options = options || {};
        options.events = options.events ? options.events.slice() : [];
        options.processes = options.processes ? options.processes.slice() : [];
        return $.extend(false, {}, ej.datavisualization.Diagram.BPMNSubProcessDefaults, options);
    };
    ej.datavisualization.Diagram.BPMNActivityDefaults = {
        activity: ej.datavisualization.Diagram.BPMNActivity.Task,
        task: ej.datavisualization.Diagram.BPMNTask(),
        subProcess: ej.datavisualization.Diagram.BPMNSubProcess(),
    };
    ej.datavisualization.Diagram.BPMNTextAnnotationDefaults = {
        annotation: {
            width: 20, height: 20, angle: 0, length: 0, text: "",
            direction: ej.datavisualization.Diagram.BPMNAnnotationDirections.Left,
        }
    };
    ej.datavisualization.Diagram.ConnectorShapeDefaults = {
        type: "bpmn",
        flow: ej.datavisualization.Diagram.BPMNFlows.Sequence,
        sequence: ej.datavisualization.Diagram.BPMNSequenceFlows.Normal,
        association: ej.datavisualization.Diagram.AssociationFlows.Default,
        message: ej.datavisualization.Diagram.BPMNMessageFlows.Default
    };
    ej.datavisualization.Diagram.Multiplicity = {
        OneToOne: "onetoone",
        OneToMany: "onetomany",
        ManyToOne: "manytoone",
        ManyToMany: "manytomany"
    };
    ej.datavisualization.Diagram.ClassifierMultiplicityDefault = {
        type: ej.datavisualization.Diagram.Multiplicity.OneToOne,
        source: {
            optional: true,
            lowerBounds: null,
            upperBounds: null
        },
        target: {
            optional: true,
            lowerBounds: null,
            upperBounds: null
        }
    };
    ej.datavisualization.Diagram.UMLActivityFlowDefaults = {
        type: "umlactivity",
        activityFlow: ej.datavisualization.Diagram.UMLActivityFlow.Control
    };
    ej.datavisualization.Diagram.AssociationDefaults = {
        type: "classifier",
        association: ej.datavisualization.Diagram.AssociationFlows.BiDirectional,
        multiplicity: ej.datavisualization.Diagram.ClassifierMultiplicityDefault
    };
    ej.datavisualization.Diagram.AggregationDefaults = {
        type: "classifier",
        multiplicity: ej.datavisualization.Diagram.ClassifierMultiplicityDefault
    };
    ej.datavisualization.Diagram.CompositionDefaults = {
        type: "classifier",
        multiplicity: ej.datavisualization.Diagram.ClassifierMultiplicityDefault
    };
    ej.datavisualization.Diagram.DependencyDefaults = {
        type: "classifier",
        multiplicity: ej.datavisualization.Diagram.ClassifierMultiplicityDefault
    };
    ej.datavisualization.Diagram.RealizationDefaults = {
        type: "classifier",
        multiplicity: ej.datavisualization.Diagram.ClassifierMultiplicityDefault
    };
    ej.datavisualization.Diagram.InheritanceDefaults = {
        type: "classifier",
        multiplicity: ej.datavisualization.Diagram.ClassifierMultiplicityDefault
    };
    ej.datavisualization.Diagram.ScopeValueDefaults = {
        Public: "public",
        Protected: "",
        Private: "",
        Package: ""
    };
    ej.datavisualization.Diagram.ClassMemberDefaults = {
        name: "",
        value: ""
    };
    ej.datavisualization.Diagram.ClassAttributeDefaults = {
        name: "",
        type: "",
        scope: ej.datavisualization.Diagram.ScopeValueDefaults.Public
    };
    ej.datavisualization.Diagram.ClassMethodsArgumentsDefault = {
        name: "",
        type: "",
    };
    ej.datavisualization.Diagram.ClassMethodsDefaults = {
        name: "",
        type: "",
        arguments: ej.datavisualization.Diagram.ClassMethodsArgumentsDefault,
        scope: ej.datavisualization.Diagram.ScopeValueDefaults.Public
    };
    ej.datavisualization.Diagram.ClassmethodArguments = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.ClassMethodsArgumentsDefault, options);
    };
    ej.datavisualization.Diagram.ClassMethod = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.ClassMethodsDefaults, options);
    };
    ej.datavisualization.Diagram.ClassMember = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.ClassMemberDefaults, options);
    };
    ej.datavisualization.Diagram.ClassAttribute = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.ClassAttributeDefaults, options);
    };
    ej.datavisualization.Diagram.ClassifierClass = function (options) {
        options.attributes = options.attributes ? options.attributes.slice() : [];
        options.methods = options.methods ? options.methods.slice() : [];
        return $.extend(false, {}, ej.datavisualization.Diagram.ClassDefaults, options);
    };
    ej.datavisualization.Diagram.ClassifierInterface = function (options) {
        options.attributes = options.attributes ? options.attributes.slice() : [];
        options.methods = options.methods ? options.methods.slice() : [];
        return $.extend(false, {}, ej.datavisualization.Diagram.InterfaceDefaults, options);
    };
    ej.datavisualization.Diagram.ClassifierEnumeration = function (options) {
        options.members = options.members ? options.members.slice() : [];
        return $.extend(false, {}, ej.datavisualization.Diagram.EnumerationDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnector = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.UMLConnectorDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnectorAssociation = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.AssociationDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnectorAggregation = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.AggregationDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnectorComposition = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.CompositionDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnectorDependency = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.DependencyDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnectorRealization = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.RealizationDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnectorInheritance = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.InheritanceDefaults, options);
    };
    ej.datavisualization.Diagram.UMLConnectorMultiplicity = function (options) {
        if (options.source) {
            options.source.optional = options.source.optional ? options.source.optional : true,
            options.source.lowerBounds = options.source.lowerBounds ? options.source.lowerBounds : null,
            options.source.upperBounds = options.source.upperBounds ? options.source.upperBounds : null
        }
        if (options.target) {
            options.target.optional = options.target.optional ? options.target.optional : true,
            options.target.lowerBounds = options.target.lowerBounds ? options.target.lowerBounds : null,
            options.target.upperBounds = options.target.upperBounds ? options.target.upperBounds : null

        }
        return $.extend(false, {}, ej.datavisualization.Diagram.ClassifierMultiplicityDefault, options);
    };
    ej.datavisualization.Diagram.UMLActivityFlow = function (options) {
        return $.extend(false, {}, ej.datavisualization.Diagram.UMLActivityFlowDefaults, options);
    }
    ej.datavisualization.Diagram.ClassDefaults = {
        name: " ",
        attributes: [
         ej.datavisualization.Diagram.ClassAttribute()
        ],
        methods: [
            ej.datavisualization.Diagram.ClassMethod()
        ]

    };
    ej.datavisualization.Diagram.InterfaceDefaults = {
        name: " ",
        attributes: [
            ej.datavisualization.Diagram.ClassAttribute()
        ],
        methods: [
            ej.datavisualization.Diagram.ClassMethod()
        ]
    };
    ej.datavisualization.Diagram.EnumerationDefaults = {
        name: " ",
        members: [
            ej.datavisualization.Diagram.ClassMember()
        ],
    };
    ej.datavisualization.Diagram.NodeType = function (options, diagram) {
        if (!options._isInternalShape) {
            var defaultType = diagram.model.defaultSettings && diagram.model.defaultSettings.node && diagram.model.defaultSettings.node.type ? diagram.model.defaultSettings.node.type : "";
            var nodeDefault = !options.isPhase && diagram.model.defaultSettings && diagram.model.defaultSettings.node ? diagram.model.defaultSettings.node : {};
            if (!options.type && !options.children && !options.isLane && !options.isSwimlane && !options.isPhase && !options.isPhaseStack) {
                if (options.segments || options.sourceNode || options.sourcePort || options.sourcePoint || options.targetNode || options.targetPort || options.targetPoint)
                    options.type = "connector";
                else
                    options.type = defaultType ? defaultType : "basic";
            }
            if (options.isSwimlane || options.type == "swimlane") options._type = "group";
            if (options.type == "basic" || options.type == "flow" || options.type == "arrow" || options.type == "bpmn" || options.type == "image" || options.type == "native" || options.type === "html" || options.type === "text" || options.type == "umlactivity") {
                if (!diagram._isLoad || (diagram._isLoad && !options._type))
                    options._type = "node";
                options = $.extend(true, {}, nodeDefault, options);
            }
            if (!diagram._isLoad || diagram.model.nodeTemplate || diagram._isOptimize) {
                if (options.type == "basic")
                    options = ej.datavisualization.Diagram.BasicShape(options);
                else if (options.type == "flow")
                    options = ej.datavisualization.Diagram.FlowShape(options);
                else if (options.type == "arrow")
                    options = ej.datavisualization.Diagram.ArrowShape(options);
                else if (options.type == "bpmn")
                    options = ej.datavisualization.Diagram.BPMNShape(options);
                else if (options.type == "umlclassifier")
                    options = ej.datavisualization.Diagram.ClassifierShape(options, diagram);
                else if (options.type == "umlactivity")
                    options = ej.datavisualization.Diagram.UMLActivityShape(options, diagram);
            }
        }
        return options;
    };
    ej.datavisualization.Diagram.BasicShape = function (options) {
        options._shape = "path";
        if (!options.shape) options.shape = "rectangle";
        switch (options.shape) {
            case "rectangle":
                options._shape = "rectangle";
                break;
            case "ellipse":
                options._shape = "ellipse";
                break;
            case "path":
                options._shape = "path";
                break;
            case "polygon":
                options._shape = "polygon";
                break;
            case "triangle":
                options.pathData = "M81.1582,85.8677L111.1582,33.9067L141.1582,85.8677L81.1582,85.8677z";
                break;
            case "plus":
                options.pathData = "M696.6084,158.2656L674.8074,158.2656L674.8074,136.4656L658.4084,136.4656L658.4084,158.2656L636.6084,158.2656L636.6084,174.6646L658.4084,174.6646L658.4084,196.4656L674.8074,196.4656L674.8074,174.6646L696.6084,174.6646L696.6084,158.2656z";
                break;
            case "star":
                options.pathData = "M540.3643,137.9336L546.7973,159.7016L570.3633,159.7296L550.7723,171.9366L558.9053,194.9966L540.3643,179.4996L521.8223,194.9966L529.9553,171.9366L510.3633,159.7296L533.9313,159.7016L540.3643,137.9336z";
                break;
            case "pentagon":
                options.pathData = "M370.9702,194.9961L359.5112,159.7291L389.5112,137.9341L419.5112,159.7291L408.0522,194.9961L370.9702,194.9961z";
                break;
            case "heptagon":
                options.pathData = "M223.7783,195.7134L207.1303,174.8364L213.0713,148.8034L237.1303,137.2174L261.1883,148.8034L267.1303,174.8364L250.4813,195.7134L223.7783,195.7134z";
                break;
            case "octagon":
                options.pathData = "M98.7319,196.4653L81.1579,178.8923L81.1579,154.0393L98.7319,136.4653L123.5849,136.4653L141.1579,154.0393L141.1579,178.8923L123.5849,196.4653L98.7319,196.4653z";
                break;
            case "trapezoid":
                options.pathData = "M127.2842,291.4492L95.0322,291.4492L81.1582,256.3152L141.1582,256.3152L127.2842,291.4492z";
                break;
            case "decagon":
                options.pathData = "M657.3379,302.4141L642.3369,291.5161L636.6089,273.8821L642.3369,256.2481L657.3379,245.3511L675.8789,245.3511L690.8789,256.2481L696.6089,273.8821L690.8789,291.5161L675.8789,302.4141L657.3379,302.4141z";
                break;
            case "righttriangle":
                options.pathData = "M836.293,292.9238L776.293,292.9238L776.293,254.8408L836.293,292.9238z";
                break;
            case "cylinder":
                options.pathData = "M 542.802,362.009C 542.802,368.452 525.341,373.676 503.802,373.676C 482.263,373.676 464.802,368.452 464.802,362.009L 464.802,466.484C 464.802,472.928 482.263,478.151 503.802,478.151C 525.341,478.151 542.802,472.928 542.802,466.484L 542.802,362.016C 542.802,368.459 525.341,373.534 503.802,373.534C 482.263,373.534 464.802,368.31 464.802,361.867L 464.802,362.016C 464.802,355.572 482.263,350.349 503.802,350.349C 525.341,350.349 542.802,355.572 542.802,362.016";
                break;
                //case "diamond": options.pathData = "M 397.784,287.875L 369.5,316.159L 341.216,287.875L 369.5,259.591L 397.784,287.875 Z"; break;
        }
        return options;
    };
    ej.datavisualization.Diagram.FlowShape = function (options) {
        options._shape = "path";
        if (!options.shape) options.shape = "process";
        var constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
        if (!(options.constraints & ej.datavisualization.Diagram.NodeConstraints.AspectRatio))
            constraints = constraints | ej.datavisualization.Diagram.NodeConstraints.AspectRatio;
        switch (options.shape) {
            case "process":
                options.pathData = "M419.511,76.687L359.511,76.687L359.511,43.086L419.511,43.086z";
                break;
            case "decision":
                options.pathData = "M 253.005,115.687L 200.567,146.071L 148.097,115.687L 200.534,85.304L 253.005,115.687 Z";
                break;
            case "document":
                options.pathData = "M 60 31.9 c 0 0 -11 -7.7 -30 0 s -30 0 -30 0 V 0 h 60 V 31.9 Z";
                break;
            case "predefinedprocess":
                options.pathData = "M 0,0 L 50,0 L 50,50 L 0,50 Z  M 8.333333333333334,0 L 8.333333333333334,50 M 41.66666666666667,0 L 41.66666666666667,50";
                break;
            case "terminator":
                options.pathData = "M 269.711,29.3333C 269.711,44.061 257.772,56 243.044,56L 158.058,56C 143.33,56 131.391,44.061 131.391,29.3333L 131.391,29.3333C 131.391,14.6057 143.33,2.66669 158.058,2.66669L 243.044,2.66669C 257.772,2.66669 269.711,14.6057 269.711,29.3333 Z";
                break;
            case "papertap":
                options.pathData = "M0.000976562,17.2042 L0.000976562,47.1654 C0.000976562,47.1654 14.403,53.5455 25.001,47.1654 C35.599,40.7852 44.403,43.5087 50.001,47.1654 L50.001,17.2042 M50.001,32.7987 L50.001,2.84052 C50.001,2.84052 35.599,-3.54271 25.001,2.84052 C14.403,9.22376 5.599,6.49418 0.000976562,2.84052 L0.000976562,32.7987";
                break;
            case "directdata":
                options.pathData = "M 1477 613 L 1619 613 C 1627 613 1634 636 1634 665 C 1634 694 1627 717 1619 717 L 1477 717 C 1469 717 1461 694 1461 665 C 1461 636 1469 613 1477 613 ZM 1619 613 C 1610 613 1603 636 1603 665 C 1603 694 1610 717 1619 717M 1619 613 C 1610 613 1603 636 1603 665 C 1603 694 1610 717 1619 717";
                break;
            case "sequentialdata":
                options.pathData = "M0.00297546,24.999 C0.00297546,11.1922 10.433,0.00216177 23.295,0.00216177 C36.159,0.00216177 46.585,11.1922 46.585,24.999 C46.585,38.8057 36.159,49.9979 23.295,49.9979 C10.433,49.9979 0.00297546,38.8057 0.00297546,24.999 z M23.294,49.999 L50.002,49.999";
                break;
            case "sort":
                options.pathData = "M50.001,24.9971 L25.001,49.9971 L0.000976562,24.9971 L25.001,-0.00286865 L50.001,24.9971 z M0.000976562,24.9971 L50.001,24.9971";
                break;
            case "multidocument":
                options.pathData = "M43.6826,40 C44.8746,40.6183 45.8586,41.3502 46.8366,42.1122 L46.8366,4.74487 L3.09857,4.74487 L3.09857,10.9544 M46.837,35.1437 C48.027,35.7653 49.025,36.6042 50.003,37.3695 L50.003,0.0021928 L6.26497,0.0021928 L6.26497,4.74451 M43.6826,47.1132 L43.6826,10.7652 L0.00257874,10.7652 L0.00257874,47.1132 C0.00257874,47.1132 12.5846,53.6101 21.8426,47.1132 C31.1006,40.6163 38.7926,43.3935 43.6826,47.1132 z";
                break;
            case "collate":
                options.pathData = "M50.001,0.00286865 L25.001,25.0029 L0.000976562,0.00286865 L50.001,0.00286865 z M0.000976562,50.0029 L25.001,25.0029 L50.001,50.0029 L0.000976562,50.0029 z";
                break;
            case "summingjunction":
                options.constraints = constraints;
                options.pathData = "M7.3252,42.6768 L42.6772,7.32477 M42.6768,42.6768 L7.3248,7.32477 M0.000976562,25.001 C0.000976562,11.193 11.197,0.000976562 25.001,0.000976562 C38.809,0.000976562 50.001,11.193 50.001,25.001 C50.001,38.809 38.809,50.001 25.001,50.001 C11.197,50.001 0.000976562,38.809 0.000976562,25.001 z";
                break;
            case "or":
                options.pathData = "M 0 50 L 100 50 M 50 100 L 50 0.0 M 0 50 C 0 22.384 22.392 0 50 0 C 77.616 0 100 22.384 100 50 C 100 77.616 77.616 100 50 100 C 22.392 100 0 77.616 0 50 Z";
                break;
            case "internalstorage":
                options.pathData = "M 0 3.8194444444444446A 2.5,3.8194444444444446 0 0,1 2.5,0L 47.5 0A 2.5,3.8194444444444446 0 0,1 50,3.8194444444444446L 50 45.833333333333336A 2.5,3.8194444444444446 0 0,1 47.5,49.65277777777778L 2.5 49.65277777777778A 2.5,3.8194444444444446 0 0,1 0,45.833333333333336L 0 3.8194444444444446ZM 0 11.458333333333334L 50 11.458333333333334M 12.5 0L 12.5 49.65277777777778";
                break;
            case "extract":
                options._shape = "polygon";
                options.constraints = constraints;
                options.points = [{ x: 0, y: 35 }, { x: 30, y: 0 }, { x: 60, y: 35 }];

                break;
            case "manualoperation":
                options._shape = "polygon";
                options.points = [{ x: 46.4, y: 28.8 }, { x: 14.8, y: 28.8 }, { x: 0, y: 0 }, { x: 60, y: 0 }];
                break;
            case "merge":
                options._shape = "polygon";
                options.constraints = constraints;
                options.points = [{ x: 60, y: 0 }, { x: 30, y: 35 }, { x: 0, y: 0 }];
                break;
            case "offpagereference":
                options._shape = "polygon";
                options.points = [{ x: 60, y: 33.3 }, { x: 30.1, y: 39 }, { x: 0, y: 33.3 }, { x: 0, y: 0 }, { x: 60, y: 0 }];
                break;
            case "sequentialaccessstorage":
                options.constraints = constraints;
                options.pathData = "M 60 30 C 60 13.4 46.6 0 30 0 S 0 13.4 0 30 s 13.4 30 30 30 h 28.6 v -6.5 h -9.9 C 55.5 48 60 39.5 60 30 Z";
                break;
            case "annotation1":
                options.pathData = "M49.9984,50.0029 L-0.00271199,50.0029 L-0.00271199,0.00286865 L49.9984,0.00286865";
                break;
            case "annotation2":
                options.pathData = "M49.9977,50.0029 L25.416,50.0029 L25.416,0.00286865 L49.9977,0.00286865 M25.4166,25.0029 L-0.00227869,25.0029";
                break;
                //case "display": options.pathData = "M47.8809,19.2914 L32.7968,-0.00594145 L11.3902,-0.00594145 C7.93166,-0.00594145 0.00124586,11.187 0.00124586,24.9968 C0.00124586,38.8032 7.93166,49.9962 11.3902,49.9962 L32.7968,49.9962 L47.615,31.0388 C47.615,31.0388 52.7986,24.9968 47.8809,19.2914 z"; break;
                //case "delay": options.pathData = "M50.0044,-0.00482496 L18.9098,-0.00482496 L3.46654,18.958 C3.46654,18.958 -4.06481,25.0015 3.07999,30.7062 L18.9098,50.0013 L50.0044,50.0013"; break;
                //case "storeddata": options.pathData = "M 5.555555555555555 0L 50 0A 1.5,30 0 0,1 50,0A 5.555555555555555,25 0 0,0 50,50A 1.5,30 0 0,1 50,50L 5.555555555555555 50A 5.555555555555555,25 0 0,1 5.555555555555555,0Z"; break;
            case "card":
                options._shape = "polygon";
                options.points = [{ x: 275, y: 60 }, { x: 400, y: 60 }, { x: 400, y: 110 }, { x: 260, y: 110 }, { x: 260, y: 75 }]; break;
            case "data": options.pathData = "M 10 0 L 40 0 L 30 40 L 0 40 Z "; break;
        }
        return options;
    };
    ej.datavisualization.Diagram.ArrowShape = function (options) {
        options._shape = "path";
        if (!options.shape) options.shape = "circulararrow";
        switch (options.shape) {
            case "circulararrow":
                options.pathData = "M433.4624,503.8848C429.4244,493.2388,419.1354,485.6678,407.0734,485.6678C391.4884,485.6678,378.8544,498.3018,378.8544,513.8868L384.4984,513.8868C384.4984,501.4178,394.6054,491.3108,407.0734,491.3108C415.9494,491.3108,423.6264,496.4338,427.3144,503.8848L422.9114,503.8848L426.8974,508.8848L430.8824,513.8868L434.8684,508.8848L438.8544,503.8848L433.4624,503.8848z";
                break;
            case "curvedrightarrow":
                options.pathData = "M0.83006144,28.226993 C2.4030598,37.092016 9.5750604,44.49601 19.365042,48.044014 L19.365042,43.129004 25.376032,47.706001 31.386044,52.282999 25.376032,56.858988 19.365042,61.436991 19.365042,55.399027 C8.24608,51.372995 0.50004381,42.368995 0.50004357,31.905003 0.50004381,30.65601 0.6160717,29.429996 0.83006144,28.226993 z M31.402985,0.5 L31.402985,7.4419994 C15.834992,7.4419994 2.9619988,16.497999 0.81800008,28.275999 0.61199981,27.139999 0.49999988,25.981999 0.5,24.803999 0.49999988,11.379999 14.334993,0.5 31.402985,0.5 z";
                break;
            case "curveduparrow":
                options.pathData = "M52.283021,0.51798058 L56.859025,6.5279841 61.436024,12.537989 55.399022,12.537989 C51.373021,23.656996 42.369015,31.403002 31.905011,31.403002 30.65601,31.403002 29.430011,31.288002 28.22701,31.073002 37.092015,29.500999 44.496018,22.328995 48.044018,12.537989 L43.129018,12.537989 47.706021,6.5279841 z M0.5,0.5 L7.4420163,0.5 C7.4420163,16.067989 16.497985,28.940971 28.276,31.083977 27.140013,31.290977 25.981993,31.402 24.804015,31.402 11.380005,31.402 0.5,17.567989 0.5,0.5 z";
                break;
            case "curvedleftarrow":
                options.pathData = "M31.073116,28.227982 C31.287107,29.429977 31.403074,30.65599 31.403074,31.905989 31.403074,42.368966 23.657099,51.372959 12.538074,55.399935 L12.538074,61.436979 6.5270846,56.85898 0.51707193,52.282993 6.5270846,47.706976 12.538074,43.129983 12.538074,48.044958 C22.328056,44.496956 29.500118,37.091961 31.073116,28.227982 z M0.5,0.5 C17.568025,0.5 31.403045,11.380997 31.403045,24.803993 31.403045,25.981992 31.291046,27.139992 31.085045,28.276992 28.941042,16.497995 16.068023,7.442997 0.5,7.442997 z";
                break;
            case "curveddownarrow":
                options.pathData = "M24.804015,0.50000453 C25.981993,0.50000453 27.140013,0.61301103 28.276,0.8180277 16.498045,2.9630154 7.4420161,15.836023 7.4420156,31.404005 L0.5,31.404005 C0.5,14.336024 11.380004,0.50000453 24.804015,0.50000453 z M31.90502,0.5 C42.369025,0.49999976 51.37303,8.2460016 55.399031,19.365004 L61.436034,19.365004 56.859034,25.377005 52.28303,31.387007 47.70603,25.377005 43.129027,19.365004 48.044028,19.365004 C44.496027,9.5760015 37.092024,2.4040001 28.227019,0.82999995 29.43002,0.61699978 30.65602,0.49999976 31.90502,0.5 z";
                break;
            case "jumpingrightarrow":
                options.pathData = "M571.7207,727.7451L563.4507,716.8841L572.3297,716.8841C565.9217,699.1961,552.5427,686.2371,536.5277,683.3951C538.6997,683.0091,540.9157,682.8001,543.1717,682.8001C562.0777,682.8001,578.3457,696.7961,585.6187,716.8841L596.5277,716.8841L588.2577,727.7451L579.9907,738.6041L571.7207,727.7451z";
                break;
            case "jumpingleftarrow":
                options.pathData = "M688.4209,727.7441L696.6889,716.8851L687.8119,716.8851C694.2179,699.1971,707.5989,686.2381,723.6119,683.3941C721.4409,683.0101,719.2259,682.8011,716.9679,682.8011C698.0639,682.8011,681.7959,696.7951,674.5209,716.8851L663.6119,716.8851L671.8839,727.7441L680.1509,738.6031L688.4209,727.7441z";
                break;
                //case "uTurnArrow": options.pathData = "M1093.3154,165.6641L1093.3154,157.0071C1093.3154,145.6621,1084.1184,136.4651,1072.7724,136.4651C1061.4274,136.4651,1052.2304,145.6621,1052.2304,157.0071L1052.2304,196.4651L1061.5834,196.4511L1061.5834,157.5951C1061.5834,151.4141,1066.5934,146.4041,1072.7724,146.4041C1078.9534,146.4041,1083.9624,151.4141,1083.9624,157.5951L1083.9624,165.6641L1074.1574,165.6641L1081.1214,174.9601L1088.0864,184.2561L1095.0514,174.9601L1102.0164,165.6641L1093.3154,165.6641z"; break;
        }
        return options;
    };
    ej.datavisualization.Diagram.UMLConnectorShape = function (options) {
        if (!options.shape.relationship) options.shape.relationship = "association";
        switch (options.shape.relationship) {
            case "association":
                options.shape = ej.datavisualization.Diagram.UMLConnectorAssociation(options.shape);
                break;
            case "aggregation":
                options.shape = ej.datavisualization.Diagram.UMLConnectorAggregation(options.shape);
                break;
            case "composition":
                options.shape = ej.datavisualization.Diagram.UMLConnectorComposition(options.shape);
                break;
            case "realization":
                options.shape = ej.datavisualization.Diagram.UMLConnectorRealization(options.shape);
                break;
            case "dependency":
                options.shape = ej.datavisualization.Diagram.UMLConnectorDependency(options.shape);
                break;
            case "inheritance":
                options.shape = ej.datavisualization.Diagram.UMLConnectorInheritance(options.shape);
                break;
        }
        if (options.shape.type == "umlactivity") {
            options.shape = ej.datavisualization.Diagram.UMLActivityFlow(options.shape);
            if (options.shape.activityFlow == "object") {
                options = $.extend(true, options, { lineDashArray: "8 4", targetDecorator: { shape: "openarrow" }, lineWidth: 2 });
                if (options.labels)
                    for (var i = 0; i < options.labels.length; i++) {
                        options.labels[i] = ej.datavisualization.Diagram.Label(options.labels[i]);
                        options.labels[i].text = "[" + options.labels[i].text + "]"
                    }
            }
            else if (options.shape.activityFlow == "control")
                options = $.extend(true, options, { sourceDecorator: { shape: "none" }, targetDecorator: { shape: "openarrow" }, lineWidth: 2 });
            else if (options.shape.activityFlow == "exception")
                options = $.extend(true, options, { segments: [{ type: "straight" }], sourceDecorator: { shape: "none" }, targetDecorator: { shape: "openarrow" }, });
        }
        else if (options.shape.multiplicity) {
            var labels = [];
            labels = ej.datavisualization.Diagram.ClassifierHelper.umlConnectorMultiplicity(options);
            if (options.labels) {
                for (var i = 0; i < labels.length; i++)
                    options.labels.push(labels[i]);
            }
            else
                options = $.extend(false, {}, { labels: labels }, options);
        }
        if (options.shape.type == "umlclassifier") {
            if (options.shape.relationship == "association") {
                if (options.shape.association == "bidirectional")
                    options = $.extend(true, options, { segments: [{ type: "straight" }], sourceDecorator: { shape: "none" }, targetDecorator: { shape: "none" }, lineWidth: 2 });
                else if (options.shape.association == "directional")
                    options = $.extend(true, options, { segments: [{ type: "straight" }], sourceDecorator: { shape: "none" }, targetDecorator: { shape: "arrow" }, lineWidth: 2 });
            }
            if (options.shape.relationship == "inheritance")
                options = $.extend(true, options, { segments: [{ type: "orthogonal" }], sourceDecorator: { shape: "none" }, targetDecorator: { shape: "arrow", fillColor: "white" }, lineWidth: 2, lineDashArray: "4 4" });
            if (options.shape.relationship == "composition")
                options = $.extend(true, options, { segments: [{ type: "orthogonal" }], sourceDecorator: { shape: "diamond", fillColor: "black" }, targetDecorator: { shape: "none" }, lineWidth: 2 });
            if (options.shape.relationship == "aggregation")
                options = $.extend(true, options, { segments: [{ type: "orthogonal" }], sourceDecorator: { shape: "diamond", fillColor: "white" }, targetDecorator: { shape: "none" }, lineWidth: 2 });
            if (options.shape.relationship == "dependency")
                options = $.extend(true, options, { segments: [{ type: "orthogonal" }], sourceDecorator: { shape: "none" }, targetDecorator: { shape: "openarrow", fillColor: "white" }, lineWidth: 2, lineDashArray: "4 4" });
            if (options.shape.relationship == "realization")
                options = $.extend(true, options, { segments: [{ type: "orthogonal" }], sourceDecorator: { shape: "none" }, targetDecorator: { shape: "arrow", fillColor: "white" }, lineWidth: 2 });

        }
        return options;
    };
    ej.datavisualization.Diagram.BPMNShape = function (options) {
        if (!options.shape) options.shape = "event";
        //if (options._annotation) delete options._annotation;
        if (options.shape != "sequentialflow" || options.shape != "associationflow" || options.shape != "messageflow") {
            if (!(options.labels && options.labels.length))
                options.labels = [{}];
            if (!(options.labels.length && options.labels[0].offset))
                options.labels[0] = $.extend(false, {}, options.labels[0], { offset: { x: 0.5, y: 1 }, verticalAlignment: "top", margin: { top: 2 } });
        }
        switch (options.shape) {
            case "event":
            case "gateway":
            case "dataobject":
            case "activity":
                options._type = "group";
                options._isBpmn = true;
                if (options.children == undefined) options.children = [];
                if (options.shape == "activity" && options.activity == "subprocess" && options.subProcess && options.subProcess.collapsed == false)
                    options = $.extend(true, { container: { type: "canvas" }, paddingLeft: 10, paddingRight: 10, paddingBottom: 10, paddingTop: 10 }, options);
                break;
            case "message":
                options = $.extend(true, options, { _shape: "path", pathData: "M0,0L19.8,12.8L40,0L0,0L0,25.5L40,25.5L40,0z" });
                break;
            case "datasource":
                options = $.extend(true, options, { _shape: "path", pathData: "M 0 10.6 c 0 5.9 16.8 10.6 37.5 10.6 S 75 16.4 75 10.6 v 0 v 68.9 v -0.1 C 75 85.3 58.2 90 37.5 90 S 0 85.3 0 79.4 l 0 0.1 V 56 V 40.6 L 0 10.6 C 0 4.7 16.8 0 37.5 0 S 75 4.7 75 10.6 S 58.2 21.2 37.5 21.2 S 0 16.5 0 10.6 l 0 6.7 v -0.2 c 0 5.9 16.8 10.6 37.5 10.6 S 75 22.9 75 17.1 v 6.8 v -0.1 c 0 5.9 -16.8 10.6 -37.5 10.6 S 0 29.6 0 23.8" });
                break;
            case "group":
                options = $.extend(true, options, { _type: "group", _isBpmn: true, minWidth: options.width, minHeight: options.height, cornerRadius: 10, container: { type: "canvas" }, paddingLeft: 10, paddingRight: 10, paddingBottom: 10, paddingTop: 10, borderDashArray: "2 2 6 2" });
                break;
        }
        return options;
    };
    ej.datavisualization.Diagram.ClassifierShape = function (options, diagram) {
        if (!options.classifier) options.classifier = "class";
        if (!options.labels) options.labels = [{}];
        if (!options.fillColor) options.fillColor = "transparent"
        if (!options.borderColor) options.borderColor = "transparent";
        if (!options.borderWidth) options.borderWidth = 1;
        if (!options.opacity) options.opacity = 1;

        switch (options.classifier) {
            case "class":
                options["class"] = ej.datavisualization.Diagram.ClassifierClass(options["class"])
                for (var i = 0; i < options["class"].attributes.length; i++)
                    options["class"].attributes[i] = ej.datavisualization.Diagram.ClassAttribute(options["class"].attributes[i])
                for (var j = 0; j < options["class"].methods.length; j++)
                    options["class"].methods[j] = ej.datavisualization.Diagram.ClassMethod(options["class"].methods[j])
                options = ej.datavisualization.Diagram.DefautShapes._getClassShape(options, diagram);
                break;
            case "interface":
                options["interface"] = ej.datavisualization.Diagram.ClassifierInterface(options["interface"]);
                for (var i = 0; i < options["interface"].attributes.length; i++)
                    options["interface"].attributes[i] = ej.datavisualization.Diagram.ClassAttribute(options["interface"].attributes[i])
                for (var j = 0; j < options["interface"].methods.length; j++)
                    options["interface"].methods[j] = ej.datavisualization.Diagram.ClassMethod(options["interface"].methods[j])
                //  options = $.extend(false, {}, ej.datavisualization.Diagram.ClassifierInterface(), options);
                options = ej.datavisualization.Diagram.DefautShapes._getClassShape(options, diagram);
                break;
            case "enumeration":
                options.enumeration = ej.datavisualization.Diagram.ClassifierEnumeration(options.enumeration);
                //  options = $.extend(false, {}, ej.datavisualization.Diagram.ClassifierEnumeration(), options);
                options = ej.datavisualization.Diagram.DefautShapes._getClassShape(options, diagram);
                break;
            case "member":
                options.labels[0] = $.extend(false, {}, { name: options.name + "_member", horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 }, text: "Member" }, options.labels[0]);
                options = $.extend(false, {}, { borderColor: "transparent", fillColor: "transparent", _shape: "rectangle", horizontalAlign: "stretch", verticalAlign: "bottom", _isClassMember: true }, options);
                break;
            case "package":
                //  options = ej.datavisualization.Diagram.DefautShapes._getUMLPackageShape(options, diagram);
                break;
            case "collapsedpackage":
                // options.labels[0] = $.extend(false, {}, { offset: { x: 0.5, y: 0.5 }, text: options.packageName }, options.labels[0]);
                //  options = $.extend(false, {}, { _shape: "rectangle" }, options);
                break;
        }
        return options;
    };
    ej.datavisualization.Diagram.UMLActivityShape = function (options) {
        options.type = "umlactivity";
        if (!options.shape) options.shape = "action";
        options._shape = "path";
        // options.port = [];
        switch (options.shape) {
            case "action":
                options.pathData = "M 90 82.895 C 90 86.819 86.776 90 82.8 90 H 7.2 C 3.224 90 0 86.819 0 82.895 V 7.105 C 0 3.181 3.224 0 7.2 0 h 75.6 C 86.776 0 90 3.181 90 7.105 V 82.895 Z";
                break;
            case "decision":
                options.pathData = "M10,19.707L0.293,10L10,0.293L19.707,10L10,19.707z";
                break;
            case "mergenode":
                options.pathData = "M10,19.707L0.293,10L10,0.293L19.707,10L10,19.707z";
                break;
            case "initialnode":
                options.pathData = "M10,19.5c-5.238,0-9.5-4.262-9.5-9.5S4.762,0.5,10,0.5s9.5,4.262,9.5,9.5S15.238,19.5,10,19.5z";
                break;
            case "finalnode":
                options.borderColor = "transparent";
                options._type = "group";
                var childNodes = [], i = 0;
                var constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.PointerEvents | ej.datavisualization.Diagram.NodeConstraints.Connect | ej.datavisualization.Diagram.NodeConstraints.Resize);
                childNodes.push({
                    name: options.name + "_activity_final_1", width: options.width, height: options.height, offsetX: options.offsetX, offsetY: options.offsetY,
                    constraints: constraints | ej.datavisualization.Diagram.NodeConstraints.Resize, type: "node", shape: "path",
                    pathData: "M164.1884,84.6909000000001C156.2414,84.6909000000001,149.7764,78.2259000000001,149.7764,70.2769000000001C149.7764,62.3279000000001,156.2414,55.8629000000001,164.1884,55.8629000000001C172.1354,55.8629000000001,178.6024,62.3279000000001,178.6024,70.2769000000001C178.6024,78.2259000000001,172.1354,84.6909000000001,164.1884,84.6909000000001"
                });
                childNodes.push({
                    name: options.name + "_activity_final_2", width: options.width / 2, height: options.height / 2, fillColor: "black", offsetX: options.offsetX, offsetY: options.offsetY,
                    constraints: constraints | ej.datavisualization.Diagram.NodeConstraints.Resize, type: "node", shape: "path",
                    pathData: "M 25 50 C 11.21 50 0 38.79 0 25 C 0 11.21 11.21 0 25 0 C 38.78 0 50 11.21 50 25 C 50 38.79 38.78 50 25 50"
                });
                for (i = 0; i < childNodes.length; i++)
                    childNodes[i] = ej.datavisualization.Diagram.Node(childNodes[i]);
                options.elementType = "group";
                options.children = childNodes; break;
            case "forknode":
                options.width = options.width ? options.width : 40;
                options.height = 5;
                options.fillColor = "black"
                options.pathData = "m0.75,0.75l636.00002,0l0,290l-636.00002,0l0,-290z";
                options.labels = [{ readOnly: true }];
                //options.ports = [];
                break;
            case "joinnode":
                options.width = options.width ? options.width : 40;
                options.height = 5;
                options.fillColor = "black"
                options.pathData = "m0.75,0.75l636.00002,0l0,290l-636.00002,0l0,-290z";
                options.labels = [{ readOnly: true }];
                //options.ports = [];
                break;
            case "timeevent":
                options.pathData = "M50.001,0.00286865 L25.001,25.0029 L0.000976562,0.00286865 L50.001,0.00286865 z M0.000976562,50.0029 L25.001,25.0029 L50.001,50.0029 L0.000976562,50.0029 z";
                break;
            case "acceptingevent":
                options.pathData = "M17.8336 32.164 L29.64 24 L17.32 16 L48.1664 16 L48.5 32 Z";
                break;
            case "sendsignal":
                options.pathData = "M48.164 31.8336 L56 23.832 L47.836 16 L16.168 16 L16.1668 31.8336 Z";
                break;
            case "receivesignal":
                options.pathData = "M48.1664 31.8336 L39.836 24 L47.836 16 L16.168 16 L16.168 31.836 Z";
                break;
            case "structurednode":
                options._shape = "rectangle";
                options.borderDashArray = "2 3";
                if (options.labels && options.labels.length > 0)
                    options.labels = [{ text: "<<" + options.labels[0].text + ">>", wrapText: "nowrap", fillColor: "white" }];
                break;
            case "note":
                options.pathData = "M20 12 L4 12 L4 22 L22 22 L22 14 L20 14 L20 12 L22 14 Z";
                break;
        }
        return options;
    };
    ej.datavisualization.Diagram.DefautShapes = {
        //#region BPMN
        _getBPMNEventShape: function (options, diagram) {
            var childNodes = [], i;
            if (options.children == undefined) options.children = [];
            options._type = "group";
            options.canUngroup = false;
            options.offset = options.offset || {}
            options.offset = ej.datavisualization.Diagram.Point(options.offset.x ? options.offset.x : null, options.offset.y ? options.offset.y : null)
            options = $.extend(false, {}, ej.datavisualization.Diagram.BPMNEventDefaults, options);
            for (i = 0; i < options.children.length; i++) {
                if (diagram.nameTable[options.children[i].name || options.children[i]]) {
                    childNodes.push(diagram.nameTable[options.children[i].name || options.children[i]]);
                    childNodes[i].rotateAngle = options.rotateAngle;
                }
            }
            var pivot = options.pivot || { x: 0.5, y: 0.5 };
            var centerX = options.offsetX ? (options.offsetX - options.width * pivot.x + options.width / 2) : options.width * pivot.x + options.width / 2;
            var centerY = options.offsetY ? (options.offsetY - options.height * pivot.y + options.height / 2) : options.height * pivot.y + options.height / 2;
            if (!childNodes.length) {
                var constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.PointerEvents | ej.datavisualization.Diagram.NodeConstraints.Connect);
                var defaultProperty = { parent: options.name, type: "node", shape: "path", offsetX: centerX, offsetY: centerY, ports: [], rotateAngle: options.rotateAngle, constraints: constraints, _isDisabled: true, _isInternalShape: true };
                childNodes.push({ name: options.name + "_0", width: options.width, height: options.height });
                childNodes.push({ name: options.name + "_1", width: options.width * .85, height: options.height * .85 });
                childNodes.push({ name: options.name + "_2", width: options.width * .5, height: options.height * .5 });
                for (i = 0; i < childNodes.length; i++)
                    childNodes[i] = ej.datavisualization.Diagram.Node($.extend(false, {}, defaultProperty, childNodes[i]));
            }
            options.constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
            options.children = this._updateBPMNEventShape(options, childNodes, options.event, options.trigger);
            return options;
        },
        _getBPMNGatewayShape: function (options, diagram) {
            var childNodes = [], i;
            if (options.children == undefined) options.children = [];
            options._type = "group";
            options.canUngroup = false;
            options = $.extend(false, {}, ej.datavisualization.Diagram.BPMNGatewayDefaults, options);
            for (i = 0; i < options.children.length; i++) {
                if (diagram.nameTable[options.children[i].name || options.children[i]]) {
                    childNodes.push(diagram.nameTable[options.children[i].name || options.children[i]]);
                    childNodes[i].rotateAngle = options.rotateAngle;
                }
            }
            var pivot = options.pivot || { x: 0.5, y: 0.5 };
            var centerX = options.offsetX ? (options.offsetX - options.width * pivot.x + options.width / 2) : options.width * pivot.x + options.width / 2;
            var centerY = options.offsetY ? (options.offsetY - options.height * pivot.y + options.height / 2) : options.height * pivot.y + options.height / 2;
            if (!childNodes.length) {
                var constraints = ej.datavisualization.Diagram.NodeConstraints.Default ^ (ej.datavisualization.Diagram.NodeConstraints.PointerEvents | ej.datavisualization.Diagram.NodeConstraints.Connect);
                var defaultProperty = { parent: options.name, type: "node", shape: "path", offsetX: centerX, offsetY: centerY, ports: [], rotateAngle: options.rotateAngle, constraints: constraints, _isDisabled: true, _isInternalShape: true };
                childNodes.push({ name: options.name + "_0", width: options.width, height: options.height, pathData: "M 40 20 L 20 40 L 0 20 L 20 0 L 40 20 Z" });
                childNodes.push({ name: options.name + "_1", width: options.width * .45, height: options.height * .45 });
                for (i = 0; i < childNodes.length; i++)
                    childNodes[i] = ej.datavisualization.Diagram.Node($.extend(false, {}, defaultProperty, childNodes[i]));
            }
            if (childNodes && childNodes[0]) {
                constraints = childNodes[0].constraints ? childNodes[0].constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
                if (options.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                    constraints = constraints | ej.datavisualization.Diagram.NodeConstraints.Shadow;
                }
            }
            options.children = childNodes;
            options.constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
            $.extend(true, childNodes, [{ fillColor: options.fillColor, constraints: constraints, shadow: options.shadow, borderColor: options.borderColor, borderWidth: options.borderWidth, opacity: options.opacity, gradient: options.gradient }, { opacity: options.opacity, fillColor: "black", visible: true }]);
            childNodes[1].fillColor = options.borderColor;
            childNodes[1].borderColor = options.borderColor;
            switch (options.gateway) {
                case "none":
                    childNodes[1].visible = false;
                    break;
                case "exclusive":                  
                    childNodes[1].pathData = "M 11.196 29.009 l 6.36 -9.712 l -5.764 -8.899 h 4.393 l 3.732 5.979 l 3.656 -5.979 h 4.354 l -5.789 9.039 l 6.36 9.572 h -4.532 l -4.126 -6.437 l -4.139 6.437 H 11.196 Z";
                    break;
                case "inclusive":                    
                    childNodes[1].pathData = "M 20.323 31.333 c -6.625 0 -12.015 -5.39 -12.015 -12.015 s 5.39 -12.015 12.015 -12.015 s 12.016 5.39 12.016 12.015 S 26.948 31.333 20.323 31.333 Z M 20.323 9.303 c -5.522 0 -10.015 4.493 -10.015 10.015 s 4.492 10.015 10.015 10.015 s 10.016 -4.493 10.016 -10.015 S 25.846 9.303 20.323 9.303 Z";
                    break;
                case "parallel":
                    childNodes[1].pathData = "M 18.394 29.542 v -8.833 H 9.626 v -3.691 h 8.768 V 8.251 h 3.734 v 8.767 h 8.768 v 3.691 h -8.768 v 8.833 H 18.394 Z";
                    break;
                case "complex":                    
                    childNodes[1].pathData = "M29.198,19.063L23.089,19.063L27.794,14.358L26.38,12.944L21.223,18.101L21.223,10.443L19.223,10.443L19.223,17.976L14.022,12.776L12.608,14.19L17.48,19.063L10.365,19.063L10.365,21.063L18.261,21.063L12.392,26.932L13.806,28.346L19.223,22.929L19.223,30.225L21.223,30.225L21.223,22.805L25.925,27.507L27.339,26.093L22.309,21.063L29.198,21.063z";
                    break;
                case "eventbased":
                    childNodes[1].fillColor = "white";
                    childNodes[1].pathData = "M 20.322 29.874 c -5.444 0 -9.873 -4.43 -9.873 -9.874 s 4.429 -9.874 9.873 -9.874 s 9.874 4.429 9.874 9.874 S 25.767 29.874 20.322 29.874 Z M 20.322 32.891 c -7.107 0 -12.89 -5.783 -12.89 -12.891 c 0 -7.107 5.782 -12.89 12.89 -12.89 c 7.108 0 12.891 5.783 12.891 12.89 C 33.213 27.108 27.431 32.891 20.322 32.891 Z M 24.191 25.386 h -7.984 l -2.469 -7.595 l 6.461 -4.693 l 6.461 4.693 L 24.191 25.386 Z";
                    break;
                case "exclusiveeventbased":
                    childNodes[1].fillColor = "white";
                    childNodes[1].pathData = "M 30 15 C 30 23.28 23.28 30 15 30 S 0 23.28 0 15 S 6.72 0 15 0 S 30 6.72 30 15 z M 15 5 L 5 12.5 L 8 22.5 H 22 L 25 12.5 z";
                    break;
                case "paralleleventbased":
                    childNodes[1].fillColor = "white";
                    childNodes[1].pathData = "M 35 17.5 C 35 27.16 27.16 35 17.5 35 S 0 27.16 0 17.5 S 7.84 0 17.5 0 S 35 7.84 35 17.5 z M 14.58 5.83 V 14.58 H 5.83 V 20.42 H 14.58 V 29.17 H 20.42 V 20.42 H 29.17 V 14.58 H 20.42 V 5.83 z";
                    break;
            }
            return options;
        },
        /*  _getUMLPackageShape: function (options, diagram) {
              var childNodes = [], i, x, y;
              var x = options.offsetX - options.width / 2, y = options.offsetY - options.height / 2;
              if (!options.children) {
                  var constraints = ej.datavisualization.Diagram.NodeConstraints.Default ^ (ej.datavisualization.Diagram.NodeConstraints.Select | ej.datavisualization.Diagram.NodeConstraints.Connect);
                  var defaultProperty = { parent: options.name, shape: "path", ports: [], borderColor: options.borderColor, borderWidth: options.borderWidth, constraints: constraints };
                  var labelWidth = options.packageName.length * 10;
                  childNodes.push({ name: options.name + "_package_header" + "_classifier", minWidth: labelWidth, maxWidth: options.width, minHeight: 26, type: "node", offsetX: x + labelWidth / 2, offsetY: y + 13, pathData: "M79.75,65.786H8.91v-47.5h70.84V65.786z", labels: [{ text: options.packageName, horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 }, margin: { left: 5, right: 5, top: 4, bottom: 4 }, fontSize: 14, bold: true }], _isClassMember: true, });
                  childNodes.push({ name: options.name + "_package_content" + "_classifier", minWidth: options.width, minHeight: options.height - 26, type: "group", offsetX: x + options.width / 2, offsetY: y + 26 + (options.height - 26) * .5, fillColor: "transparent", pathData: "M39.083,19.286H8.91V9.37h30.173V19.286z", container: { type: "canvas", orientation: "vertical" }, children: [], labels: [{ readOnly: true }], paddingRight: 10, paddingLeft: 10, paddingTop: 10, paddingBottom: 10, allowDrop: true, _isPackage: true });
                  for (i = 0; i < childNodes.length; i++)
                      childNodes[i] = ej.datavisualization.Diagram.Node($.extend(false, {}, defaultProperty, childNodes[i]));
                  if (childNodes[1].constraints)
                      childNodes[1].constraints |= ej.datavisualization.Diagram.NodeConstraints.AllowDrop;
                  var classnodes = [];
                  if (options.members) {
                      for (var i = 0; i < options.members.length; i++) {
                          var classnode = ej.datavisualization.Diagram.ClassifierShape(options.members[i], diagram);
                          classnode.parent = childNodes[1].name;
                          classnodes.push(classnode);
                      }
                      for (var j = 0; j < classnodes.length;j++)
                          childNodes[1].children.push( classnodes[j]);
                  }
                  options.children = childNodes;
                  options._type = "group";
                  options.labels[0] = $.extend(false, {}, { readOnly: true }, options.labels[0]);
                  options.container = { type: "stack", orientation: "vertical" };
                  options.allowDrop = false;
                  options.constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
                  options.constraints = options.constraints & ~(ej.datavisualization.Diagram.NodeConstraints.Connect | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeWest | ej.datavisualization.Diagram.NodeConstraints.ResizeNorth);
              }
              else {
                  for (i = 0; i < options.children.length; i++)
                      if (diagram.nameTable[options.children[i].name]) {
                          if (diagram.nameTable[options.children[i].name || options.children[i]])
                              childNodes.push(diagram.nameTable[options.children[i].name || options.children[i]]);
                      }
                      else
                          childNodes.push(typeof options.children[i] == "object" ? options.children[i] : diagram.nameTable[options.children[i]]);
              }
              childNodes[0].fillColor = options.fillColor;
              childNodes[0].borderColor = options.borderColor;
              childNodes[0].borderWidth = options.borderWidth;
              childNodes[0].opacity = options.opacity;
              if (options.gradient) childNodes[0].gradient = options.gradient;
              return options;
          },*/
        _getClassShape: function (options, diagram) {
            var childNodes = [], i, textNode, height, width;
            var attributeText = "", methodText = "", memberText = "", argumentText = "";
            if (!options.children) {
                var constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.Select | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeWest | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeNorth | ej.datavisualization.Diagram.NodeConstraints.ResizeSouth | ej.datavisualization.Diagram.NodeConstraints.Connect | ej.datavisualization.Diagram.NodeConstraints.Rotate | ej.datavisualization.Diagram.NodeConstraints.ResizeEast | ej.datavisualization.Diagram.NodeConstraints.Drag);
                var defaultProperty = { width: options.width, offsetX: options.offsetX, parent: options.name, ports: [], fillColor: "transparent", borderColor: options.borderColor, type: "node", labels: [{ margin: { left: 5, right: 5, top: 5, bottom: 5 } }], _isClassMember: true };
                if (options.fillColor) defaultProperty.fillColor = options.fillColor;
                if (options.borderColor) defaultProperty.borderColor = options.borderColor;
                if (options.borderWidth) defaultProperty.borderWidth = options.borderWidth
                if (options.labels) {
                    for (var i = 0; i < options.labels.length; i++)
                        defaultProperty.labels[i] = $.extend(false, {}, defaultProperty.labels[i], options.labels[i])
                }
                switch (options.classifier) {
                    case "class":
                        childNodes.push({ ports: [], name: options.name + "_header" + "_classifier", minHeight: 30, labels: [{ name: "title", offset: { x: 0.5, y: 0.65 }, text: options["class"].name, bold: true, fontSize: 14 }, { name: "class", offset: { x: 0.5, y: 0.25 }, text: "<<Class>>" }], constraints: constraints });
                        break;
                    case "interface":
                        childNodes.push({ name: options.name + "_header" + "_classifier", minHeight: 40, labels: [{ name: "title", offset: { x: 0.5, y: 0.65 }, text: options["interface"].name, bold: true, fontSize: 14 }, { name: "interface", offset: { x: 0.5, y: 0.25 }, text: "<<Interface>>" }], constraints: constraints });
                        break;
                    case "enumeration":
                        childNodes.push({ name: options.name + "_header" + "_classifier", minHeight: 40, labels: [{ name: options.name + "Label1", offset: { x: 0.5, y: 0.65 }, text: options.enumeration.name, bold: true, fontSize: 14 }, { name: options.name + "enumeration", offset: { x: 0.5, y: 0.25 }, text: "<<Enumeration>>" }], constraints: constraints });
                        break;
                }
                var attribute = options["class"] ? options["class"] : options["interface"];
                if (attribute && attribute.attributes && attribute.attributes.length) {
                    for (i = 0; i < (attribute.attributes.length) ; i++) {
                        attribute.attributes[i] = ej.datavisualization.Diagram.ClassAttribute(attribute.attributes[i]);
                        if (options.Interface)
                            attribute.attributes[i].scope = ej.datavisualization.Diagram.ScopeValueDefaults.Public;
                        if (attribute.attributes[i].scope && attribute.attributes[i].scope == "public")
                            var text = "+";
                        if (attribute.attributes[i].scope && attribute.attributes[i].scope == "private")
                            text = "-";
                        if (attribute.attributes[i].scope && attribute.attributes[i].scope == "protected")
                            text = "#";
                        if (attribute.attributes[i].scope && attribute.attributes[i].scope == "package")
                            text = "~";
                        if (attribute.attributes[i].name != "")
                            if (text)
                                attributeText += text + " " + attribute.attributes[i].name + " " + ": " + attribute.attributes[i].type;
                            else
                                attributeText += attribute.attributes[i].name + ": " + attribute.attributes[i].type;
                        if (i != attribute.attributes.length - 1)
                            attributeText += "\n";
                    }
                    if (attributeText)
                        childNodes.push({ name: options.name + "_attribute" + "_classifier", labels: [{ text: attributeText, horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 } }], constraints: constraints });
                }
                var member = options.enumeration;
                if (member && member.members && member.members.length) {
                    for (i = 0; i < member.members.length; i++) {
                        member.members[i] = ej.datavisualization.Diagram.ClassMember(member.members[i]);
                        if (member.members[i].name != "")
                            memberText += member.members[i].name;
                        if (i != member.members.length - 1)
                            memberText += "\n";
                    }
                    if (memberText)
                        childNodes.push({ name: options.name + "_member" + "_classifier", labels: [{ text: memberText, horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 } }], constraints: constraints });
                }
                var method = options["class"] ? options["class"] : options["interface"];
                 if (method && method.methods && method.methods.length) {
                    for (i = 0; i < method.methods.length ; i++) {
                        method.methods[i] = ej.datavisualization.Diagram.ClassMethod(method.methods[i]);
                        if (method.methods[i].scope && method.methods[i].scope == "public")
                            var text = "+";
                        if (method.methods[i].scope && method.methods[i].scope == "private")
                            text = "-";
                        if (method.methods[i].scope && method.methods[i].scope == "protected")
                            text = "#";
                        if (method.methods[i].scope && method.methods[i].scope == "package")
                            text = "~";
                        if (method.methods[i].arguments) {
                            for (var j = 0; j < method.methods[i].arguments.length; j++) {
                                if (method.methods[i].arguments[j].type)
                                    argumentText += method.methods[i].arguments[j].name + ":" + method.methods[i].arguments[j].type;
                                else
                                    argumentText += method.methods[i].arguments[j].name;
                                if (j != method.methods[i].arguments.length - 1)
                                    argumentText += ",";
                            }
                        }
                        if (method.methods[i].name != "") {
                            if (text)
                                methodText += text + " " + method.methods[i].name + "(" + argumentText + ")" + " " + ":" + " " + method.methods[i].type;
                            else
                                methodText += method.methods[i].name + "(" + argumentText + ")" + " " + ":" + method.methods[i].type;
                        }
                        if (i != method.methods.length - 1)
                            methodText += "\n";
                    }
                    if (methodText)
                        childNodes.push({ name: options.name + "_method" + "_classifier", labels: [{ text: methodText, horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 } }], constraints: constraints });
                }
                for (i = 0; i < childNodes.length; i++) {
                    childNodes[i] = ej.datavisualization.Diagram.Node($.extend(false, {}, defaultProperty, childNodes[i]));
                    for (var j = 0; j < childNodes[i].labels.length; j++)
                        childNodes[i].labels[j] = $.extend(false, {}, childNodes[i].labels[j], defaultProperty.labels[0]);
                }
                options.children = childNodes;
                options._type = "group";
                //  options.labels[0] = $.extend(false, {}, { readOnly: true }, options.labels[0]);
                options.constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
                options.constraints = options.constraints & ~(ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeWest | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeNorth | ej.datavisualization.Diagram.NodeConstraints.ResizeSouth | ej.datavisualization.Diagram.NodeConstraints.Rotate | ej.datavisualization.Diagram.NodeConstraints.ResizeEast);
                for (var i = 0; i < childNodes.length; i++) {
                    if (childNodes.length == 1) {
                        if (options["class"]) {
                            delete options["class"].attributes;
                            delete options["class"].methods;
                        }
                        if (options["interface"]) {
                            delete options["interface"].attributes;
                            delete options["interface"].methods;
                        }
                        if (options.enumeration)
                            delete options.enumeration.members;
                    }
                    if (childNodes.length == 2) {
                        options.children[i] = typeof options.children[i] == "string" ? diagram.nameTable[options.children[i]] : options.children[i];
                        if (options["class"]) {
                            if (options.children[i].name.match("attribute"))
                                delete options["class"].methods;
                            if (options.children[i].name.match("method"))
                                delete options["class"].attributes;
                        }
                        if (options["interface"]) {
                            if (options.children[i].name.match("attribute"))
                                delete options["interface"].methods;
                            if (options.children[i].name.match("method"))
                                delete options["interface"].attributes;
                        }
                    }
                }
            }
            else {
                for (i = 0; i < options.children.length; i++)
                    if (diagram.nameTable[options.children[i].name || options.children[i]])
                        childNodes.push(diagram.nameTable[options.children[i].name || options.children[i]]);
                if (childNodes.length <= 0 && options.children.length > 0) {
                    for (var j = 0; j < options.children.length; j++)
                        childNodes.push(options.children[j]);
                }
            }

            options._height = 0;
            for (i = 0; i < childNodes.length; i++) {
                diagram._getNodeDimension(childNodes[i], childNodes[i].labels[0]);
                //   this._updateClassNode(childNodes[i], options)
                height = childNodes[i].height ? childNodes[i].height : childNodes[i]._height;
                childNodes[i].offsetY = options._height + height / 2;
                options._height += height;
            }
            width = childNodes[0]._width;
            if (childNodes[1])
                width = childNodes[0]._width > childNodes[1]._width ? childNodes[0]._width : childNodes[1]._width
            if (childNodes[2])
                width = childNodes[2]._width > width ? childNodes[2]._width : width;
            childNodes[0].width = width;
            if (childNodes[1])
                childNodes[1].width = width;
            if (childNodes[2])
                childNodes[2].width = width;
            options._width = width;
            options.width = options._width;
            options.height = options._height;
            for (i = 0; i < childNodes.length; i++)
                childNodes[i].offsetY += (options.offsetY - options.height / 2);
            return options;
        },
        _updateClassNode: function (node, parent) {
            if (node.name.match("_header")) {
                if (parent.type == "class") parent.className = node.labels[0].text;
                else if (parent.type == "interface") parent.interfaceName = node.labels[0].text;
                else parent.enumerationName = node.labels[0].text;
            }
            else {
                var type = node.name.match("_attribute") ? "attribute" : (node.name.match("_method") ? "method" : "member");
                var label = node.labels[0];
                var str = label.text.split("\n");
                var classMember = [], data, i;
                for (i = 0; i < str.length; i++) {
                    var text = parent["Class"] ? parent["Class"] : parent.Interface;
                    switch (type) {
                        case "attribute":
                            data = str[i].split(/:[ ]*/g);
                            classMember.push(ej.datavisualization.Diagram.ClassMember({ name: data[0], type: data[1] }));
                            break;
                        case "method":
                            data = str[i].replace(")", "").replace("(", ":").split(/:[ ]*/g);
                            classMember.push(ej.datavisualization.Diagram.ClassMember({ name: data[0], returnType: data[1], parameter: data[2] }));
                            break;
                        case "member":
                            classMember.push(ej.datavisualization.Diagram.ClassMember({ name: str[i] }));
                            break;
                    }
                }
                if (type == "attribute") parent.attributes = classMember;
                else if (type == "method") parent.methods = classMember;
                else parent.members = classMember;
            }

        },
        _getBPMNDataShape: function (options, diagram) {
            var childNodes = [], i;
            if (options.children == undefined) options.children = [];
            options._type = "group";
            var pivot = options.pivot || { x: 0.5, y: 0.5 };
            options.canUngroup = false;
            options.data = ej.datavisualization.Diagram.BPMNDataObject(options.data);
            options = $.extend(false, {}, ej.datavisualization.Diagram.BPMNDataObjectDefaults, options);
            var x = options.offsetX ? options.offsetX - options.width * pivot.x : options.width * pivot.x;
            var y = options.offsetY ? options.offsetY - options.height * pivot.y : options.height * pivot.y;
            for (i = 0; i < options.children.length; i++) {
                if (diagram.nameTable[options.children[i].name || options.children[i]]) {
                    childNodes.push(diagram.nameTable[options.children[i].name || options.children[i]]);
                    childNodes[i].rotateAngle = options.rotateAngle;
                }
            }
            var centerX = options.offsetX ? (options.offsetX - options.width * pivot.x + options.width / 2) : options.width * pivot.x + options.width / 2;
            if (!childNodes.length) {
                var constraints = ej.datavisualization.Diagram.NodeConstraints.Default ^ (ej.datavisualization.Diagram.NodeConstraints.PointerEvents | ej.datavisualization.Diagram.NodeConstraints.Connect);
                var defaultProperty = { parent: options.name, type: "node", shape: "path", offsetX: centerX, ports: [], rotateAngle: options.rotateAngle, constraints: constraints, _isDisabled: true, _isInternalShape: true };
                childNodes.push({ name: options.name + "_0", width: options.width, height: options.height, offsetY: y + options.height / 2, addInfo: { offset: { x: 0.5, y: 0.5 } }, constraints: constraints, shape: "polygon", points: [{ x: 29.904, y: 5 }, { x: 7.853, y: 5 }, { x: 7.853, y: 45 }, { x: 42.147, y: 45 }, { x: 42.147, y: 17.242 }, { x: 29.932, y: 5 }, { x: 29.932, y: 17.242 }, { x: 42.147, y: 17.242 }] });
                childNodes.push({ name: options.name + "_1", width: 7.5, height: 15, offsetY: 85 + y, addInfo: { offset: { x: .5, y: 1 }, margin: { bottom: 15 } }, constraints: constraints & ~ej.datavisualization.Diagram.NodeConstraints.Resize, fillColor: "black", pathData: "M 0 0 L 0.1 0 L 0.1 2 L 0 2 Z M 0.4 0 L 0.6 0 L 0.6 2 L0.4 2 Z M 0.9 0 L 1 0 L 1 2 L 0.9 2 Z " });
                childNodes.push({ name: options.name + "_2", width: 25, height: 20, offsetX: x + 15, offsetY: y + 15, addInfo: { offset: { x: 0, y: 0 }, margin: { left: 17.5, top: 15 } }, constraints: constraints & ~ej.datavisualization.Diagram.NodeConstraints.Resize, borderColor: "black", fillColor: "white", pathData: "M 3 9.4 l 6 0 v 2.4 l 3.6 -4 L 9 4 v 2.5 H 3 V 9.4 Z" });
                for (i = 0; i < childNodes.length; i++)
                    childNodes[i] = ej.datavisualization.Diagram.Node($.extend(false, {}, defaultProperty, childNodes[i]));
            }
            options.children = childNodes;
            options.constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
            if (options.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                constraints = constraints | ej.datavisualization.Diagram.NodeConstraints.Shadow;
            }
            $.extend(true, childNodes, [{ fillColor: options.fillColor, constraints: constraints, shadow: options.shadow, borderColor: options.borderColor, borderWidth: options.borderWidth, opacity: options.opacity, gradient: options.gradient }, { opacity: options.opacity, visible: options.data.collection }, { opacity: options.opacity, visible: true }]);
            switch (options.data.type) {
                case "none":
                    childNodes[2].visible = false;
                    break;
                case "input":
                    childNodes[2].fillColor = "white";
                    break;
                case "output":
                    childNodes[2].fillColor = "black";
                    break;
            }
            return options;
        },
        _getBPMNActivityShape: function (options, diagram) {            
                var childNodes = [], childTable = {}, i;
                if (options.children == undefined) options.children = [];
                options._type = "group";
                options.canUngroup = false;
                options.task = ej.datavisualization.Diagram.BPMNTask(options.task);
                options.subProcess = ej.datavisualization.Diagram.BPMNSubProcess(options.subProcess);
                options = $.extend(false, {}, ej.datavisualization.Diagram.BPMNActivityDefaults, options);
                for (i = 0; i < options.children.length; i++) {
                    if (diagram.nameTable[options.children[i].name || options.children[i]]) {
                        childNodes.push(diagram.nameTable[options.children[i].name || options.children[i]]);
                        childNodes[i].rotateAngle = options.rotateAngle;
                    }
                }
                if (!childNodes.length) {
                    var constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.PointerEvents | ej.datavisualization.Diagram.NodeConstraints.Connect | ej.datavisualization.Diagram.NodeConstraints.Resize);
                    var defaultProperty = { parent: options.name, type: "node", shape: "path", ports: [], labels: [], constraints: constraints, rotateAngle: options.rotateAngle, _isDisabled: true, _isInternalShape: true };
                    childNodes.push({ name: options.name + "_activity", width: options.width, height: options.height, addInfo: { offset: { x: 0.5, y: 0.5 } }, constraints: constraints | ej.datavisualization.Diagram.NodeConstraints.Resize });
                    childNodes.push({ name: options.name + "_taskType", width: 14, height: 14, borderColor: "black", addInfo: { offset: { x: 0, y: 0 }, hAlign: "left", vAlign: "top", margin: { left: 14, top: 14 } }, pathData: "M10 0L40 0L30 40L0 40Z" });
                    childNodes.push({ name: options.name + "_loop", width: 12, height: 12, addInfo: { offset: { x: 0.5, y: 1 }, hAlign: "center", vAlign: "bottom", margin: { bottom: 12 } }, borderColor: "black", fillColor: "black", pathData: "M10 0L40 0L30 40L0 40Z" });
                    childNodes.push({ name: options.name + "_compensation", width: 12, height: 12, addInfo: { offset: { x: 0.5, y: 1 }, hAlign: "center", vAlign: "bottom", margin: { bottom: 12 } }, borderColor: "black", fillColor: "black", pathData: "M10 0L40 0L30 40L0 40Z" });
                    childNodes.push({ name: options.name + "_expanded", width: 12, height: 12, constraints: constraints, addInfo: { offset: { x: 0.5, y: 1 }, hAlign: "center", vAlign: "bottom", margin: { bottom: 12 } }, borderColor: "black", fillColor: "black", pathData: "M10 0L40 0L30 40L0 40Z" });
                    childNodes.push({ name: options.name + "_adhoc", width: 12, height: 8, addInfo: { offset: { x: 0.5, y: 1 }, hAlign: "center", vAlign: "bottom", margin: { bottom: 12 } }, borderColor: "black", fillColor: "black", pathData: "M10 0L40 0L30 40L0 40Z" });
                    childNodes.push({ name: options.name + "_event_1", width: 24, height: 24, addInfo: { offset: { x: 0, y: 0 }, hAlign: "left", vAlign: "top", margin: { left: 18, top: 18 } } });
                    childNodes.push({ name: options.name + "_event_2", width: 20.4, height: 20.4, addInfo: { offset: { x: 0, y: 0 }, hAlign: "left", vAlign: "top", margin: { left: 18, top: 18 } } });
                    childNodes.push({ name: options.name + "_event_3", width: 12, height: 12, addInfo: { offset: { x: 0, y: 0 }, hAlign: "left", vAlign: "top", margin: { left: 18, top: 18 } } });

                    for (i = 0; i < childNodes.length; i++)
                        childNodes[i] = ej.datavisualization.Diagram.Node($.extend(true, {}, defaultProperty, childNodes[i]));

                    if (options.activity == "subprocess" && !options.subProcess.collapsed && options.subProcess.processes && options.subProcess.processes.length) {
                        for (var j = 0, process = options.subProcess.processes; j < options.subProcess.processes.length; j++) {
                            process[j] = ej.datavisualization.Diagram.Node(ej.datavisualization.Diagram.NodeType(process[j], diagram));
                            childNodes.push(process[j]);
                        }
                    }
                }
                options.constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
                options.children = this._updateBPMNActivityShape(options, childNodes);
                for (i = 0; i < options.children.length; i++)
                    childTable[options.children[i].name] = options.children[i];
                ej.datavisualization.Diagram.Util._updateBPMNProperties(options, diagram, childTable);
            return options;
        },
        _getBPMNGroupShape: function (options, diagram) {
            var childNodes = [], i = 0;
            if (options.children == undefined) options.children = [];
            for (i = 0; i < options.children.length; i++)
                if (diagram.nameTable[options.children[i].name || options.children[i]])
                    childNodes.push(diagram.nameTable[options.children[i].name || options.children[i]]);
            if (!childNodes.length) {
                for (i = 0; i < options.children.length; i++) {
                    var child = ej.datavisualization.Diagram.Node(ej.datavisualization.Diagram.NodeType(options.children[i], diagram));
                    if (child.type == "bpmn") childNodes.push(child);
                }
            }
            options.ports = [];
            options.children = childNodes;
            options.constraints = options.constraints ? options.constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
            options.constraints = options.constraints & ~ej.datavisualization.Diagram.NodeConstraints.Connect | ej.datavisualization.Diagram.NodeConstraints.AllowDrop;;
            return options;
        },

        _updateBPMNEventShape: function (node, childNodes, event, trigger) {
            var constraints;
            if (childNodes && childNodes[0]) {
                constraints = childNodes[0].constraints ? childNodes[0].constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
                if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                    constraints = constraints | ej.datavisualization.Diagram.NodeConstraints.Shadow;
                }
            }
            var defaultPathData = "M164.1884,84.6909000000001C156.2414,84.6909000000001,149.7764,78.2259000000001,149.7764,70.2769000000001C149.7764,62.3279000000001,156.2414,55.8629000000001,164.1884,55.8629000000001C172.1354,55.8629000000001,178.6024,62.3279000000001,178.6024,70.2769000000001C178.6024,78.2259000000001,172.1354,84.6909000000001,164.1884,84.6909000000001";
            var defaultChildNodes = [{ pathData: defaultPathData, fillColor: node.fillColor, constraints: constraints, shadow: node.shadow, borderWidth: node.borderWidth, borderColor: node.borderColor, borderDashArray: "1 0", opacity: node.opacity, gradient: node.gradient, visible: true },
                                     { pathData: defaultPathData, fillColor: node.fillColor, borderColor: node.borderColor, borderDashArray: "1 0", opacity: node.opacity, gradient: node.gradient, visible: true },
                                     { pathData: defaultPathData, fillColor: "white", borderColor: node.borderColor, opacity: node.opacity, height: childNodes[0].height * .5, visible: true }];
            $.extend(true, childNodes, defaultChildNodes);
            switch (event) {
                case "start":
                    childNodes[1].visible = false;
                    break;
                case "noninterruptingstart":
                    childNodes[0].borderDashArray = "2 3";
                    childNodes[1].visible = false;
                    break;
                case "intermediate":
                    childNodes[0].fillColor = "white";
                    childNodes[0].gradient = null;
                    break;
                case "noninterruptingintermediate":
                    childNodes[0].fillColor = "white";
                    childNodes[0].gradient = null;
                    childNodes[0].borderDashArray = "2 3";
                    childNodes[1].borderDashArray = "2 3";
                    break;
                case "throwingintermediate":
                case "end":
                    childNodes[0].fillColor = event != "end" ? "white" : node.borderColor;
                    childNodes[0].gradient = null;
                    childNodes[2].fillColor = "black";
                    childNodes[2].borderColor = node.fillColor;
                    break;
            }
            switch (trigger) {
                case ej.datavisualization.Diagram.BPMNTriggers.None:
                    childNodes[2].visible = false;
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Message:
                    childNodes[2].pathData = "M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0";
                    childNodes[2].height = 3 * childNodes[2].width / 4;
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Timer:                   
                    childNodes[2].pathData = "M40,20c0,8.654-5.496,16.024-13.189,18.81" +
                                             "C24.685,39.58,22.392,40,20,40C8.954,40,0,31.046,0,20S8.954,0,20,0S40,8.954,40,20z M20,0 L20,2.583 L20,5.283 M10.027,2.681 L11.659,5.507 L12.669,7.257 M2.731,9.989 L6.014,11.885 L7.307,12.631 M0.067,19.967 L2.667,19.967 L5.35,19.967" +
                                             "M2.748,29.939 L5.731,28.217 L7.323,27.298 M10.056,37.236 L11.292,35.095 L12.698,32.66 M20.033,39.9 L20.033,36.417 L20.033,34.617 M30.006,37.219 L28.893,35.292 L27.364,32.643 M37.302,29.911 L34.608,28.355 L32.727,27.269" +
                                             "M39.967,19.933 L37.417,19.933 L34.683,19.933 M37.286,9.961 L34.583,11.521 L32.71,12.602 M29.977,2.664 L28.653,4.957 L27.336,7.24 M22.104,8.5 L19.688,20 L24.75,20 L31.604,20 L24.75,20 L19.688,20z";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Error:                    
                    childNodes[2].pathData = "M 23.77 18.527 l -7.107 27.396 l 8.507 -17.247 L 36.94 40.073 l 6.394 -25.997 l -8.497 15.754 L 23.77 18.527 Z";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Escalation:
                    childNodes[2].pathData = "M 30.001 8.098 L 11.842 43.543 l 18.159 -18.882 l 18.162 18.882 L 30.001 8.098 Z ";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Cancel:
                    childNodes[2].pathData = "M 3.5 16 L 0 12.6 L 4.6 8 L 0 3.5 L 3.4 0 L 8 4.6 l 4.5 -4.5 L 16 3.5 L 11.5 8 l 4.5 4.5 l -3.4 3.5 L 8 11.4 L 3.5 16 Z";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Compensation:
                    childNodes[2].pathData = "M 25.7086 0 L 0 25 L 25.7086 50 V 26.3752 L 50 50 V 0 L 25.7086 23.6248 V 0 Z ";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Conditional:
                    childNodes[2].pathData = "M 0 0 H 16 V 16 H 0 z M 1.14 3.2 H 14.85 M 1.14 6.4 H 14.85 M 1.14 9.6 H 14.85 M 1.14 12.8 H 14.85";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Link:
                    childNodes[2].pathData = "M 32.014 19.258 v 5.992 H 9.373 v 9.504 h 22.641 v 5.988 L 50.622 30 L 32.014 19.258 Z";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Signal:
                    childNodes[2].pathData = "M 50 50 H 0 L 25.0025 0 L 50 50 Z";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Terminate:
                    childNodes[2].pathData = "M 25 50 C 11.21 50 0 38.79 0 25 C 0 11.21 11.21 0 25 0 C 38.78 0 50 11.21 50 25 C 50 38.79 38.78 50 25 50";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Multiple:                                 
                    childNodes[2].pathData = "M 17.784 48.889 H 42.21 l 7.548 -23.23 L 29.997 11.303 L 10.236 25.658 L 17.784 48.889 Z";
                    break;
                case ej.datavisualization.Diagram.BPMNTriggers.Parallel:
                    childNodes[2].pathData = "M 27.276 49.986 h 5.58 v -17.15 h 17.146 V 27.17 h -17.15 l 0.004 -17.15 h -5.58 l -0.004 17.15 H 9.994 v 5.666 h 17.278 L 27.276 49.986 Z";
                    break;
            }
            return childNodes;
        },
        _updateBPMNActivityShape: function (node, childNodes) {
            var constraints;
            if (childNodes && childNodes[0]) {
                constraints = childNodes[0].constraints ? childNodes[0].constraints : ej.datavisualization.Diagram.NodeConstraints.Default;
                if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                    constraints = constraints | ej.datavisualization.Diagram.NodeConstraints.Shadow;
                }
            }
            var defaultChildNodes = [{ fillColor: node.fillColor, borderWidth: node.borderWidth, constraints: constraints, shadow: node.shadow, borderColor: node.borderColor, borderDashArray: "1 0", opacity: node.opacity, gradient: node.gradient, pathData: this._updateRoundedRectanglePath(node, 12) },
                                    { fillColor: "white", borderColor: "black", width: 14, height: 14, opacity: node.opacity, visible: false },
                                    { addInfo: { margin: { left: 0 } }, opacity: node.opacity, visible: true }, { addInfo: { margin: { left: 0 } }, opacity: node.opacity, visible: true },
                                    { addInfo: { margin: { left: 0 } }, opacity: node.opacity, visible: false }, { addInfo: { margin: { left: 0 } }, opacity: node.opacity, visible: false },
                                    { opacity: node.opacity, visible: false }, { opacity: node.opacity, visible: false }, { opacity: node.opacity, visible: false }];
            var subActivities = [], start = 9, j = 0;
            $.extend(true, childNodes, defaultChildNodes);
            if (node.activity == "subprocess" && !node.subProcess.collapsed && childNodes.length > start && node.subProcess.processes.length)
                subActivities = childNodes.splice(childNodes.length - node.subProcess.processes.length, node.subProcess.processes.length);
            var loop = node.activity == "task" ? node.task.loop : node.subProcess.loop;
            var compensation = node.activity == "task" ? node.task.compensation : node.subProcess.compensation;
            switch (loop) {
                case "none":
                    childNodes[2].visible = false;
                    break;
                case "standard":
                    childNodes[2].pathData = "M 52.002 73.379 c -2.494 -2.536 -6.55 -2.534 -9.043 0 c -1.208 1.228 -1.874 2.861 -1.874 4.598 c 0 1.225 0.337 2.395 0.957 3.411 l -1.167 1.186 l 2.071 0.458 l 2.071 0.458 l -0.45 -2.106 l -0.45 -2.106 l -1.292 1.314 c -1.119 -2.065 -0.842 -4.709 0.877 -6.458 c 2.084 -2.119 5.475 -2.117 7.557 0 c 2.083 2.119 2.083 5.565 0 7.685 c -0.976 0.992 -2.272 1.557 -3.65 1.59 l 0.025 1.068 c 1.65 -0.041 3.2 -0.716 4.368 -1.903 c 1.208 -1.228 1.874 -2.861 1.874 -4.597 C 53.875 76.24 53.209 74.607 52.002 73.379 Z";
                    break;
                case "parallelmultiinstance":
                    childNodes[2].pathData = "M 51.5,69.5 L52.5,69.5 L52.5,84.5 L51.5 84.5 Z M 46.5,69.5 L47.5,69.5 L47.5,84.5 L46.5 84.5 Z M 41.5,69.5 L42.5,69.5 L42.5,84.5 L41.5 84.5 Z  ";
                    break;
                case "sequencemultiinstance":
                    childNodes[2].pathData = "M 40.375,71.5 L 55.375,71.5 L 55.375,72.5 L 40.375,72.5 Z M 40.375,76.5 L 55.375,76.5 L 55.375,77.5 L 40.375,77.5 Z M 40.375,76.5 L 55.375,76.5 L 55.375,77.5 L 40.375,77.5 Z M 40.375,81.5 L 55.375,81.5 L 55.375,82.5 L 40.375,82.5 Z";;
                    break;
            }
            if (compensation)
                childNodes[3].pathData = "M 22.462 18.754 l -6.79 3.92 l 6.79 3.92 V 22.89 l 6.415 3.705 v -7.841 l -6.415 3.705 V 18.754 Z M 28.331 19.701 v 5.947 l -5.149 -2.973 L 28.331 19.701 Z M 21.916 25.647 l -5.15 -2.973 l 5.15 -2.973 V 25.647 Z M 22.275 12.674 c -5.513 0 -9.999 4.486 -9.999 9.999 c 0 5.514 4.486 10.001 9.999 10.001 c 5.514 0 9.999 -4.486 9.999 -10.001 C 32.274 17.16 27.789 12.674 22.275 12.674 Z M 22.275 32.127 c -5.212 0 -9.453 -4.241 -9.453 -9.454 c 0 -5.212 4.241 -9.453 9.453 -9.453 c 5.212 0 9.453 4.241 9.453 9.453 C 31.728 27.887 27.487 32.127 22.275 32.127 Z";
            else
                childNodes[3].visible = false;
            var eventCollections = node.activity == ej.datavisualization.Diagram.BPMNActivity.Task ? node.task.events : node.subProcess.events;
            if (eventCollections && eventCollections.length) {
                for (var i = 0; i < eventCollections.length; i++) {
                    var eventNodes = childNodes.slice(start + i * 3, start + 3 + i * 3);
                    if (!eventNodes.length || eventNodes.length < 3) {
                        var constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.PointerEvents | ej.datavisualization.Diagram.NodeConstraints.Connect | ej.datavisualization.Diagram.NodeConstraints.Resize);
                        var defaultProperty = { parent: node.name, type: "group", constraints: constraints, rotateAngle: node.rotateAngle, _isInternalShape: true, opacity: node.opacity, addInfo: { offset: eventCollections[i].offset }, borderColor: "transparent", labels: [{ offset: { x: 0.5, y: 1 }, verticalAlignment: "top", margin: { top: 2 } }] };
                        eventCollections[i].offset = eventCollections[i].offset || {}
                        eventCollections[i].fillColor = 'transparent';
                        eventCollections[i].offset = ej.datavisualization.Diagram.Point(eventCollections[i].offset.x ? eventCollections[i].offset.x : null, eventCollections[i].offset.y ? eventCollections[i].offset.y : null);
                        eventCollections[i] = ej.datavisualization.Diagram.Node($.extend(true, { name: node.name + "_" + ej.datavisualization.Diagram.Util.randomId() }, ej.datavisualization.Diagram.BPMNEventDefaults, defaultProperty, eventCollections[i]));
                        eventCollections[i].ports = eventCollections[i].ports.length > 0 ? eventCollections[i].ports : node.ports;
                        eventNodes = [{ width: 24, height: 24 }, { width: 20.4, height: 20.4 }, { width: 12, height: 12 }];                      
                        for (var j = 0; j < eventNodes.length; j++) {
                            var eventDefaultProperty = { parent: eventCollections[i].name, type: "node", shape: "path", rotateAngle: eventCollections[i].rotateAngle, constraints: constraints, _isInternalShape: true, opacity: node.opacity, addInfo: { offset: eventCollections[i].offset } };
                            eventNodes[j] = ej.datavisualization.Diagram.Node($.extend(true, { name: eventCollections[i].name + "_" + ej.datavisualization.Diagram.Util.randomId() }, eventDefaultProperty, eventNodes[j]));
                        }
                        eventCollections[i].children = eventNodes                        
                    }
                    this._updateBPMNEventShape(node, eventNodes, eventCollections[i].event, eventCollections[i].trigger);
                }
                childNodes = childNodes.concat(eventCollections);
            }
            else
                childNodes.splice(start, childNodes.length - 1);
            if (node.activity == ej.datavisualization.Diagram.BPMNActivity.Task) {
                childNodes[1].visible = true;
                delete childNodes[1]._isService;
                switch (node.task.type) {
                    case "none":
                        childNodes[1].visible = false;
                        break;
                    case "service":
                        childNodes[1].pathData = "M 32.699 20.187 v -4.005 h -3.32 c -0.125 -0.43 -0.292 -0.83 -0.488 -1.21 l 2.373 -2.375 l -2.833 -2.83 l -2.333 2.333 c -0.44 -0.253 -0.9 -0.448 -1.387 -0.595 v -3.32 h -4.003 v 3.32 c -0.46 0.137 -0.89 0.322 -1.3 0.537 l -2.285 -2.275 l -2.833 2.83 l 2.285 2.278 c -0.235 0.42 -0.41 0.847 -0.547 1.307 h -3.33 v 4.005 h 3.33 c 0.148 0.488 0.343 0.955 0.588 1.395 l -2.325 2.325 l 2.822 2.832 l 2.373 -2.382 c 0.392 0.205 0.792 0.37 1.212 0.497 v 3.33 h 4.003 v -3.33 c 0.46 -0.138 0.89 -0.323 1.3 -0.547 l 2.43 2.432 l 2.822 -2.832 l -2.42 -2.422 c 0.222 -0.41 0.4 -0.85 0.535 -1.297 H 32.699 Z M 22.699 21.987 c -2.1 0 -3.803 -1.703 -3.803 -3.803 c 0 -2.1 1.703 -3.803 3.803 -3.803 c 2.1 0 3.803 1.703 3.803 3.803 C 26.502 20.285 24.8 21.987 22.699 21.987 Z";
                        childNodes[1]._isService = true;
                        break;
                    case "receive":
                        childNodes[1].pathData = "M 12.217 12.134 v 13.334 h 20 V 12.134 H 12.217 Z M 30.44 13.007 l -8.223 5.35 l -8.223 -5.35 H 30.44 Z M 13.09 24.594 V 13.459 l 9.127 5.94 l 9.127 -5.94 v 11.135 H 13.09 Z";
                        childNodes[1].height = 12;
                        break;
                    case "send":
                        childNodes[1].pathData = "M 45.7256 3.16055 L 25 23.4017 L 4.27442 3.16055 H 45.7256 Z M 47.8963 46.8413 H 2.10375 V 4.80813 L 25 27.1709 L 47.8963 4.80813 V 46.8413 Z";
                        childNodes[1].height = 12;
                        childNodes[1].fillColor = "black";
                        childNodes[1].borderColor = "white";
                        break;
                    case "instantiatingreceive":
                        childNodes[1].pathData = "M 16.306 17.39 v 8.79 h 13.198 v -8.79 H 16.306 Z M 28.375 17.946 l -5.47 3.558 l -5.47 -3.558 H 28.375 Z M 28.948 25.625 H 16.861 v -7.389 l 6.043 3.931 l 6.043 -3.931 V 25.625 Z M 22.905 11.785 c -5.514 0 -9.999 4.486 -9.999 10 c 0 5.514 4.485 10 9.999 10 s 9.999 -4.486 9.999 -10 C 32.904 16.272 28.419 11.785 22.905 11.785 Z M 22.905 31.239 c -5.212 0 -9.453 -4.241 -9.453 -9.454 c 0 -5.212 4.241 -9.453 9.453 -9.453 s 9.452 4.241 9.452 9.453 C 32.357 26.998 28.117 31.239 22.905 31.239 Z";
                        childNodes[1].width = 20;
                        childNodes[1].height = 20;
                        break;
                    case "manual":
                        childNodes[1].pathData = "M 13.183 15.325 h 2.911 c 0.105 0 0.207 -0.043 0.281 -0.117 c 0.078 -0.074 0.117 -0.176 0.117 -0.281 c 0 -0.753 0.718 -1.362 1.596 -1.362 h 2.579 c -0.117 0.227 -0.191 0.48 -0.195 0.757 c 0 0.433 0.168 0.851 0.46 1.144 c 0.008 0.004 0.015 0.011 0.019 0.015 c -0.289 0.285 -0.475 0.691 -0.479 1.148 c 0 0.433 0.168 0.846 0.46 1.139 c 0.011 0.012 0.023 0.02 0.035 0.032 c -0.301 0.281 -0.491 0.694 -0.495 1.155 c 0 0.432 0.168 0.847 0.46 1.143 c 0.265 0.266 0.612 0.414 0.975 0.414 h 0.839 c 0.027 0.004 0.051 0.012 0.074 0.012 h 8.443 c 0.352 0 0.636 0.344 0.636 0.761 c 0 0.414 -0.285 0.753 -0.636 0.753 h -6.687 c -0.019 0 -0.035 -0.008 -0.051 -0.008 h -2.27 c -0.121 -0.835 -0.667 -1.187 -1.795 -1.187 h -2.158 c -0.223 0 -0.402 0.18 -0.402 0.403 c 0 0.219 0.179 0.398 0.402 0.398 h 2.158 c 0.972 0 1.019 0.203 1.019 0.784 c 0 0.219 0.179 0.399 0.402 0.399 c 0.008 0 0.016 -0.004 0.027 -0.004 c 0.028 0.004 0.055 0.016 0.082 0.016 h 2.56 c 0.34 0.015 0.616 0.343 0.616 0.752 c 0 0.418 -0.285 0.757 -0.636 0.761 h -0.004 h -6.442 c -0.878 0 -1.595 -0.639 -1.595 -1.427 v -0.683 c 0 -0.109 -0.043 -0.211 -0.114 -0.285 c -0.078 -0.074 -0.179 -0.117 -0.285 -0.117 h -0.004 l -2.989 0.027 c -0.223 0 -0.398 0.184 -0.398 0.402 c 0 0.219 0.179 0.395 0.398 0.395 h 0.004 l 2.591 -0.02 v 0.282 c 0 1.229 1.073 2.223 2.391 2.223 h 3.895 c 0.004 0 0.007 0.004 0.011 0.004 h 2.536 c 0.792 0 1.436 -0.698 1.436 -1.561 c 0 -0.273 -0.07 -0.53 -0.188 -0.752 h 5.49 c 0.792 0 1.436 -0.695 1.436 -1.553 c 0 -0.858 -0.644 -1.557 -1.436 -1.557 h -3.566 c 0.121 -0.226 0.199 -0.487 0.199 -0.768 c 0 -0.468 -0.195 -0.882 -0.495 -1.167 c 0.301 -0.285 0.495 -0.698 0.495 -1.163 c 0 -0.456 -0.191 -0.866 -0.483 -1.152 c 0.293 -0.285 0.483 -0.694 0.483 -1.151 c 0 -0.858 -0.647 -1.557 -1.439 -1.557 h -8.373 c -1.167 0 -2.142 0.757 -2.352 1.76 l -2.548 -0.004 c -0.219 0 -0.399 0.18 -0.399 0.403 C 12.784 15.145 12.964 15.325 13.183 15.325 L 13.183 15.325 Z M 21.907 19.707 c -0.191 0 -0.328 -0.094 -0.41 -0.176 c -0.144 -0.145 -0.226 -0.355 -0.226 -0.577 c 0.003 -0.418 0.289 -0.753 0.643 -0.753 h 4.468 c 0.008 0 0.015 -0.004 0.027 -0.008 h 0.051 c 0.351 0 0.636 0.344 0.636 0.761 c 0 0.414 -0.286 0.753 -0.636 0.753 H 21.907 Z M 27.097 16.629 c 0 0.414 -0.286 0.753 -0.64 0.753 h -4.464 c -0.004 0 -0.004 0 -0.004 0 h -0.082 c -0.191 0 -0.328 -0.098 -0.414 -0.18 c -0.14 -0.145 -0.222 -0.352 -0.222 -0.573 c 0 -0.413 0.285 -0.749 0.631 -0.753 h 3.434 c 0 0 0 0 0.004 0 h 1.116 c 0.008 0 0.012 -0.004 0.02 -0.004 C 26.819 15.887 27.097 16.215 27.097 16.629 L 27.097 16.629 Z M 27.097 14.322 c 0 0.41 -0.278 0.737 -0.62 0.749 c -0.008 0 -0.012 0 -0.016 0 h -3.637 c -0.008 0 -0.015 0.004 -0.023 0.004 h -0.886 c -0.004 0 -0.008 0 -0.012 0 c -0.187 0 -0.324 -0.094 -0.406 -0.176 c -0.144 -0.144 -0.226 -0.355 -0.226 -0.577 c 0.003 -0.414 0.293 -0.753 0.643 -0.753 h 4.468 c 0.008 0 0.015 -0.004 0.027 -0.004 h 0.051 C 26.811 13.565 27.097 13.905 27.097 14.322 L 27.097 14.322 Z M 27.097 14.322";
                        childNodes[1].width = 20;
                        break;
                    case "businessrule":
                        childNodes[1].pathData = "M 32.844 13.245 h -0.089 v 0 H 13.764 v -0.015 h -1.009 v 16.989 h 0.095 v 0.011 h 19.716 v -0.011 h 0.278 V 13.245 Z M 31.844 14.229 v 4.185 h -18.08 v -4.185 H 31.844 Z M 18.168 25.306 v 3.938 h -4.404 v -3.938 H 18.168 Z M 13.764 24.322 v -4.923 h 4.404 v 4.923 H 13.764 Z M 19.177 25.306 h 12.667 v 3.938 H 19.177 V 25.306 Z M 19.177 24.322 v -4.923 h 12.667 v 4.923 H 19.177 Z";
                        break;
                    case "user":
                        childNodes[1].pathData = "M 21.762 21.935 c 2.584 0 4.687 -2.561 4.687 -5.703 c 0 -3.147 -2.103 -5.703 -4.687 -5.703 c -1.279 0 -2.475 0.61 -3.363 1.721 c -0.855 1.071 -1.327 2.484 -1.324 3.983 C 17.075 19.374 19.178 21.935 21.762 21.935 L 21.762 21.935 Z M 21.762 11.779 c 1.894 0 3.436 1.995 3.436 4.452 c 0 2.453 -1.541 4.452 -3.436 4.452 c -1.895 0 -3.44 -1.999 -3.44 -4.452 C 18.323 13.774 19.864 11.779 21.762 11.779 L 21.762 11.779 Z M 25.699 21.309 c -0.348 0 -0.626 0.277 -0.626 0.626 c 0 0.344 0.277 0.622 0.626 0.622 c 2.136 0 3.875 1.74 3.875 3.879 c 0 0.272 -0.227 0.498 -0.501 0.498 H 14.447 c -0.274 0 -0.497 -0.223 -0.497 -0.498 c 0 -2.139 1.736 -3.879 3.872 -3.879 c 0.344 0 0.625 -0.277 0.625 -0.622 c 0 -0.348 -0.28 -0.626 -0.625 -0.626 c -2.826 0 -5.124 2.297 -5.124 5.126 c 0 0.965 0.784 1.749 1.748 1.749 h 14.626 c 0.964 0 1.748 -0.784 1.748 -1.749 C 30.822 23.606 28.524 21.309 25.699 21.309 L 25.699 21.309 Z M 22.217 9.832 c 0.448 -0.263 0.924 -0.396 1.419 -0.396 c 1.895 0 3.436 1.995 3.436 4.452 c 0 0.439 -0.048 0.873 -0.143 1.284 c -0.08 0.336 0.128 0.672 0.464 0.751 c 0.048 0.012 0.098 0.019 0.143 0.019 c 0.284 0 0.541 -0.195 0.608 -0.483 c 0.119 -0.506 0.18 -1.034 0.18 -1.571 c 0 -3.147 -2.102 -5.703 -4.687 -5.703 c -0.711 0 -1.419 0.198 -2.054 0.573 c -0.296 0.174 -0.397 0.559 -0.219 0.855 C 21.536 9.911 21.921 10.009 22.217 9.832 L 22.217 9.832 Z M 27.697 18.81 c -0.345 0 -0.626 0.277 -0.626 0.622 c 0 0.348 0.281 0.626 0.626 0.626 c 2.137 0 3.75 1.782 3.75 3.918 c 0 0.07 -0.013 0.141 -0.043 0.205 c -0.14 0.314 0.003 0.684 0.318 0.823 c 0.082 0.037 0.167 0.055 0.253 0.055 c 0.241 0 0.466 -0.141 0.57 -0.373 c 0.101 -0.226 0.153 -0.464 0.153 -0.714 C 32.699 21.15 30.523 18.81 27.697 18.81 L 27.697 18.81 Z M 27.697 18.81";
                        break;
                    case "script":
                        childNodes[1].pathData = "M 22.453 15.04 c 0 0 -1.194 -3.741 2.548 -3.774 c 0 0 2.497 0.126 1.766 4.321 c -0.008 0.043 -0.015 0.086 -0.024 0.13 c -0.806 4.323 -2.516 8.42 -3.193 10.581 h 3.904 c 0 0 0.983 4.581 -2.549 4.968 H 13.292 c 0 0 -3.097 -1.42 -1.517 -5.323 l 3 -10.839 H 11.84 c 0 0 -1.129 -2.902 1.709 -3.806 l 11.425 -0.032 l -0.73 0.355 l -1.193 1.726 L 22.453 15.04 Z M 22.409 12.597 c 0 0 -0.242 0.483 -0.278 0.98 h -9.098 c 0 0 -0.06 -0.871 0.714 -1.041 L 22.409 12.597 Z M 26.341 27.734 c 0 0 -0.13 2.678 -2.226 1.871 c 0 0 -0.823 -0.565 -0.758 -1.855 L 26.341 27.734 Z M 22.905 15.008 c 0 0 0.653 -0.258 0.709 -1.501 c 0 0 0.145 -1.144 1.483 -0.693 c 0 0 0.808 0.355 0.259 2.404 c 0 0 -2.226 8.5 -3.032 10.339 c 0 0 -1.064 2.646 0.096 4.226 h -8.581 c 0 0 -1.806 -0.452 -0.741 -3.613 c 0 0 2.935 -9.549 3.193 -11.162 L 22.905 15.008 Z";
                        break;
                }
                if (node.task.call) childNodes[0].borderWidth = 4;
                if (node.task.compensation && node.task.loop != "none") {
                    childNodes[2].addInfo.margin.left -= childNodes[2].width / 2 + 2;
                    childNodes[3].addInfo.margin.left += childNodes[3].width / 2 + 2;
                }
            }
            else if (node.activity == ej.datavisualization.Diagram.BPMNActivity.SubProcess) {
                var markerX = 0, markerWidth = 0, index = 2;
                if (node.subProcess.collapsed) {
                    childNodes[4].constraints = childNodes[4].constraints | ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                    childNodes[4].visible = true;
                    childNodes[4].pathData = "M 8.13789 15 H 0 V 0 H 8.13789 V 15 Z M 0.625991 13.75 H 7.51189 V 1.25 H 0.625991 V 13.75 Z M 2.18095 7.03125 L 5.95631 7.03125 L 5.95631 7.46875 L 2.18095 7.46875 Z M 3.8342 3.73 L 4.30369 3.73 L 4.30369 11.2687 L 3.8342 11.2687 Z";
                }
                else {
                    childNodes[4].constraints = childNodes[4].constraints | ej.datavisualization.Diagram.NodeConstraints.PointerEvents;
                    childNodes[4].visible = true;
                    childNodes[4].pathData = "M 8.13789 15 H 0 V 0 H 8.13789 V 15 Z M 0.625991 13.75 H 7.51189 V 1.25 H 0.625991 V 13.75 Z M 2.18095 7.03125 L 5.95631 7.03125 L 5.95631 7.46875 L 2.18095 7.46875 Z M 3.8342 3.73 L 4.30369 3.73 L 4.30369 11.2687 L 3.8342 11.2687 Z";
                    childNodes[0] = $.extend(true, childNodes[0], { marginLeft: -node.paddingLeft, marginRight: -node.paddingRight, marginTop: -node.paddingTop, marginBottom: -node.paddingBottom, minWidth: node.width, minHeight: node.height });
                    node.constraints = node.constraints | ej.datavisualization.Diagram.NodeConstraints.AllowDrop;
                    node.minWidth = node.width;
                    node.minHeight = node.height;
                    while (j < subActivities.length) {
                        if (subActivities[j].type != "bpmn") subActivities.splice(j, 1);
                        j++;
                    }
                    childNodes = childNodes.concat(subActivities);
                }
                switch (node.subProcess.boundary) {
                    case "default":
                        childNodes[0].borderWidth = node.borderWidth;
                        childNodes[0].borderDashArray = "1 0";
                        break;
                    case "call":
                        childNodes[0].borderWidth = node.borderWidth < 4 ? 4 : node.borderWidth;;
                        childNodes[0].borderDashArray = "1 0";
                        break;
                    case "event":
                        childNodes[0].borderWidth = node.borderWidth;
                        childNodes[0].borderDashArray = "2 2";
                        break;
                }
                if (node.subProcess.adhoc) {
                    childNodes[5].visible = true;
                    childNodes[5].pathData = "M 49.832 76.811 v -2.906 c 0 0 0.466 -1.469 1.931 -1.5 c 1.465 -0.031 2.331 1.219 2.897 1.688 s 1.06 0.75 1.526 0.75 c 0.466 0 1.548 -0.521 1.682 -1.208 s 0.083 3.083 0.083 3.083 s -0.76 0.969 -1.859 0.969 c -1.066 0 -1.865 -0.625 -2.464 -1.438 s -1.359 -0.998 -2.064 -0.906 C 50.598 75.467 49.832 76.811 49.832 76.811 Z";
                }
                else if (node.subProcess.type == "event") {
                    childNodes[0].borderWidth = node.borderWidth;
                    childNodes[0].borderDashArray = "2 2";
                    this._updateBPMNEventShape(node, childNodes.slice(6, 9), node.subProcess.event, node.subProcess.trigger);

                }
                else if (node.subProcess.type == "transaction") {
                    var innerRect = { x: 3, y: 3, width: node.width - 3, height: node.height - 3 };
                    childNodes[0].pathData += ej.datavisualization.Diagram.DefautShapes._updateRoundedRectanglePath(innerRect, 12);
                }
                //Reset Marker's postion
                do {
                    if (childNodes[index].visible) {
                        childNodes[index].addInfo.margin.left = markerWidth + childNodes[index].width / 2;
                        markerWidth += childNodes[index].width + 2;
                    }
                    index++;
                } while (index < 6);
                markerWidth -= 2;
                index = 2;
                markerX = markerWidth / 2;
                do {
                    if (childNodes[index].visible)
                        childNodes[index].addInfo.margin.left -= markerX;
                    index++;
                } while (index < 6);
            }
            return childNodes;
        },
        _updateRoundedRectanglePath: function (node, a) {
            var d = "", i = 0;
            var points = [{ x: node.x || 0, y: node.y || 0 }, { x: node.x || 0, y: node.height }, { x: node.width, y: node.height }, { x: node.width, y: node.y || 0 }];
            var vector = [{ x: a, y: a }, { x: a, y: -a }, { x: -a, y: -a }, { x: -a, y: a }];
            for (i = 0; i < points.length; i++) {
                d += !d ? "M" : "L";
                d += (points[i].x + (i % 2 == 0 ? vector[i].x : 0)) + "," + (points[i].y + (i % 2 != 0 ? vector[i].y : 0));
                d += "C" + points[i].x + "," + points[i].y + " " + points[i].x + "," + points[i].y;
                d += " " + (points[i].x + (i % 2 != 0 ? vector[i].x : 0)) + "," + (points[i].y + (i % 2 == 0 ? vector[i].y : 0));
            }
            d += "L" + (points[0].x + vector[0].x) + "," + (points[0].y);
            d += "Z";
            return d;
        },

        initBPMNAnnotationShape: function (options, diagram) {
            var annotationNodes = [], n = 0;
            if (options._annotation && options._annotation.length) {
                while (n < options._annotation.length) {
                    var element = diagram.nameTable[options._annotation[n++]];
                    if (element && element.name.split('annotation_')[0] != options.name) options._annotation.splice(--n, 1);
                    else if (element) annotationNodes.push(element);
                    else break;
                }
            }
            if (options.annotation && options.annotation.text) {
                options = $.extend(false, {}, ej.datavisualization.Diagram.BPMNTextAnnotationDefaults, options);
                if (!annotationNodes.length) {
                    var visibility = ej.datavisualization.Diagram.PortVisibility.Hidden;
                    var portConstraints = ej.datavisualization.Diagram.PortConstraints.None;
                    var ports = [{ offset: { x: 0, y: 0.5 }, name: "left", visibility: visibility, constraints: portConstraints }, { offset: { x: 0.5, y: 0 }, name: "top", visibility: visibility, constraints: portConstraints }, { offset: { x: 1, y: 0.5 }, name: "right", visibility: visibility, constraints: portConstraints }, { offset: { x: 0.5, y: 1 }, name: "bottom", visibility: visibility, constraints: portConstraints }];
                    var name0 = options.name + "annotation_" + ej.datavisualization.Diagram.Util.randomId(), name1 = options.name + "annotation_" + ej.datavisualization.Diagram.Util.randomId();
                    var constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.Connect);
                    var connectorConstraints = ej.datavisualization.Diagram.ConnectorConstraints.Default & ~(ej.datavisualization.Diagram.ConnectorConstraints.DragSourceEnd | ej.datavisualization.Diagram.ConnectorConstraints.Drag);
                    if (options._annotation && options._annotation.length) {
                        name0 = typeof options._annotation[0] == "string" ? options._annotation[0] : options._annotation[0].name;
                        name1 = typeof options._annotation[1] == "string" ? options._annotation[1] : options._annotation[1].name;
                    }
                    else
                        options._annotation = [];
                    annotationNodes.push({ name: name0, labels: [{ text: options.annotation.text }], annotation: options.annotation, type: "bpmn", shape: "annotation", _type: "node", _shape: "path", ports: ports, constraints: constraints, width: options.annotation.width, height: options.annotation.height, _preventStretch: true });
                    annotationNodes.push({ name: name1, labels: [{ readOnly: true }], type: "connector", segments: [{ type: "straight" }], targetDecorator: { shape: "none" }, sourceNode: annotationNodes[0].name, targetNode: options.name, constraints: connectorConstraints, annotation: options.annotation, _isAnnotationLine: true });
                }
                annotationNodes[0].offsetX = options.offsetX + options.annotation.length * Math.cos(-options.annotation.angle * (Math.PI / 180));
                annotationNodes[0].offsetY = options.offsetY + options.annotation.length * Math.sin(-options.annotation.angle * (Math.PI / 180));
                var defaultChildNodes = [{ fillColor: "transparent", borderColor: options.borderColor, rotateAngle: options.rotateAngle, opacity: options.opacity, ports: [] },
                                        { lineColor: options.borderColor, opacity: options.opacity }];
                $.extend(true, annotationNodes, defaultChildNodes);
                var node = diagram.nameTable[annotationNodes[0].name], connector = diagram.nameTable[annotationNodes[1].name];
                if (!node) {
                    node = diagram._getNewNode(annotationNodes[0]);
                    diagram.nameTable[node.name] = node;
                    options._annotation.splice(0, 1, node.name);
                }
                if (!connector) {
                    connector = diagram._getNewConnector(annotationNodes[1]);
                    diagram.nameTable[connector.name] = connector;
                    options._annotation.splice(1, 1, connector.name);
                }
                this.updateBPMNAnnotationShape(connector, node, null, options, diagram);
            }
            return options;
        },
        renderBPMNAnnotationShape: function (node, diagram) {
            if (node._annotation && node._annotation.length) {
                for (var n = 0; n < node._annotation.length; n++) {
                    var element = typeof node._annotation[n] == "string" ? diagram.nameTable[node._annotation[n]] : node._annotation[n];
                    if (element) {
                        diagram.nameTable[element.name] = element;
                        var type = diagram.getObjectType(element);
                        if (type == "node") {
                            ej.datavisualization.Diagram.DiagramContext.renderNode(element, diagram);
                        }
                        else if (type == "connector") {
                            var disableSegmentChange = diagram._disableSegmentChange;
                            diagram._disableSegmentChange = false;
                            diagram._updateEdges(element);
                            diagram._dock(element, diagram.nameTable);
                            ej.datavisualization.Diagram.DiagramContext.renderConnector(element, diagram);
                            diagram._disableSegmentChange = disableSegmentChange;
                        }
                    }
                }
            }
        },
        updateBPMNAnnotationShape: function (element, annotationNode, previousTarget, currentTarget, diagram) {
            if (diagram.getObjectType(element) == "connector" && element._isAnnotationLine) {
                if (previousTarget && diagram.nameTable[previousTarget]) {
                    var prevNode = diagram.nameTable[previousTarget];
                    $.extend(true, prevNode, ej.datavisualization.Diagram.BPMNTextAnnotationDefaults);
                    delete prevNode._annotation;
                }
                if (!currentTarget) currentTarget = diagram.nameTable[element.targetNode];
                var annotationBounds = ej.datavisualization.Diagram.Util.bounds(annotationNode);
                var w = 20, h = 20, targetBounds;
                if (currentTarget) targetBounds = ej.datavisualization.Diagram.Util.bounds(currentTarget);
                else targetBounds = { x: element.targetPoint.x, y: element.targetPoint.y, width: element.lineWidth, height: element.lineWidth };
                var port = "";
                if (annotationBounds.x <= targetBounds.x + targetBounds.width && annotationBounds.x + annotationBounds.width >= targetBounds.x) {
                    if (annotationBounds.y + annotationBounds.height < targetBounds.y) port = "bottom";
                    if (annotationBounds.y > targetBounds.y + targetBounds.height) port = "top";
                }
                if (!port) {
                    if (annotationBounds.x > targetBounds.x + targetBounds.width) port = "left";
                    if (annotationBounds.x + annotationBounds.width < targetBounds.x) port = "right";
                }
                if (!port && !element.annotation.direction) port = "left";
                element.annotation.direction = port;
                annotationNode.labels[0].horizontalAlignment = annotationNode.labels[0].verticalAlignment = annotationNode.labels[0].textAlign = "center";
                switch (element.annotation.direction) {
                    case "left":
                        h = annotationBounds.height;
                        annotationNode.pathData = "M" + w + "," + h + " L0," + h + " L0,0 L" + w + ",0";
                        annotationNode.labels[0].horizontalAlignment = "left";
                        annotationNode.labels[0].textAlign = "left";
                        annotationNode.labels[0].offset = ej.datavisualization.Diagram.Point(0.05, 0.5);
                        break;
                    case "right":
                        h = annotationBounds.height;
                        w = annotationBounds.width - 20;
                        annotationNode.pathData = "M" + w + "," + h + " L" + (w + 20) + "," + h + " L" + (w + 20) + ",0 L" + w + ",0";
                        annotationNode.labels[0].horizontalAlignment = "right";
                        annotationNode.labels[0].textAlign = "right";
                        annotationNode.labels[0].offset = ej.datavisualization.Diagram.Point(0.95, 0.5);
                        break;
                    case "top":
                        w = annotationBounds.width;
                        annotationNode.pathData = "M" + w + "," + h + " L" + w + ",0 L0,0 L0," + h;
                        annotationNode.labels[0].verticalAlignment = "top";
                        annotationNode.labels[0].offset = ej.datavisualization.Diagram.Point(0.5, 0);
                        break;
                    case "bottom":
                        h = annotationBounds.height - 20;
                        w = annotationBounds.width;
                        annotationNode.pathData = "M" + w + "," + h + " L" + w + "," + (h + 20) + " L0," + (h + 20) + " L0," + h;
                        annotationNode.labels[0].verticalAlignment = "bottom";
                        annotationNode.labels[0].offset = ej.datavisualization.Diagram.Point(0.5, 1);
                        break;
                }
                if (diagram.nameTable[element.name]) {
                    var disableSegmentChange = diagram._disableSegmentChange;
                    diagram._disableSegmentChange = false;
                    element.annotation.direction = element.sourcePort = port;
                    diagram._updateEdges(element);
                    diagram._dock(element, diagram.nameTable);
                    diagram._disableSegmentChange = disableSegmentChange;
                }
                ej.datavisualization.Diagram.DiagramContext.update(annotationNode, diagram);
            }
        },
        translateBPMNAnnotationShape: function (node, sw, sh, pivot, diagram) {
            if (node.annotation && node.shape != "annotation") {
                var annotationNodes = [];
                if (node.annotation && node.annotation.text) {
                    node = $.extend(false, {}, ej.datavisualization.Diagram.BPMNTextAnnotationDefaults, node);
                    if (node._annotation && node._annotation.length) {
                        for (var n = 0; n < node._annotation.length; n++)
                            if (diagram.nameTable[node._annotation[n]])
                                annotationNodes.push(diagram.nameTable[node._annotation[n]]);
                        if (annotationNodes.length) {
                            var dx = sw, dy = sh;
                            //pivot is previous offset value
                            if (pivot) {
                                var dx = 0, dy = 0;
                                var matrix = ej.Matrix.identity();
                                if (node.rotateAngle) {
                                    ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                                    ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                                    ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                                }
                                else ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                                var diffx = node.offsetX - pivot.x, diffy = node.offsetY - pivot.y;
                                var cornerPoints = {
                                    bottom: { x: node.offsetX, y: bounds.y },
                                    left: { x: bounds.x + bounds.width, y: node.offsetY },
                                    top: { x: node.offsetX, y: bounds.y + bounds.height },
                                    right: { x: bounds.x, y: node.offsetY }
                                }
                                var pt = cornerPoints[annotationNodes[0].annotation.direction];
                                var oldPosition = ej.Matrix.transform(matrix, { x: pt.x - diffx, y: pt.y - diffy });
                                if (oldPosition.x != pt.x) dx = pt.x - oldPosition.x;
                                if (oldPosition.y != pt.y) dy = pt.y - oldPosition.y;
                            }
                            diagram._translate(annotationNodes[0], dx, dy, diagram.nameTable);
                        }
                    }
                }
            }
            else if (node.annotation && node.shape == "annotation") {
                var connector;
                for (var i = 0; i < node.outEdges.length; i++) {
                    var edge = diagram.nameTable[node.outEdges[i]];
                    if (edge._isAnnotationLine) {
                        connector = edge;
                        break;
                    }
                }
                if (connector) {
                    var target = node.targetNode ? diagram.nameTable[node.targetNode] : null;
                    this.updateBPMNAnnotationShape(connector, diagram.nameTable[connector.sourceNode], null, target, diagram);
                }
            }
        },
        updateAnnotationProperties: function (element, diagram) {
            if (diagram.getObjectType(element) == "node")
                element = diagram.nameTable[element.outEdges[0]];
            var currentTarget = diagram.nameTable[element.targetNode];
            var annotationNode = diagram.nameTable[element.sourceNode];
            if (currentTarget && annotationNode) {
                element.annotation.angle = ej.datavisualization.Diagram.Util._findAngle({ x: annotationNode.offsetX, y: annotationNode.offsetY }, { x: currentTarget.offsetX, y: currentTarget.offsetY }) * -1;
                element.annotation.length = ej.datavisualization.Diagram.Util.findLength({ x: currentTarget.offsetX, y: currentTarget.offsetY }, { x: annotationNode.offsetX, y: annotationNode.offsetY });
                annotationNode.annotation = currentTarget.annotation = $.extend(false, {}, element.annotation);
                currentTarget._annotation = [element.sourceNode, element.name];
                if (diagram.nodes().indexOf(annotationNode) > -1) {
                    ej.datavisualization.Diagram.Util.removeItem(diagram.nodes(), annotationNode);
                    ej.datavisualization.Diagram.Util.removeItem(diagram.connectors(), element);
                    diagram._nodes = $.extend(true, [], diagram.nodes());
                }
            }
            else if (annotationNode) {
                element.annotation.angle = ej.datavisualization.Diagram.Util._findAngle({ x: annotationNode.offsetX, y: annotationNode.offsetY }, element.targetPoint) * -1;
                element.annotation.length = ej.datavisualization.Diagram.Util.findLength(element.targetPoint, { x: annotationNode.offsetX, y: annotationNode.offsetY });
                annotationNode.annotation = $.extend(false, {}, element.annotation);
                diagram.nodes().push(annotationNode);
                diagram.connectors().push(element);
                diagram._nodes = $.extend(true, [], diagram.nodes());
            }
        },
        updateInlineDecoratorsShape: function (connector, diagram) {
            var node;
            if (connector.shape && connector.shape.type == "bpmn" && connector.shape.flow == "message") {
                if (connector._inlineDecorators.length) {
                    var nodes = connector._inlineDecorators.filter(function (e) { if (e.name == connector.name + "_" + connector.shape.message) return e; });
                    if (nodes.length) node = nodes[0];

                }
                connector._inlineDecorators = [];
                if (connector.shape.message == "initiatingmessage" || connector.shape.message == "noninitiatingmessage") {
                    var position = ej.datavisualization.Diagram.Util._findOffsetOnConnector(connector, { segmentOffset: 0.5 }, 0.5, diagram);
                    var fillColor = connector.shape.message == "noninitiatingmessage" ? "lightgrey" : "white";
                    if (node) {
                        node.offsetX = position.offset.x; node.offsetY = position.offset.y; node.fillColor = fillColor;
                    } else
                        node = ej.datavisualization.Diagram.Node({ name: connector.name + "_" + connector.shape.message, width: 25, height: 15, offsetX: position.offset.x, offsetY: position.offset.y, fillColor: fillColor, shape: "path", pathData: "M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0", constraints: ej.datavisualization.Diagram.NodeConstraints.Delete });
                    connector._inlineDecorators.push(node);
                }
            }
            return connector;
        },
        //#endregion
    };
    ej.datavisualization.Diagram.bpmnHelper = {
        resetNodeMargin: function (node, overnode, diagram) {
            var margins = { marginLeft: node.marginLeft, marginRight: node.marginRight, marginTop: node.marginTop, marginBottom: node.marginBottom };
            ej.datavisualization.Diagram.canvasHelper._updateNodeMargin(diagram, node, overnode);
            if (overnode && overnode._type == "group") {
                for (var i = 0; i < overnode.children.length; i++) {
                    var child = typeof overnode.children[i] == "string" ? diagram.nameTable[overnode.children[i]] : overnode.children[i];
                    for (var margin in margins)
                        if (margins[margin] == 0) child[margin] = 0;
                }
            }
        },
        updateCanvas: function (node, diagram) {
            if (!diagram._isUndo) ej.datavisualization.Diagram.canvasHelper._updateNodeMargin(diagram, node, diagram.nameTable[node.parent])
            if (node.container && node.container.type === "canvas") {
                ej.datavisualization.Diagram.canvasHelper._setSize(diagram, node, true);
                this.updateProcessCollection(node, diagram);
                if (node.parent && diagram.nameTable[node.parent]) {
                    var parent = diagram.nameTable[node.parent];
                    this.resetNodeMargin(node, parent, diagram);
                    this.updateCanvas(parent, diagram);
                }
                else {
                    ej.datavisualization.Diagram.canvasHelper._updateNodeMargin(diagram, node, diagram.nameTable[node.parent]);
                }
                if (diagram.nameTable[node.name]) {
                    var disableSegmentChange = diagram._disableSegmentChange;
                    diagram._disableSegmentChange = false;
                    diagram._updateAssociatedConnectorEnds(node, diagram.nameTable);
                    ej.datavisualization.Diagram.DiagramContext.update(node, diagram);
                    diagram._disableSegmentChange = disableSegmentChange;
                }
            }
        },
        updateProcessCollection: function (node, diagram) {
            if (node.shape == "activity" && node.activity == "subprocess") {
                var process = node.subProcess.processes, i = 0;
                var children = diagram._getChildren(node.children);
                while (process && process.length && i < process.length) {
                    if (children.indexOf(process[i].name) == -1)
                        ej.datavisualization.Diagram.Util.removeItem(process, process[i]);
                    else
                        process[i] = diagram.nameTable[process[i++].name];
                }
                for (var i = 0; i < node.children.length; i++) {
                    var child = typeof node.children[i] == "string" ? diagram.nameTable[node.children[i]] : node.children[i];
                    if (!child._isInternalShape && process.indexOf(child) == -1)
                        process.push(child);
                }
            }
        },
        isBPMNContainerChild: function (node, diagram) {
            if (node && node.parent) {
                var parent = diagram.nameTable[node.parent];
                return (parent && parent.type == "bpmn" && parent.shape != "group" && parent.container && parent.activity !== "subprocess") ? true : false;
            }
        },
        canMoveOutofBounds: function (diagram, element, ptX, ptY) {
            if (diagram.getObjectType(element) == "connector") {
                if (element.sourceNode || element.targetNode) {
                    var node = diagram.nameTable[element.sourceNode || element.targetNode];
                    if (node && this.isBPMNContainerChild(node, diagram)) {
                        var bpmnContainer = diagram.nameTable[node.parent];
                        var bounds = ej.datavisualization.Diagram.Util.bounds(bpmnContainer);
                        bounds = ej.datavisualization.Diagram.Geometry.rect([bounds.topLeft, bounds.topRight, bounds.bottomRight, bounds.bottomLeft]);
                        return ((ptX >= bounds.x + bounds.width || ptX <= bounds.x) || (ptY >= bounds.y + bounds.height || ptY <= bounds.y)) ? false : true;
                    }
                }
            }
            return true;
        },
        canAllowConnection: function (diagram, connectedNode, possibleConnection) {
            var parent = null, element = null;
            if (connectedNode && possibleConnection && possibleConnection.type == "bpmn") {
                if (possibleConnection.parent)
                    parent = diagram.nameTable[possibleConnection.parent];
                if (parent && parent.type == "bpmn" && parent.shape != "group" && connectedNode.parent != possibleConnection.parent)
                    return parent;
                else if (diagram._containsChild(possibleConnection, connectedNode) || diagram._containsChild(connectedNode, possibleConnection))
                    return null;
            }
            return possibleConnection;
        },
        canAllowDropOnContainer: function (node, target) {
            if (target.type != "bpmn" || (node.type == "bpmn" && node.shape != "annotation"))
                return true;
            return false;
        }
    };
})(jQuery, Syncfusion);;

(function ($, ej) {
    "use strict";

    //#region SVG
    var Svg = (function () {
        function Svg(attr) {
            this.xmlns = "http://www.w3.org/2000/svg";
            this.document = document.createElementNS(this.xmlns, "svg");
            this.id = attr.id;
            if (attr) {
                ej.datavisualization.Diagram.Util.attr(this.document, attr);
            }
            return this;
        }
        Svg.prototype.element = function (attr, tag) {
            var element;
            if (attr && attr.id) {
                element = this.document.getElementById(attr.id);
            }
            if (!element) {
                element = document.createElementNS(this.xmlns, tag);
            }
            if (attr)
                ej.datavisualization.Diagram.Util.attr(element, attr);
            return element;
        };
        Svg.prototype.g = function (attr) {
            return this.element(attr, "g");
        };
        Svg.prototype.defs = function (attr) {
            return this.element(attr, "defs");
        };
        Svg.prototype.image = function (attr) {
            return this.element(attr, "image");
        };
        Svg.prototype.path = function (attr) {
            return this.element(attr, "path");
        };
        Svg.prototype.text = function (attr) {
            return this.element(attr, "text");
        };
        Svg.prototype.textPath = function (attr) {
            return this.element(attr, "textPath");
        };
        Svg.prototype.tspan = function (attr) {
            return this.element(attr, "tspan");
        };
        Svg.prototype.rect = function (attr) {
            return this.element(attr, "rect");
        };
        Svg.prototype.ellipse = function (attr) {
            return this.element(attr, "ellipse");
        };
        Svg.prototype.circle = function (attr) {
            return this.element(attr, "circle");
        };
        Svg.prototype.title = function (attr) {
            return this.element(attr, "title");
        };
        Svg.prototype.line = function (attr) {
            return this.element(attr, "line");
        };
        Svg.prototype.polyline = function (attr) {
            return this.element(attr, "polyline");
        };
        Svg.prototype.polygon = function (attr) {
            return this.element(attr, "polygon");
        };
        Svg.prototype.foreignObject = function (attr) {
            return this.element(attr, "foreignObject");
        };
        Svg.prototype.linearGradient = function (attr) {
            return this.element(attr, "linearGradient");
        };
        Svg.prototype.radialGradient = function (attr) {
            return this.element(attr, "radialGradient");
        };
        Svg.prototype.stop = function (attr) {
            return this.element(attr, "stop");
        };
        Svg.prototype.pattern = function (attr) {
            return this.element(attr, "pattern");
        };
        Svg.prototype.appendChild = function (element) {
            this.document.appendChild(element);
        };
        Svg.prototype.removeChild = function (element, parent) {
            if (parent) {
                parent.removeChild(element);
            } else {
                this.document.removeChild(element);
            }
        };
        Svg.prototype.getElementById = function (id) {
            return this.document.getElementById(id);
        };
        Svg.prototype.getElementsByClassName = function (name) {
            return this.document.getElementsByClassName(name);
        };
        Svg.prototype.getElementsByTagName = function (name) {
            return this.document.getElementsByTagName(name);
        };
        Svg.prototype.pathBounds = function (data) {
            var attributes = { d: data };
            var path = this.path(attributes);
            var svg = new ej.datavisualization.Diagram.Svg({ "id": "TempSvg" });
            document.body.appendChild(svg.document);
            svg.document.appendChild(path);
            var bounds = path.getBBox();
            document.body.removeChild(svg.document);
            return bounds;
        };
        Svg.prototype.textBounds = function (text, attr, textElement) {
            var bounds = null;
            if (text && attr) {
                var svgText = this.text(attr);
                svgText.appendChild(document.createTextNode(text));
                this.document.appendChild(svgText);
                bounds = svgText.getBBox();
                this.document.removeChild(svgText);
            }
            else if (textElement) {
                this.document.appendChild(textElement);
                bounds = textElement.getBBox();
                this.document.removeChild(textElement);
            }
            return bounds;
        };
        Svg.prototype.absolutePath = function (path) {
            var x0, y0, x1, y1, x2, y2, segs = ej.datavisualization.Diagram.Util.convertPathToArray(path.getAttribute("d"));
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(char)) {
                    if ('x' in seg) x = seg.x;
                    if ('y' in seg) y = seg.y;
                } else {
                    if ('x1' in seg) x1 = x + seg.x1;
                    if ('x2' in seg) x2 = x + seg.x2;
                    if ('y1' in seg) y1 = y + seg.y1;
                    if ('y2' in seg) y2 = y + seg.y2;
                    if ('x' in seg) x += seg.x;
                    if ('y' in seg) y += seg.y;
                    var newSeg;
                    switch (char) {
                        case 'm':
                            newSeg = { pathSegTypeAsLetter: "M", x: x, y: y };
                            break;
                        case 'l':
                            newSeg = { pathSegTypeAsLetter: "L", x: x, y: y };
                            break;
                        case 'h':
                            newSeg = { pathSegTypeAsLetter: "H", x: x };
                            break;
                        case 'v':
                            newSeg = { pathSegTypeAsLetter: "V", y: y };
                            break;
                        case 'c':
                            newSeg = { pathSegTypeAsLetter: "C", x: x, y: y, x1: x1, y1: y1, x2: x2, y2: y2 };
                            break;
                        case 's':
                            newSeg = { pathSegTypeAsLetter: "S", x: x, y: y, x2: x2, y2: y2 };
                            break;
                        case 'q':
                            newSeg = { pathSegTypeAsLetter: "Q", x: x, y: y, x1: x1, y1: y1 };
                            break;
                        case 't':
                            newSeg = { pathSegTypeAsLetter: "T", x: x, y: y };
                            break;
                        case 'a':
                            newSeg = { pathSegTypeAsLetter: "A", x: x, y: y, r1: seg.r1, r2: seg.r2, angle: seg.angle, largeArcFlag: seg.largeArcFlag, sweepFlag: seg.sweepFlag };
                            break;
                        case 'z':
                        case 'Z':
                            x = x0; y = y0;
                            newSeg = segs[i];
                            break;
                    }
                    if (newSeg)
                        segs[i] = newSeg;
                }
                if (char === 'M' || char === 'm') x0 = x, y0 = y;
            }
            path.setAttribute("d", ej.datavisualization.Diagram.Util.pathSegArrayAsString(segs));
            return path;
        };
        return Svg;
    })();

    ej.datavisualization.Diagram.Svg = Svg;
    //#endregion

    //#region SVG Renderer
    ej.datavisualization.Diagram.SvgContext = {

        _renderDocument: function (view, diagram, isload) {
            if (window.SVGSVGElement) {
                var svgParent = $("#" + view.canvas.id + "_svgParent")[0];
                if (!svgParent)
                    svgParent = document.createElement("div");
                var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(diagram);
                var attr = {
                    "id": view.canvas.id + "_svgParent",
                    "style": "height:auto;width:auto;position:absolute;overflow:hidden;left:" + rulerSize.left + "px;top:" + rulerSize.top + "px;bottom:0px;"
                }
                ej.datavisualization.Diagram.Util.attr(svgParent, attr);
                view.canvas.appendChild(svgParent);
                diagram._svgParent = svgParent;
                var attr = {
                    id: view.canvas.id + "_svg",
                    version: "1.1",
                    "style": "position:absolute;",
                    "class": "mainview_svg",
                    "role": "img",
                };
                if (ej.isMobile())
                    attr.style = "position: inherit";
                if (!isload)
                    var svg = new ej.datavisualization.Diagram.Svg(attr);
                else
                    svg = diagram._svg
                view.svg = svg;
                if (diagram) {
                    this._renderRulers(diagram, view.canvas, view.svg, isload)
                    diagram._svg = svg;
                    if (!isload && !document.getElementById(svg.document.id)) {
                        diagram._svgParent.appendChild(svg.document);
                    }
                    diagram._view = this._renderView(view.canvas, view.svg, isload);
                    diagram._page = this._renderPage(view.canvas, view.svg, diagram._view, isload);
                    this._renderBackground(diagram, view.canvas, view.svg, diagram._page, diagram.model, isload);
                    diagram._pageBackgroundLayer = this._renderBackgroundLayer(view.canvas, view.svg, diagram._page, isload);
                    this._renderGrid(view.canvas, view.svg, diagram._page, diagram);
                    diagram._diagramLayer = view.diagramLayer = this._renderDiagramLayer(view.canvas, view.svg, diagram._page);
                    diagram._htmlLayer = this._renderHtmlLayer(view.canvas, isload, diagram);
                    this._renderAdornerLayer(diagram, view.canvas, isload, view);
                }
                else {


                }
            }
        },
        _renderRulers: function (diagram, canvas, svg, isload) {
            if (diagram.model.rulerSettings.showRulers) {
                this._renderOverLappingElement(diagram, canvas, svg, isload);
                this._renderRuler(diagram, canvas, svg, false, isload);
                this._renderRuler(diagram, canvas, svg, true, isload);
            }
            else {
                var div
                div = document.getElementById(canvas.id + "_hRuler");
                if (div) div.parentNode.removeChild(div);
                div = document.getElementById(canvas.id + "_vRuler");
                if (div) div.parentNode.removeChild(div);
                div = document.getElementById(canvas.id + "_overlap-Ruler")
                if (div) div.parentNode.removeChild(div);

            }
        },
        _renderOverLappingElement: function (diagram, canvas, svg, isload) {
            var div = document.getElementById(canvas.id + "_overlap-Ruler"), rulerSize, style;
            if (!div) {
                div = document.createElement("div");
                rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(diagram);
                div.setAttribute("id", canvas.id + "_overlap-Ruler")
                style = "height: " + rulerSize.top + "px;width:" + rulerSize.left + "px;position:absolute;left:0;top:0";
                div.setAttribute("style", style)
                div.setAttribute("class", "sf-diagram_overlap");
            }
            canvas.insertBefore(div, canvas.firstChild)
        },
        _updateRulerSpace: function (diagram, rulerGeometry, isHorizontal) {
            var div = document.getElementById(diagram._canvas.id + (isHorizontal ? "_hRuler" : "_vRuler"));
            var ruler = isHorizontal ? diagram._hRulerInstance : diagram._vRulerInstance;
            if (div && diagram && rulerGeometry) {
                if (isHorizontal) {
                    div.style.width = (rulerGeometry.width + (diagram._hRulerInstance.model.segmentWidth * 2)) + "px";
                    div.style.height = ruler.model.thickness + "px";
                    div = document.getElementById(diagram._canvas.id + "_overlap-Ruler")
                    if (div)
                        div.style.height = ruler.model.thickness + "px";

                }
                else {
                    div.style.height = (rulerGeometry.height + (diagram._vRulerInstance.model.segmentWidth * 2)) + "px";
                    div.style.width = ruler.model.thickness + "px";
                    div = document.getElementById(diagram._canvas.id + "_overlap-Ruler")
                    if (div)
                        div.style.width = ruler.model.thickness + "px";
                }
            }
        },
        _renderRuler: function (diagram, canvas, svg, isHorizontal, isload) {
            var div = document.getElementById(canvas.id + (isHorizontal ? "_hRuler" : "_vRuler"));
            var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(diagram);
            var rulerGeometry = ej.datavisualization.Diagram.ScrollUtil._getRulerGeometry(diagram);
            if (!div) {
                div = document.createElement("div");
                if (isHorizontal)
                    var style = "height: " + rulerSize.top + "px;width:" + (rulerGeometry.width) + "px;margin-left:" + rulerSize.left + "px;" + "";
                else
                    var style = "height:" + rulerGeometry.height + "px;width: " + rulerSize.left + "px;" + "float:left;top:" + rulerSize.top + "px;";
                div.setAttribute("id", canvas.id + (isHorizontal ? "_hRuler" : "_vRuler"))
                div.setAttribute("style", style)
                div.setAttribute("class", (isHorizontal ? "sf-diagram_hRuler" : "sf-diagram_hRuler"));
            }
            //canvas.appendChild(div);
            canvas.insertBefore(div, canvas.firstChild)
            var ruler = isHorizontal ? diagram.model.rulerSettings.horizontalRuler : diagram.model.rulerSettings.verticalRuler
            ruler = $.extend(true, {}, ruler);
            ruler.length = (isHorizontal ? rulerGeometry.width : rulerGeometry.height) + ruler.segmentWidth;
            ruler.orientation = isHorizontal ? "horizontal" : "vertical";
            var rulerObj = $("#" + div.id).ejRuler(ruler);
            var rulerInstance = $("#" + div.id).ejRuler("instance");
            if (isHorizontal) {
                diagram._hRuler = rulerObj;
                diagram._hRulerInstance = rulerInstance;
            }
            else {
                diagram._vRuler = rulerObj;
                diagram._vRulerInstance = rulerInstance;
            }
        },

        _renderView: function (canvas, svg, isload) {
            var view = svg.document.getElementById(canvas.id + "_view");
            if (!view) {
                var attr = { id: canvas.id + "_view" };
                view = svg.g(attr);
            }
            if (!isload)
                svg.appendChild(view);
            return view;
        },

        _renderHtmlLayer: function (canvas, isload, diagram) {
            var div = document.getElementById(canvas.id + "_htmlLayer");
            if (!div)
                div = document.createElement("div");
            var attr = { "id": canvas.id + "_htmlLayer", "class": "htmlLayer" };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            var htmlLayer = div;
            div.style.pointerEvents = "none";
            if (!isload) {
                diagram._svgParent.appendChild(htmlLayer);
            }
            return htmlLayer;
        },

        _renderAdornerLayer: function (diagram, canvas, isload, view) {
            var div = document.getElementById(canvas.id + "_adorner");
            if (!div)
                div = document.createElement("div");
            var attr = { "id": canvas.id + "_adorner", "class": "adornerLayer_parent_div", "style": "position:absolute;left:0px;top:0px" };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            diagram._adornerLayer = this._renderAdornerSvg(diagram, canvas, div, isload, view);
            diagram._tooltipLayer = this._renderTooltipLayer(canvas, div, isload);
            if (!isload)
                diagram._svgParent.appendChild(div);
        },

        _renderTooltipLayer: function (canvas, parent, isload) {
            var div = document.getElementById(canvas.id + "_tooltip");
            if (!div)
                div = document.createElement("div");
            var attr = { "id": canvas.id + "_tooltip", "class": "diagram_tooltip" };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            var tooltipdiv = div;
            div.style.pointerEvents = "none";
            if (!isload)
                parent.appendChild(tooltipdiv);
            return tooltipdiv;
        },

        _renderPage: function (canvas, svg, parent, isload) {
            var page = svg.document.getElementById(canvas.id + "_page");
            if (!page) {
                var attr = { "id": canvas.id + "_page", "class": "page" };
                page = svg.g(attr);
            }
            if (!isload)
                parent.appendChild(page);
            return page;
        },

        _renderDiagramLayer: function (canvas, svg, parent) {
            var diagramLayer = svg.document.getElementById(canvas.id + "_diagramLayer");
            if (!diagramLayer) {
                var attr = { "id": canvas.id + "_diagramLayer", "class": "DiagramLayer" };
                diagramLayer = svg.g(attr);
                parent.appendChild(diagramLayer);
            }
            return diagramLayer;
        },

        _renderAdornerSvg: function (diagram, canvas, parent, isload, view) {
            if (window.SVGSVGElement) {
                var attr = {
                    id: canvas.id + "_svg_adorner",
                    version: "1.1",
                    "style": "position:absolute",
                    "fill": "none",
                    "pointer-events": "none"
                };
                var svg;
                if (!isload)
                    svg = new ej.datavisualization.Diagram.Svg(attr);
                else
                    svg = diagram._adornerSvg;
                if (!isload && !document.getElementById(svg.document.id))
                    parent.appendChild(svg.document);
                var expander = svg.document.getElementById(canvas.id + "_expander");
                if (!expander) {
                    var attr = { "id": canvas.id + "_expander", "class": "ExpanderLayer", "pointer-events": "all" };
                    expander = svg.g(attr);
                    svg.document.appendChild(expander);
                }
                view._expander = diagram._expander = expander;
                var adornerLayer = svg.document.getElementById(canvas.id + "_adornerLayer");
                if (!adornerLayer) {
                    var attr = { "id": canvas.id + "_adornerLayer", "class": "AdornerLayer", "pointer-events": "none" };
                    adornerLayer = svg.g(attr);
                    svg.document.appendChild(adornerLayer);
                }
                var portLayer = svg.document.getElementById(canvas.id + "_portLayer");
                if (!portLayer) {
                    var attr = { "id": canvas.id + "_portLayer", "class": "portLayer", "pointer-events": "none" };
                    portLayer = svg.g(attr);
                    adornerLayer.appendChild(portLayer);
                }
                diagram._adornerSvg = svg;
                return adornerLayer;
            }
        },

        _renderBackgroundLayer: function (canvas, svg, parent, isload) {
            var pageBackgroundLayer = svg.document.getElementById(canvas.id + "_pageBackground");
            if (!pageBackgroundLayer) {
                var attr = {
                    "id": canvas.id + "_pageBackground",
                    "class": "PageBackgroundLayer",
                    "style": "pointer-events:none;",
                };
                pageBackgroundLayer = svg.g(attr);
            }
            if (!isload)
                parent.appendChild(pageBackgroundLayer);
            return pageBackgroundLayer;
        },

        _renderBackground: function (diagram, canvas, svg, parent, model, isload) {
            svg.document.style.msTouchAction = "none";
            svg.document.style.display = "block";
            svg.document.style.backgroundColor = "white";
            var attr = { id: canvas.id + "_backgroundLayer" };
            var g = svg.g(attr);
            var pageBounds = diagram._getDigramBounds();
            if (diagram._backgroundImage()) {
                var bgImg = diagram._backgroundImage();
                var alignment = ej.datavisualization.Diagram.Util._getImageAlignment(bgImg.alignment);
                var preserveAspectRatio = "none " + alignment != "none" && bgImg.scale != "none" ? alignment + " " + bgImg.scale : "none";
                attr = { "id": canvas.id + "_backgroundImage", "x": pageBounds.x, "y": pageBounds.y, "width": pageBounds.width, "height": pageBounds.height, "preserveAspectRatio": preserveAspectRatio, "pointer-events": "none" };
                var image = svg.image(attr);
                image.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", bgImg.source);
                if (!svg.getElementById(canvas.id + "_backgroundImage")) {
                    g.appendChild(image);
                }
            }
            var bgColor = diagram._backgroundColor();
            var rect = svg.rect({
                "id": canvas.id + "_backgroundColor", "width": "100%", "height": "100%", "fill": bgColor, "pointer-events": "none"

            });
            if (bgColor) {
                if (!svg.getElementById(canvas.id + "_backgroundColor")) {
                    g.appendChild(rect);
                }
            }
            else {
                if (svg.getElementById(rect.id)) {
                    g.removeChild(svg.getElementById(rect.id));
                }
            }

            if (!svg.getElementById(g.id))
                parent.appendChild(g);

        },

        _renderGrid: function (canvas, svg, parent, diagram) {
            var defs = diagram._svg.document.getElementById(canvas.id + "patterndefinition")
            if (!defs) {
                defs = svg.defs({ "id": canvas.id + "patterndefinition" });
                svg.appendChild(defs);
            }
            var g;
            if (diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.ShowHorizontalLines ||
                diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.ShowVerticalLines) {
                var grid = document.getElementById(canvas.id + "_grid");
                var rect = document.getElementById(canvas.id + "pattern_gridline");
                var pattern = document.getElementById(canvas.id + "pattern_grid");
                if (pattern && pattern.parentNode)
                    pattern.parentNode.removeChild(pattern);
                var attr = { id: canvas.id + "_grid", "pointer-events": "none" };
                g = svg.g(attr);
                var height = 0;
                if (diagram.model.snapSettings.horizontalGridLines.linesInterval) {
                    diagram.model.snapSettings.horizontalGridLines.linesInterval.forEach(function (entry) {
                        height += entry;
                    });
                }
                var width = 0;
                if (diagram.model.snapSettings.verticalGridLines.linesInterval) {
                    diagram.model.snapSettings.verticalGridLines.linesInterval.forEach(function (entry) {
                        width += entry;
                    });
                }
                var scale = this._scaleSnapInterval(diagram.model, diagram._currZoom);;

                attr = { id: canvas.id + "pattern_grid", x: 0, y: 0, width: width * scale, height: height * scale, patternUnits: "userSpaceOnUse" };
                var pattern = svg.pattern(attr);
                //pattern.setAttribute("patternUnits", "userSpaceOnUse");
                scale = this._scaleSnapInterval(diagram.model, scale);
                this._renderHorizontalGridlines(scale, pattern, width, diagram, svg);
                this._renderVerticalGridlines(scale, pattern, height, diagram, svg);
                defs.appendChild(pattern);
                var rect = svg.rect({ id: canvas.id + "pattern_gridline", "x": diagram._hScrollOffset, "y": diagram._vScrollOffset, "width": "100%", "height": "100%", "fill": "url(#" + canvas.id + "pattern_grid)" });
                g.appendChild(rect);
                if (!grid) {
                    if (diagram._diagramLayer) { parent.insertBefore(g, diagram._diagramLayer); }
                    else
                        parent.appendChild(g);
                }
            }
            else {
                g = document.getElementById(canvas.id + "_grid");
                if (g) {
                    var grid = document.getElementById(canvas.id + "pattern_gridline");
                    if (grid && grid.parentNode)
                        grid.parentNode.removeChild(grid);
                }
            }
        },

        _updateBackground: function (hoffset, voffset, scale, diagram) {
            var attr = {
                x: hoffset,
                y: voffset
            };
            var bgClr = document.getElementById(diagram._id + "_canvas_backgroundColor");
            if (bgClr)
                ej.datavisualization.Diagram.Util.attr(bgClr, attr);
            var bgImg = document.getElementById(diagram._id + "_canvas_backgroundImage");
            var pageBounds = diagram._getDigramBounds();
            if (bgImg)
                ej.datavisualization.Diagram.Util.attr(bgImg, { "transform": "scale(" + scale + ")", "x": pageBounds.x, "y": pageBounds.y, "width": pageBounds.width, "height": pageBounds.height });
        },

        _updateGrid: function (hoffset, voffset, scale, diagram) {
            var grid = document.getElementById(diagram._canvas.id + "pattern_gridline");
            var i;
            if (grid) {
                var pattern = document.getElementById(diagram._canvas.id + "pattern_grid");
                var height = 0;
                if (diagram.model.snapSettings.horizontalGridLines.linesInterval) {
                    for (i = 0; i < diagram.model.snapSettings.horizontalGridLines.linesInterval.length; i++) {
                        height += diagram.model.snapSettings.horizontalGridLines.linesInterval[i];
                    }
                }
                var width = 0;
                if (diagram.model.snapSettings.verticalGridLines.linesInterval) {
                    for (i = 0; i < diagram.model.snapSettings.verticalGridLines.linesInterval.length; i++) {
                        width += diagram.model.snapSettings.verticalGridLines.linesInterval[i];
                    }
                }

                var attr = {
                    x: hoffset,
                    y: voffset
                };
                ej.datavisualization.Diagram.Util.attr(grid, attr);

                scale = this._scaleSnapInterval(diagram.model, scale);
                var svg = diagram._svg;
                var defs = svg.defs({ "id": diagram._canvas.id + "patterndefinition" });
                if (pattern)
                    defs.removeChild(pattern);
                var attr = { id: diagram._canvas.id + "pattern_grid", x: 0, y: 0, width: width * scale, height: height * scale, patternUnits: "userSpaceOnUse" };
                pattern = diagram._svg.pattern(attr);
                this._renderHorizontalGridlines(scale, pattern, width, diagram, diagram._svg);
                this._renderVerticalGridlines(scale, pattern, height, diagram, diagram._svg);
                defs.appendChild(pattern);
            }
        },

        _scaleSnapInterval: function (model, scale) {
            if (scale >= 2) {
                while (scale >= 2) {
                    scale /= 2;
                }
            }
            else if (scale <= 0.5) {
                while (scale <= 0.5) {
                    scale *= 2;
                }
            }
            var i;
            if (scale !== 1) {
                model.snapSettings.horizontalGridLines._snapinterval = [];
                for (i = 0; i < model.snapSettings.horizontalGridLines.snapInterval.length; i++) {
                    model.snapSettings.horizontalGridLines._snapinterval[i] =
                        model.snapSettings.horizontalGridLines.snapInterval[i] * scale;
                }
                model.snapSettings.verticalGridLines._snapinterval = [];
                for (i = 0; i < model.snapSettings.verticalGridLines.snapInterval.length; i++) {
                    model.snapSettings.verticalGridLines._snapinterval[i] =
                        model.snapSettings.verticalGridLines.snapInterval[i] * scale;
                }
            }
            return scale;
        },
        _updateRulerSegment: function (scale, pattern, value, diagram, svg, isVertical) {
            if (diagram.model.rulerSettings.showRulers) {
                var snapSettings = diagram.model.snapSettings;
                var ruler = $("#" + (isVertical ? diagram._hRuler[0].id : diagram._vRuler[0].id)).ejRuler("instance");
                var obruler = $("#" + (isVertical ? diagram._vRuler[0].id : diagram._hRuler[0].id)).ejRuler("instance");
                var segmentWidth = ruler._updateSegmentWidth(diagram._currZoom);
                var spaceWidth = obruler._updateSegmentWidth(diagram._currZoom);
                var tickInterval = segmentWidth / ruler.model.interval;
                var space = 0, i, line, thickness, d;
                var lines = isVertical ? snapSettings.verticalGridLines : snapSettings.horizontalGridLines;
                for (i = 0; i < ruler.model.interval; i++) {
                    thickness = (i == 0 ? 1.25 : .25)
                    d = Number(space + (thickness / 2));
                    if (!isVertical) {
                        line = svg.path({
                            "d": "M " + 0 + " " + d + " L " + spaceWidth + " " + d + " Z",
                            "stroke": lines.lineColor,
                            "stroke-width": thickness, "stroke-dasharray": lines.lineDashArray
                        })
                    }
                    else {
                        line = svg.path({
                            "d": "M " + d + " " + 0 + " L " + d + " " + spaceWidth + " Z",
                            "stroke": lines.lineColor,
                            "stroke-width": thickness, "stroke-dasharray": lines.lineDashArray
                        })
                    }
                    space += (tickInterval + (thickness / 2));
                    if (line)
                        pattern.appendChild(line);
                }
                if (!isVertical)
                    pattern.setAttribute("height", segmentWidth);
                else pattern.setAttribute("width", segmentWidth);
            }
        },
        _checkForDefaultGridlines: function (gridlines) {
            var defGridLine = [1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75], i;
            if (gridlines) {
                if (gridlines.length > 0 && defGridLine.length > 0 && gridlines.length != defGridLine.length)
                    return false;
                for (i = 0; i < defGridLine.length; i++) {
                    if (defGridLine[i] != gridlines[i])
                        return false;
                }
            }
            return true;
        },
        _renderHorizontalGridlines: function (scale, pattern, width, diagram, svg) {
            var model = diagram.model;
            var snapSettings = model.snapSettings;
            if (diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.ShowHorizontalLines) {
                if (diagram.model.rulerSettings.showRulers && this._checkForDefaultGridlines(diagram.model.snapSettings.horizontalGridLines.linesInterval))
                    this._updateRulerSegment(scale, pattern, width, diagram, svg);
                else {
                    var space = 0, d;
                    var cnt = 0;
                    for (var i = 0; i < snapSettings.horizontalGridLines.linesInterval.length; i = i + 2) {
                        var thickness = snapSettings.horizontalGridLines.linesInterval[i];
                        d = Number(space + (thickness / 2));
                        var line = svg.path({
                            "d": "M " + 0 + " " + d * scale + " L " + width * scale + " " + d * scale + " Z",
                            "stroke": snapSettings.horizontalGridLines.lineColor,
                            "stroke-width": thickness, "stroke-dasharray": snapSettings.horizontalGridLines.lineDashArray
                        });
                        space += snapSettings.horizontalGridLines.linesInterval[i + 1] + thickness;
                        pattern.appendChild(line);
                        cnt++;
                    }
                }
            }
        },

        _renderVerticalGridlines: function (scale, pattern, height, diagram, svg) {
            var model = diagram.model;
            var snapSettings = model.snapSettings;
            if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.ShowVerticalLines) {
                if (diagram.model.rulerSettings.showRulers && this._checkForDefaultGridlines(diagram.model.snapSettings.verticalGridLines.linesInterval))
                    this._updateRulerSegment(scale, pattern, height, diagram, svg, true);
                else {
                    var space = 0, d;
                    var cnt = 0;
                    for (var i = 0; i < snapSettings.verticalGridLines.linesInterval.length; i = i + 2) {
                        var thickness = model.snapSettings.verticalGridLines.linesInterval[i];
                        d = Number(space + (thickness / 2));
                        var line = svg.path({
                            "d": "M " + d * scale + " " + 0 + " L " + d * scale + " " + height * scale + " Z",
                            "stroke": snapSettings.verticalGridLines.lineColor,
                            "stroke-width": thickness, "stroke-dasharray": snapSettings.verticalGridLines.lineDashArray
                        });
                        space += snapSettings.verticalGridLines.linesInterval[i + 1] + thickness;
                        pattern.appendChild(line);
                        cnt++;
                    }
                }
            }
        },
        //#region Transformation
        transformView: function (diagram, hOffset, vOffset) {
            var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(diagram);
            var view = diagram._view;
            var attr = {
                "transform": "translate(" + hOffset + "," + vOffset + ")"
            };
            ej.datavisualization.Diagram.Util.attr(view, attr);
            ej.datavisualization.Diagram.Util.attr(diagram._adornerLayer, attr);
            ej.datavisualization.Diagram.Util.attr(diagram._expander, {
                "transform": "translate(" + hOffset + "," + vOffset + "),scale(" + diagram.model.scrollSettings.currentZoom + ")"
            });
            if (diagram._htmlLayer) {
                diagram._htmlLayer.style.left = hOffset + "px";
                diagram._htmlLayer.style.top = vOffset + "px";
                diagram._htmlLayer.style.position = "absolute";
            }
        },
        scaleContent: function (diagram, scale) {
            var diagramLayer = diagram._diagramLayer;
            ej.datavisualization.Diagram.Util.attr(diagramLayer, { "transform": "scale(" + scale + ")" });
            var hOffset1 = typeof diagram.model.scrollSettings.horizontalOffset === "function" ? diagram.model.scrollSettings.horizontalOffset() : diagram.model.scrollSettings.horizontalOffset;
            var vOffset1 = typeof diagram.model.scrollSettings.verticalOffset === "function" ? diagram.model.scrollSettings.verticalOffset() : diagram.model.scrollSettings.verticalOffset;
            ej.datavisualization.Diagram.Util.attr(diagram._expander, { "transform": "translate(" + (-hOffset1) + "," + (-vOffset1) + "),scale(" + scale + ")" });
            if (diagram._htmlLayer) {
                diagram._htmlLayer.style.webkitTransform = "scale(" + scale + ")";
                diagram._htmlLayer.style.MozTransform = "scale(" + scale + ")";
                diagram._htmlLayer.style.OTransform = "scale(" + scale + ")";
                diagram._htmlLayer.style.msTransform = "scale(" + scale + ")";
                diagram._htmlLayer.style.transform = "scale(" + scale + ")";
            }
            if (diagram.selectionList.length > 0)
                this.updateSelector(diagram.selectionList[0], diagram._adornerSvg, scale, diagram, diagram.model.selectedItems.constraints);
            if (diagram.selectionList[0]) {
                if ((diagram.model.selectedItems.userHandles && diagram.model.selectedItems.userHandles.length > 0)) {
                    var isMultipleSelection = false;
                    if (diagram.selectionList[0].type == "pseudoGroup")
                        isMultipleSelection = true;
                    if (diagram.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                        ej.datavisualization.Diagram.SvgContext.updateUserHandles(diagram.model.selectedItems.userHandles, diagram.selectionList[0], diagram._adornerSvg, isMultipleSelection, false, scale, diagram);
                }
            }
            var nodes = diagram.nodes();
            for (var i = 0, len = nodes.length; i < len; ++i) {
                this._updatePortScale(nodes[i], diagram);
            }
        },

        _updatePortScale: function (node, diagram) {
            var children;
            node = diagram.nameTable[diagram._getChild(node)];
            this._updatePorts(node, diagram._adornerSvg, diagram);
            if (node.type != "pseudoGroup") {
                children = node.children;
                if (children && children.length > 0) {
                    for (var j = 0, clen = children.length; j < clen; ++j) {
                        this._updatePortScale(children[j], diagram);
                    }
                }
            }
        },

        setSize: function (diagram, width, height) {
            ej.datavisualization.Diagram.Util.attr(diagram._svg.document, { width: width + "px", height: height + "px" });
            if (!diagram._svgParentDimention || (diagram._svgParentDimention.width !== width || diagram._svgParentDimention.height !== height)) {
                var rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(diagram);
                diagram._svgParentDimention = {};
                diagram._svgParentDimention.width = diagram.element.width() - rulerSize.left;
                diagram._svgParentDimention.height = diagram.element.height() - rulerSize.top;
            }
            $(diagram._svgParent).css("width", diagram._svgParentDimention.width + "px").css("height", diagram._svgParentDimention.height + "px");
            ej.datavisualization.Diagram.Util.attr(diagram._adornerSvg.document, { width: width + "px", height: height + "px" });
        },
        //#endregion

       
        //#region Render Node

        //#region render
        renderNode: function (node, svg, parent, palette, diagram, isoverView) {
            var g;
            // if (node.visible) 
            {
                var g;

                var width = node.width ? node.width : node._width || 0;
                var height = node.height ? node.height : node._height || 0;
                var name = node.name;
                var offX = 0, offY = 0, x = 0, y = 0, rAngle = 0;
                var visible = node.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden";
                if (!palette) {
                    x = node.offsetX - width * node.pivot.x;
                    y = node.offsetY - height * node.pivot.y;
                    offX = node.offsetX;
                    offY = node.offsetY;
                    rAngle = node.rotateAngle;
                }
                if (ej.datavisualization.Diagram.Util.canCrispEdges(node, diagram)) {
                    x = Math.floor(x) + 0.5;
                    y = Math.floor(y) + 0.5
                }
                var attr = {
                    "id": name, "class": "ej-d-node", "transform": "rotate(" + rAngle + "," + offX + "," + offY +
                        "),translate(" + x + "," + y + ")", "visibility": visible
                };
                if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(node, diagram))
                    attr["style"] = "pointer-events:none";
                if (node._isClassifier)
                    attr["class"] += " " + "ej-d-classifier";
                g = svg.g(attr);
                if (parent) {
                    parent.appendChild(g);
                }
                else {
                    svg.appendChild(g);
                }
                var flip = node.flip !== "none" ? node.flip : node._flip;
                if (flip && flip !== ej.datavisualization.Diagram.FlipDirection.None) {
                    var attr1 = this.renderflipElement(node, diagram);
                    if (attr1) {
                        attr["transform"] = "rotate(" + rAngle + "," + offX + "," + offY +
                            ")" + attr1
                    }
                    svg.g(attr);
                }
                if (node._isDisabled)
                    ej.datavisualization.Diagram.Util.attr(g, { "style": "pointer-events:none;" });
                this._renderNode(node, svg, g, diagram, palette, isoverView);
                if (node && node.annotation)
                    ej.datavisualization.Diagram.DefautShapes.renderBPMNAnnotationShape(node, diagram);
            }
            if (node._isClassifier)
                delete node._isClassifier;
            return g;
        },

        renderflipElement: function (node, diagram) {
            var attr = null;
            var offsetX = node.offsetX + node.width * node.pivot.x;
            var offsetY = node.offsetY + node.height * node.pivot.y;
            var x = node.offsetX - node.width * node.pivot.x;
            var y = node.offsetY - node.height * node.pivot.y;
            var flip = node.flip !== "none" ? node.flip : node._flip;
            if (node.parent) {
                var parent = diagram.nameTable[node.parent];
            }
            if (!(parent && parent.flip === node.flip)) {
                if (flip == ej.datavisualization.Diagram.FlipDirection.Horizontal) {
                    attr = 'translate(' + offsetX + ',' + y + ') scale(' + -1 + ','
                        + 1 + ')'
                }
                else if (flip == ej.datavisualization.Diagram.FlipDirection.Vertical) {
                    attr = 'translate(' + x + ',' + offsetY + ') scale(' + 1 + ','
                        + -1 + ')'

                } else if (flip == ej.datavisualization.Diagram.FlipDirection.Both) {
                    attr = 'translate(' + offsetX + ',' + offsetY + ') scale(' + -1 + ','
                        + -1 + ')'
                }
            }
            return attr;
        },

        _renderNode: function (node, svg, g, diagram, palette, isoverView) {
            this._renderShape(node, svg, g, diagram);
            this._renderLabels(node, svg, diagram, palette);
            this._renderPorts(node, (diagram._adornerSvg && !isoverView) ? diagram._adornerSvg : svg, diagram, isoverView);
            if (node.outEdges.length > 0) {
                this._renderIcons(node, diagram);
            }
        },

        _renderShadow: function (node, svg) {
            if (!node.segments) {

                var g = svg.document.getElementById(node.name);
                if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                    var fill = node.fillColor;
                    if (node.type === "image" || node.type === "text" || node.type === "html") {
                        var shape = svg.document.getElementById(node.name + "_backRect");
                    }
                    else if (node.type != "text" && node.type != "image") {
                        var shape = svg.document.getElementById(node.name + "_shape");
                    }
                    if (shape) {
                        var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                        var attr = {
                            "id": node.name + "_shadow", "width": node.width, "height": node.height, "stroke": node.borderColor != "none" || node.borderColor != "transparent" ? "lightgrey" : "none", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
                            "transform": "translate(" + point.x + "," + point.y + ")", "opacity": node.shadow.opacity, "stroke-dasharray": ""
                        };
                        if (node.type === "native" || node.type === "html")
                            g.insertBefore(svg.rect(attr), shape);
                        else {
                            var shadow = shape.cloneNode(true);
                            g.insertBefore(shadow, shape);
                            ej.datavisualization.Diagram.Util.attr(shadow, attr);
                        }
                    }
                }
            }
        },

        _updateShadow: function (node, svg) {
            var g = svg.document.getElementById(node.name);
            var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
            var attr = { id: node.name + "_shadow", transform: "translate(" + point.x + "," + point.y + ")", opacity: node.shadow.opacity };
            svg.g(attr);

        },
        _deleteLabel: function (node, label, diagram, svg, view) {
            var g;
            if (diagram.model.labelRenderingMode === "html") {
                var htmlLayer = view.svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                var nodeElement = this._findChild(htmlLayer.childNodes, node);
                if (nodeElement) {
                    var length = nodeElement.childNodes.length;
                    for (var i = 0; i < length; i++) {
                        if (nodeElement.childNodes[i].id == node.name + "_" + label.name + "_lblbg") {
                            nodeElement.childNodes[i].parentNode.removeChild(nodeElement.childNodes[i]);
                        }
                    }
                }
            }
            else {
                var label = svg.document.getElementById(node.name + "_" + label.name);
                if (label)
                    label.parentNode.removeChild(label);
            }
        },
        _deletePort: function (node, port, diagram, svg, view) {
            if (node) {
                var port = svg.document.getElementById(node.name + "_" + port.name);
                if (port)
                    port.parentNode.removeChild(port);
            }
        },
        _removeShadow: function (node, svg) {
            if (node.type != "text") {
                var g, shadow, nodeName = node.name;
                if (node.type === "bpmn" && node.children && (node.shape != "group")) {
                    nodeName = node.children[0].name;
                }
                g = svg.document.getElementById(nodeName);
                shadow = svg.document.getElementById(nodeName + "_shadow");
                if (g && shadow) {
                    g.removeChild(shadow);
                }
            }
        },

        _renderphase: function (node, svg, parent, diagram, parNode) {
            var g;
            g = svg.g({ "id": node.name + "_phase_g", "class": "ej-d-seperator" });
            if (node.parent) {
                //parent = svg.getElementById(node.parent);
                //if (parent)
                parent.appendChild(g);
            } else {
                svg.appendChild(g);
            }
            var visibility = "visible";
            var tx = 0, ty = 0;
            if (parNode) {
                var children = diagram._getChildren(parNode.children);
                if (children.length > 1)
                    var header = diagram.nameTable[children[0]];
                var bounds = ej.datavisualization.Diagram.Util.bounds(parNode);
                var points = [], nPoint;
                var top = bounds.top + 50;
                var left = bounds.left + 50;
                if (node.orientation == "vertical") {
                    points.push({ x: 0, y: 0 });
                    points.push({ x: bounds.width, y: 0 });
                    nPoint = this._convertToSVGPoints(points);
                    tx = bounds.x;
                    ty = bounds.y + node.offset + header.height;
                    if (header)
                        top += header.height;
                    if (!(ty < bounds.bottom && ty > top)) {
                        visibility = "hidden";
                    }
                } else {
                    points.push({ x: 0, y: header.height ? header.height : 0 });
                    points.push({ x: 0, y: bounds.height });
                    nPoint = this._convertToSVGPoints(points);
                    tx = bounds.x + node.offset;
                    ty = bounds.y;

                    if (!(tx < bounds.right && tx > left)) {
                        visibility = "hidden";
                    }
                }


                var attr = {
                    "id": node.name + "_phase",
                    "stroke": node.lineColor,
                    "stroke-width": node.lineWidth,
                    "stroke-dasharray": node.lineDashArray,
                    "points": nPoint,
                    //"transform": "translate(" + tx + "," + ty + ")",
                };
                var line = svg.polyline(attr);
                g.appendChild(line);

                attr = {
                    "id": node.name + "_phase_hitTest",
                    "class": "hitTest",
                    "stroke-width": 10,
                    "points": nPoint,
                    //"transform": "translate(" + tx + "," + ty + ")",
                    "stroke": "transparent",

                };
                line = svg.polyline(attr);
                g.appendChild(line);
                g.setAttribute("transform", "translate(" + tx + "," + ty + ")");
            }

        },

        renderphase: function (node, svg, parent, diagram, group) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                if (parent)
                    parent = panel.document.getElementById(parent.id)
                view.context._renderphase(node, panel, parent || view.diagramLayer, diagram, group);
            });
        },

        _renderGroupBackground: function (group, g, svg, diagram) {
            if (group.fillColor != "none") {
                var x = group.offsetX - group.width * group.pivot.x;
                var y = group.offsetY - group.height * group.pivot.y;
                var fillColor = group.fillColor, borderColor = group.borderColor;
                if ((group.type == "bpmn" && group.shape != "group") || (group.classifier && group.classifier == "package")) {
                    fillColor = "transparent";
                    borderColor = "transparent";
                }
                if (ej.datavisualization.Diagram.Util.canCrispEdges(group, diagram)) {
                    x = Math.floor(x) + 0.5;
                    y = Math.floor(y) + 0.5;
                }
                var angle = group.rotateAngle;
                var pt = new ej.datavisualization.Diagram.Point(x + group.width * group.pivot.x, y + group.height * group.pivot.y);
                var attr = {
                    "id": group.name + "_shape",
                    "rx": group.cornerRadius,
                    "ry": group.cornerRadius,
                    "width": Math.round((group.width < 0) ? 0 : group.width),
                    "height": Math.round((group.height < 0) ? 0 : group.height),
                    "fill": fillColor,
                    "stroke": borderColor,
                    "stroke-width": group.borderWidth,
                    "opacity": group.opacity,
                    "stroke-dasharray": group.borderDashArray,
                    "transform": "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")",
                };
                if (group.type == "umlclassifier" || group._isClassifier)
                    attr["class"] = "ej-d-group" + " " + "ej-d-classifier";
                if (group.gradient && group.type != "bpmn")
                    attr["fill"] = this._renderGradient(group.name, group.gradient, svg);
                this._addCssClass(group, attr);
                var rect = svg.rect(attr);
                g.appendChild(rect);
                if (group.type === "bpmn" && group.shape === "group" && (group.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)) {
                    var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, group.shadow.angle, group.shadow.distance);
                    if (group.shape === "group" && group.children.length === 0) {
                        point.x = (group.offsetX - group.width * group.pivot.x) + point.x;
                        point.y = (group.offsetY - group.height * group.pivot.y) + point.y;
                    }
                    var attr1 = {
                        "id": group.name + "_shadow", "width": group.width, "height": group.height, "stroke": group.borderColor != "none" || group.borderColor != "transparent" ? "lightgrey" : "none", "fill": fillColor != "none" || fillColor != "transparent" ? "lightgrey" : "none",
                        "transform": "translate(" + point.x + "," + point.y + ")", "opacity": group.shadow.opacity, "stroke-dasharray": ""
                    };
                    var shadow = rect.cloneNode(true);
                    g.insertBefore(shadow, rect);
                    ej.datavisualization.Diagram.Util.attr(shadow, attr1);

                }

            }
        },

        renderGroup: function (group, svg, parent, nameTable, diagram, isLoad, overView) {
            var g;
            var visible = group.visible && ej.datavisualization.Diagram.Util.enableLayerOption(group, "visible", diagram) ? "visible" : "hidden";
            //if (group.visible) 
            {
                var attr = { "id": group.name, "class": "ej-d-group", "visibility": visible };
                if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(group, diagram))
                    attr["style"] = "pointer-events:none";
                if (group.type == "umlclassifier" || group._isClassifier)
                    attr["class"] += " " + "ej-d-classifier";
                g = svg.g(attr);
                if (parent) {
                    parent.appendChild(g);
                } else {
                    svg.appendChild(g);
                }
                if (group.parent == "" && group.container) {
                    if (isLoad) {
                        group.height = 0;
                        group.width = 0;
                    }
                    if (!overView) {
                        diagram._updateChildAdjacentConnectors(group);
                    }
                }
                this._renderGroupBackground(group, g, svg, diagram);
                if (group.isSwimlane)
                    diagram._disableSwimlaneUptate = true;
                var children = group.children;
                if (children && children.length > 0) {
                    for (var i = 0, len = children.length; i < len; i++) {
                        var child = nameTable[ej.datavisualization.Diagram.Util.getChild(children[i])];
                        if (child) {
                            if (child._type === "group") {
                                if (group.type == "umlclassifier")
                                    child._isClassifier = true;
                                this.renderGroup(child, svg, g, nameTable, diagram, isLoad, overView);
                                ej.datavisualization.Diagram.Util._updateGroupBounds(child, diagram, true);
                                ej.datavisualization.Diagram.DiagramContext.update(child, diagram);
                            }
                            else if (child.segments) {
                                ej.datavisualization.Diagram.Util.updateBridging(child, diagram);
                                this.renderConnector(child, svg, g, diagram);
                            }
                            else {
                                if (group.type == "umlclassifier")
                                    child._isClassifier = true;
                                this.renderNode(child, svg, g, undefined, diagram, overView);
                                if (child._isService) {
                                    var child1 = $.extend(true, {}, child);
                                    child1.name = child.name + "service";
                                    child1.offsetX = child.offsetX + 7;
                                    child1.offsetY = child.offsetY + 5;
                                    this.renderNode(child1, svg, g, undefined, diagram, overView);
                                }
                            }
                        }
                    }
                }
                this._renderLabels(group, svg, diagram);
                this._renderPorts(group, (diagram._adornerSvg && !overView) ? diagram._adornerSvg : svg, diagram, overView);
                if (group.isSwimlane)
                    delete diagram._disableSwimlaneUptate;
            }
            if (group && group.annotation)
                ej.datavisualization.Diagram.DefautShapes.renderBPMNAnnotationShape(group, diagram);
            if (group && group.isSwimlane) {
                var view, panel, parent;
                var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, group);
                diagram._views.forEach(function (viewid) {
                    view = diagram._views[viewid];
                    panel = view.svg || view._canvas;
                    if (parent)
                        parent = panel.document.getElementById(parent.id)
                    for (var i = 0; phases && i < phases.length; i++) {
                        var node = diagram.nameTable[diagram._getChild(phases[i])];
                        if (node)
                            view.context._renderphase(node, panel, parent || view.diagramLayer, diagram, group);
                    }
                });
            }
            if (group._isClassifier)
                delete group._isClassifier;
            return g;
        },


        _renderGradient: function (name, gradient, svg) {

            var fill;
            var id;
            if (gradient.type === "linear") {
                id = this._renderLinearGradient(svg.id + "_" + name, gradient, svg);
                fill = "url(#" + id + ")";
            }
            else if (gradient.type === "radial") {
                id = this._renderRadialGradient(svg.id + "_" + name, gradient, svg);
                fill = "url(#" + id + ")";
            }
            return fill;
        },

        _checkGradientTag: function (name, svg, linear) {
            if (svg.getElementById(name + "_gradient")) {
                var gradTag = svg.getElementById(name + "_gradient")
                if ((linear && gradTag.localName === "radialGradient") || (!linear && gradTag.localName === "linearGradient"))
                    gradTag.parentNode.removeChild(gradTag);
            }
        },
        _renderLinearGradient: function (name, gradient, svg) {
            var defs = svg.document.getElementById(svg.document.parentNode.parentNode.id + "patterndefinition") || svg.document.getElementById(name + "patterndefinition");
            if (defs) {
                this._checkGradientTag(name, svg, true);
                var attr = { "id": name + "_gradient", "x1": gradient.x1 + "%", "y1": gradient.y1 + "%", "x2": gradient.x2 + "%", "y2": gradient.y2 + "%" };
                var linear = svg.linearGradient(attr);
                this._renderStops(gradient, svg, linear);
                defs.appendChild(linear);
                return linear.id;
            }
            return null;
        },

        _renderRadialGradient: function (name, gradient, svg) {
            var defs = svg.document.getElementById($(svg.document).parents()[1].id + "patterndefinition") || svg.document.getElementById(name + "patterndefinition");
            if (defs) {
                this._checkGradientTag(name, svg, false);
                var attr = {
                    "id": name + "_gradient", "cx": gradient.cx + "%", "cy": gradient.cy + "%",
                    "fx": gradient.fx + "%", "fy": gradient.fy + "%", "r": gradient.r + "%"
                };
                var radial = svg.radialGradient(attr);
                this._renderStops(gradient, svg, radial);
                defs.appendChild(radial);
                return radial.id;
            }
            return null;
        },

        _renderStops: function (gradient, svg, element) {
            if (svg.getElementById(element.getAttribute("id")) === element) {
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }
            }
            var stops = gradient.stops;
            var stop;
            for (var i = 0, len = stops.length; i < len; i++) {
                stop = stops[i];
                element.appendChild(svg.stop({ "offset": stop.offset + "%", "stop-color": stop.color, "stop-opacity": stop.opacity }));
            }
        },

        _renderShape: function (node, svg, g, diagram) {
            var type = node._shape ? node._shape : node.type;
            switch (type) {
                case "rectangle":
                    this._renderRect(node, svg, g);
                    break;
                case "ellipse":
                    this._renderEllipse(node, svg, g);
                    break;
                case "image":
                    this._renderImage(node, svg, g);
                    break;
                case "path":
                    this._renderPath(node, svg, g);
                    break;
                case "polygon":
                    this._renderPolygon(node, svg, g);
                    break;
                case "text":
                    this._renderTextElement(node, svg, g, diagram);
                    break;
                case "html":
                    this._renderHtmlElement(node, svg, g, diagram);
                    break;
                case "native":
                    this._rendercontent(node, svg, g, diagram);
                    break;
            }
        },

        _renderHTMLTemplate: function (node, diagram) {
            if (node.templateId && $.templates) {
                return diagram._renderEjTemplate("#" + node.templateId, node);
            }
        },

        _renderSvgTemplate: function (node, svg, g, html) {
            var div = document.createElement('div');
            div.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg"><g id="tempNative">' + html + '</g></svg>';
            document.body.appendChild(div);
            var tempContent = document.getElementById("tempNative");
            var content = tempContent.cloneNode(true);
            content.id = node.name + "_shape";
            g.appendChild(content);
            var attr = {
                "id": node.name + "_shape",
                "fill": node.fillColor, "stroke": node.borderColor,
                "stroke-width": node.borderWidth, "opacity": node.opacity, "stroke-dasharray": node.borderDashArray
            };
            this._addCssClass(node, attr);
            if (node.gradient)
                attr["fill"] = this._renderGradient(node.name, node.gradient, svg);
            svg.g(attr);
            var object = this._scaleNodeContent(node, tempContent);
            if (object)
                content.setAttribute("transform", "translate(" + object.x + "," + object.y + "),scale(" + object.sx + "," + object.sy + ")");
            content.setAttribute("id", node.name + "_shape");
            div.parentNode.removeChild(div);
        },

        _scaleNodeContent: function (node, content) {
            if (node.scale != "none") {
                if (content)
                    var bounds = node.type == "html" ? content.getBoundingClientRect() : content.getBBox();
                if (node.type == "html") { bounds.x = bounds.left; bounds.y = bounds.top };
                var width = node.width ? node.width : node._width;
                var height = node.height ? node.height : node._height;
                if (!content) var bounds = { x: node.offsetX - node.width * node.pivot.x, y: node.offsetY - node.height * node.pivot.y, width: width, height: height };
                var proportionX = bounds.width ? width / bounds.width : 1;
                var proportionY = bounds.height ? height / bounds.height : 1;
                var x = ((bounds.x * proportionX) * -1);
                var y = ((bounds.y * proportionY) * -1);
                if (node.scale != "stretch" && node.contentAlignment != "none") {
                    var proportion = node.scale == "meet" ? Math.min(proportionX, proportionY) : Math.max(proportionX, proportionY);
                    if (node.contentAlignment.indexOf("xmid") > -1) {
                        x = width / 2 - bounds.width * proportion / 2;
                    }
                    else if (node.contentAlignment.indexOf("xmax") > -1) {
                        x = bounds.x + width - bounds.width * proportion;
                    }
                    if (node.contentAlignment.indexOf("ymid") > -1) {
                        y = bounds.y + height / 2 - bounds.height * proportion / 2;
                    }
                    else if (node.contentAlignment.indexOf("ymax") > -1) {
                        y = bounds.y + height - bounds.height * proportion;
                    }
                    return { x: x, y: y, sx: proportion, sy: proportion };
                }
                return { x: x, y: y, sx: proportionX, sy: proportionY };
            }
            return null;
        },
        _rendercontent: function (node, svg, g, diagram) {
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                var fill = node.fillColor;
                var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                var shadow = {
                    "id": node.name + "_shadow", "width": node.width, "height": node.height, "stroke": node.borderColor != "none" || node.borderColor != "transparent" ? "lightgrey" : "none", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
                    "transform": "translate(" + point.x + "," + point.y + ")", "opacity": node.shadow.opacity
                };
                g.appendChild(svg.rect(shadow));
            }

            if (!node.segments && node.templateId && $.templates) {
                var width = node.width;
                var height = node.height;
                if (node._type === "node" && !node.height && !node.width) {
                    node.width = node._width;
                    node.height = node._height;
                }
                var html = diagram._renderEjTemplate("#" + node.templateId, node);
                node.width = width;
                node.height = height;
                this._renderSvgTemplate(node, svg, g, html);
            }
        },

        _fill: function (node, svg) {
            var fill;
            if (node.gradient) {
                fill = this._renderGradient(node.name, node.gradient, svg);
            }
            if (!fill) {
                fill = node.fillColor;
            }
            return fill;
        },

        _fillBorder: function (node, svg) {
            var fillBorder;
            if (node.borderGradient) {
                fillBorder = this._renderGradient(node.name, node.borderGradient, svg);
            }
            if (!fillBorder) {
                fillBorder = node.borderColor;
            }
            return fillBorder;
        },

        _addCssClass: function (object, attr) {
            if (object.cssClass) {
                if (attr) {
                    if (attr["class"])
                        attr["class"] = attr["class"] + " " + object.cssClass;
                    else
                        attr["class"] = object.cssClass;
                }
            }
            object._cssClass = object.cssClass;
            return attr;
        },

        _updateCssClass: function (object, attr) {
            if ((object._cssClass != "" || (object._cssClass === "" && object.cssClass !== "")) && object._cssClass !== undefined && object.cssClass != object._cssClass) {
                var classTmp = attr["class"];
                if (classTmp)
                    attr["class"] = classTmp.replace(object._cssClass, "").trim();
                return this._addCssClass(object, attr);
            }
            return attr;
        },

        _renderRect: function (node, svg, g) {
            var fill = this._fill(node, svg);
            var fillBorder = this._fillBorder(node, svg);
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var attr = {
                "id": node.name + "_shape", "rx": node.cornerRadius, "ry": node.cornerRadius, "role": "presentation",
                "width": width, "height": height, "fill": fill, "stroke": fillBorder,
                "stroke-width": node.borderWidth, "opacity": node.opacity, "stroke-dasharray": node.borderDashArray
            };
            if (node._isClassifier)
                var class1 = "ej-d-node" + " " + "ej-d-classifier";
            attr["class"] = class1;
            this._addCssClass(node, attr);
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                var shadow = {
                    "id": node.name + "_shadow", "rx": node.cornerRadius, "ry": node.cornerRadius,
                    "width": node.width, "height": node.height, "stroke": node.borderColor != "none" || node.borderColor != "transparent" ? "lightgrey" : "none", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
                    "transform": "translate(" + point.x + "," + point.y + ")", "opacity": node.shadow.opacity
                };
                g.appendChild(svg.rect(shadow));
            }
            g.appendChild(svg.rect(attr));
        },

        _renderEllipse: function (node, svg, g) {
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var fill = this._fill(node, svg);
            var fillBorder = this._fillBorder(node, svg);
            var attr = {
                "id": node.name + "_shape", "rx": width / 2, "ry": height / 2, "role": "presentation",
                "cx": width / 2, "cy": height / 2,
                "fill": fill, "stroke": fillBorder, "stroke-width": node.borderWidth,
                "opacity": node.opacity, "stroke-dasharray": node.borderDashArray

            };
            this._addCssClass(node, attr);
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                var shadow = {
                    "id": node.name + "_shadow", "rx": node.width / 2, "ry": node.height / 2,
                    "cx": node.width / 2, "cy": node.height / 2, "stroke": node.borderColor != "none" || node.borderColor != "transparent" ? "lightgrey" : "none", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
                    "transform": "translate(" + point.x + "," + point.y + ")", "opacity": node.shadow.opacity
                };
                g.appendChild(svg.ellipse(shadow));
            }
            g.appendChild(svg.ellipse(attr));
        },

        _renderImage: function (node, svg, g) {
            var fill = node.fillColor;
            var backRect = this._renderBackgroundRect(node, svg, g);
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var alignment = ej.datavisualization.Diagram.Util._getImageAlignment(node.contentAlignment);
            var scale = node.scale == "none" ? "meet" : node.scale;
            var attr = {
                "id": node.name + "_shape",
                "opacity": node.opacity, "preserveAspectRatio": (scale != "stretch" && alignment != "none" ? alignment + " " + scale : "none"),
                "width": width, "height": height, "role": "img",
            };
            var image = new Image();
            image.src = node.source;
            if (node.scale == "none") {
                attr["width"] = image.width || width; attr["height"] = image.height || height;
            }
            var shape = svg.image(attr);
            shape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", image.src);
            g.appendChild(shape);
        },

        _renderPolygon: function (node, svg, g) {
            var fill = this._fill(node, svg);
            var fillBorder = this._fillBorder(node, svg);
            ej.datavisualization.Diagram.Geometry.updatePolygonPoints(node);
            var points = this._convertToSVGPoints(node.points);
            var attr = {
                "id": node.name + "_shape", "fill": fill, "stroke": fillBorder, "role": "presentation",
                "stroke-width": node.borderWidth, "opacity": node.opacity,
                "stroke-dasharray": node.borderDashArray, "points": points
            };
            this._addCssClass(node, attr);
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                var shadow = {
                    "id": node.name + "_shadow", "points": points, "stroke": node.borderColor != "none" || node.borderColor != "transparent" ? "lightgrey" : "none", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
                    "transform": "translate(" + point.x + "," + point.y + ")", "opacity": node.shadow.opacity
                };
                g.appendChild(svg.polygon(shadow));
            }
            g.appendChild(svg.polygon(attr));
        },

        _renderPath: function (node, svg, g) {
            var fill = this._fill(node, svg);
            var fillBorder = this._fillBorder(node, svg);
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var d;
            if (!node._preventStretch && !node._polyline)
                node._absolutePath = d = ej.datavisualization.Diagram.Geometry.updatePath(0, 0, width, height, node.pathData, svg, null, node);
            else node._absolutePath = d = node.pathData;
            var attr = {
                "id": node.name + "_shape",
                "d": d, "opacity": node.opacity, "role": "presentation",
                "stroke-dasharray": node.borderDashArray, "stroke": fillBorder,
                "stroke-width": node.borderWidth, "fill": fill

            };
            if (node._isClassifier)
                attr["class"] = "ej-d-node" + " " + "ej-d-classifier";
            this._addCssClass(node, attr);
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                var shadow = {
                    "id": node.name + "_shadow", "width": node.width,
                    "height": node.height, "d": d, "stroke": node.borderColor != "none" || node.borderColor != "transparent" ? "lightgrey" : "none", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
                    "transform": "translate(" + point.x + "," + point.y + ")", "opacity": node.shadow.opacity
                };
                g.appendChild(svg.path(shadow));
            }
            g.appendChild(svg.path(attr));
        },

        _renderHtmlElement: function (node, svg, g, diagram) {
            var backRect = this._renderBackgroundRect(node, svg, g);
            if (!node.segments && node.templateId) {
                var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                var element = $(htmlLayer).children("#" + node.name + "_parentdiv")[0];
                if (element) htmlLayer.removeChild(element);
                var width = node.width ? node.width : node._width;
                var height = node.height ? node.height : node._height;
                var x = node.offsetX - width * node.pivot.x;
                var y = node.offsetY - height * node.pivot.y;
                var div = svg.document.getElementById(node.name + "_html")
                if (!div)
                    var div = document.createElement("div");
                var style = "width:" + width + "px;height:" + height + "px;padding:1px; left:" + x + "px; top:" + y + "px;position:absolute;";
                style += "display: block; border:0px; pointer-events: all; opacity:" + node.opacity + ";";
                style += "transform:" + "rotate(" + node.rotateAngle + "deg)";
                var attr = { "id": node.name + "_html", "class": "foreignObject", "style": style };
                this._addCssClass(node, attr);
                ej.datavisualization.Diagram.Util.attr(div, attr);
                if (!node.segments && node.templateId) {
                    var tmplString = this._renderHTMLTemplate(node, diagram)
                    div.innerHTML = tmplString;
                }
                var parentdiv = document.createElement("div");
                var attr1 = { "id": node.name + "_parentdiv", "class": "ej-d-node" };
                ej.datavisualization.Diagram.Util.attr(parentdiv, attr1);
                parentdiv.appendChild(div);
                var visibility = node.visible ? "visible" : "hidden";
                parentdiv.style.visibility = visibility;
                var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                if (htmlLayer)
                    htmlLayer.appendChild(parentdiv);
                else
                    svg.document.parentNode.appendChild(div);
            }
        },

        _initializeGuidelines: function (svg, attr, parent) {
            var g = svg.g(attr);
            parent.appendChild(g);
            return g;
        },

        _renderSideAlignmentLines: function (start, end, g, svg, scale) {
            var line = svg.line({
                "x1": start.x * scale, "y1": start.y * scale,
                "x2": end.x * scale, "y2": end.y * scale, "stroke": "#07EDE1", "stroke-width": 1
            });
            g.appendChild(line);
        },

        _renderCenterAlignmentLines: function (start, end, g, svg, scale) {
            var line = svg.line({
                "x1": start.x * scale, "y1": start.y * scale,
                "x2": end.x * scale, "y2": end.y * scale, "stroke": "#07EDE1", "stroke-width": 1,
            });
            g.appendChild(line);
        },

        _renderSpacingLines: function (start, end, g, svg, scale) {
            if (g) {
                var d, d1;
                var div1 = svg.g({});
                if (start.x == end.x) {
                    d = "M" + (start.x * scale - 5) + " " + (start.y * scale + 5) + " L" + start.x * scale + " " + start.y * scale + " L" + (start.x * scale + 5) + " " + (start.y * scale + 5) + "z";
                    d1 = "M" + (end.x * scale - 5) + " " + (end.y * scale - 5) + " L" + end.x * scale + " " + end.y * scale + " L" + (end.x * scale + 5) + " " + (end.y * scale - 5) + "z";
                    div1.appendChild(svg.line({ "x1": start.x * scale - 8, "x2": start.x * scale + 8, "y1": start.y * scale - 1, "y2": start.y * scale - 1, "stroke": "#07EDE1", "stroke-width": 1 }));
                    div1.appendChild(svg.line({ "x1": end.x * scale - 8, "x2": end.x * scale + 8, "y1": end.y * scale + 1, "y2": end.y * scale + 1, "stroke": "#07EDE1", "stroke-width": 1 }));
                }
                else {
                    d = "M" + (start.x * scale + 5) + " " + (start.y * scale + 5) + " L" + start.x * scale + " " + start.y * scale + " L" + (start.x * scale + 5) + " " + (start.y * scale - 5) + "z";
                    d1 = "M" + (end.x * scale - 5) + " " + (end.y * scale - 5) + " L" + end.x * scale + " " + end.y * scale + " L" + (end.x * scale - 5) + " " + (end.y * scale + 5) + "z";
                    div1.appendChild(svg.line({ "x1": start.x * scale - 1, "x2": start.x * scale - 1, "y1": start.y * scale - 8, "y2": start.y * scale + 8, "stroke": "#07EDE1", "stroke-width": 1 }));
                    div1.appendChild(svg.line({ "x1": end.x * scale + 1, "x2": end.x * scale + 1, "y1": end.y * scale - 8, "y2": end.y * scale + 8, "stroke": "#07EDE1", "stroke-width": 1 }));
                }
                div1.appendChild(svg.path({ "d": d, "fill": "#07EDE1" }));
                var line = svg.line({
                    "x1": start.x * scale, "y1": start.y * scale,
                    "x2": end.x * scale, "y2": end.y * scale, "stroke": "#07EDE1", "stroke-width": 0.6, "fill": "#07EDE1"
                });
                div1.appendChild(line);
                div1.appendChild(svg.path({ "d": d1, "fill": "#07EDE1" }));
                g.appendChild(div1);
            }
        },

        _removeGuidelines: function (parent, g) {
            if (g != null) {
                parent.removeChild(g);
            }
        },

        //#endregion

        //#region update
        update: function (data, diagram) {
            if (diagram && !diagram._isInit && data._status !== "new")
                data._status = "update";
            var svg = diagram._svg;
            if (data._type === "group")
                this.updateGroup(data, svg, diagram);
            else if (data.segments)
                this.updateConnector(data, svg, diagram);
            else
                this.updateNode(data, svg, diagram);
        },

        _updateGoupBackground: function (group, svg, diagram) {
            var x = group.offsetX - group.width * group.pivot.x;
            var y = group.offsetY - group.height * group.pivot.y;
            var angle = group.rotateAngle;           
            var pt = new ej.datavisualization.Diagram.Point(x + group.width * group.pivot.x, y + group.height * group.pivot.y);
            var fillColor = group.fillColor, borderColor = group.borderColor;
            var nodeConstraints = ej.datavisualization.Diagram.NodeConstraints;
            if ((group.type == "bpmn" && group.shape != "group") || (group.classifier && group.classifier == "package")) {
                fillColor = "transparent";
                borderColor = "transparent";
            }
            if (ej.datavisualization.Diagram.Util.canCrispEdges(group, diagram)) {
                x = Math.floor(x) + 0.5;
                y = Math.floor(y) + 0.5;
            }
            var attr = {
                "id": group.name + "_shape",
                "rx": group.cornerRadius,
                "ry": group.cornerRadius,
                "width": Math.round((group.width < 0) ? 0 : group.width),
                "height": Math.round((group.height < 0) ? 0 : group.height),
                "fill": fillColor,
                "stroke": borderColor,
                "stroke-width": group.borderWidth,
                "opacity": group.opacity,
                "stroke-dasharray": group.borderDashArray,
                "transform": "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")",
            };
            if (group.shape === "group" && (group.constraints & nodeConstraints.Shadow)) {
                var shadow = svg.document.getElementById(group.name + "_shadow");
                var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, group.shadow.angle, group.shadow.distance);
                x = (group.offsetX - group.width * group.pivot.x) + point.x;
                y = (group.offsetY - group.height * group.pivot.y) + point.y;
                var attr1 = {
                    "id": group.name + "_shadow", "width": group.width, "height": group.height, "stroke": group.borderColor != "none" || group.borderColor != "transparent" ? "lightgrey" : "none",
                    "transform": "translate(" + x + "," + y + ")", "opacity": group.shadow.opacity, "stroke-dasharray": ""
                };
                if (shadow)
                    ej.datavisualization.Diagram.Util.attr(shadow, attr1);
            }
            if (group.gradient && group.type != "bpmn")
                attr["fill"] = this._renderGradient(group.name, group.gradient, svg);
            var element = svg.getElementById(group.name + "_shape");
            if (element) {
                attr["class"] = element.getAttribute("class");
                this._updateCssClass(group, attr);
                ej.datavisualization.Diagram.Util.attr(element, attr);
            }
        },

        updateGroup: function (group, svg, diagram, layout, isoverView) {
            var children = diagram._getChildren(group.children);
            var visible = group.visible && ej.datavisualization.Diagram.Util.enableLayerOption(group, "visible", diagram) ? "visible" : "hidden";
            var style = "display:block;"
            if (!(group.visible))
                style = "display:none;"
            if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(group, diagram))
                style = "pointer-events:none";

            svg.g({ "id": group.name, "visibility": visible, "style": style });
            for (var i = 0, len = children.length; i < len; i++) {
                var child = diagram.nameTable[children[i]];
                if (child) {
                    if (child._type === "group")
                        this.updateGroup(child, svg, diagram, layout, isoverView);
                    else if (child.segments) {
                        ej.datavisualization.Diagram.Util.updateBridging(child, diagram);
                        this.updateConnector(child, svg, diagram, isoverView);
                    }
                    else {
                        this.updateNode(child, svg, diagram, layout, isoverView);
                        if (child._isService) {
                            var child1 = $.extend(true, {}, child);
                            child1.name = child.name + "service";
                            child1.offsetX = child.offsetX + 7;
                            child1.offsetY = child.offsetY + 5;
                            this.updateNode(child1, svg, diagram, layout, isoverView);
                        }
                    }
                }
            }
            svg.g({ "id": group.name, "visibility": visible, "style": style });
            this._updateGoupBackground(group, svg, diagram);

            this._updateAssociatedConnector(group, svg, diagram);
            this._updateLabels(group, svg, diagram, isoverView);
            this._updatePorts(group, (diagram._adornerSvg && !isoverView) ? diagram._adornerSvg : svg, diagram, isoverView);
            if (group.isSwimlane) {
                var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, group);
                var phase = null;
                if (phases && phases.length > 0) {
                    for (var j = 0; j < phases.length; j++) {
                        phase = diagram.nameTable[diagram._getChild(phases[j])];
                        if (phase)
                            this._updatephase(phase, diagram, group);
                        this._updatePhaseStyle(phase, {}, diagram)
                    }
                }
            }
        },

        _removephases: function (group, diagram) {
            if (group.isSwimlane) {
                var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, group);
                if (phases) {
                    for (var j = phases.length; j >= 0; j--) {
                        var phase = diagram.nameTable[diagram._getChild(phases[j])];
                        this._removePhase(diagram, phase);
                    }
                }
            }
        },
        _removePhase: function (diagram, phase) {
            if (phase) {
                diagram._views.forEach(function (viewid) {
                    var view = diagram._views[viewid];
                    var panel = view.svg || view._canvas;
                    var element = panel.document.getElementById(phase.name + "_phase_g");
                    if (element)
                        element.parentNode.removeChild(element);
                });
            }
        },
        _updatePhaseStyle: function (phase, options, diagram) {
            if (phase && options) {
                var visible = phase.visible && ej.datavisualization.Diagram.Util.enableLayerOption(phase, "visible", diagram) ? "visible" : "hidden";
                diagram._svg.g({ "id": phase.name + "_phase_g", "visibility": visible });
                options.id = phase.name + "_phase";
                diagram._svg.g(options);
            }
        },

        _updatephase: function (node, diagram, group) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context._updatephase1(node, diagram, panel, group);
            });
        },

        _updatephase1: function (node, diagram, svg, parNode) {
            svg = svg ? svg : diagram._svg;

            if (parNode) {
                var tx = 0, ty = 0, transform = null;
                var points = [], nPoint;
                var bounds = ej.datavisualization.Diagram.Util.bounds(parNode);
                var children = diagram._getChildren(parNode.children);
                if (children.length > 1)
                    var header = diagram.nameTable[children[0]];
                var top = bounds.top + 50;
                var left = bounds.left + 50;
                var visibility = "visible";
                if (node.orientation == "vertical") {
                    tx = bounds.x;
                    ty = bounds.y + header.height + node.offset;
                    if (header)
                        top += header.height;
                    if (ty - .1 <= bounds.bottom && ty - .1 >= top) {
                        transform = "translate(" + tx + "," + ty + ")";
                    }
                    points.push({ x: 0, y: 0 });
                    points.push({ x: bounds.width, y: 0 });
                    nPoint = this._convertToSVGPoints(points);
                }
                else {
                    tx = bounds.x + node.offset;
                    ty = bounds.y;
                    if (tx - .1 <= bounds.right && tx - .1 > left) {
                        transform = "translate(" + tx + "," + ty + ")";
                    }
                    if (header) {
                        points.push({ x: 0, y: header.height });
                        points.push({ x: 0, y: bounds.height });
                    }
                    nPoint = this._convertToSVGPoints(points);
                }

                var attr = {
                    "points": nPoint,
                    "id": node.name + "_phase",
                };
                svg.polyline(attr);
                attr = {
                    "points": nPoint,
                    "id": node.name + "_phase_hitTest",
                };
                svg.polyline(attr);
                if (transform)
                    attr = {
                        "id": node.name + "_phase_g",
                        "transform": transform,
                        //"visibility": visibility
                    }
                if (node.label && diagram.model.labelRenderingMode != ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                    this._updatePhaseLabel(node, node.label, diagram)
                }
                svg.g(attr);
                if (svg.getElementById(attr.id))
                    $('#' + attr.id).insertAfter($('#' + attr.id)[0].parentNode.lastChild);
            }
        },
        _updatePhaseLabel: function (node, label, diagram) {
            var svg = diagram._svg;
            var bounds = diagram._getPhaseBounds(node);
            var text = svg.getElementById(node.name + "_" + label.name);
            if (text) {
                text.setAttribute("fill", label.fontColor);
                if (!label.text)
                    return;
                text.textContent = label.text;
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                this._wrapText(node, bounds, text, label, svg);
                this._alignTextOnPhase(node, bounds, text, label, svg);
            }
        },
        updateLabelStyle: function (node, label, svg, diagram) {
            if (!label.templateId) {
                if (diagram && diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                    var attr = {
                        "id": node.name + "_" + label.name + "_lblbg",
                        "fill": node._isHeader ? "transparent" : label.fillColor,
                        "stroke": node._isHeader ? "transparent" : label.borderColor, 
                        "stroke-width": label.borderWidth,
                        "pointer-events": "none",
                        "visibility": label.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden",
                        "fill-opacity": label.opacity,
                        "stroke-opacity": label.opacity,
                    };
                    svg.rect(attr);

                    attr = {
                        "id": node.name + "_" + label.name,
                        "class": "ej-d-label", "font-family": label.fontFamily,
                        "font-size": label.fontSize, "fill": label.fontColor,
                        "text-decoration": label.textDecoration,
                        "font-weight": label.bold ? "bold" : "normal",
                        "font-style": label.italic ? "italic" : "normal",
                        "visibility": label.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden",
                        "fill-opacity": label.opacity,
                        "stroke-opacity": label.opacity,
                    };
                    var text = svg.text(attr);

                    attr["class"] = text.getAttribute("class");
                    this._updateCssClass(label, attr);
                    ej.datavisualization.Diagram.Util.attr(text, attr);

                }
                else {
                    var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                    var text = $(htmlLayer).find("#" + node.name + "_" + label.name)[0];
                    if (node && text && label && !label.templateId) {
                        if (label.bold) text.style.fontWeight = "bold"; else text.style.fontWeight = "";
                        if (label.italic) text.style.fontStyle = "italic"; else text.style.fontStyle = "";
                        if (label.visible) text.style.visibility = ""; else text.style.visibility = "hidden";
                        text.style.opacity = label.opacity;
                        text.style.textDecoration = label.textDecoration;
                        text.style.fontFamily = label.fontFamily;
                        text.style.fontSize = label.fontSize + "px";
                        text.style.color = label.fontColor;
                        text.style.backgroundColor = label.fillColor;
                        text.style.borderColor = label.borderColor;
                        text.style.borderWidth = label.borderWidth + "px";
                        text.style.borderStyle = "solid";
                        if (node._isHeader) {
                            text.style.borderWidth = 0 + "px";
                            text.style.backgroundColor = "transparent";
                        }
                        var attr = this._updateCssClass(label, { "class": text.className });
                        if (attr)
                            text.className = attr["class"];
                    }
                }
            }
            else {
                if (diagram && diagram.model.labelRenderingMode !== ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                    var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                    var text = $(htmlLayer).find("#" + node.name + "_" + label.name)[0];
                    if (node && text && label) {
                        text.style.opacity = label.opacity;
                        if (label.visible) text.style.visibility = ""; else text.style.visibility = "hidden";
                    }
                }
            }
        },

        updatePort: function (node, port, svg, diagram) {
            var portshape = svg.getElementById(node.name + "_" + port.name);
            if (portshape) {
                if (portshape && portshape.parentNode)
                    portshape.parentNode.removeChild(portshape);
                var g = svg.getElementById(node.name + "_ej_ports");;
                portshape = ej.datavisualization.Diagram.SvgContext._renderPort(node, port, diagram._adornerSvg, diagram);
                g.appendChild(portshape);
            }

        },

        _updateNodeStyle: function (node, svg) {
            if (node && svg) {
                var attr = {};
                attr["opacity"] = node.opacity;
                attr["fill"] = node.fillColor;
                attr["stroke"] = node.borderColor;
                attr["stroke-width"] = node.borderWidth;
                attr["stroke-dasharray"] = node.borderDashArray;
                if (node.gradient)
                    attr["fill"] = this._renderGradient(node.name, node.gradient, svg);
                if (node.borderGradient)
                    attr["stroke"] = this._renderGradient(node.name, node.borderGradient, svg);
                if (node._type == "node") {
                    var type = node.type == "text" || node.type == "html" ? "_backRect" : "_shape";
                    if (node.type == "html") {
                        var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                        var element = $(htmlLayer).children("#" + node.name + "_parentdiv")[0].childNodes[0];
                        if (element) {
                            element.style.opacity = node.opacity;
                        }
                    }
                    var element = svg.getElementById(node.name + type);
                    if (element) {
                        attr["class"] = element.getAttribute("class");
                        this._updateCssClass(node, attr);
                        ej.datavisualization.Diagram.Util.attr(element, attr);
                    }

                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                        var shadow = svg.document.getElementById(node.name + "_shadow");
                        if (shadow)
                            ej.datavisualization.Diagram.Util.attr(shadow, { "fill": node.fillColor != "none" || node.fillColor != "transparent" ? "lightgrey" : "none" });
                    }
                }
            }
        },

        _updateConnectorStyle: function (connector, svg) {
            if (connector && svg) {
                var attr = {};
                attr["opacity"] = connector.opacity;
                attr["stroke"] = connector.lineColor;
                attr["stroke-width"] = connector.lineWidth;
                attr["stroke-dasharray"] = connector.lineDashArray;
                var element = svg.getElementById(connector.name + "_segments");
                if (element) {
                    attr["class"] = element.getAttribute("class");
                    this._updateCssClass(connector, attr);
                    ej.datavisualization.Diagram.Util.attr(element, attr);
                }

            }
        },

        updateTargetDecoratorStyle: function (connector, svg) {
            if (svg) {
                var attr = {};
                attr["stroke"] = connector.targetDecorator.borderColor;
                attr["fill"] = connector.targetDecorator.fillColor;
                var element = svg.getElementById(connector.name + "_targetDecorator");
                if (element) {
                    attr["class"] = element.getAttribute("class");
                    this._updateCssClass(connector.targetDecorator, attr);
                    ej.datavisualization.Diagram.Util.attr(element, attr);
                }
            }
        },

        updateSourceDecoratorStyle: function (connector, svg) {
            if (svg) {
                var attr = {};
                attr["stroke"] = connector.sourceDecorator.borderColor;
                attr["fill"] = connector.sourceDecorator.fillColor;
                var element = svg.getElementById(connector.name + "_sourceDecorator");
                if (element) {
                    attr["class"] = element.getAttribute("class");
                    this._updateCssClass(connector.sourceDecorator, attr);
                    ej.datavisualization.Diagram.Util.attr(element, attr);
                }
            }
        },

        updateNode: function (node, svg, diagram, layout, isoverView) {
            if (svg) {
                if (diagram && !diagram._isInit && node._status !== "new")
                    node._status = "update";
                this._updateLabels(node, svg, diagram, isoverView);
                this._updateNode(node, svg, diagram);
                if (node.outEdges.length)
                    this._updateIcons(node, svg, diagram);
                node._scaled = false;
                this._updatePorts(node, (diagram._adornerSvg && !isoverView) ? diagram._adornerSvg : svg, diagram, isoverView);
                if (diagram._layoutInAction) return;
                this._updateAssociatedConnector(node, svg, diagram);
            }
        },

        updateTextBlock: function (node, label, svg, diagram) {
            if (diagram && diagram.model.labelRenderingMode !== ej.datavisualization.Diagram.LabelRenderingMode.Svg) { 
                var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                var parent = $(htmlLayer).children("#" + node.name + "_label")[0];
                var textContainter = $(parent).children("#" + node.name + "_shape_lblbg")[0];
                var text = textContainter.childNodes[0];
                if (node && text && label) {
                    if (label.bold) text.style.fontWeight = "bold"; else text.style.fontWeight = "";
                    if (label.italic) text.style.fontStyle = "italic"; else text.style.fontStyle = "";
                    text.style.textDecoration = label.textDecoration;
                    text.style.fontFamily = label.fontFamily;
                    text.style.fontSize = label.fontSize + "px";
                    text.style.color = label.fontColor;
                }
            } 
            this._updateTextElement(node, svg, diagram);
        },

        _updateAssociatedConnector: function (node, svg, diagram) {
            var i, len;
            if (!diagram._associatedConnectorsUpdate) {
                if (node.inEdges && node.inEdges.length > 0) {
                    for (i = 0, len = node.inEdges.length; i < len; i++) {
                        if (diagram.nameTable[node.inEdges[i]]) {
                            if (diagram.nameTable[node.inEdges[i]] && ej.datavisualization.Diagram.Util.canBridge(diagram.nameTable[node.inEdges[i]], diagram)) {
                                ej.datavisualization.Diagram.Util.updateBridging(diagram.nameTable[node.inEdges[i]], diagram);
                                diagram._updateConnectorBridging(diagram.nameTable[node.inEdges[i]]);
                            }
                            if (!diagram._disableSegmentChange)
                                ej.datavisualization.Diagram.DiagramContext.update(diagram.nameTable[node.inEdges[i]], diagram);
                        }
                    }
                }
                if (node.outEdges && node.outEdges.length > 0) {
                    for (i = 0, len = node.outEdges.length; i < len; i++) {
                        if (diagram.nameTable[node.outEdges[i]]) {
                            if (diagram.nameTable[node.outEdges[i]] && ej.datavisualization.Diagram.Util.canBridge(diagram.nameTable[node.outEdges[i]], diagram)) {
                                ej.datavisualization.Diagram.Util.updateBridging(diagram.nameTable[node.outEdges[i]], diagram);
                                diagram._updateConnectorBridging(diagram.nameTable[node.outEdges[i]]);
                            }
                            if (!diagram._disableSegmentChange)
                                ej.datavisualization.Diagram.DiagramContext.update(diagram.nameTable[node.outEdges[i]], diagram);
                        }
                    }
                }
            }
        },

        _updateNode: function (node, svg, diagram, layout) {
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var x = node.offsetX - width * node.pivot.x;
            var y = node.offsetY - height * node.pivot.y;
            var angle = node.rotateAngle;           
            var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
            var visible = node.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden";
            if (ej.datavisualization.Diagram.Util.canCrispEdges(node, diagram)) {
                x = Math.floor(x) + 0.5
                y = Math.floor(y) + 0.5;
            }
            var attr = ({
                "id": node.name, "transform": "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")",
                "visibility": visible
            });
            if (!(ej.datavisualization.Diagram.Util.canEnablePointerEvents(node, diagram)))
                attr["style"] = "pointer-events:none";
            else
                attr["style"] = "";
            var flip = node.flip !== "none" ? node.flip : node._flip;
            if (flip && flip !== ej.datavisualization.Diagram.FlipDirection.None) {
                var attr1 = this.renderflipElement(node, diagram);
                if (attr1) {
                    attr["transform"] = "rotate(" + angle + "," + pt.x + "," + pt.y + ")" + this.renderflipElement(node, diagram);
                }

            }
            svg.g(attr);
            var type = node._shape ? node._shape : node.type;
            switch (type) {
                case "rectangle":
                    svg.rect({
                        "id": node.name + "_shape", "width": (width < 0) ? 0 : width, "height": (height < 0) ? 0 : height,
                    });
                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                        svg.rect({
                            "id": node.name + "_shadow", "width": node.width, "height": node.height,
                        });
                    break;
                case "ellipse":
                    svg.ellipse({
                        "id": node.name + "_shape", "rx": width / 2, "ry": height / 2,
                        "cx": width / 2, "cy": height / 2
                    });
                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                        svg.ellipse({
                            "id": node.name + "_shadow", "rx": node.width / 2, "ry": node.height / 2,
                            "cx": node.width / 2, "cy": node.height / 2
                        });
                    break;
                case "image":
                    this._updateBackgroundRect(node, svg);
                    var alignment = ej.datavisualization.Diagram.Util._getImageAlignment(node.contentAlignment);
                    var scale = node.scale == "none" ? "meet" : node.scale;
                    var attr = {
                        "id": node.name + "_shape", "preserveAspectRatio": (scale != "stretch" && alignment != "none" ? alignment + " " + scale : "none")
                    };
                    if (node.scale != "none") {
                        attr["width"] = width; attr["height"] = height;
                    }

                    svg.image(attr);
                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                        svg.rect({
                            "id": node.name + "_shadow", "width": node.width, "height": node.height,
                        });
                    break;
                case "path":
                    var d;
                    if (node._preventStretch)
                        d = node._absolutePath = node.pathData;
                    else {
                        if (node._scaled || !node._absolutePath) {
                            d = ej.datavisualization.Diagram.Geometry.updatePath(0, 0, width, height, node.pathData, svg, node._absoluteBounds);
                            node._absolutePath = d;
                            node._scaled = false;
                        }
                        else d = node._absolutePath;
                    }
                    svg.path({
                        "id": node.name + "_shape", "d": d,
                    });
                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                        svg.path({
                            "id": node.name + "_shadow", "d": d,
                        });
                    break;
                case "polygon":
                    this._updatePolygon(node, svg);
                    break;
                case "text":
                    this._updateTextElement(node, svg, diagram);
                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                        svg.rect({
                            "id": node.name + "_shadow", "width": node.width, "height": node.height,
                        });
                    break;
                case "html":
                    this._updateHtmlElement(node, svg, diagram);
                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                        svg.rect({
                            "id": node.name + "_shadow", "width": node.width, "height": node.height
                        });
                    break;
                case "native":
                    var object = this._scaleNodeContent(node, $("#" + node.name + "_shape")[0]);
                    var attr = {
                        "id": node.name + "_shape",
                    }
                    if (node.width)
                        attr["width"] = node.width;
                    if (node.height)
                        attr["height"] = node.height;
                    if (object) attr["transform"] = "translate(" + object.x + "," + object.y + "),scale(" + object.sx + "," + object.sy + ")"
                    svg.g(attr);
                    if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                        svg.rect({
                            "id": node.name + "_shadow", "width": node.width, "height": node.height
                        });
                    break;
            }

        },

        _updateHtmlElement: function (node, svg, diagram) {
            this._updateBackgroundRect(node, svg);
            var visibility = node.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden";
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var x = node.offsetX - width * node.pivot.x;
            var y = node.offsetY - height * node.pivot.y;
            var div;
            var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
            var parentDiv = $(htmlLayer).children("#" + node.name + "_parentdiv");
            if (parentDiv) {
                div = $(parentDiv).children("#" + node.name + "_html")[0];
                if (div) {
                    div.style.left = x + "px";
                    div.style.top = y + "px";
                    div.style.webkitTransform = "rotate(" + node.rotateAngle + "deg)";
                    div.style.MozTransform = "rotate(" + node.rotateAngle + "deg)";
                    div.style.OTransform = "rotate(" + node.rotateAngle + "deg)";
                    div.style.msTransform = "rotate(" + node.rotateAngle + "deg)";
                    div.style.transform = "rotate(" + node.rotateAngle + "deg)";
                    div.style.opacity = node.opacity;
                    div.style.visibility = visibility;
                }
            }
            if (div) {
                div.style.width = node.width.toString() + "px";
                div.style.height = node.height.toString() + "px";
            }
        },

        _updatePolygon: function (node, svg) {
            ej.datavisualization.Diagram.Geometry.updatePolygonPoints(node);
            svg.polygon({
                "id": node.name + "_shape", "points": this._convertToSVGPoints(node.points)
            });
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow)
                svg.polygon({
                    "id": node.name + "_shadow", "points": this._convertToSVGPoints(node.points)
                });
        },

        _convertToSVGPoints: function (points) {
            var pts = "";
            for (var i = 0, len = points.length; i < len; i++) {
                pts += points[i].x + "," + points[i].y + " ";
            }
            return pts.trim();
        },



        _renderTextElement: function (node, svg, g, diagram) {
            if (diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                this._renderBackgroundRect(node, svg, g);
                var label = node.textBlock;
                var nodeElement = svg.getElementById(node.name);

                var attr = {
                    "id": node.name + "_shape_lblbg", "class": "ej-d-label", "font-family": label.fontFamily, "font-size": label.fontSize, "fill": label.fontColor, "text-decoration": label.textDecoration, "font-weight": label.bold ? "bold" : "normal", "font-style": label.italic ? "italic" : "normal",
                };
                var textElement = svg.text(attr);
                nodeElement.appendChild(textElement);
                this._renderLabelSpanElement(textElement, node, label, svg, diagram, false);
            }
            else {
                var textElement = node.textBlock;
                if (textElement) {
                    var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                    this._renderBackgroundRect(node, svg, g);
                    var container = document.createElement("div");
                    var text = document.createElement("span");
                    ej.datavisualization.Diagram.Util.attr(text, { "id": node.name + "_label_lblbg", "class": "ej-d-label", "style": "display: inline-block; position: absolute; pointer-events: all; line-height: normal; alignment-baseline:middle" });
                    if (textElement.bold) text.style.fontWeight = "bold";
                    if (textElement.italic) text.style.fontStyle = "italic";
                    text.style.textDecoration = textElement.textDecoration;
                    text.style.fontFamily = textElement.fontFamily;
                    text.style.fontSize = textElement.fontSize + "px";
                    text.style.color = textElement.fontColor;
                    text.textContent = textElement.text;
                    var style = "display: inline-block; position: absolute; width: inherit; height: inherit; pointer-events: none; ";
                    ej.datavisualization.Diagram.Util.attr(container, { "id": node.name + "_shape_lblbg", "style": style });
                    container.appendChild(text);

                    var element = $(htmlLayer).children("#" + node.name + "_label")[0];
                    if (element) htmlLayer.removeChild(element);
                    element = document.createElement("div");
                    var width = node.width ? node.width : node._width;
                    var height = node.height ? node.height : node._height;
                    var x = node.offsetX - width * node.pivot.x;
                    var y = node.offsetY - height * node.pivot.y;
                    var style = "width:" + width + "px; height:" + height + "px; left:" + x + "px; top:" + y + "px; display: block; position: absolute; pointer-events: none; ";
                    var class1 = "ej-d-node";
                    ej.datavisualization.Diagram.Util.attr(element, { "id": node.name + "_label", "class": class1, "style": style });
                    element.style.webkitTransform = "rotate(" + node.rotateAngle + "deg) ";
                    element.style.MozTransform = "rotate(" + node.rotateAngle + "deg) ";
                    element.style.OTransform = "rotate(" + node.rotateAngle + "deg) ";
                    element.style.msTransform = "rotate(" + node.rotateAngle + "deg)";
                    element.style.transform = "rotate(" + node.rotateAngle + "deg) ";
                    element.appendChild(container);

                    if (htmlLayer)
                        htmlLayer.appendChild(element);
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    this._alignTextOnLabel(node, bounds, text, container, node.textBlock);
                    //this._renderShadow(node, svg, g);
                }
            }
        },

        _updateTextElement: function (node, svg, diagram) {
            if (diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                this._updateBackgroundRect(node, svg);
                var label = node.textBlock;
                var nodeElement = svg.getElementById(node.name);

                var attr = {
                    "id": node.name + "_shape_lblbg",
                    "class": "ej-d-label", "font-family": label.fontFamily, "font-size": label.fontSize, "fill": label.fontColor, "text-decoration": label.textDecoration, "font-weight": label.bold ? "bold" : "normal", "font-style": label.italic ? "italic" : "normal",
                };
                var textElement = svg.text(attr);
                this._updateLabelSpanElement(node, label, svg, diagram, false);
            }
            else {
                this._updateBackgroundRect(node, svg);
                var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                if (htmlLayer) {
                    var parent = this._findChild(htmlLayer.childNodes, node);
                    var visible = node.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden";
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    var width, height, x, y;
                    if (parent) {
                        width = bounds.width; height = bounds.height;
                        x = node.offsetX - node.width * node.pivot.x; y = node.offsetY - node.height * node.pivot.y;
                        parent.style.width = width + "px";
                        parent.style.height = height + "px";
                        parent.style.left = x + "px";
                        parent.style.top = y + "px";
                        parent.style.visibility = visible;
                        parent.style.webkitTransform = "rotate(" + node.rotateAngle + "deg)";
                        parent.style.MozTransform = "rotate(" + node.rotateAngle + "deg)";
                        parent.style.OTransform = "rotate(" + node.rotateAngle + "deg)";
                        parent.style.msTransform = "rotate(" + node.rotateAngle + "deg)";
                        parent.style.transform = "rotate(" + node.rotateAngle + "deg)";

                    }
                    var textContainer = $(parent).children("#" + node.name + "_shape_lblbg")[0];
                    if (textContainer) {
                        var text = textContainer.childNodes[0];
                        text.textContent = node.textBlock.text;
                        this._alignTextOnLabel(node, bounds, text, textContainer, node.textBlock, diagram);
                    }
                }
            }
        },

        _renderBackgroundRect: function (node, svg, g) {
            var fill = this._fill(node, svg);
            var fillBorder = this._fillBorder(node, svg);
            var attr = {
                "id": node.name + "_backRect", "class": "backrect", "x": 0, "y": 0,
                "width": node.width, "height": node.height, "fill": fill,
                "stroke": fillBorder, "stroke-width": node.borderWidth, "opacity": node.opacity,
                "stroke-dasharray": node.borderDashArray
            };
            this._addCssClass(node, attr);
            if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                var point = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                var shadow = {
                    "id": node.name + "_shadow", "class": "backrect", "width": node.width, "height": node.height, "stroke": "lightgrey", "fill": fill != "none" || fill != "transparent" ? "lightgrey" : "none",
                    "transform": "translate(" + point.x + "," + point.y + ")", "opacity": node.shadow.opacity
                };
                g.appendChild(svg.rect(shadow));
            }
            g.appendChild(svg.rect(attr));

        },

        _updateBackgroundRect: function (node, svg) {
            var fill = this._fill(node, svg);
            var fillBorder = this._fillBorder(node, svg);
            var attr = {
                "id": node.name + "_backRect", "x": 0, "y": 0,
                "width": node.width, "height": node.height,
                "fill": fill, "stroke": fillBorder, "stroke-width": node.borderWidth,
                "opacity": node.opacity, "stroke-dasharray": node.borderDashArray, "class": node.cssClass
            };
            svg.rect(attr);
        },

        _hideNode: function (node, svg) {
            var attr = { "id": node.name, "style": "pointer-events:none;" };
            svg.rect(attr);
        },

        _showNode: function (node, svg) {
            var attr = { "id": node.name, "style": "pointer-events:auto;" };
            svg.rect(attr);
        },
        _removePhasehelper: function (diagram) {
            if (diagram._adornerSvg.getElementById("phase_helper"))
                diagram._adornerSvg.removeChild(diagram._adornerSvg.getElementById("phase_helper"), diagram._adornerLayer);
        },
        _updatePhaseHelper: function (diagram, phase, bounds) {
            if (phase) {
                var svg = diagram._adornerSvg, scale = diagram._currZoom, attr;
                bounds.width = bounds.width < 0 ? 1 : bounds.width;
                bounds.height = bounds.height < 0 ? 1 : bounds.height;
                attr = {
                    "id": "phase_helper", "class": "helper", "pointer-events": "none", "width": bounds.width * scale, "height": bounds.height * scale
                };
                diagram._adornerSvg.rect(attr);
            }
        },
        _phasehelper: function (diagram, phase, bounds) {
            if (phase) {
                var svg = diagram._adornerSvg, scale = diagram._currZoom;
                var offsetX = (bounds.x + bounds.width / 2);
                var offsetY = (bounds.y + bounds.height / 2);
                var rect = svg.rect({
                    "id": "phase_helper", "class": "helper",
                    "stroke-width": 2, "stroke-dasharray": "3,3", "pointer-events": "none",
                    "width": bounds.width * scale, "height": bounds.height * scale, "fill": "transparent", "stroke": "green",
                    "transform": "translate(" + (offsetX - bounds.width / 2) * scale + "," + (offsetY - bounds.height / 2) * scale + "),rotate(" + 0 + "," + (bounds.width / 2) * scale + "," + (bounds.height / 2) * scale + ")"
                });
                diagram._adornerLayer.appendChild(rect);
            }
        },
        _drawContainerHelper: function (diagram) {
            var shape = diagram.activeTool.helper;
            var svg = diagram._adornerSvg;
            var scale = diagram._currZoom;
            if (shape)
                var bounds = ej.datavisualization.Diagram.Util.bounds(shape, true);
            var height = bounds.height;
            var width = bounds.width;
            var pivot;
            if (shape.pivot) pivot = { x: bounds.width * shape.pivot.x, y: bounds.height * shape.pivot.y };
            else pivot = { x: width / 2, y: height / 2 };
            var rotateAngle = shape.rotateAngle ? shape.rotateAngle : 0;
            var rect = svg.rect({
                "id": "helper", "class": "helper",
                "stroke-width": 1, "stroke-dasharray": "3,3", "pointer-events": "none",
                "width": width * scale, "height": height * scale, "fill": "transparent", "stroke": "red",
                "transform": "translate(" + (bounds.x) * scale + "," + (bounds.y) * scale + "),rotate(" + rotateAngle + "," + (pivot.x) * scale + "," + (pivot.y) * scale + ")"
            });
            diagram._adornerLayer.appendChild(rect);
        },

        _updateContainerHelper: function (diagram) {
            var attr;
            var shape = diagram.activeTool.helper;
            var scale = diagram._currZoom;
            if (shape)
                var bounds = ej.datavisualization.Diagram.Util.bounds(shape, true);
            var height = bounds.height;
            var width = bounds.width;
            var pivot;
            if (shape.pivot) pivot = { x: bounds.width * shape.pivot.x, y: bounds.height * shape.pivot.y };
            else pivot = { x: width / 2, y: height / 2 };
            diagram._raiseOffsetPropertyChange(shape, bounds.center.x, bounds.center.y, true);
            diagram._raiseSizePropertyChange(shape, bounds.width / shape.width, bounds.height / shape.height, true);
            var rotateAngle = shape.rotateAngle ? shape.rotateAngle : 0;
            attr = {
                "id": "helper", "class": "helper",
                "width": width * scale, "height": height * scale, "fill": "transparent", "stroke": "red",
                "transform": "translate(" + (bounds.x) * scale + "," + (bounds.y) * scale + "),rotate(" + rotateAngle + "," + (pivot.x) * scale + "," + (pivot.y) * scale + ")"
            };
            diagram._adornerSvg.rect(attr);
        },

        _removeContainerHelper: function (node, svg, parent) {
            if (svg.getElementById("helper"))
                svg.removeChild(svg.getElementById("helper"), parent);
        },
        //#endregion

        setNodeShape: function (node, svg, parent, diagram) {
            var g;
            if (parent) {
                var parentg = svg.getElementById(parent.name);
                g = $(parentg).find("#" + node.name)[0];
            }
            else {
                g = svg.getElementById(node.name);
            }
            if (g) {
                $(g).empty();
                this._renderNode(node, svg, g, diagram);
            }
        },

        setLine: function (connector, svg, parent, diagram) {
            var g;
            if (parent) {
                var parentg = svg.getElementById(parent.name);
                g = $(parentg).find("#" + connector.name)[0];
            }
            else {
                g = svg.getElementById(connector.name);
            }
            $(g).empty();

            this.renderConnector(connector, svg, g, diagram);
        },

        addNodeLabel: function (node, label, svg, parent, diagram) {
            this._renderLabels(node, svg, diagram);
        },
        //#endregion

        //#region Render Connector
        renderConnector: function (connector, svg, parent, diagram) {
            var g, attr;
            var visible = connector.visible && ej.datavisualization.Diagram.Util.enableLayerOption(connector, "visible", diagram) ? "visible" : "hidden";
            if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                attr = { "id": connector.name, "class": "ej-d-connector", "visibility": visible, "opacity": connector.opacity, "transform": "translate(" + 0.5 + "," + 0.5 + ")" };
            else
                attr = { "id": connector.name, "class": "ej-d-connector", "visibility": visible, "opacity": connector.opacity };
            if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(connector, diagram))
                attr["style"] = "pointer-events:none";
            g = svg.g(attr);
            if (parent) {
                if (parent.id !== g.id) {
                    parent.appendChild(g);
                }
            }
            else {
                svg.appendChild(g);
            }
            var seg = svg.g({ "id": connector.name + "segments" });
            this._renderSegments(connector, svg, seg, diagram);
            g.appendChild(seg);
            this._renderLabels(connector, svg, diagram);
            this._renderDecorators(connector, svg, g, diagram);
            if (connector.shape) {
                ej.datavisualization.Diagram.DefautShapes.updateInlineDecoratorsShape(connector, diagram);
                for (var i = 0; i < connector._inlineDecorators.length; i++)
                    this.renderNode(connector._inlineDecorators[i], svg, g, undefined, diagram);
            }
            return g;
        },

        _renderSegments: function (connector, svg, g, diagram) {
            var visibility = connector.visible && ((diagram && diagram._browserInfo ? diagram._browserInfo.name : ej.browserInfo().name) === "msie") ? "collapse" : "hidden";
            var path = this._findPath(connector, diagram);
            var attr = {
                "id": connector.name + "_hitTest", "class": "hitTest", "stroke-width": connector.lineHitPadding, "d": path,
                "stroke": "transparent", "visibility": "hidden"
            };
            if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(connector, diagram))
                attr["pointer-events"] = "none";
            else
                attr["pointer-events"] = connector.visible ? "stroke" : "none";
            var line = svg.path(attr);
            g.appendChild(line);
            attr = {
                "id": connector.name + "_segments",
                "d": path, "fill": "none", "stroke": connector.lineColor,
                "stroke-width": connector.lineWidth, "stroke-dasharray": connector.lineDashArray, "opacity": connector.opacity
            };
            this._addCssClass(connector, attr);
            line = svg.path(attr);
            g.appendChild(line);
            if (connector.shape && connector.shape.type == "umlactivity" && connector.shape.activityFlow == "exception") {
                var attr = {
                    "id": connector.name + "_Activityflow", "class": "umlactivityflow", "fill": "none", "stroke": connector.lineColor, "pointer-events": "none", "stroke-width": connector.lineWidth, "stroke-dasharray": connector.lineDashArray, "opacity": connector.opacity, "d": connector._temppath,
                };
                var line1 = svg.path(attr);
                this._addCssClass(connector, attr);
                g.appendChild(line1);
            }
        },

        _findPath: function (connector, diagram) {
            var st, end, path;
            for (var i = 0; i < connector.segments.length; i++) {
                var seg = connector.segments[i];
                if (seg._bridges.length > 0) {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        bridge._rendered = false;
                    }
                }
                var points = seg.points;
                if (connector.shape && connector.shape.flow == "sequence" && connector.shape.sequence == "default" && i == 0) {
                    var beginningpoint = { x: seg.points[0].x, y: seg.points[0].y };
                    var distance = ej.datavisualization.Diagram.Geometry.distance(seg.points[0], seg.points[1]);
                    distance = Math.min(30, distance / 2);
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(seg.points[0], seg.points[1]);
                    var transferpoint = ej.datavisualization.Diagram.Geometry.transform({ x: beginningpoint.x, y: beginningpoint.y }, angle, distance);
                    var startpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: transferpoint.x, y: transferpoint.y }, angle + 45, -12);
                    var endpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: startpoint1.x, y: startpoint1.y }, angle + 45, 12 * 2);
                    if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                        var path1 = "M" + Math.floor(startpoint1.x) + " " + Math.floor(startpoint1.y) + " L" + Math.floor(endpoint1.x) + " " + Math.floor(endpoint1.y);
                    else
                        var path1 = "M" + startpoint1.x + " " + startpoint1.y + " L" + endpoint1.x + " " + endpoint1.y;
                }
                if (connector.shape && connector.shape.type == "umlactivity" && connector.shape.activityFlow == "exception" && i == 0) {
                    var beginningpoint = { x: seg.points[0].x, y: seg.points[0].y };
                    var distance = ej.datavisualization.Diagram.Geometry.distance(seg.points[0], seg.points[1]);
                    distance = Math.max(30, distance / 2);
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(seg.points[0], seg.points[1]);
                    var transferpoint = ej.datavisualization.Diagram.Geometry.transform({ x: beginningpoint.x, y: beginningpoint.y }, angle, distance);
                    var startpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: transferpoint.x, y: transferpoint.y }, angle + 145, 9);
                    var endpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: startpoint1.x, y: startpoint1.y }, angle + 225, 7 * 2);
                    if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                        var path1 = "M" + Math.floor(startpoint1.x) + " " + Math.floor(startpoint1.y) + " L" + Math.floor(endpoint1.x) + " " + Math.floor(endpoint1.y);
                    else
                        var path1 = "M" + endpoint1.x + " " + startpoint1.y + "L" + endpoint1.x + " " + endpoint1.y + " L" + startpoint1.x + " " + startpoint1.y + " L" + startpoint1.x + " " + endpoint1.y;
                }
                if (i == 0) {
                    if (diagram && connector.sourceNode) var node = diagram._findNode(connector.sourceNode);
                    points = this._clipDecorators(connector, seg, true, node);
                    if (seg.type == "bezier" && connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                        points[0] = ej.datavisualization.Diagram.Util._adjustPoint(points[0], seg._point1, true, connector.lineWidth);
                    }
                    if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                        path = "M" + Math.floor(points[0].x) + " " + Math.floor(points[0].y);
                    else
                        path = "M" + points[0].x + " " + points[0].y;
                }
                if (i == connector.segments.length - 1) {
                    if (diagram && connector.targetNode) var node = diagram._findNode(connector.targetNode);
                    points = this._clipDecorators(connector, seg, false, node);
                }
                if (seg.type != "bezier") {
                    if (connector.cornerRadius > 0) {
                        for (var j = 0; j < points.length - 1; j++) {
                            var segLength = ej.datavisualization.Diagram.Geometry.distance(points[j], points[j + 1]);
                            if (segLength > 0) {
                                if (i < connector.segments.length - 1 || j < points.length - 2) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        end = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], false, segLength / 2);
                                    }
                                    else end = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], false, connector.cornerRadius);
                                }
                                else end = points[j + 1];

                                if (i > 0 || j > 0) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        st = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], true, segLength / 2);
                                        if (i < connector.segments.length - 1 || j < points.length - 2)
                                            end = null;
                                    }
                                    else st = ej.datavisualization.Diagram.Util._adjustPoint(points[j], points[j + 1], true, connector.cornerRadius);
                                }

                                if (st) {
                                    if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                                        path += " Q" + Math.floor(points[j].x) + " " + Math.floor(points[j].y) + " " + Math.floor(st.x) + " " + Math.floor(st.y);
                                    else
                                        path += " Q" + points[j].x + " " + points[j].y + " " + st.x + " " + st.y;
                                }
                                if (end) {
                                    if (seg._bridges.length > 0) {
                                        path = this._updateBridging(seg, path, j);
                                        if (seg.type === "orthogonal")
                                            path = this._updateBridging(seg, path, j + 1);
                                    }
                                    if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                                        path += " L" + Math.floor(end.x) + " " + Math.floor(end.y);
                                    else
                                        path += " L" + end.x + " " + end.y;
                                }
                            }
                        }
                    }
                    else {
                        for (var j = 0; j < points.length; j++) {
                            if (j > 0) {
                                path = this._updateBridging(seg, path, j);
                                if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                                    path += " L" + Math.floor(points[j].x) + " " + Math.floor(points[j].y);
                                else
                                    path += " L" + points[j].x + " " + points[j].y;
                            }
                        }
                    }
                }
                else {
                    var endPoint = seg._endPoint;
                    if (connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(seg._endPoint, seg._point2, true, connector.lineWidth);
                    }
                    if (connector.targetNode && diagram) {
                        var targetNode = diagram._findNode(connector.targetNode);
                        if (node.borderColor != "none")
                            endPoint = ej.datavisualization.Diagram.Util._adjustPoint(endPoint, seg._point2, true, targetNode.borderWidth / 2);
                    }
                    if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                        path += " C" + Math.floor(seg._point1.x) + " " + Math.floor(seg._point1.y) + " " + Math.floor(seg._point2.x) + " " + Math.floor(seg._point2.y) + " " + Math.floor(endPoint.x) + " " + Math.floor(endPoint.y);
                    else
                        path += " C" + seg._point1.x + " " + seg._point1.y + " " + seg._point2.x + " " + seg._point2.y + " " + endPoint.x + " " + endPoint.y;
                }
            }
            if (connector.shape && connector.shape.flow == "sequence" && connector.shape.sequence == "default") {
                path += path1;
            }
            if (connector.shape && connector.shape.activityFlow == "exception" && connector.shape.type == "umlactivity") {
                path = path;
                connector._temppath = path1;
            }
            return path;
        },

        _updateBridging: function (seg, path, pointIndex) {
            var pathData = path;
            if (seg._bridges.length > 0) {
                if (seg.type === "straight") {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (!bridge._rendered) {
                            pathData += " L" + bridge.startPoint.x + " " + bridge.startPoint.y;
                            pathData += bridge.path;
                        }
                    }
                }
                else if (seg.type === "orthogonal") {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (bridge.segmentPointIndex === pointIndex && !bridge._rendered) {
                            pathData += " L" + bridge.startPoint.x + " " + bridge.startPoint.y;
                            pathData += bridge.path;
                            bridge._rendered = true;
                        }
                    }
                }
            }
            return pathData;
        },

        _refreshSegments: function (connector, svg, diagram) {
            this._updateConnector(connector, svg, diagram);
            this._updateDecorators(connector, svg, diagram);
        },

        _refreshOnlySegments: function (connector, svg, diagram) {
            var path = this._findPath(connector, diagram);
            var element = svg.document.getElementById(connector.name + "_segments");
            if (element) {
                element.setAttribute("d", path);
                element = svg.document.getElementById(connector.name + "_hitTest");
                element.setAttribute("d", path);
            }
        },

        _clipDecorators: function (connector, segment, source, node) {
            var points = [];
            if (!source && connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var start, end;
                for (var i = 0; i < segment.points.length; i++) {
                    points[i] = segment.points[i];
                }
                start = points[points.length - 1];
                end = points[points.length - 2];
                var len = ej.datavisualization.Diagram.Geometry.distance(start, end);
                len = (len == 0) ? 1 : len;
                var width = connector.lineWidth;
                var newPoint = ej.datavisualization.Diagram.Point();
                newPoint.x = start.x + width * (end.x - start.x) / len;
                newPoint.y = start.y + width * (end.y - start.y) / len;
                if (node && node.borderColor != "none")
                    newPoint = ej.datavisualization.Diagram.Util._adjustPoint(newPoint, end, true, node.borderWidth / 2);
                points[points.length - 1] = newPoint;
            }
            else if (source && connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                for (var i = 0; i < segment.points.length; i++) {
                    points[i] = segment.points[i];
                }
                start = points[0];
                end = points[1];
                var len = ej.datavisualization.Diagram.Geometry.distance(start, end);
                len = (len == 0) ? 1 : len;
                var width = connector.lineWidth;
                var newPoint = ej.datavisualization.Diagram.Point();
                newPoint.x = start.x + width * (end.x - start.x) / len;
                newPoint.y = start.y + width * (end.y - start.y) / len;
                if (segment.type == "bezier") {
                    newPoint.x = start.x + (segment._point1.x - start.x) / len;
                    newPoint.y = start.y + (segment._point1.y - start.y) / len;
                }
                if (node && node.borderColor != "none")
                    newPoint = ej.datavisualization.Diagram.Util._adjustPoint(newPoint, segment.type != "bezier" ? end : segment._point1, true, node.borderWidth / 2);
                points[0] = newPoint;
            }
            else if (source) {
                for (var i = 0; i < segment.points.length; i++) {
                    points[i] = segment.points[i];
                }
                if (node && node.borderColor != "none")
                    points[0] = ej.datavisualization.Diagram.Util._adjustPoint(points[0], points[1], true, node.borderWidth / 2);
            }
            else {
                for (var i = 0; i < segment.points.length; i++) {
                    points[i] = segment.points[i];
                }
                if (node && node.borderColor != "none")
                    points[points.length - 1] = ej.datavisualization.Diagram.Util._adjustPoint(points[points.length - 1], points[points.length - 2], true, node.borderWidth / 2);
            }
            return points;
        },

        _updateConnector: function (connector, svg, diagram) {
            if (diagram && !diagram._isInit && connector._status !== "new")
                connector._status = "update";
            var path = this._findPath(connector, diagram);
            svg.path({ "id": connector.name + "_segments", "d": path });
            var attr = { "id": connector.name + "_hitTest", "d": path, "stroke-width": connector.lineHitPadding };
            if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(connector, diagram))
                attr["pointer-events"] = "none";
            else
                attr["pointer-events"] = (connector.isPhase || (diagram.activeTool.name === "move" && diagram.activeTool.inAction) ||
                    (diagram._selectedSymbol && diagram.selectionList[0] && diagram.selectionList[0].name == connector.name))
                    ? "none" : (connector.visible ? "stroke" : "none")
            svg.path(attr);
            if (connector.shape && connector.shape.type == "umlactivity" && connector.shape.activityFlow == "exception") {
                var attr = {
                    "id": connector.name + "_Activityflow", "class": "umlactivityflow", "fill": "none", "stroke": connector.lineColor, "pointer-events": "none", "stroke-width": connector.lineWidth, "stroke-dasharray": connector.lineDashArray, "opacity": connector.opacity, "d": connector._temppath,
                };
                svg.path(attr);
            }

        },

        updateConnector: function (connector, svg, diagram, isOverview) {
            //var svg = diagram._svg;
            if (svg) {
                var visible = connector.visible && ej.datavisualization.Diagram.Util.enableLayerOption(connector, "visible", diagram) ? "visible" : "hidden";
                var attr;
                if (ej.datavisualization.Diagram.Util.canCrispEdges(connector, diagram))
                    attr = { "id": connector.name, "visibility": visible, opacity: connector.opacity, "transform": "translate(" + 0.5 + "," + 0.5 + ")" };
                else
                    attr = { "id": connector.name, "visibility": visible, opacity: connector.opacity };
                if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(connector, diagram))
                    attr["style"] = "pointer-events:none";
                else
                    attr["style"] = "";
                if (!diagram._animatingLayout)
                    svg.g(attr);
                this._updateConnector(connector, svg, diagram);
                this._updateLabels(connector, svg, diagram, isOverview);
                this._updateDecorators(connector, svg, diagram);
                if (connector.shape) {
                    ej.datavisualization.Diagram.DefautShapes.updateInlineDecoratorsShape(connector, diagram);
                    for (var i = 0; i < connector._inlineDecorators.length; i++)
                        this.updateNode(connector._inlineDecorators[i], svg, diagram);
                }
            }
        },

        renderDecorators: function (connector, svg, diagram) {
            var g = svg.getElementById(connector.name);
            this._renderDecorators(connector, svg, g, diagram);
        },

        clearDecorators: function (connector, svg, diagram) {
            this._updateConnector(connector, svg, diagram);
            var g = svg.getElementById(connector.name);
            var dec = svg.getElementById(connector.name + "_targetDecorator");
            if (dec)
                svg.removeChild(dec, g);
            dec = svg.getElementById(connector.name + "_sourceDecorator");
            if (dec)
                svg.removeChild(dec, g);
        },
        //#endregion

        //#region Render Decorator
        _renderDecorators: function (connector, svg, g, diagram) {
            var startPoint;
            var endPoint;
            if (connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var segment = connector.segments[connector.segments.length - 1];
                startPoint = segment.points[segment.points.length - 2];
                endPoint = connector.targetPoint;
                if (segment.type == "bezier") {
                    startPoint = segment._point2;
                }
                if (connector.targetNode && diagram) {
                    var targetNode = diagram._findNode(connector.targetNode);
                    if (targetNode && targetNode.borderColor != "none")
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(endPoint, startPoint, true, targetNode.borderWidth / 2);
                }
                this._renderDecorator(connector.name + "_targetDecorator", endPoint,
                    startPoint, connector, connector.targetDecorator, svg, g);
            }
            if (connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var segment = connector.segments[0];
                startPoint = connector.sourcePoint;
                endPoint = segment.points[1];
                if (segment.type == "bezier") {
                    endPoint = segment._point1;
                }
                if (connector.sourceNode && diagram) {
                    var sourceNode = diagram._findNode(connector.sourceNode);
                    if (sourceNode && sourceNode.borderColor != "none")
                        startPoint = ej.datavisualization.Diagram.Util._adjustPoint(startPoint, endPoint, true, sourceNode.borderWidth / 2);
                }
                this._renderDecorator(connector.name + "_sourceDecorator", startPoint,
                    endPoint, connector, connector.sourceDecorator, svg, g);
            }
        },
        _renderIcons: function (node, diagram) {
            var expandicon = node.expandIcon;
            var collapseicon = node.collapseIcon;
            if (expandicon.shape != "none" || collapseicon.shape != "none") {
                var g;
                var width = node.width ? node.width : node._width || 0;
                var height = node.height ? node.height : node._height || 0;
                var name = node.name;
                var offX = 0, offY = 0, x = 0, y = 0, rAngle = 0;
                var visible = node.visible ? "visible" : "hidden";
                x = node.offsetX - width * node.pivot.x;
                y = node.offsetY - height * node.pivot.y;
                offX = node.offsetX;
                offY = node.offsetY;
                rAngle = node.rotateAngle;
                var attr = {
                    "id": name, "transform": "rotate(" + rAngle + "," + offX + "," + offY +
                        "),translate(" + x + "," + y + ")", "visibility": visible
                };
                var svg = diagram._adornerSvg;
                g = svg.g(attr);
                var expander = svg.document.parentNode.getElementsByClassName("ExpanderLayer")[0] || diagram._expander;
                expander.appendChild(g);
                if (expandicon != undefined && node.isExpanded) {
                    this._renderIcon(node, svg, expandicon, g, diagram);
                } if (collapseicon != undefined && !node.isExpanded) {
                    this._renderIcon(node, svg, collapseicon, g, diagram);
                }
            }
        },
        _renderIcon: function (node, svg, icon, g, diagram) {
            var shape;
            var attr, point;
            if (icon != undefined) {
                point = ej.datavisualization.Diagram.Util._getIconPosition(icon, ej.datavisualization.Diagram.Util.bounds(node, true), true);
                if (icon.shape != "path") {
                    this._renderExpanderTemplate(node, svg, icon, g, diagram, point);
                }
                else
                    //path
                    if (icon.shape == "path") {
                        var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute("id", node.name + "_expander");
                        g.setAttribute("class", "ej-d-icon-template");
                        var d = ej.datavisualization.Diagram.Geometry.updatePath(point.x - icon.width / 2, point.y - icon.height / 2, icon.width, icon.height, icon.pathData, svg);
                        var visible = node.visible ? "visible" : "hidden";
                        icon._absolutePath = d;
                        if (icon.margin.left && icon.margin.right)
                            icon.width -= (icon.margin.left || 0) + (icon.margin.right || 0);
                        if (icon.margin.top && icon.margin.bottom)
                            icon.height -= (icon.margin.top || 0) + (icon.margin.bottom || 0);
                        attr = {
                            "id": node.name + "_pathexpander",
                            "x": point.x, "y": point.y, "width": icon.width,
                            "height": icon.height, "fill": icon.borderColor, "stroke": icon.borderColor, "stroke-width": icon.borderWidth, "visibility": visible,
                            "d": d
                        };
                        this._addCssClass(g, attr);
                        var a = svg.path(attr);
                        g.appendChild(a);
                        return g;
                    }
                //image
                if (icon.shape == "image") {
                    var image = new Image();
                    image.src = icon.source;
                    var shape = svg.image(attr);
                    shape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", image.src);
                    g.appendChild(shape);

                } return shape;
            }
        },
        _renderExpanderTemplate: function (node, svg, icon, g, diagram, point, update) {
            //drawing iconShape using template
            var temp = this.construct_template_iconshape(icon, node.isExpanded, diagram);
            if (temp != "undefined") {
                if (update)
                    g.removeChild(svg.document.getElementById(node.name + "_expander"));
                var div = document.createElement('div'); div.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg"><g id="tempNative">' + temp + '</g></svg>';
                document.body.appendChild(div);
                var element = document.getElementById("tempNative");
                var content = element.cloneNode(true);
                content.id = node.name + "_expander";
                var bounds = element.getBBox();
                var width = icon.width;
                var height = icon.height;
                var delwidth = bounds.width ? width / (bounds.width) : 1;
                var delheight = bounds.height ? height / (bounds.height) : 1;
                div.parentNode.removeChild(div);
                g.appendChild(content);
                var ratio = Math.min(delwidth, delheight);
                var visible = node.visible ? "visible" : "hidden";
                if (icon.horizontalAlignment || icon.verticalAlignment) {
                    var x = 0, y = 0;
                    var offset = { x: icon.offset.x, y: icon.offset.y };
                    switch (icon.horizontalAlignment) {
                        case "left":
                            point.x += 0;
                            break;
                        case "center":
                            point.x -= icon.width / 2;
                            break;
                        case "right":
                            point.x -= icon.width;
                            break;
                    }
                    switch (icon.verticalAlignment) {
                        case "top":
                            point.y += 0;
                            break;
                        case "center":
                            point.y -= icon.height / 2;
                            break;
                        case "bottom":
                            point.y -= icon.height;
                            break;
                    }
                    var left = ((point.x) - bounds.x * delwidth);
                    var top = ((point.y) - bounds.y * delheight);
                    var attr = {
                        "id": node.name + "_expander", "class": "ej-d-icon-template",
                        "transform": "translate(" + left + "," + top + "),scale(" + delwidth + "," + delheight + ")",
                        "x": point.x, "y": point.y, "width": icon.width,
                        "height": icon.height, "fill": icon.borderColor, "stroke": icon.borderColor, "stroke-width": icon.borderWidth
                    }; svg.g(attr);
                }
            }
        },
        construct_template_iconshape: function (icon, expanded, diagram) {
            var content;
            if (icon.shape) {
                switch (icon.shape) {
                    case "arrowup":
                        content = '<rect  x="2.5" y="2.5" width="15" height="15" style="fill:#FFFFFF;stroke:#000000;stroke-miterlimit:10"/><path d="M8.7,7.2L8.9,7h2.2l0.2,0.2l0,0l4.8,4.8h-2.5L10,8.4L6.4,12H3.9L8.7,7.2L8.7,7.2z"/></path></rect>';
                        break;
                    case "arrowdown":
                        content = '<rect  x="2.5" y="2.5" width="15" height="15" style="fill:#FFFFFF;stroke:#000000;stroke-miterlimit:10"/><path d="M9,12.2l0.1,0.1h1.7l0.1-0.1l0,0l3.8-3.8h-2L10,11.2L7.2,8.4h-2L9,12.2L9,12.2z"/></path></rect>';
                        break;
                    case "plus":
                        content = '<rect x="2.5" y="2.5" width="15" height="15" style="fill:#FFFFFF;stroke:#000000;stroke-miterlimit:10"/><line style="fill:#FFFFFF;stroke:#000000;stroke-width:2;stroke-miterlimit:10" x1="6.1" y1="10" x2="13.9" y2="10"/></line><line style=" fill:#FFFFFF;stroke:#000000;stroke-width:2;stroke-miterlimit:10" x1="10" y1="6.1" x2="10" y2="13.9"/></line></rect>';
                        break;
                    case "minus":
                        content = ' <rect x="2.5" y="2.5" width="15" height="15" style="fill:#FFFFFF;stroke:#000000;stroke-miterlimit:10"/><line style="fill:#FFFFFF;stroke:#000000;stroke-width:2;stroke-miterlimit:10" x1="6.1" y1="10" x2="13.9" y2="10"/></line></rect>';
                        break;
                    case "template":
                        content = diagram._renderEjTemplate("#" + icon.templateId, icon);
                } return content;
            }
        },
        _updateIcons: function (node, svg, diagram) {
            var expandicon = node.expandIcon;
            var collapseicon = node.collapseIcon;
            if (expandicon.shape != "none" || collapseicon.shape != "none") {
                var g;
                var width = node.width ? node.width : node._width || 0;
                var height = node.height ? node.height : node._height || 0;
                var name = node.name;
                var offX = 0, offY = 0, x = 0, y = 0, rAngle = 0;
                var visible = node.visible ? "visible" : "hidden";
                x = node.offsetX - width * node.pivot.x;
                y = node.offsetY - height * node.pivot.y;
                offX = node.offsetX;
                offY = node.offsetY;
                rAngle = node.rotateAngle;
                var attr = {
                    "id": name, "transform": "rotate(" + rAngle + "," + offX + "," + offY +
                        "),translate(" + x + "," + y + ")", "visibility": visible
                };
                var svg = diagram._adornerSvg;
                g = svg.g(attr);
                var expander = svg.document.parentNode.getElementsByClassName("ExpanderLayer")[0] || diagram._expander;
                if (expandicon != undefined && node.isExpanded) {
                    this._updateIcon(node, diagram._adornerSvg, g, expandicon, diagram);
                } if (collapseicon != undefined && !node.isExpanded) {
                    this._updateIcon(node, diagram._adornerSvg, g, collapseicon, diagram);
                }
            }
        },
        _updateIcon: function (node, svg, g, icon, diagram) {
            var attr, point;
            var d, x;
            if (icon != undefined && (node._scaled || node._updateExpander)) {
                point = ej.datavisualization.Diagram.Util._getIconPosition(icon, ej.datavisualization.Diagram.Util.bounds(node, true), true);
                if (icon.shape != "path") {
                    if (node._scaled || node._updateExpander) {
                        //drawingtemplate
                        this._renderExpanderTemplate(node, svg, icon, g, diagram, point, true);
                    }
                }
                else {
                    if (icon.shape == "path") {
                        var d = ej.datavisualization.Diagram.Geometry.updatePath(point.x - icon.width / 2, point.y - icon.height / 2, icon.width, icon.height, icon.pathData, svg);
                        var visible = node.visible ? "visible" : "hidden";
                        icon._absolutePath = d;
                        if (icon.margin.left && icon.margin.right)
                            icon.width -= (icon.margin.left || 0) + (icon.margin.right || 0);
                        if (icon.margin.top && icon.margin.bottom)
                            icon.height -= (icon.margin.top || 0) + (icon.margin.bottom || 0);
                        attr = {
                            "id": node.name + "_pathexpander",
                            "x": point.x, "y": point.y, "width": icon.width,
                            "height": icon.height, "fill": icon.borderColor, "stroke": icon.borderColor, "stroke-width": icon.borderWidth, "visibility": visible,
                            "d": d
                        };
                        svg.path(attr);
                    }
                }
                //image
                if (icon.shape == "image") {
                    var image = new Image();
                    image.src = icon.source;
                    var shape = svg.image(attr);
                    shape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", image.src);
                    g.appendChild(shape);
                }

                node._updateExpander = false;
            }

        },
        _renderDecorator: function (name, point1, point2, connector, decorator, svg, g) {
            var shape;
            var attr;
            var d, x;
            var size = ej.datavisualization.Diagram.Size(decorator.width, decorator.height);
            switch (decorator.shape) {
                case "arrow":
                    d = this._constructArrow(point1, size);
                    attr = { "id": name, "class": "decorator", "d": d, "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth };
                    this._addCssClass(decorator, attr);
                    shape = svg.path(attr);
                    x = 1.1 * decorator.borderWidth;
                    break;
                case "openarrow":
                    d = this._constructArrow(point1, size, true);
                    attr = { "id": name, "class": "decorator", "d": d, "fill": "transparent", "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth };
                    this._addCssClass(decorator, attr);
                    shape = svg.path(attr);
                    x = 1.1 * decorator.borderWidth;
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    attr = {
                        "id": name, "class": "decorator", "rx": rx, "ry": ry, "cx": (point1.x + size.width / 2), "cy": (point1.y),
                        "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth
                    };
                    this._addCssClass(decorator, attr);
                    shape = svg.ellipse(attr);
                    x = 0.5 * decorator.borderWidth;
                    break;
                case "diamond":
                    d = this._constructDiamond(point1, size, svg);
                    attr = {
                        "id": name, "class": "decorator", "x": point1.x, "y": point1.y, "width": size.width,
                        "height": size.height, "d": d, "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth
                    };
                    this._addCssClass(decorator, attr);
                    shape = svg.path(attr);
                    x = 0.7 * decorator.borderWidth;
                    break;
                case "path":
                    d = ej.datavisualization.Diagram.Geometry.updatePath(point1.x, point1.y - size.height / 2, size.width, size.height, decorator.pathData, svg);
                    decorator._absolutePath = d;
                    attr = {
                        "id": name, "class": "decorator", "x": point1.x, "y": point1.y, "width": size.width,
                        "height": size.height, "d": d, "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth
                    };
                    this._addCssClass(decorator, attr);
                    shape = svg.path(attr);
                    x = 0.5 * decorator.borderWidth;
                    break;
            }
            //apply translate matrix and rotate matrix here
            if (shape) {
                if (decorator.borderColor != "none") {
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(point1, point2);
                    var extra = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, angle, x);
                    shape.setAttribute("transform", "translate(" + extra.x + "," + extra.y + "),rotate(" + angle + " " + point1.x + " " + point1.y + ")");
                }
                else
                    shape.setAttribute("transform", "rotate(" + ej.datavisualization.Diagram.Geometry.findAngle(point1, point2) + " " + point1.x + " " + point1.y + ")");
                g.appendChild(shape);
            }
        },

        _updateDecorators: function (connector, svg, diagram) {
            var startPoint;
            var endPoint;
            if (connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var segment = connector.segments[connector.segments.length - 1];
                var points = segment.points;
                startPoint = points[points.length - 2];
                endPoint = connector.targetPoint;
                if (segment.type == "bezier") {
                    startPoint = segment._point2;
                }
                if (connector.targetNode && diagram) {
                    var targetNode = diagram._findNode(connector.targetNode);
                    if (targetNode && targetNode.borderColor != "none")
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(connector.targetPoint, startPoint, true, targetNode.borderWidth / 2);
                }
                this._updateDecorator(connector.name + "_targetDecorator", endPoint, startPoint, connector, connector.targetDecorator, svg);
            }
            if (connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                var segment = connector.segments[0];
                var points = segment.points;
                startPoint = connector.sourcePoint;
                endPoint = points[1];
                if (segment.type == "bezier") {
                    endPoint = segment._point1;
                }
                if (connector.sourceNode && diagram) {
                    var sourceNode = diagram._findNode(connector.sourceNode);
                    if (sourceNode.borderColor != "none")
                        startPoint = ej.datavisualization.Diagram.Util._adjustPoint(connector.sourcePoint, endPoint, true, sourceNode.borderWidth / 2);
                }
                this._updateDecorator(connector.name + "_sourceDecorator", startPoint, endPoint, connector, connector.sourceDecorator, svg);
            }
        },

        _updateDecorator: function (name, point1, point2, connector, decorator, svg) {
            var shape;
            var attr;
            var d, x;
            var size = ej.datavisualization.Diagram.Size(decorator.width, decorator.height);

            switch (decorator.shape) {
                case "arrow":
                    d = this._constructArrow(point1, size);
                    attr = { "id": name, "d": d };
                    shape = svg.path(attr);
                    x = 1.1 * decorator.borderWidth;
                    break;
                case "openarrow":
                    d = this._constructArrow(point1, size, true);
                    attr = { "id": name, "d": d, "fill": "transparent", "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth };
                    shape = svg.path(attr);
                    x = 1.1 * decorator.borderWidth;
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    attr = { "id": name, "rx": rx, "ry": ry, "cx": (point1.x + size.width / 2), "cy": (point1.y), "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth };
                    shape = svg.ellipse(attr);
                    x = 0.5 * decorator.borderWidth;
                    break;
                case "diamond":
                    d = this._constructDiamond(point1, size, svg);
                    attr = { "id": name, "x": point1.x, "y": point1.y, "width": size.width, "height": size.height, "d": d, "fill": decorator.fillColor, "stroke": decorator.borderColor, "stroke-width": decorator.borderWidth };
                    shape = svg.path(attr);
                    x = 0.7 * decorator.borderWidth;
                    break;
                case "path":
                    d = ej.datavisualization.Diagram.Geometry.updatePath(point1.x, point1.y - size.height / 2, size.width, size.height, decorator.pathData, svg);
                    decorator._absolutePath = d;
                    attr = {
                        "id": name, "d": d
                    };
                    shape = svg.path(attr);
                    x = 0.5 * decorator.borderWidth;
                    break;
            }
            //apply translate matrix and rotate matrix here
            if (shape) {
                if (decorator.borderColor != "none") {
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(point1, point2);
                    var extra = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, angle, x);
                    shape.setAttribute("transform", "translate(" + extra.x + "," + extra.y + "),rotate(" + angle + " " + point1.x + " " + point1.y + ")");
                }
                else
                    shape.setAttribute("transform", "rotate(" + ej.datavisualization.Diagram.Geometry.findAngle(point1, point2) + " " + point1.x + " " + point1.y + ")");
            }
        },

        _constructArrow: function (point, size, isOpen) {
            var path = new ej.datavisualization.Diagram.Path();
            path.moveTo(point.x + size.width, point.y + size.height / 2);
            path.lineTo(point.x, point.y);
            path.lineTo(point.x + size.width, point.y - size.height / 2);
            if (!isOpen) {
                path.close();
            }
            return path.toString();
        },

        _constructDiamond: function (point, size, svg) {
            var path = new ej.datavisualization.Diagram.Path();
            path.moveTo(point.x + size.width, point.y);
            path.lineTo(point.x + size.width / 2, point.y + size.height / 2);
            path.lineTo(point.x, point.y);
            path.lineTo(point.x + size.width / 2, point.y - size.height / 2);
            path.lineTo(point.x + size.width, point.y);
            var d = path.toString();
            return d;
        },
        //#endregion

        //#region Render Label
        _addLabel: function (node, label, panel, diagram, index) {
            if (diagram && diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                var container = this._renderSVGLabel(node, label, panel, diagram);
                if (index != undefined) {
                    if (index != node.labels.length - 1 && !(index > node.labels.length - 1)) {
                        var currentLabel = node.labels[index];
                        if (currentLabel) {
                            var curLblElement = diagram._svg.document.getElementById(node.name + "_" + currentLabel.name + "_lblbg");
                            var labelBG = diagram._svg.document.getElementById(node.name + "_" + label.name + "_lblbg");
                            var labelEle = diagram._svg.document.getElementById(node.name + "_" + label.name);
                            if (curLblElement && labelBG)
                                curLblElement.parentNode.insertBefore(labelBG, curLblElement);
                            if (labelEle && labelEle)
                                curLblElement.parentNode.insertBefore(labelEle, curLblElement);
                        }
                    }
                }
            }
            else {
                var width, height, x, y;
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                width = bounds.width;
                height = bounds.height;
                x = bounds.x; y = bounds.y;
                var element;
                var htmlLayer = panel.document.parentNode.getElementsByClassName("htmlLayer")[0];
                element = $(htmlLayer).children("#" + node.name + "_label")[0];
                var classname = node._type === "node" ? "ej-d-node" : (node._type === "group" ? "ej-d-group" : "ej-d-connector");
                if (!element) {
                    element = document.createElement("div");
                    var style = "width:" + width + "px; height:" + height + "px; left:" + x + "px; top:" + y + "px; display: block; position: absolute; pointer-events: none; " + "; padding: inherit;";
                    var class1 = node._type === "node" ? "ej-d-node" : (node._type === "group" ? "ej-d-group" : "ej-d-connector");
                    if (node._isClassifier)
                        class1 += " " + "ej-d-classifier";
                    ej.datavisualization.Diagram.Util.attr(element, { "id": node.name, "class": class1, "style": style });
                    if (node.rotateAngle) {
                        element.style.webkitTransform = "rotate(" + node.rotateAngle + "deg) ";
                        element.style.MozTransform = "rotate(" + node.rotateAngle + "deg) ";
                        element.style.OTransform = "rotate(" + node.rotateAngle + "deg) ";
                        element.style.msTransform = "rotate(" + node.rotateAngle + "deg)";
                        element.style.transform = "rotate(" + node.rotateAngle + "deg) ";
                        element.style["transform-origin"] = node.pivot.x * 100 + "% " + node.pivot.y * 100 + "%";

                    }
                    if (htmlLayer) htmlLayer.appendChild(element);
                }
                ej.datavisualization.Diagram.Util.attr(element, { "id": node.name + "_label", "class": classname });
                var container = this._renderLabel(node, bounds, label, element, htmlLayer, panel, width, height, diagram);
                if (index != undefined) {
                    element.insertBefore(container, element.childNodes[index]);
                }
            }
        },
        _getCharBoundsValues: function (char, label, svg, node, index) {

            var attr = {
                "id": node.name + "_" + label.name + "temp",
                "class": "ej-d-label", "font-family": label.fontFamily,
                "font-size": label.fontSize,

            };
            var textElement = svg.text(attr);
            svg.document.appendChild(textElement);
            var tspan = svg.tspan({
                "id": node.name + "_" + label.name + "temp_snap"
            });
            tspan.textContent = char;
            textElement.appendChild(tspan);
            var normal = textElement.childNodes[0].getComputedTextLength();

            attr["font-style"] = "normal";
            attr["font-weight"] = "bold";
            svg.text(attr);
            var bold = textElement.childNodes[0].getComputedTextLength();

            attr["font-style"] = "italic";
            attr["font-weight"] = "normal";
            svg.text(attr);
            var italic = textElement.childNodes[0].getComputedTextLength();

            attr["font-style"] = "italic";
            attr["font-weight"] = "bold";
            svg.text(attr);
            var boldItalic = textElement.childNodes[0].getComputedTextLength();
            svg.document.removeChild(textElement);
            if (char == " ") {
                if (label.text) {
                    var pre = label.text[index - 1] && label.text[index - 1] != "\n" ? label.text[index - 1] : "W";
                    var next = label.text[index + 1] && label.text[index + 1] != "\n" ? label.text[index + 1] : "W";
                }
                var forSpace1 = this._getCharBoundsValues(pre, label, svg, node, index);
                var forSpace2 = this._getCharBoundsValues(next, label, svg, node, index);
                var forSpace3 = this._getCharBoundsValues(pre + " " + next, label, svg, node, index);
                return {
                    normal: forSpace3.normal - (forSpace1.normal + forSpace2.normal),
                    bold: forSpace3.bold - (forSpace1.bold + forSpace2.bold),
                    italic: forSpace3.italic - (forSpace1.italic + forSpace2.italic),
                    boldItalic: forSpace3.boldItalic - (forSpace1.boldItalic + forSpace2.boldItalic)
                }
            }
            return {
                normal: normal, bold: bold, italic: italic, boldItalic: boldItalic
            }
            return Wbounds;
        },

        _updateHashTableValues: function (textSeries, fontTable, label, node, svg, diagram) {

            for (var j = 0; j < textSeries.length; j++) {
                if (!fontTable[textSeries[j]]) {
                    var cchar = textSeries[j] == "\n" ? "new_space_line" : textSeries[j];
                    fontTable[cchar] = this._getCharBoundsValues(textSeries[j], label, svg, node, j);
                }
            }
        },
        _updateHashTable: function (label, node, svg, diagram, isTextOverFlow) {
            if (label && svg && diagram) {
                if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.Wrap || isTextOverFlow) {
                    if (label.text != "" || label.hyperlink != "") {
                        var text = label.text ? label.text : label.hyperlink;
                        var fontTable = diagram._labelHashTable[label.fontFamily+ "_" + label.fontSize];
                        if (!fontTable)
                            fontTable = diagram._labelHashTable[label.fontFamily+ "_" + label.fontSize] = {};
                        this._updateHashTableValues(text, fontTable, label, node, svg, diagram)
                    }
                }
                else if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.WrapWithOverflow) {
                    if (label.text != "" || label.hyperlink != "") {
                        var text = label.text ? label.text : label.hyperlink;
                        var newLines = text.split("\n");
                        for (var i = 0; i < newLines.length; i++) {
                            var newLine = newLines[i];
                            var textSeries = newLine.split(" ");
                            var fontTable = diagram._labelHashTable[label.fontFamily + "_" + label.fontSize];
                            if (!fontTable)
                                fontTable = diagram._labelHashTable[label.fontFamily + "_" + label.fontSize] = {};
                            this._updateHashTableValues(textSeries, fontTable, label, node, svg, diagram);
                            this._updateHashTableValues([" "], fontTable, label, node, svg, diagram);
                        }
                        fontTable["new_space_line"] = this._getCharBoundsValues(" ", label, svg, node);    
                    }
                    
                }
            }
        },

        _getSuitableLabelSize: function (label, char, diagram) {
            char = (char == "\n" || char === ".") ? "new_space_line" : char;
            if(char != '') {
                var hashChar = diagram._labelHashTable[label.fontFamily+ "_" + label.fontSize][char];
                if (label.bold && label.italic)
                    return hashChar.boldItalic;
                if (label.bold)
                    return hashChar.bold;
                if (label.italic)
                    return hashChar.italic;
                else
                    return hashChar.normal;
            }
            return;
        },
        _postionConnectorTextElement: function (node, label, textElement, svg, diagram) {
            var x = 0;
            var y = 0;
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            var textBounds = textElement.getBBox();
            var wideTextBounds = this._getCharBoundsValues("W", label, svg, node);
            var hAlign = label.horizontalAlignment;
            var vAlign = label.verticalAlignment;
            var relatetiveMode = false;
            if (node.segments && label.relativeMode == "segmentpath") {
                var obj = this._getConnectorHandlePosition(label, node, 1, diagram);
                var pt = obj.position;
                x = pt.x;
                y = pt.y;
                var alignment = ej.datavisualization.Diagram.Util._alignLabelOnSegments(node, label, diagram, obj);
                vAlign = alignment.vAlign; hAlign = alignment.hAlign
                relatetiveMode = true;
                switch (hAlign) {
                    case "left":
                        x = 0 + label.margin.left;
                        break;
                    case "right":
                        x = -textBounds.width - label.margin.right;
                        break;
                    case "center":
                        x = x + (-textBounds.width / 2) + (label.margin.left - label.margin.right);
                        break;
                    case "stretch":
                        x = (textBounds.width / 2);
                        break;
                }
                switch (vAlign) {
                    case "top":
                        y = 0 + label.margin.top;
                        break;
                    case "bottom":
                        y = -textBounds.height - label.margin.bottom;
                        break;
                    case "center":
                        y = y + (-textBounds.height / 2) + (label.margin.top - label.margin.bottom);
                        break;
                    case "stretch":
                        y = (textBounds.height / 2);
                        break;
                }
            }
            else {

                switch (hAlign) {
                    case "left":
                        x = textBounds.width / 2;
                        break;
                    case "right":
                        x = -textBounds.width / 2;
                        break;
                }
                switch (vAlign) {
                    case "top":
                        y = textBounds.height / 2;
                        break;
                    case "bottom":
                        y = -textBounds.height / 2;
                        break;
                }
                if (node.segments) {
                    x += nodeBounds.left;
                    y += nodeBounds.top;
                }
                x = x + (nodeBounds.width * label.offset.x);
                y = y + (nodeBounds.height * label.offset.y) - 2;
            }
            if (!label.relativeMode == "segmentpath") {
                x = x * (label.offset.x ? (label.offset.x / 0.5) : 0);
                y = y * (label.offset.y ? (label.offset.y / 0.5) : 0) + label.fontSize;
                var x = x + (nodeBounds.center.x - nodeBounds.width / 2);
                var y = y + (nodeBounds.center.y - nodeBounds.height / 2);
            }
            this._updateLabelBackground(x, y + label.fontSize, textBounds, node, label, textElement, svg, diagram);
            if (node.segments && node.segments.length > 0) {
                textElement.setAttribute("transform", "translate(" + x + "," + (y - 2) + ") rotate(" + label.rotateAngle + " " + (textBounds.x + (textBounds.width / 2)) + " " + (textBounds.y + (textBounds.height / 2)) + ")");
            }
            else {
                textElement.setAttribute("transform", "translate(" + x + "," + (y - 2) + ") rotate(" + label.rotateAngle + " " + (textBounds.x + (textBounds.width / 2)) + " " + (textBounds.y + (textBounds.height / 2)) + ")");
            }
        },

        _postionNodeTextElement: function (node, label, textElement, svg, diagram) {
            var x = 0;
            var y = 0;
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            var textBounds = textElement.getBBox();
            var textBounds1 = ej.datavisualization.Diagram.Rectangle(textBounds.x, textBounds.y, textBounds.width, textBounds.height);
            if (textBounds1.height >= 2)
                textBounds1.height -= 2;
            var wideTextBounds = this._getCharBoundsValues("W", label, svg, node);

            switch (label.horizontalAlignment) {
                case "left":
                    x = 0 + label.margin.left;
                    break;
                case "right":
                    x = -textBounds1.width - label.margin.right;
                    break;
                case "center":
                    x = (-textBounds1.width / 2) + (label.margin.left - label.margin.right);
                    break;
                case "stretch":
                    x = -(textBounds1.width / 2);
                    break;
            }
            switch (label.verticalAlignment) {
                case "top":
                    y = 0 + label.margin.top;
                    break;
                case "bottom":
                    y = -textBounds1.height - label.margin.bottom;
                    break;
                case "center":
                    y = (-textBounds1.height / 2) + (label.margin.top - label.margin.bottom);
                    break;
                case "stretch":
                    y = -(textBounds1.height / 2);
                    break;
            }
            x = x + (nodeBounds.width * label.offset.x);
            y = y + (nodeBounds.height * label.offset.y) - 2;

            this._updateLabelBackground(x, y + label.fontSize, textBounds1, node, label, textElement, svg, diagram);
            if (node.segments && node.segments.length > 0) {
                textElement.setAttribute("transform", "translate(" + (nodeBounds.center.x - (textBounds1.width / 2)) + "," + (nodeBounds.center.y - (textBounds1.height / 2) + label.fontSize) + ")");
            }
            else {
                if (node.type === "group" || (node.children && node.children.length > 0)) {
                    var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
                    var width = node.width ? node.width : node._width;
                    var height = node.height ? node.height : node._height;
                    var x = x + (node.offsetX - node.width / 2);
                    var y = y + (node.offsetY - node.height / 2);
                    var angle = node.rotateAngle + label.rotateAngle;
                    textElement.setAttribute("transform", "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")");
                }
                else
                    textElement.setAttribute("transform", "translate(" + x + "," + y + ") rotate(" + label.rotateAngle + " " + (textBounds1.x + (textBounds1.width / 2)) + " " + (textBounds1.y + (textBounds1.height / 2)) + ")");
            }
        },
        _postionSpanElement: function (node, label, textElement, svg, diagram) {
            for (var i = 0; i < textElement.childNodes.length; i++) {
                var child = textElement.childNodes[i];
                if (child) {
                    var position = this._getSVGTextAlignPosition(child, node, label, textElement, svg, diagram);
                    child.setAttribute("x", position.x);
                }
            }
        },
        _getSVGTextAlignPosition: function (child, node, label, textElement, svg, diagram) {
            var x = 0, y = 0;
            if (child && label) {
                var width = child.getAttribute("totalWidth");
                if (width)
                    width = Number(width);
                else
                    width = child.getComputedTextLength();
                var textBounds = textElement.getBBox();
                switch (label.textAlign) {
                    case "left":
                        x = (textBounds.x);
                        break;
                    case "right":
                        x = (textBounds.x + textBounds.width) - (width);
                        break;
                    case "center":
                    case "justify":
                        x = (textBounds.x + textBounds.width / 2) - (width / 2);
                        break;
                }
            }
            return {
                x: x, y: y
            };

        },
        _updateTspanElement: function (node, label, textElement, svg, diagram) {
            this._postionSpanElement(node, label, textElement, svg, diagram);
            if (node.segments && node.segments.length > 0)
                this._postionConnectorTextElement(node, label, textElement, svg, diagram);
            else
                this._postionNodeTextElement(node, label, textElement, svg, diagram);
        },
        _updateLabelBackground: function (x, y, textBounds, node, label, textElement, svg, diagram) {
            var height = label.verticalAlignment === "stretch" ? node.height - 2 : textBounds.height;
            var width = label.horizontalAlignment === "stretch" ? node.width - 2 : textBounds.width;
            x = label.horizontalAlignment === "stretch" ? 1 : x;
            y = label.verticalAlignment === "stretch" ? 1 : y - label.fontSize;
            var labelbg = $("#" + node.name + "_" + label.name + "_lblbg")[0];
            var attr = {
                id: node.name + "_" + label.name + "_lblbg",
                height: height, width: width,
                x: x, y: y,
                "transform": "rotate(" + label.rotateAngle + " " + (x + width / 2) + " " + (y + height / 2) + ")"
            };
            if (node.type === "group" || (node.children && node.children.length > 0)) {
                var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
                var x = x + (node.offsetX - node.width / 2);
                var y = y + (node.offsetY - node.height / 2);
                var angle = node.rotateAngle + label.rotateAngle;
                attr.x = 0;
                attr.y = 0;
                attr.transform = "rotate(" + angle + "," + pt.x + "," + pt.y + "),translate(" + x + "," + y + ")";
            }
            svg.rect(attr);
        },
        _renderLabelSpanElement: function (textElement, node, label, svg, diagram, palette) {
            if (!label.templateId) {
                this._updateHashTable(label, node, svg, diagram);
                if (textElement)
                    textElement.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.Wrap) {
                    this._svgTextWrapping(textElement, node, label, svg, diagram, palette);
                }
                else if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.WrapWithOverflow) {
                    this._svgWordWrapping(textElement, node, label, svg, diagram, palette);
                }
                else {
                    var tspan = svg.tspan();
                    textElement.appendChild(tspan);
                    tspan.setAttribute("x", "0px");
                    tspan.setAttribute("y", "0px");
                    if (label.textOverflow) {
                        var labelSize = this._getLabelSize(label, node, diagram);
                        this._updateOverFlowTspan(textElement, node, label, svg, diagram, palette, label.text, tspan, labelSize)
                    }
                    else
                        tspan.textContent = label.text;

                }
                this._updateTspanElement(node, label, textElement, svg, diagram);
            }
        },
        _getLabelSize: function (label, node, diagram) {
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            return Math.max(label.width, bounds.width);
        },
        _svgTextWrapping: function (textElement, node, label, svg, diagram, palette) {
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            var fontSize = label.fontSize + 2;
            var tspan = svg.tspan();
            tspan.setAttribute("x", "0px");
            if (textElement.childNodes && textElement.childNodes.length === 0)
                tspan.setAttribute("dy", fontSize - 2);
            else
                tspan.setAttribute("dy", fontSize);
            textElement.appendChild(tspan);
            var totawidth = 0
            var text = label.text ? label.text : label.hyperlink;
            tspan.textContent += text[0];
            var labelSize = this._getLabelSize(label, node, diagram);
            totawidth += (this._getSuitableLabelSize(label, text[0], diagram) * (label.fontSize / label.fontSize));
            for (var i = 1; i < text.length; i++) {
                if (text[i] == "\n" || totawidth + (this._getSuitableLabelSize(label, text[i], diagram) * (label.fontSize / label.fontSize)) >= labelSize) {
                    if (label.textOverflow) {
                        if (label.overflowType == "ellipsis") {
                            tspan.textContent = tspan.textContent.substr(0, tspan.textContent.length - 3);
                            tspan.textContent += "...";
                        }
                        return false;
                    }
                    else {
                        if (textSeries.length - 1 > j || totawidth > 0) {
                            tspan.setAttribute("totalWidth", totawidth);
                            var tspan = svg.tspan();
                            textElement.appendChild(tspan);
                            var textElementBounds = textElement.getBBox();
                            tspan.setAttribute("x", "0px");
                            tspan.setAttribute("y", fontSize);
                        }
                        if (text[i] != "\n") {
                            tspan.textContent += text[i];
                            totawidth = (this._getSuitableLabelSize(label, text[i], diagram) * (label.fontSize / label.fontSize));
                        }
                        else totawidth = 0;
                    }
                }
                else {
                    tspan.textContent += text[i];
                    totawidth += (this._getSuitableLabelSize(label, text[i], diagram) * (label.fontSize / label.fontSize));
                }
            }
        },
        _updateOverFlowTspan: function (textElement, node, label, svg, diagram, palette, newLine, tspan, labelSize) {
            var textSeries = newLine;
            this._updateHashTable(label, node, svg, diagram, true);
            var eTextWidth = 0, eText = "", eTspanText = "", eDotWidth = 0;
            if (label.overflowType == "ellipsis")
                eDotWidth = (this._getSuitableLabelSize(label, ".", diagram) * (label.fontSize / 12)) * 3;
            for (var e = 0; e < textSeries.length; e++) {
                eText = textSeries[e];
                eTextWidth += (this._getSuitableLabelSize(label, eText, diagram) * (label.fontSize / 12));
                if (eTextWidth + eDotWidth >= labelSize)
                    break;
                eTspanText += eText;
            }
            tspan.textContent = eTspanText + ((label.overflowType == "ellipsis") ? "..." : "");
        },
        _svgWordWrapping: function (textElement, node, label, svg, diagram, palette) {
            var nodeBounds, tspan, totawidth = 0, text;
            nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            var newLines = label.text ? label.text.split("\n") : label.hyperlink.split("\n");
            var fontSize = label.fontSize + 2;
            for (var i = 0; i < newLines.length; i++) {
                var textElementBounds = textElement.getBBox();
                var tspan = svg.tspan();
                tspan.setAttribute("x", "0px");
                if (textElement.childNodes && textElement.childNodes.length === 0)
                    tspan.setAttribute("dy", fontSize - 2);
                else
                    tspan.setAttribute("dy", fontSize);
                textElement.appendChild(tspan);
                var newLine = newLines[i];
                totawidth = 0;
                var labelSize = this._getLabelSize(label, node, diagram);
                if (node._isHeader && label.rotateAngle) {
                    var labelRotate = false;
                    if (diagram) {
                        var lane = diagram.nameTable[node.parent];
                        if (lane && lane.isLane) {
                            labelRotate = true;
                        }
                        var phaseStack = diagram.nameTable[node.parent];
                        if (phaseStack && phaseStack.isPhaseStack && !node.orientation == "vertical") {
                            labelRotate = true;
                        }
                    }
                    if(labelRotate) {
                        labelSize = nodeBounds.height;
                    }
                }
                if (newLine === " ") {
                    tspan.textContent = '\u00a0';
                }
                else {
                    var textSeries = newLine.split(" ");
                    for (var j = 0; j < textSeries.length; j++) {
                        //totawidth += (this._getSuitableLabelSize(label, "new_space_line", diagram) * (label.fontSize / 12));
                        if (totawidth + (this._getSuitableLabelSize(label, textSeries[j], diagram) * (label.fontSize / label.fontSize)) >= labelSize) {
                            if (label.textOverflow) {
                                this._updateOverFlowTspan(textElement, node, label, svg, diagram, palette, newLine, tspan, labelSize);
                                break;
                            }
                            else {
                                if (textSeries.length - 1 > j || totawidth > 0) {
                                    tspan.setAttribute("totalWidth", totawidth);
                                    var tspan = svg.tspan();
                                    textElement.appendChild(tspan);
                                    var textElementBounds = textElement.getBBox();
                                    tspan.setAttribute("x", "0");
                                    tspan.setAttribute("dy", fontSize);
                                }
                                if (textSeries[j] != "\n") {
                                    tspan.textContent += textSeries[j];
                                    totawidth = (this._getSuitableLabelSize(label, textSeries[j], diagram) * (label.fontSize / label.fontSize));
                                }
                                else
                                    totawidth = 0;
                            }
                        }
                        else {
                            if (totawidth) {
                                tspan.textContent += " ";
                                totawidth += (this._getSuitableLabelSize(label, " ", diagram) * (label.fontSize / label.fontSize));
                            }
                            tspan.textContent += textSeries[j];
                            totawidth += (this._getSuitableLabelSize(label, textSeries[j], diagram) * (label.fontSize / label.fontSize));
                        }
                    }
                }
            }
        },
        _renderLabelSVG: function (node, label, svg, diagram, palette) {
            var nodeElement = svg.getElementById(node.name);
            var html = diagram._renderEjTemplate("#" + label.templateId, label);
            var div = document.createElement('div');
            div.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg"><g class="ej-label-template" id=' + node.name + "_" + label.name + '>' + html + '</g></svg>';
            document.body.appendChild(div);
            var content = document.getElementById(node.name + "_" + label.name).cloneNode(true);
            nodeElement.appendChild(content);
            div.parentNode.removeChild(div);
            return content;
        },
        _renderSVGLabel: function (node, label, svg, diagram, palette) {
            var nodeElement = svg.getElementById(node.name);
            if (label.templateId && label.templateType === ej.datavisualization.Diagram.TemplateType.Svg) {
                this._renderLabelSVG(node, label, svg, diagram, palette);
                this._updateSVGTemplate(node, label, svg, diagram, palette);
            }
            else {
                var attr = {
                    "id": node.name + "_" + label.name + "_lblbg",
                    "fill": node._isHeader ? "transparent" : label.fillColor,
                    "stroke": node._isHeader ? "transparent" : label.borderColor, 
                    "stroke-width": label.borderWidth,
                    "pointer-events": "none",
                    "visibility": label.visible ? "visible" : "hidden",
                    "fill-opacity": label.opacity,
                    "stroke-opacity": label.opacity,
                };

                var background = svg.rect(attr);
                nodeElement.appendChild(background);
                attr = {
                    "id": node.name + "_" + label.name,
                    "class": "ej-d-label", "font-family": label.fontFamily,
                    "font-size": label.fontSize,
                    "fill": label.hyperlink !== "" ? "blue" : label.fontColor,
                    "text-decoration": label.hyperlink !== "" ? "underline" : label.textDecoration,
                    "font-weight": label.bold ? "bold" : "normal",
                    "font-style": label.italic ? "italic" : "normal",
                    "visibility": label.visible ? "visible" : "hidden",
                    "fill-opacity": label.opacity,
                    "stroke-opacity": label.opacity,
                };
                this._addCssClass(label, attr);
                if (label.hyperlink) {
                    var anchor = document.createElementNS("http://www.w3.org/2000/svg", "a");
                    anchor.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", label.hyperlink);
                    anchor.setAttribute("target", '_blank');
                    anchor.setAttribute("class", "ej-d-anchor");
                    var textElement = svg.text(attr);
                    anchor.appendChild(textElement);
                    nodeElement.appendChild(anchor);
                }
                else {
                    var textElement = svg.text(attr);
                    nodeElement.appendChild(textElement);
                }
                this._renderLabelSpanElement(textElement, node, label, svg, diagram, palette);
            }
            return nodeElement;
        },
        _renderSVGLabels: function (node, svg, diagram, palette) {
            if (node.labels.length && node.type != "text") {
                var labels = node.labels;
                for (var i = 0; i < labels.length; i++) {
                    this._renderSVGLabel(node, labels[i], svg, diagram, palette);
                }
            }
        },
        _updateLabelSpanElement: function (node, label, svg, diagram, palette) {
            var textElement = svg.getElementById(node.name + "_" + label.name);
            if (node.textBlock)
                textElement = svg.getElementById(node.name + "_shape_lblbg");
            if (textElement) {
                $(textElement).empty();
                this._updateHashTable(label, node, svg, diagram);
                if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.Wrap) {
                    this._svgTextWrapping(textElement, node, label, svg, diagram, palette);
                }
                else if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.WrapWithOverflow) {
                    this._svgWordWrapping(textElement, node, label, svg, diagram, palette);
                }
                else {
                    var tspan = svg.tspan();
                    textElement.appendChild(tspan);
                    tspan.setAttribute("x", "0px");
                    tspan.setAttribute("y", label.fontSize);
                    if (label.textOverflow) {
                        var labelSize = this._getLabelSize(label, node, diagram);
                        this._updateOverFlowTspan(textElement, node, label, svg, diagram, palette, label.text, tspan, labelSize)
                    }
                    else
                        tspan.textContent = label.text;
                }
                this._updateTspanElement(node, label, textElement, svg, diagram);
            }
        },
        _updateSVGTemplate: function (node, label, svg, diagram, palette) {

            var x = 0;
            var y = 0;
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            var templateElement = svg.document.getElementById(node.name + "_" + label.name)
            if (templateElement) {
                var templateBounds = templateElement.getBBox();
                if (node.segments && label.relativeMode == "segmentpath") {

                    var obj = this._getConnectorHandlePosition(label, node, 1, diagram);
                    var pt = obj.position;
                    x = pt.x;
                    y = pt.y;
                    var alignment = ej.datavisualization.Diagram.Util._alignLabelOnSegments(node, label, diagram, obj);
                    var vAlign = alignment.vAlign; var hAlign = alignment.hAlign
                    var relatetiveMode = true;
                    switch (hAlign) {
                        case "left":
                            x = x - templateBounds.x + label.margin.left;
                            break;
                        case "right":
                            x = x - templateBounds.width - label.margin.right;
                            break;
                        case "stretch":
                        case "center":
                            x = (x - (templateBounds.width / 2)) + label.margin.left - label.margin.right;
                            break;
                    }
                    switch (vAlign) {
                        case "top":
                            y = y - templateBounds.y + label.margin.top;
                            break;
                        case "bottom":
                            y = y - templateBounds.height + label.margin.bottom;
                            break;
                        case "stretch":
                        case "center":
                            y = (y - (templateBounds.height / 2)) + label.margin.top - label.margin.bottom;
                            break;
                    }
                }
                else {
                    switch (label.horizontalAlignment) {
                        case "left":
                            x = nodeBounds.width / 2 + label.margin.left;
                            break;
                        case "right":
                            x = nodeBounds.width / 2 - templateBounds.width;
                            break;
                        case "stretch":
                            x = (nodeBounds.width / 2) - (templateBounds.width / 2);
                            break;
                        case "center":
                            x = ((nodeBounds.width / 2)) - (templateBounds.width / 2);
                            break;
                    }
                    switch (label.verticalAlignment) {
                        case "top":
                            y = nodeBounds.height / 2;
                            break;
                        case "bottom":
                            y = nodeBounds.height / 2 - templateBounds.height;
                            break;
                        case "stretch":
                            y = (nodeBounds.height / 2) - (templateBounds.height / 2);
                            break;
                        case "center":
                            y = (nodeBounds.height / 2) - (templateBounds.height / 2);
                            break;
                    }
                    x = x * (label.offset.x ? (label.offset.x / 0.5) : 0) + label.margin.left - label.margin.right
                    y = y * (label.offset.y ? (label.offset.y / 0.5) : 0) + label.margin.top - label.margin.bottom;
                    if (node.segments) {
                        x += nodeBounds.left;
                        y += nodeBounds.top;
                    }
                }
                templateElement.setAttribute("transform", "translate(" + x + "," + y + ") rotate(" + label.rotateAngle + " " + (templateBounds.x + (templateBounds.width / 2)) + " " + (templateBounds.y + (templateBounds.height / 2)) + ")");
            }
        },
        _updateLabelTemplate: function (node, label, svg, diagram, palette) {
            if (label.templateId) {
                if (diagram && diagram.model.labelRenderingMode === ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                    var oldContent = svg.document.getElementById(node.name + "_" + label.name);
                    oldContent.parentNode.removeChild(oldContent);
                    var content = this._renderLabelSVG(node, label, svg, diagram, palette);
                    var attr = {
                        "visibility": label.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden",
                        style: "opacity:" + label.opacity
                    }
                    ej.datavisualization.Diagram.Util.attr(content, attr);
                }
                else {
                    var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0] || diagram._htmlLayer;
                    var parent = this._findChild(htmlLayer.childNodes, node);
                    var textContainter = $(parent).children("#" + node.name + "_" + label.name + "_lblbg")[0];
                    var html = diagram._renderEjTemplate("#" + label.templateId, label);
                    var templateContainer = textContainter.childNodes[0];
                    templateContainer.innerHTML = html;
                }
            }
        },
        _updateSVGLabel: function (node, label, svg, diagram, palette) {
            if (label.templateId) {
                var content = document.getElementById(node.name + "_" + label.name);
                if (content) {
                    var attr = {
                        "visibility": label.visible ? "visible" : "hidden",
                        style: "opacity:" + label.opacity
                    }
                }
                ej.datavisualization.Diagram.Util.attr(content, attr);
                this._updateSVGTemplate(node, label, svg, diagram, palette);
            }
            else {
                var attr = {
                    "id": node.name + "_" + label.name,
                    "class": "ej-d-label", "font-family": label.fontFamily,
                    "font-size": label.fontSize,
                    "fill": label.hyperlink !== "" ? "blue" : label.fontColor,
                    "text-decoration": label.hyperlink !== "" ? "underline" : label.textDecoration,
                };
                svg.text(attr);
                this._updateLabelSpanElement(node, label, svg, diagram, palette);
            }
        },
        _updateSVGLabels: function (node, svg, diagram, palette) {
            if (node.labels.length && node.type != "text") {
                var labels = node.labels;
                for (var i = 0; i < labels.length; i++) {
                    this._updateSVGLabel(node, labels[i], svg, diagram, palette);
                }
            }
        },
        _renderLabels: function (node, svg, diagram, palette) {
            if (diagram && diagram.model.labelRenderingMode != ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                if (node.labels.length && node.type != "text") {

                    var labels = node.labels;
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    var width, height, x, y;
                    var element;
                    var isEleCreated = false;
                    for (var i = 0; i < labels.length; i++) {
                        if (node.labels[i].hyperlink)
                            this._renderSVGLabel(node, node.labels[i], svg, diagram, palette);
                        else {
                            if (!isEleCreated) {
                                isEleCreated = true;
                                var htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                                element = $(htmlLayer).children("#" + node.name + "_label")[0];
                                if (element) htmlLayer.removeChild(element);
                                element = document.createElement("div");
                                if (!node.segments) {
                                    width = node.width ? node.width : node._width;
                                    height = node.height ? node.height : node._height;
                                    x = node.offsetX - width * node.pivot.x;
                                    y = node.offsetY - height * node.pivot.y;
                                }
                                else {
                                    width = bounds.width;
                                    height = bounds.height;
                                    x = bounds.x; y = bounds.y;
                                }
                                if (palette) {
                                    x = 0;
                                    y = 0;
                                }
                                var visibility = node.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden";
                                var style = "width:" + width + "px; height:" + height + "px; left:" + x + "px; top:" + y + "px; display: block; position: absolute; pointer-events: none; " + "visibility:" + visibility + "; padding: inherit;";
                                var class1 = node._type === "node" ? "ej-d-node" : (node._type === "group" ? "ej-d-group" : "ej-d-connector");
                                if (node._isClassifier)
                                    class1 += " " + "ej-d-classifier";
                                ej.datavisualization.Diagram.Util.attr(element, {
                                    "id": node.name + "_label", "class": class1, "style": style
                                });
                                if (node.rotateAngle) {
                                    element.style.webkitTransform = "rotate(" + node.rotateAngle + "deg) ";
                                    element.style.MozTransform = "rotate(" + node.rotateAngle + "deg) ";
                                    element.style.OTransform = "rotate(" + node.rotateAngle + "deg) ";
                                    element.style.msTransform = "rotate(" + node.rotateAngle + "deg)";
                                    element.style.transform = "rotate(" + node.rotateAngle + "deg) ";
                                    element.style["transform-origin"] = node.pivot.x * 100 + "% " + node.pivot.y * 100 + "%";

                                }
                                if (htmlLayer) htmlLayer.appendChild(element);
                            }
                            this._renderLabel(node, bounds, labels[i], element, htmlLayer, svg, width, height, diagram)
                        }
                    }
                }
            }
            else {
                this._renderSVGLabels(node, svg, diagram, palette);
            }
        },
        _isParentVisible: function (name, svg) {
            var nodeEle = svg.document.getElementById(name);
            while (nodeEle && (nodeEle.getAttribute("class") != "DiagramLayer" || nodeEle.localName && nodeEle.localName !== "svg")) {
                if (nodeEle.localName && nodeEle.localName !== "svg")
                    break;
                if (nodeEle && (nodeEle.getAttribute("visibility") !== "visible"))
                    return true;
                nodeEle = nodeEle.parentNode;
            }
        },


        _renderLabel: function (node, nodeBounds, label, element, htmlLayer, svg, width, height, diagram) {
            var container = document.createElement("div");
            var text = document.createElement("span");
            if (label.templateId)
                var html = diagram._renderEjTemplate("#" + label.templateId, label);
            if (svg.document && svg.document.getAttribute("class") === "overview_svg")
                ej.datavisualization.Diagram.Util.attr(text, this._addCssClass(label, { "id": node.name + "_" + label.name, "class": "ej-d-label", "style": "display: inline-block; position: absolute; line-height: normal; pointer-events: none" }));
            else {
                var enabled = ej.datavisualization.Diagram.Util.canEnablePointerEvents(node, diagram);
                var class1 = "ej-d-label"
                if (node._isClassifier)
                    class1 += " " + "ej-d-classifier"
                ej.datavisualization.Diagram.Util.attr(text, this._addCssClass(label, { "id": node.name + "_" + label.name, "class": class1, "style": "display: inline-block; position: absolute; line-height: normal; pointer-events:" + (enabled ? "all" : "none") }));
            }
            if (label.horizontalAlignment == "stretch" || label.verticalAlignment == "stretch") {
                var actualDimensions = this._rotateLabel(width, height, label);
                if (label.horizontalAlignment == "stretch") text.style.width = Math.abs(actualDimensions.x) + "px";
                if (label.verticalAlignment == "stretch") {
                    text.style.alignItems = "center"; text.style.display = "flex"; text.style.justifyContent = "center"; text.style.height = Math.abs(actualDimensions.y) + "px";
                }
                if (label.textOverflow) {
                    text.style.display = "inline-block"
                    if (label.rotateAngle == 0 && node._isHeader) {
                        text.style.top = (Math.abs(actualDimensions.y) / 2 - label.fontSize / 2) + "px"
                        text.style.left = "0px"
                    }
                    else if (node._isHeader) {
                        text.style.left = (Math.abs(actualDimensions.y) / 2 - label.fontSize / 2) + "px"
                        text.style.top = "0px"
                    }
                }
            }
            if (label.bold) text.style.fontWeight = "bold";
            if (label.italic) text.style.fontStyle = "italic";
            if (!label.visible || this._isParentVisible(node.name, svg)) text.style.visibility = "hidden";
            text.style.opacity = label.opacity;
            text.style.textDecoration = label.textDecoration;
            text.style.fontFamily = label.fontFamily;
            text.style.fontSize = label.fontSize + "px";
            text.style.color = label.fontColor;
            text.style.backgroundColor = label.fillColor;
            text.style.borderColor = label.borderColor;
            text.style.borderWidth = label.borderWidth + "px";
            if (node._isHeader) {
                text.style.borderWidth = 0 + "px";
                text.style.backgroundColor = "transparent";
            }
            text.style.borderStyle = "solid";
            text.textContent = label.text;
            width = width > label.width ? width : label.width;
            width -= (label.padding.left + label.padding.right);
            height = height > label.height ? height : label.height;
            if (label.margin.left && label.margin.right) width -= (label.margin.left || 0) + (label.margin.right || 0);
            if (label.margin.top && label.margin.bottom) height -= (label.margin.top || 0) + (label.margin.bottom || 0);
            var style = "display: inline-block; position: absolute; pointer-events: none; " + "width:" + width + "px;height:" + height + "px;";
            ej.datavisualization.Diagram.Util.attr(container, { "id": node.name + "_" + label.name + "_lblbg", "style": style });
            if (!label.templateId) {
                container.appendChild(text);
                element.appendChild(container);
                this._alignTextOnLabel(node, nodeBounds, text, container, label, diagram, templateDiv);
            }
            if (label.templateId) {
                var templateDiv = document.createElement("div");
                templateDiv.setAttribute("class", "ej-label-template")
                templateDiv.setAttribute("id", node.name + "_" + label.name);
                templateDiv.innerHTML = html;
                container.appendChild(templateDiv);
                element.appendChild(container);
                var marginX, marginY;
                templateDiv.style.position = "absolute";
                this._alignTextOnLabel(node, nodeBounds, templateDiv, container, label, diagram);
            }

            return container;
        },

        _findChild: function (childNodes, node) {
            var length = childNodes.length;
            for (var i = 0; i < length; i++) {
                if (childNodes[i].id == node.name + "_label") {
                    return childNodes[i];
                }
            }
        },
        _updateLabels: function (node, svg, diagram, isOverview) {
            if (diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                if (!diagram._isSelectMode)
                    this._updateSVGLabels(node, svg, diagram);
            }
            else if (node.labels && node.type != "text") {
                var labels = node.labels;
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                var width, height, x, y;
                var htmlLayer = isOverview ? svg._htmlLayer : diagram._htmlLayer;
                if (!htmlLayer) {
                    htmlLayer = svg.document.parentNode.getElementsByClassName("htmlLayer")[0]
                }
                if (htmlLayer) {
                    var parent = htmlLayer.childNodes[node.zOrder];
                    if (!parent || parent.id != node.name) {
                        var childNodes = htmlLayer.childNodes;
                        parent = this._findChild(childNodes, node, svg);
                    }
                }
                if (parent) {
                    if (!node.segments) {
                        width = node.width ? node.width : node._width;
                        height = node.height ? node.height : node._height;
                        x = node.offsetX - width * node.pivot.x;
                        y = node.offsetY - height * node.pivot.y;
                    }
                    else {
                        width = bounds.width; height = bounds.height;
                        x = bounds.x; y = bounds.y;
                    }
                    var visibility = node.visible && ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram) ? "visible" : "hidden";
                    parent.style.width = width + "px";
                    parent.style.height = height + "px";
                    parent.style.left = x + "px";
                    parent.style.top = y + "px";
                    parent.style.opacity = node.opacity;
                    var transform = "rotate(" + node.rotateAngle + "deg) ";
                    var origin;
                    if (node.pivot)
                        origin = node.pivot.x * 100 + "% " + node.pivot.y * 100 + "%";
                    else
                        origin = 50 + "% " + 50 + "%";
                    parent.style.webkitTransform = transform;
                    parent.style.MozTransform = transform;
                    parent.style.OTransform = transform;
                    parent.style.msTransform = transform;
                    parent.style.transform = transform;
                    parent.style["transform-origin"] = parent.style["ms-transform-origin"] = parent.style["webkit-transform-origin"] =
                        parent.style["o-transform-origin"] = parent.style["moz-transform-origin"] = origin;
                    parent.style.visibility = visibility;
                }
                var textContainter, labelheight, labelwidth;
                for (var i = 0; i < labels.length; i++) {
                    if (node.labels[i].hyperlink) {
                        this._updateSVGLabel(node, node.labels[i], svg, diagram);
                    }
                    else if (parent) {
                        var label = labels[i];
                        textContainter = parent.childNodes[i];
                        if (textContainter) {
                            var text = textContainter.childNodes[0];
                            if (label.text || text.textContent) {
                                labelwidth = width > label.width ? width : label.width;
                                if (label.margin.left && label.margin.right) labelwidth -= (label.margin.left || 0) + (label.margin.right || 0);
                                if (label.margin.top && label.margin.bottom) labelheight -= (label.margin.top || 0) + (label.margin.bottom || 0);
                                labelwidth -= (label.padding.left + label.padding.right);
                                textContainter.style.height = labelheight + "px";
                                textContainter.style.width = labelwidth + "px";
                                if (!label.templateId)
                                    text.textContent = label.text;
                                if (label.horizontalAlignment == "stretch" || label.verticalAlignment == "stretch") {
                                    var actualDimensions = this._rotateLabel(width, height, label);
                                    if (label.horizontalAlignment == "stretch") text.style.width = Math.abs(actualDimensions.x) + "px";
                                    if (label.verticalAlignment == "stretch") {
                                        text.style.alignItems = "center"; text.style.display = "flex"; text.style.justifyContent = "center"; text.style.height = Math.abs(actualDimensions.y) + "px";
                                    }
                                    if (label.textOverflow)
                                        text.style.display = "inline-block";
                                }
                                this._alignTextOnLabel(node, bounds, text, textContainter, label, diagram);
                            }
                            else if (node._isHeader) {
                                if (diagram && diagram.activeTool && diagram.activeTool.name === "move" && diagram.activeTool.inAction)
                                    text.style["pointer-events"] = "none";
                                else
                                    text.style["pointer-events"] = "all";
                            }
                        }
                    }
                }


            }
        },

        _alignTextOnPhase: function (node, bounds, text, label, svg) {
            if (svg.getElementById(node.name))
                var phaseBounds = svg.getElementById(node.name).getBoundingClientRect();
            if (phaseBounds) {
                var textbounds = text.getBBox();
                var background = svg.getElementById(node.name + "_" + label.name + "_lblbg");
                text.setAttribute("transform", "translate(" + -textbounds.width / 2 + "," + 50 + "), rotate(" + 0 + "," + 0 + "," + 0 + ")");
                text.setAttribute("pointer-events", "auto");
                if (background) {
                    var attr = {
                        "width": textbounds.width, "height": textbounds.height, "fill": label.fillColor,
                        "stroke": label.borderColor, "stroke-width": label.borderWidth,
                        "transform": "translate(" + -textbounds.width + "," + phaseBounds.top + "), rotate(" + 0 + "," + 0 + "," + 0 + ")"
                    };
                    ej.datavisualization.Diagram.Util.attr(background, attr);
                }
            }
        },

        updateLabel: function (node, label, svg, diagram) {
            if (typeof label.text === "string") {
                var textContainter, labelheight, labelwidth, width, height;
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                var htmlLayer = diagram._htmlLayer || svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                var parent = $(htmlLayer).children("#" + node.name + "_label")[0];
                if (!node.segments) {
                    width = node.width ? node.width : node._width;
                    height = node.height ? node.height : node._height;
                }
                else {
                    width = bounds.width; height = bounds.height;
                }
                textContainter = $(parent).children("#" + node.name + "_" + label.name + "_lblbg")[0];
                if (textContainter) {
                    var text = textContainter.childNodes[0];
                    labelwidth = width > label.width ? width : label.width;
                    if (label.margin.left && label.margin.right) labelwidth -= (label.margin.left || 0) + (label.margin.right || 0);
                    if (label.margin.top && label.margin.bottom) labelheight -= (label.margin.top || 0) + (label.margin.bottom || 0);
                    labelwidth -= (label.padding.left + label.padding.right);
                    textContainter.style.height = labelheight + "px";
                    textContainter.style.width = labelwidth + "px";
                    textContainter.style.opacity = node.opacity;
                    if (!label.templateId)
                        text.textContent = label.text;
                    text.style.opacity = label.opacity;
                    if (label.horizontalAlignment == "stretch" || label.verticalAlignment == "stretch") {
                        var actualDimensions = this._rotateLabel(width, height, label);
                        if (label.horizontalAlignment == "stretch") text.style.width = Math.abs(actualDimensions.x) + "px";
                        if (label.verticalAlignment == "stretch") {
                            text.style.alignItems = "center"; text.style.display = "flex"; text.style.justifyContent = "center"; text.style.height = Math.abs(actualDimensions.y) + "px";
                        }
                        if (label.textOverflow)
                            text.style.display = "inline-block";
                    } if (node.type == "node" && !node.width && !node.height)
                        this.updateNode(node, svg, diagram);
                    this._alignTextOnLabel(node, bounds, text, textContainter, label, diagram);
                }
                else {
                    this._updateLabelSpanElement(node, label, svg, diagram);
                }
            }
        },

        _alignTextOnLabel: function (node, nodeBounds, text, textContainter, label, diagram) {
            var actualDimensions, hAlign, vAlign, obj, laneObject = (diagram && diagram.getNode) ? diagram.getNode(node.parent) : null;
            if (node.segments && label.relativeMode == "segmentpath") {
                obj = this._getConnectorHandlePosition(label, node, 1, diagram);
                var pt = obj.position;
                var offset = {
                    x: (pt.x - nodeBounds.x) / nodeBounds.width,
                    y: (pt.y - nodeBounds.y) / nodeBounds.height
                };
                var alignment = ej.datavisualization.Diagram.Util._alignLabelOnSegments(node, label, diagram, obj);
                vAlign = alignment.vAlign; hAlign = alignment.hAlign;
            }
            else {
                var offset = { x: label.offset.x, y: label.offset.y };
                hAlign = label.horizontalAlignment;
                vAlign = label.verticalAlignment;
            }
            if (!ej.datavisualization.Diagram.Util.canEnablePointerEvents(node, diagram))
                text.style["pointer-events"] = "none";
            else if (diagram && diagram.activeTool && diagram.activeTool.name === "move" && diagram.activeTool.inAction)
                text.style["pointer-events"] = "none";
            else
                text.style["pointer-events"] = "all";
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            width -= label.margin.left + label.margin.right;
            height -= label.margin.top + label.margin.bottom;
            actualDimensions = { x: width, y: height };
            if (label.textOverflow) {                 
                text.style.textOverflow = label.overflowType;
                text.style.overflow = "hidden";
                text.style.whiteSpace = "nowrap";
                if ((node.isPhase && node.orientation === "vertical") || (laneObject && laneObject.isLane && laneObject.orientation === "horizontal" && node._isHeader)) {
                    text.style.width = height + "px";
                    text.style.height = width + "px";
                }
                else 
                  text.style.width = width + "px";
            }
            if (label.rotateAngle) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, label.rotateAngle, offset.x, offset.y);
                actualDimensions = ej.Matrix.transform(matrix, { x: width, y: height });
            }
            var x = 0, y = 0, marginX, marginY;
            var canMoveLabel = ej.datavisualization.Diagram.Util.canMoveLabel(node);
            if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.NoWrap) {
                text.style.whiteSpace = "nowrap";
                text.style.wordWrap = "normal";
                text.style.maxWidth = "";
                text.style.maxHeight = "";
            }
            else {
                if (!label.templateId) {
                    if (!label.textOverflow) {
                        if (label.textAlign != "justify")
                            text.style.whiteSpace = "pre-wrap";
                        else text.style.whiteSpace = "pre-line";
                    }
                    if (label.wrapping == ej.datavisualization.Diagram.TextWrapping.Wrap) {
                        text.style.wordBreak = "break-all";
                        text.style.wordWrap = "break-word";
                        if (!node.segments) {
                            if (Math.abs(actualDimensions.x) < label.width) actualDimensions.x = label.width;
                            if (label.textOverflow) {
                                text.style.maxWidth = Math.abs(actualDimensions.x) + "px";
                                text.style.maxHeight = Math.abs(actualDimensions.y) + "px";
                            }
                        }
                        else {
                            if (label.textOverflow) {
                                text.style.maxWidth = (nodeBounds.width > label.width ? nodeBounds.width : label.width) + "px";
                            }
                        }
                    }
                    else {
                        text.style.wordWrap = "break-word";
                        text.style.maxWidth = "";
                        text.style.maxHeight = "";
                    }
                }
            }
            switch (hAlign) {
                case ej.datavisualization.Diagram.HorizontalAlignment.Left:
                    x = "0%";
                    marginX = label.margin.left + "px";
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Center:
                    x = "-50%";
                    marginX = label.margin.left - label.margin.right + "px";
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Right:
                    x = "-100%";
                    marginX = -label.margin.right + "px";
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Stretch:
                    x = "-50%";
                    break;
            }
            switch (vAlign) {
                case ej.datavisualization.Diagram.VerticalAlignment.Top:
                    y = "0%";
                    marginY = label.margin.top + "px";
                    break;
                case ej.datavisualization.Diagram.VerticalAlignment.Center:
                    y = "-50%";
                    marginY = label.margin.top - label.margin.bottom + "px";
                    break;
                case ej.datavisualization.Diagram.VerticalAlignment.Bottom:
                    y = "-100%";
                    marginY = -label.margin.bottom + "px";
                    break;
                case ej.datavisualization.Diagram.VerticalAlignment.Stretch:
                    y = "-50%";
                    break;
            }
            if (label.margin.left && label.margin.right && label.margin.top && label.margin.bottom && !node._isClassifier && !node._isClassMember) {
                text.style.marginLeft = marginX;
                text.style.marginTop = marginY;
            }
            else {
                textContainter.style.marginLeft = marginX;
                textContainter.style.marginTop = marginY;
            }
            offset.x *= 100;
            offset.y *= 100;
            text.style.textAlign = label.textAlign;
            text.style.webkitTransform = "translate(" + x + ", " + y + ") rotate(" + label.rotateAngle + "deg)";
            text.style.MozTransform = "translate(" + x + ", " + y + ") rotate(" + label.rotateAngle + "deg)";
            text.style.OTransform = "translate(" + x + ", " + y + ") rotate(" + label.rotateAngle + "deg)";
            text.style.msTransform = "translate(" + x + ", " + y + ") rotate(" + label.rotateAngle + "deg)";
            text.style.transform = "translate(" + x + ", " + y + ") rotate(" + label.rotateAngle + "deg)";

            if (label.horizontalAlignment != "stretch" && label.verticalAlignment != "stretch" && !(label.templateId)) {
                text.style.left = "0px";
                text.style.top = "0px";
            }
            if (textContainter) {
                textContainter.style.left = offset.x + "%";
                textContainter.style.top = offset.y + "%";
            }
        },

        _rotateLabel: function (width, height, label) {
            var actualDimensions = { x: width, y: height };
            if (label.rotateAngle) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, label.rotateAngle, 0, 0);
                actualDimensions = ej.Matrix.transform(matrix, { x: width, y: height });
            }
            return actualDimensions;
        },
        _renderLabelGroup: function (node, svg, diagram) {
            if (node._type == "group") {
                for (var i = 0; i < node.children.length; i++) {
                    var child = diagram.nameTable[diagram._getChild(node.children[i])];
                    if (child._type == "group")
                        this._renderLabelGroup(child, svg, diagram);
                    else
                        this._renderLabelsAsSvg(child, svg, diagram);
                }
                this._renderLabelsAsSvg(node, svg, diagram);
            }
        },
        //#region Render labels as svg
        _renderLabelsAsSvg: function (node, svg, diagram) {
            var g = svg.document.getElementById(node.name);
            if (node.type === "text") {
                this._renderTextElementAsSvg(node, node.textBlock, g, svg, diagram);
            } else {
                for (var i = 0; i < node.labels.length; i++) {
                    this._renderTextElementAsSvg(node, node.labels[i], g, svg, diagram);
                }
            }
        },
        _renderTextElementAsSvg: function (node, label, g, svg, diagram) {
            var attr = {
                "id": node.name + "_" + label.name, "class": "ej-d-label", "font-family": label.fontFamily,
                "font-size": label.fontSize, "fill": label.fontColor, "text-decoration": label.textDecoration, "visibility": label.visible || node.type === "text" ? "visible" : "hidden",
                "pointer-events": "none"
            };
            if (label.bold)
                attr["font-weight"] = "bold";
            if (label.italic)
                attr["font-style"] = "italic";
            var text = svg.text(attr);
            text.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            text.textContent = label.text;
            attr = {
                "id": node.name + "_" + label.name + "_lblbg",
                "fill": label.fillColor,
                "stroke": label.borderColor, "stroke-width": label.borderWidth, "transform": "translate(" + 0 + "," + 0 + ")"
            };
            var bg = svg.rect(attr);
            if (!label.text)
                return;
            g.appendChild(text);
            g.insertBefore(bg, text);
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            var labelRotate = false;
            if (node._isHeader && label.rotateAngle) {
                if (diagram) {
                    var lane = diagram.nameTable[node.parent];
                    if (lane && lane.isLane) {
                        labelRotate = true;
                    }
                    var phaseStack = diagram.nameTable[node.parent];
                    if (phaseStack && phaseStack.isPhaseStack && !node.orientation == "vertical") {
                        labelRotate = true;
                    }
                }
            }

            this._wrapText(node, bounds, text, label, svg, labelRotate);
            this._alignTextOnSvgLabel(node, bounds, text, label, svg, diagram, labelRotate);
        },

        _alignTextOnSvgLabel: function (node, nodeBounds, text, label, svg, diagram, labelRotate) {
            var bounds = text.getBBox();
            var offset = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds);
            if (labelRotate) {
                bounds = ej.datavisualization.Diagram.Util._rBounds(bounds, label.rotateAngle);
                offset = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds, null, null, labelRotate, text);
            }
            if (labelRotate)
                point = offset;
            else
                var point = this._adjustOffsetWithTextBounds(node, label, text, offset, bounds, nodeBounds, diagram);
            var bWidth = label.borderWidth || 0;
            text.setAttribute("transform", "translate(" + (point.x + bWidth) + "," + (point.y + bWidth) + "), rotate(" + label.rotateAngle + "," + (offset.x - point.x) + "," + (offset.y - point.y) + ")");
            //Updates the label background
            var background = svg.getElementById(node.name + "_" + label.name + "_lblbg");
            if (background) {
                var x = point.x + bounds.x;
                var y = point.y;
                //if (ej.browserInfo().name === "mozilla")
                //    y = point.y + label.fontSize / 2;
                x = x + bWidth / 2;
                y = y + bWidth / 2;
                var attr = {
                    "width": bounds.width + bWidth, "height": bounds.height + bWidth, "transform": "translate(" + x + "," + y + "), rotate(" + label.rotateAngle + "," + (offset.x - x) + "," + (offset.y - y) + ")", "fill": label.fillColor ? label.fillColor : "transparent",
                    "stroke": label.borderColor, "stroke-width": label.borderWidth
                };
                if (labelRotate)
                    attr["fill"] = "transparent";
                ej.datavisualization.Diagram.Util.attr(background, attr);
            }
        },
        _adjustOffsetWithTextBounds: function (node, label, text, offset, bounds, nodeBounds, diagram) {
            var point = { x: 0, y: 0 };
            var y = 0;
            var vAlign, hAlign;
            if (node.segments && label.relativeMode === "segmentpath") {
                var obj = this._getConnectorHandlePosition(label, node, 1, diagram);
                var pt = obj.position;
                var ptt = {
                    x: (pt.x - nodeBounds.x) / nodeBounds.width,
                    y: (pt.y - nodeBounds.y) / nodeBounds.height
                };
                ptt = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds, ptt);
                offset.x = ptt.x;
                offset.y = ptt.y;
                var alignment = ej.datavisualization.Diagram.Util._alignLabelOnSegments(node, label, diagram, obj);
                hAlign = alignment.hAlign;
                vAlign = alignment.vAlign;
            }
            else {
                hAlign = label.horizontalAlignment;
                vAlign = label.verticalAlignment;
            }
            if (vAlign == ej.datavisualization.Diagram.VerticalAlignment.Top)
                y = offset.y;
            else if (vAlign == ej.datavisualization.Diagram.VerticalAlignment.Center)
                y = offset.y - bounds.height / 2;
            else if (vAlign == ej.datavisualization.Diagram.VerticalAlignment.Bottom)
                y = offset.y - bounds.height;
            else if (vAlign == ej.datavisualization.Diagram.VerticalAlignment.Stretch)
                y = offset.y - bounds.height / 2;
            point.y = y;
            if (label.textAlign == "justify") {
                if (text.childNodes.length > 1) {
                    {
                        point.x = offset.x - node.width / 2;
                    }
                }
                else {
                    point.x = offset.x;
                }
            }
            else {
                switch (hAlign) {
                    case ej.datavisualization.Diagram.HorizontalAlignment.Left:
                        switch (label.textAlign) {
                            case ej.datavisualization.Diagram.TextAlign.Left:
                                point.x = offset.x;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Center:
                                point.x = offset.x + bounds.width / 2;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Right:
                                point.x = offset.x + bounds.width;
                                break;
                        }
                        break;
                    case ej.datavisualization.Diagram.HorizontalAlignment.Center:
                        switch (label.textAlign) {
                            case ej.datavisualization.Diagram.TextAlign.Left:
                                point.x = offset.x - bounds.width / 2;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Center:
                                point.x = offset.x;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Right:
                                point.x = offset.x + bounds.width / 2;
                                break;
                        }
                        break;
                    case ej.datavisualization.Diagram.HorizontalAlignment.Right:
                        switch (label.textAlign) {
                            case ej.datavisualization.Diagram.TextAlign.Left:
                                point.x = offset.x - bounds.width;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Center:
                                point.x = offset.x - bounds.width / 2;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Right:
                                point.x = offset.x;
                                break;
                        }
                        break;
                    case ej.datavisualization.Diagram.HorizontalAlignment.Stretch:
                        switch (label.textAlign) {
                            case ej.datavisualization.Diagram.TextAlign.Left:
                                point.x = offset.x - nodeBounds.width / 2;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Center:
                                point.x = offset.x;
                                break;
                            case ej.datavisualization.Diagram.TextAlign.Right:
                                point.x = offset.x + nodeBounds.width / 2;
                                break;
                        }
                        break;
                }
            }
            if (node.segments || node._type == "group") {
                point.x = point.x + nodeBounds.x;
                point.y = point.y + nodeBounds.y;
                offset.x += nodeBounds.x;
                offset.y += nodeBounds.y;
            }
            //if (ej.browserInfo().name === "mozilla")
            //    point.y = point.y - label.fontSize / 2;
            return point;
        },

        _wrapText: function (node, textBBox, text, label, svg, labelRotate) {
            var str = label.text; var attr = null;
            while (text.hasChildNodes()) {
                text.removeChild(text.lastChild);
            }
            var bbWidth, bbHeight;
            if (node.segments) {
                bbWidth = textBBox.width;
                bbHeight = textBBox.height;
            }
            else {
                bbWidth = textBBox.width - label.margin.left - label.margin.right;
                bbHeight = textBBox.height - label.margin.top - label.margin.bottom;
            }
            if (labelRotate) {
                var temp = bbWidth;
                bbWidth = bbHeight;
                bbHeight = temp;
            }
            bbWidth -= 2 * (label.borderWidth ? label.borderWidth : 1);
            bbWidth = bbWidth < label.width ? label.width : bbWidth;
            var eachLine = str.split('\n');
            var x, y, tspan, j, string = "", childNodes, bounds, i, k, txt = "", spltWord;
            if (svg.getElementById(text.id))
                childNodes = svg.getElementById(text.id).childNodes;
            if (childNodes) {
                var wrap = label.wrapping == "wrapwithoverflow" ? true : false;
                for (j = 0; j < eachLine.length; j++) {
                    tspan = svg.tspan();
                    tspan.style.fontSize = label.fontSize;
                    text.appendChild(tspan);
                    if (label.wrapping != "nowrap") {
                        if (eachLine[j] === " ") {
                            tspan.textContent = '\u00a0';
                        }
                        else {
                            var words = label.wrapping == "wrapwithoverflow" ? eachLine[j].split(" ") : eachLine[j];
                            for (i = 0; i < words.length; i++) {
                                var newword = words[i];
                                if (newword.indexOf('-') >= 0 && wrap) {
                                    tspan = this._splitHyphenWord(tspan, newword, text, label, bbWidth, svg);
                                    if (i == words.length - 1) {
                                        if (!(i == words.length - 1)) {
                                            tspan = svg.tspan();
                                            text.appendChild(tspan);
                                        }
                                    }
                                    else {
                                        if (this._getTextLength(svg, text, tspan.textContent + " " + (words[i + 1] || "")).width > bbWidth) {
                                            tspan = svg.tspan();
                                            text.appendChild(tspan);
                                        }
                                    }
                                }
                                else {
                                    tspan.textContent += ((tspan.textContent && wrap) ? " " : "") + words[i];
                                    bounds = childNodes[childNodes.length - 1].getComputedTextLength();
                                    if (bounds >= bbWidth) {
                                        if (!(i == words.length - 1)) {
                                            tspan = svg.tspan();
                                            text.appendChild(tspan);
                                        }
                                    }
                                    else {
                                        if (wrap || (label && label.wrapping === "wrap")) {
                                            var newText = tspan.textContent;
                                            if (i < words.length - 1) {
                                                if (words[i + 1].indexOf("-") >= 0 && wrap) {
                                                    tspan = this._splitHyphenWord(tspan, words[i + 1], text, label, bbWidth, svg);
                                                    if (this._getTextLength(svg, text, tspan.textContent + " " + (words[i + 1] || "")).width > bbWidth) {
                                                        tspan = svg.tspan();
                                                        text.appendChild(tspan);
                                                    }
                                                    i++;
                                                }
                                                else {
                                                    tspan.textContent += (wrap ? " " : "") + (words[i + 1] || "");
                                                    bounds = childNodes[childNodes.length - 1].getComputedTextLength();
                                                    tspan.textContent = newText;
                                                    if (bounds > bbWidth) {
                                                        tspan = svg.tspan();
                                                        text.appendChild(tspan);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else tspan.textContent += eachLine[j];
                }
                this._wrapTextAlign(text, childNodes, label.fontSize, label.textAlign, node, label, svg);
            }
        },

        _splitHyphenWord: function (tspan, hyphenWord, text, label, bbWidth, svg) {
            var txt = tspan.textContent;
            var wrap = label.wrapping == "wrapwithoverflow" ? true : false;
            var newText = tspan.textContent ? tspan.textContent + " " : "";
            var splitWords = hyphenWord.split("-");
            for (var i = 0; i < splitWords.length; i++) {
                newText += splitWords[i];
                var bounds = this._getTextLength(svg, text, newText);
                if (bounds >= bbWidth) {
                    tspan.textContent = txt;
                    tspan = svg.tspan();
                    text.appendChild(tspan);
                    if (i < splitWords.length - 1) {
                        newText = splitWords[i] + "-";
                    }
                    else
                        newText = splitWords[i]
                    txt = newText;
                }
                else {
                    if (wrap || (label && label.wrapping === "wrap")) {
                        txt = newText;
                        if (i < splitWords.length - 1) {
                            newText += "-";
                            if (this._getTextLength(svg, text, newText) > bbWidth) {
                                tspan.textContent = txt;
                                tspan = svg.tspan();
                                text.appendChild(tspan);
                                newText = "-";
                            }
                            else {
                                txt = newText;
                            }
                        }
                    }
                }
            }
            tspan.textContent = txt;
            return tspan;
        },

        _getTextLength: function (svg, text, textContent) {
            var length;
            var tspan = svg.tspan();
            text.appendChild(tspan);
            tspan.textContent = textContent;
            length = tspan.getComputedTextLength();
            text.removeChild(tspan);
            return length;
        },

        _getTSpanLength: function (tspan, label, svg, node) {
            var length = 0;
            if (tspan && tspan.textContent) {
                for (var i = 0; i < tspan.textContent.length; i++) {
                    length += this._getCharBoundsValues(tspan.textContent[i], label, svg, node).bold
                }
            }
            return length;
        },
        _wrapTextAlign: function (text, childNodes, height, textAlign, node, label, svg) {
            var x, difspace, wordSpacing, txt, prevHeight, prevX = null, def = 2, removeChild = [], tspan;
            for (var i = 0; i < childNodes.length; i++) {
                var tspan = childNodes[i];
                if (textAlign == "justify" && i != childNodes.length - 1) {
                    txt = tspan.textContent;
                    if (txt[txt.length - 1] == " ") {
                        txt = txt.slice(0, txt.length - 1);
                    } if (txt[0] == " ") {
                        txt = txt.slice(1, txt.length);
                    }
                    tspan.textContent = txt;
                    x = tspan.getComputedTextLength();
                    difspace = node.width - x;
                    wordSpacing = difspace / (txt.split(" ").length - 1);
                    tspan.setAttribute("word-spacing", wordSpacing + "px");
                    x = tspan.getComputedTextLength();
                }
                else {
                    var length = this._getTSpanLength(tspan, label, svg, node)
                    x = length ? length : tspan.getComputedTextLength();

                }
                if (textAlign == "justify") {
                    childNodes.length > 1 ? textAlign = "left" : textAlign = "center";
                }
                switch (textAlign) {
                    case "left":
                        x = 0;
                        break;
                    case "center":
                        x = -x / 2;
                        break;
                    case "right":
                        x = -x;
                        break;
                }
                var attr = {
                    "x": Number(x), "dy": def > 2 ? (height * def) : height
                };
                if (x == 0 && tspan.textContent == "") {
                    def++;
                }
                else
                    def = 2;
                ej.datavisualization.Diagram.Util.attr(tspan, attr);
            }
        },
        //#endregion

        //#region Render Port
        _renderPorts: function (node, svg, diagram, isoverView) {
            var width = node.width ? node.width : node._width || 0;
            var height = node.height ? node.height : node._height || 0;
            var x = node.offsetX - width * node.pivot.x;
            var y = node.offsetY - height * node.pivot.y;
            var ports = node.ports || [];
            if (node._ports && node._ports.length > 0)
                ports = ports.concat(node._ports);
            var port, shape, g_ports, p_ports, parentElement, attr;
            var scale = diagram._currZoom;
            if (diagram.model.palettes || isoverView) {
                g_ports = svg.getElementById(node.name);
            }
            else {
                attr = {
                    "id": node.name + "_ej_ports", "pointer-events": "all", "padding": "inherit",
                };
                if (node._type !== "group") {
                    var flip = node.flip !== "none" ? node.flip : node._flip;
                    if (flip && flip !== ej.datavisualization.Diagram.FlipDirection.None) {
                        var attr1 = this.renderflipElement(node, diagram);
                        if (attr1) {
                            attr["transform"] = "rotate(" + node.rotateAngle + "," + node.offsetX * scale + "," + node.offsetY * scale + ")" + attr1;

                        }
                    } else {
                        attr["transform"] = "rotate(" + node.rotateAngle + "," + node.offsetX * scale + "," + node.offsetY * scale + "), translate(" + x * scale + "," + y * scale + ")";
                    }
                }
                g_ports = svg.g(attr);
            }
            for (var i = 0, len = ports.length; i < len; ++i) {
                port = ports[i];
                shape = this._renderPort(node, port, svg, diagram);
                g_ports.appendChild(shape)
            }
            parentElement = svg.getElementById(node.parent + "_ej_ports");
            if (node.parent != "") {
                if (!parentElement) {
                    p_ports = svg.g({
                        "id": node.parent + "_ej_ports", "pointer-events": "all", "padding": "inherit",
                    });
                    if (!diagram.model.palettes && !isoverView)
                        svg.getElementById(diagram._canvas.id + "_portLayer").appendChild(p_ports)
                    else svg.getElementById(node.name).appendChild(p_ports)
                    parentElement = p_ports
                }
            }
            if (!diagram.model.palettes && !isoverView) {
                if (!parentElement) {
                    svg.getElementById(diagram._canvas.id + "_portLayer").appendChild(g_ports);
                }
                else {
                    parentElement.appendChild(g_ports);
                }
            }
        },

        _renderPort: function (node, port, svg, diagram, isoverView) {
            var shape;
            var attr, visibility;
            var size = ej.datavisualization.Diagram.Size(port.size, port.size);
            var point;
            var scale = diagram._currZoom ? diagram._currZoom : 1;
            if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hidden || port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover || port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect)
                visibility = "hidden";
            else {
                if (ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram))
                    visibility = "visible";
                else
                    visibility = "hidden";
            }
            if (node._type === "group")
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), false);
            else
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), true);
            if (node._type === "group" && node.rotateAngle) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                point = ej.Matrix.transform(matrix, point);
                port._absolutePoint = point;
            }
            switch (port.shape) {
                case "x":
                    var d = this._constructX(point, port.size, scale);
                    attr = {
                        "id": node.name + "_" + port.name, "class": "ej-d-port", "fill": port.fillColor, "visibility": visibility,
                        "stroke": port.borderColor, "stroke-width": port.borderWidth, "d": d
                    };
                    this._addCssClass(port, attr);
                    shape = svg.path(attr);
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    attr = {
                        "id": node.name + "_" + port.name, "class": "ej-d-port", "rx": rx, "ry": ry, "visibility": visibility,
                        "cx": (point.x * scale), "cy": (point.y * scale), "fill": port.fillColor, "stroke": port.borderColor,
                        "stroke-width": port.borderWidth
                    }
                    this._addCssClass(port, attr);
                    shape = svg.ellipse(attr);
                    break;
                case "square":
                    attr = {
                        "id": node.name + "_" + port.name, "class": "ej-d-port", "x": ((point.x * scale) - port.size / 2), "visibility": visibility,
                        "y": ((point.y * scale) - port.size / 2), "width": size.width, "height": size.height,
                        "fill": port.fillColor, "stroke": port.borderColor, "stroke-width": port.borderWidth
                    };
                    this._addCssClass(port, attr);
                    shape = svg.rect(attr);
                    break;
                case "path":
                    var width = size.width;
                    var height = size.height;
                    var d = port._absolutePath = ej.datavisualization.Diagram.Geometry.updatePath(((point.x * scale) - port.size / 2), ((point.y * scale) - port.size / 2), width, height, port.pathData, svg);
                    attr = {
                        "id": node.name + "_" + port.name, "class": "ej-d-port", "width": width,
                        "height": height, "d": d, "stroke": port.borderColor,
                        "stroke-width": port.borderWidth, "fill": port.fillColor, "visibility": visibility
                    };
                    this._addCssClass(port, attr);
                    shape = svg.path(attr);
                    break;
            }
            return shape;
        },

        deleteLabel: function (node, label, diagram) {
            diagram._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                var panel = view.svg || view._canvas;
                view.context._deleteLabel(node, label, diagram, panel, view);
            });
        },
        deletePort: function (node, port, diagram) {
            diagram._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                var panel = view.svg || view._canvas;
                view.context._deletePort(node, port, diagram, view.type !== "overview" ? diagram._adornerSvg : panel, view);
            });
        },
        _insertPort: function (node, port, svg, index, diagram, isOverView) {
            var g;
            g = (!isOverView) ? svg.getElementById(node.name + "_ej_ports") : svg.getElementById(node.name);
            var portshape = ej.datavisualization.Diagram.SvgContext._renderPort(node, port, svg, diagram);
            var ports = [];
            for (var i = 0; i < g.childNodes.length; i++) {
                if (g.childNodes[i].className.animVal == "ej-d-port")
                    ports.push(g.childNodes[i]);
            }
            if (index != undefined) {
                if (ports.length == 0)
                    g.appendChild(portshape);
                else {
                    g.insertBefore(portshape, ports[index] ? ports[index] : ports[ports.length]);
                }
            }
            else
                g.appendChild(portshape);
            if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hidden || port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover || port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect) {
                portshape.setAttribute("visibility", "hidden");
            }

        },
        _updatePort: function (node, port, svg, diagram, isoverView) {
            var size = ej.datavisualization.Diagram.Size(port.size, port.size);
            var point = null;
            var visibility
            var scale = (!isoverView) ? diagram._currZoom : 1;
            if (node._type === "group")
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), false);
            else
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true), true);
            var id = node.name + "_" + port.name;
            if (node._type === "group" && node.rotateAngle) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                point = ej.Matrix.transform(matrix, point);
                port._absolutePoint = point;
            }

            visibility = ((port.visibility & ej.datavisualization.Diagram.PortVisibility.Visible) &&
                ej.datavisualization.Diagram.Util.enableLayerOption(node, "visible", diagram)) ? "visible" : "hidden";

            switch (port.shape) {
                case "x": var d = this._constructX(point, port.size, scale);
                    svg.path({ "id": id, "d": d, "visibility": visibility });
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    if (node.type === "group") {
                        svg.ellipse({ "id": id, "rx": rx, "ry": ry, "cx": 0, "cy": 0, "visibility": visibility, "transform": "rotate(" + node.rotateAngle + "," + (point.x * scale) + "," + (point.y * scale) + "),translate(" + (point.x * scale) + "," + (point.y * scale) + ")" });
                    }
                    else
                        svg.ellipse({ "id": id, "rx": rx, "ry": ry, "visibility": visibility, "cx": (point.x * scale), "cy": (point.y * scale) });
                    break;
                case "square":
                    if (node.type === "group") {
                        svg.rect({ "id": id, "x": 0, "y": 0, "visibility": visibility, "transform": "rotate(" + node.rotateAngle + "," + (point.x * scale) + "," + (point.y * scale) + "),translate(" + ((point.x * scale) - port.size / 2) + "," + ((point.y * scale) - port.size / 2) + ")" });
                    }
                    else
                        svg.rect({ "id": id, "visibility": visibility, "x": (point.x * scale) - port.size / 2, "y": (point.y * scale) - port.size / 2 });
                    break;
                case "path":
                    var width = size.width;
                    var height = size.height;
                    var d = port._absolutePath = ej.datavisualization.Diagram.Geometry.updatePath((point.x * scale) - port.size / 2, (point.y * scale) - port.size / 2, width, height, port.pathData, svg);
                    var attr = {
                        "id": id, "visibility": visibility, "d": d
                    };
                    if (node.type === "group") {
                        attr = {
                            "id": id, "d": d, "visibility": visibility, "transform": "rotate(" + node.rotateAngle + "," + (point.x * scale) + "," + (point.y * scale) + ")"
                        };
                    }
                    svg.path(attr);
                    break;
            }
        },

        _updatePorts: function (node, svg, diagram, isoverView) {
            if (node.ports || node._ports) {
                var ports = node.ports || [];
                if (node._ports && node._ports.length > 0)
                    ports = ports.concat(node._ports);
                var scale = diagram._currZoom;
                var width = (node.width ? node.width : node._width);
                var height = (node.height ? node.height : node._height);
                var x = node.offsetX - width * node.pivot.x;
                var y = node.offsetY - height * node.pivot.y;
                var port, g_port, attr = {};
                g_port = (!isoverView) ? svg.getElementById(node.name + "_ej_ports") : svg.getElementById(node.name);
                for (var i = 0, len = ports.length; i < len; ++i) {
                    port = ports[i];
                    this._updatePort(node, port, svg, diagram);
                }
                if (g_port && node._type !== "group") {
                    if (!isoverView) {                        
                        var    angle = node.rotateAngle;                       
                        var flip = node.flip !== "none" ? node.flip : node._flip;
                        if (flip && flip !== ej.datavisualization.Diagram.FlipDirection.None) {
                            
                            var attr1 = this.renderflipElement(node, diagram);
                            if (attr1) {
                                g_port.setAttribute("transform", "rotate(" + angle + "," + node.offsetX * scale + "," + node.offsetY * scale + ")" + this.renderflipElement(node, diagram));
                            }
                        } else {
                            g_port.setAttribute("transform", "rotate(" + node.rotateAngle + "," + node.offsetX * scale + "," + node.offsetY * scale + "), translate(" + x * scale + "," + y * scale + ")");

                        }
                    }
                }
            }
        },

        _constructX: function (point, size, scale) {
            var path = new ej.datavisualization.Diagram.Path();
            path.moveTo(((point.x * scale) - size / 2), ((point.y * scale) - size / 2));
            path.lineTo(((point.x * scale) + size / 2), ((point.y * scale) + size / 2));
            path.moveTo(((point.x * scale) + size / 2), ((point.y * scale) - size / 2));
            path.lineTo(((point.x * scale) - size / 2), ((point.y * scale) + size / 2));
            return path.toString();
        },
        _enableSelectedNode: function (node, svg, diagram) {
            if (node) {
                if (node.type == "pseudoGroup") {
                    var children = node.children;
                    for (var i = 0, len = children.length; i < len; i++) {
                        var child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child)
                            this._enableSelectedNode(child, svg, diagram);
                    }
                } else {
                    var attr = {
                        "id": node.name,
                        "pointer-events": "auto",
                        "style": "pointer-events:block",
                    }
                    if (node.segments) {
                        var element = svg.document.getElementById(node.name + "_hitTest");
                        if (element)
                            element.setAttribute("pointer-events", node.visible ? "stroke" : "none");
                    }
                    svg.g(attr);
                }

                if (node && node.type === "html") {
                    var htmlLayer = diagram._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                    if (htmlLayer)
                        var htmlnode = $(htmlLayer).find("#" + node.name + "_parentdiv")[0];
                    if (htmlnode) {
                        htmlnode.style.pointerEvents = "all";
                        var html = htmlnode.children[0];
                        if (html) {
                            html.style.pointerEvents = "all";
                        }
                    }
                }

                if (diagram._adornerSvg) {
                    var selector = diagram._adornerSvg.document.getElementById(diagram._adornerSvg.document.id + "handle_g");
                    if (selector) selector.setAttribute("pointer-events", "visible");
                }
                if (node.isLane) {
                    $("#diagram").find(".s-resize").css("pointer-events", "visible");
                    $("#diagram").find(".e-resize").css("pointer-events", "visible");
                }
                $("#diagram").find(".ej-d-seperator").css("pointer-events", "visible");
            }
        },
        _disableSelectedNode: function (node, svg, diagram) {
            if (node) {
                if (node.type == "pseudoGroup") {
                    var children = node.children;
                    for (var i = 0, len = children.length; i < len; i++) {
                        var child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child)
                            this._disableSelectedNode(child, svg, diagram);
                    }
                } else {
                    var attr = {
                        "id": node.name,
                        "style": "pointer-events:none",
                        "pointer-events": "none",
                    }
                    if (node.segments) {
                        var element = svg.document.getElementById(node.name + "_hitTest");
                        element.setAttribute("pointer-events", "none");
                    }
                    svg.g(attr);
                }
                if (diagram._adornerSvg) {
                    var selector = diagram._adornerSvg.document.getElementById(diagram._adornerSvg.document.id + "handle_g");
                    if (selector) selector.setAttribute("pointer-events", "none");
                }

                if (node && node.type === "html") {
                    var htmlLayer = diagram._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                    if (htmlLayer)
                        var htmlnode = $(htmlLayer).find("#" + node.name + "_parentdiv")[0];
                    if (htmlnode) {
                        htmlnode.style.pointerEvents = "none";
                        var html = htmlnode.children[0];
                        if (html) {
                            html.style.pointerEvents = "none";
                        }
                    }
                }
                if (node.isLane) {
                    $("#diagram").find(".s-resize").css("pointer-events", "none");
                    $("#diagram").find(".e-resize").css("pointer-events", "none");
                }
                $("#diagram").find(".ej-d-seperator").css("pointer-events", "none");
            }
        },

        _drawStackHighlighter: function (node, svg, parent, scale, currentPoint, isVertcal) {
            var nPoint, points = [];
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            if (isVertcal) {
                if (currentPoint.y >= bounds.y && currentPoint.y < bounds.center.y) {
                    points.push({ x: bounds.topLeft.x * scale - 5, y: bounds.topLeft.y * scale - 5 });
                    points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
                    points.push({ x: bounds.topLeft.x * scale - 5, y: bounds.topLeft.y * scale + 5 });
                    points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
                    points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
                    points.push({ x: bounds.topRight.x * scale + 5, y: bounds.topRight.y * scale - 5 });
                    points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
                    points.push({ x: bounds.topRight.x * scale + 5, y: bounds.topRight.y * scale + 5 });
                    points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
                }
                else {
                    points.push({ x: bounds.bottomLeft.x * scale - 5, y: bounds.bottomLeft.y * scale - 5 });
                    points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
                    points.push({ x: bounds.bottomLeft.x * scale - 5, y: bounds.bottomLeft.y * scale + 5 });
                    points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
                    points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
                    points.push({ x: bounds.bottomRight.x * scale + 5, y: bounds.bottomRight.y * scale - 5 });
                    points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
                    points.push({ x: bounds.bottomRight.x * scale + 5, y: bounds.bottomRight.y * scale + 5 });
                    points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
                }
            }
            else {
                if (currentPoint.x >= bounds.x && currentPoint.x < bounds.center.x) {
                    points.push({ x: bounds.topLeft.x * scale - 5, y: (bounds.topLeft.y) * scale - 5 });
                    points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
                    points.push({ x: bounds.topLeft.x * scale + 5, y: (bounds.topLeft.y) * scale - 5 });
                    points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
                    points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
                    points.push({ x: bounds.bottomLeft.x * scale - 5, y: bounds.bottomLeft.y * scale + 5 });
                    points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
                    points.push({ x: bounds.bottomLeft.x * scale + 5, y: bounds.bottomLeft.y * scale + 5 });
                    points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
                    points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
                }
                else {
                    points.push({ x: bounds.topRight.x * scale - 5, y: bounds.topRight.y * scale - 5 });
                    points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
                    points.push({ x: bounds.topRight.x * scale + 5, y: (bounds.topRight.y) * scale - 5 });
                    points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
                    points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
                    points.push({ x: bounds.bottomRight.x * scale - 5, y: (bounds.bottomRight.y) * scale + 5 });
                    points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
                    points.push({ x: bounds.bottomRight.x * scale + 5, y: (bounds.bottomRight.y) * scale + 5 });
                    points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
                    points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
                }

            }
            var nPoint = this._convertToSVGPoints(points);
            var attr = {
                "id": "nodeHighlighter",
                "points": nPoint,
                "fill": "transparent",
                "stroke": "red",
                "stroke-width": 2,
                "pointer-events": "none",
                "style": "pointer-events: none",
            };
            var line = svg.polyline(attr);
            parent.appendChild(line);
            return line;
        },

        _drawNodeHighlighter: function (node, svg, parent, scale) {
            var shape;
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var x = node.offsetX - width * node.pivot.x;
            var y = node.offsetY - height * node.pivot.y;
            var center = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
            var transform = "rotate(" + node.rotateAngle + "," + center.x * scale + "," + center.y * scale + ")";
            var stroke = node.isLane || node.isSwimlane ? "red" : "#0dc923";
            var attr = {
                "id": "nodeHighlighter",
                "class": "ej-d-node",
                "x": x * scale,
                "y": y * scale,
                "width": width * scale,
                "height": height * scale,
                "fill": "transparent",
                "stroke": stroke,
                "stroke-width": 2,
                "pointer-events": "none",
                "transform": transform,
                "style": "pointer-events: none",
            };
            shape = svg.rect(attr);
            parent.appendChild(shape);
            return shape;
        },

        _drawNavigationHighlighter: function (bounds, svg, parent, scale) {
            var attr = {
                "id": "nodeHighlighter", "x": bounds.x * scale, "y": bounds.y * scale, "width": bounds.width * scale, "height": bounds.height * scale,
                "fill": "transparent", "stroke": "black", "stroke-dasharray": "2 2", "shape-rendering": "crispEdges", "style": "pointer-events: none"
            }
            parent.appendChild(svg.rect(attr));
        },
        _removeNodeHighlighter: function (svg, parent) {
            var highlighter = svg.getElementById("nodeHighlighter");
            if (highlighter) {
                svg.removeChild(highlighter, parent);
            }
        },
        _drawPortHighlighter: function (port, node, svg, parent, scale, diagram) {
            var shape, size, point, x, y, transform;
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var bounds;
            var fill = "#8CC63F";
            var border = "#1A1A1A";
            var borderWidth = 0.5;
            if (!port) {
                bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                size = ej.datavisualization.Diagram.Size(bounds.width, bounds.height);
                point = ej.datavisualization.Diagram.Point(bounds.x, bounds.y);
                x = point.x * scale;
                y = point.y * scale;
                border = fill;
                fill = "transparent";
                borderWidth = 2;
                var center = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
                transform = "rotate(" + node.rotateAngle + "," + center.x * scale + "," + center.y * scale + ")";
            }
            else {
                size = ej.datavisualization.Diagram.Size(port.size * 2, port.size * 2);
                point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true));
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                point = ej.Matrix.transform(matrix, point);
                x = (point.x - port.size) * scale;
                y = (point.y - port.size) * scale;
                transform = "rotate(" + 0 + "," + (x + size.width / 2) + "," + (y + size.height / 2) + ")";
                if (diagram)
                    diagram.portHighlight = true;
            }
            var attr = {
                "id": "portHighlighter", "class": "ej-d-port", "x": x,
                "y": y, "width": size.width * scale, "height": size.height * scale,
                "fill": fill, "stroke": border, "stroke-width": borderWidth, "pointer-events": "none", "transform": transform
            };
            shape = svg.rect(attr);
            parent.appendChild(shape);
            return shape;
        },

        _drawConnectorHighlighter: function (connector, diagram, scale) {
            var svg = diagram._adornerSvg;
            var g = svg.g({ "id": "connector_highlighter", "visibility": "visible", transform: "scale(" + scale + ")" });
            diagram._adornerLayer.appendChild(g);
            var path = this._findPath(connector, diagram);
            var attr = {
                "id": "highlighter_segments",
                "d": path, "fill": "none", "stroke": "#0dc923",
                "stroke-width": connector.lineWidth, "pointer-events": "none"
            };
            var line = svg.path(attr);
            g.appendChild(line);
            return g;
        },

        _removeConnectorHighlighter: function (parent, svg) {
            var highlighter = svg.getElementById("connector_highlighter");
            if (highlighter) {
                parent.removeChild(highlighter);
            }
        },
        _removePortHighlighter: function (svg, parent) {
            var highlighter = svg.getElementById("portHighlighter");
            if (highlighter) {
                svg.removeChild(highlighter, parent);
            }
        },

        _renderPhaseResize: function (shape, svg, scale, constraints, parent) {
            var nPoint, points = [];
            var clName = "", isHorizon = false, isVerti = false;
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            //#region left
            nPoint, points = [];
            points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
            points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
            nPoint = this._convertToSVGPoints(points);
            var attr = {
                "id": "w-resize", "points": nPoint, "stroke-dasharray": "3,3", "fill": "transparent", "stroke": "red", "stroke-width": 2, "pointer-events": "none"
            };
            line = svg.polyline(attr);
            parent.appendChild(line);
            //#endregion  

            //#region Top
            nPoint, points = [];
            points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
            points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
            nPoint = this._convertToSVGPoints(points);
            var attr = {
                "id": "n-resize", "points": nPoint, "stroke-dasharray": "3,3", "fill": "transparent", "stroke": "red", "stroke-width": 2, "pointer-events": "none"
            };
            line = svg.polyline(attr);
            parent.appendChild(line);
            //#endregion 

            //#region right
            clName = "";
            if (shape.orientation == "vertical") {
                clName = "e-resize"
                isVerti = true;
            }
            nPoint, points = [];
            points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
            points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
            nPoint = this._convertToSVGPoints(points);
            if (isVerti) {
                attr = {
                    "id": "e-resize-hitTest", "class": clName, "points": nPoint, "fill": "transparent", "stroke": "transparent", "stroke-width": 10, "pointer-events": isVerti ? "stroke" : "none"
                };
                var line = svg.polyline(attr);
                parent.appendChild(line);
            }
            var attr = {
                "id": "e-resize", "class": clName, "points": nPoint, "stroke-dasharray": "3,3", "fill": "transparent", "stroke": "red", "stroke-width": 2, "pointer-events": isVerti ? "stroke" : "none"
            };
            line = svg.polyline(attr);
            parent.appendChild(line);
            //#endregion

            //#region bottom
            clName = "";
            if (shape.orientation == "horizontal") {
                clName = "s-resize"
                isHorizon = true;
            }
            nPoint, points = [];
            points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
            points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
            nPoint = this._convertToSVGPoints(points);
            if (isHorizon) {
                attr = {
                    "id": "s-resize-hitTest", "class": clName, "points": nPoint, "fill": "transparent", "stroke": "transparent", "stroke-width": 10, "pointer-events": isHorizon ? "stroke" : "none"
                };
                var line = svg.polyline(attr);
                parent.appendChild(line);
            }
            var attr = {
                "id": "s-resize", "class": clName, "points": nPoint, "stroke-dasharray": "3,3", "fill": "transparent", "stroke": "red", "stroke-width": 2, "pointer-events": isHorizon ? "stroke" : "none"
            };
            line = svg.polyline(attr);
            parent.appendChild(line);
            //#endregion
        },
        //#endregion

        //#region Render Selector

        renderSelector: function (shape, svg, parent, scale, constraints, bounds, diagram) {
            $(".phaseSelector").remove();
            var width = shape.width ? shape.width : shape._width;
            var height = shape.height ? shape.height : shape._height;
            var transform;
            if (shape.segments) {
                var g = svg.g({
                    "id": svg.document.id + "handle_g", "class": "handle", "pointer-events": "visible"
                });
                parent.appendChild(g);
                this._renderEndPointHandle(shape, svg, scale);
            }
            else if (shape.type != "phase") {
                if (!(shape.isLane || shape.isSwimlane)) {
                    transform = this._selectorLocation(shape, scale, diagram);
                    var g = svg.g({
                        "id": svg.document.id + "handle_g", "class": "handle", "pointer-events": "visible",
                        "transform": transform
                    });
                    parent.appendChild(g);
                    this._updateMultiSelectHandle(shape, scale, constraints, diagram);
                    this._renderResizeHandle(shape, svg, scale, constraints, diagram);
                }
                else {
                    var g = svg.g({
                        "id": svg.document.id + "handle_g", "class": "handle", "pointer-events": "visible"
                    });
                    parent.appendChild(g);
                    this._renderPhaseResize(shape, svg, scale, constraints, g, bounds);
                }
            }
            else if (shape.type == "phase" && bounds) {
                var g = svg.g({
                    "id": svg.document.id + "handle_g", "class": "handle", "pointer-events": "visible",
                    "transform": "translate(" + (bounds.x) * scale + "," + (bounds.y) * scale + "),rotate(0," + (bounds.width / 2) * scale + "," + (bounds.height / 2) * scale + ")"
                });
                if (!svg.document.getElementById(svg.document.id + "handle_g"))
                    parent.appendChild(g);
                var rect = svg.rect({
                    "id": "phaseSelector", "class": "phaseSelector",
                    "stroke-width": 2, "stroke-dasharray": "3,3", "pointer-events": "none",
                    "width": (bounds.width < 0) ? 1 : bounds.width * scale, "height": (bounds.height < 0) ? 1 : bounds.height * scale, "fill": "transparent", "stroke": "red",
                });
                g.appendChild(rect);
            }
        },
        _updateMultiSelectHandle: function (node, scale, constraints, diagram) {
            if (node.type === "pseudoGroup" && ej.datavisualization.Diagram.Util.canDragHelper(diagram)) {
                var width = node.width ? node.width : node._width;
                var height = node.height ? node.height : node._height;
                var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
                if (!diagram._svg.getElementById(diagram.element[0].id + "_multiselector")) {
                    var attr = {
                        "id": diagram.element[0].id + "_multiselector", "class": "ej-d-multiselector", "width": width, "height": height,
                        "transform": "rotate(" + node.rotateAngle + "," + pt.x + "," + pt.y + "),translate(" + (node.offsetX - width * node.pivot.x) + "," + (node.offsetY - height * node.pivot.y) + ")",
                        "fill": "transparent", opacity: ".5"
                    }
                    var dLayer, rect;
                    dLayer = diagram._svg.getElementById(diagram.element[0].id + "_canvas_diagramLayer");
                    rect = diagram._svg.rect(attr);
                    dLayer.insertBefore(rect, dLayer.firstChild);
                }
                else {
                    attr = {
                        "id": diagram.element[0].id + "_multiselector", "width": width, "height": height,
                        "transform": "rotate(" + node.rotateAngle + "," + pt.x + "," + pt.y + "),translate(" + (node.offsetX - width * node.pivot.x) + "," + (node.offsetY - height * node.pivot.y) + ")"
                    };
                    diagram._svg.rect(attr);
                }
            }
        },
        _renderResizeHandle: function (node, svg, scale, constraints, diagram) {
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var pivot = node.pivot ? node.pivot : { x: 0.5, y: 0.5 };
            var rotate = ej.datavisualization.Diagram.Point(width * pivot.x, -20 / scale);
            var visible = "visible", resizable;
            if (node._type !== "label") {
                if (ej.datavisualization.Diagram.Util.canShowResizeThumbs(diagram)) {
                    var rect1 = ej.datavisualization.Diagram.Rectangle(0, 0, 14, 14);
                    var rect2 = ej.datavisualization.Diagram.Rectangle(((width / 2) * scale), 0, 14, 14);
                    var rect3 = ej.datavisualization.Diagram.Rectangle(0, (height / 2) * scale, 14, 14);
                    visible = this._resizeHandleVisiblity(rect1, rect2, rect3);
                }
            }
            if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Rotator && node.type != "umlclassifier") {
                var padding = 0;
                if (visible == "hidden")
                    padding = -20;
                this._renderPivotLine(node, svg, scale, padding);
                this._renderRotateThumb("rotateHandle", node, rotate.x, rotate.y + padding, scale, svg);
            }
            if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Resizer) {
                this._renderResizeBorder("resizeBorder", node, svg, scale);
                if (node.type != "umlclassifier") {
                    if (node._type == "label")
                        resizable = !(node.constraints & ej.datavisualization.Diagram.LabelConstraints.Resizable);
                    this._renderResizeCorner("nw-resize", node, 0, 0, svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest), undefined, visible);
                    this._renderResizeCorner("ne-resize", node, width * scale, 0, svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast), undefined, visible);
                    this._renderResizeCorner("sw-resize", node, 0, height * scale, svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest), undefined, visible);
                    this._renderResizeCorner("se-resize", node, width * scale, height * scale, svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast), undefined, visible);
                    this._renderResizeCorner("n-resize", node, (width / 2) * scale, 0, svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorth), undefined, visible);
                    this._renderResizeCorner("w-resize", node, 0, (height / 2) * scale, svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeWest), undefined, visible);
                    this._renderResizeCorner("e-resize", node, (width * scale), (height / 2) * scale, svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeEast), undefined, visible);
                    this._renderResizeCorner("s-resize", node, (width / 2) * scale, (height * scale), svg, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouth), undefined, visible);
                }
            }
        },

        renderUserHandles: function (handles, shape, svg, isMultipleSelection, scale, parent, diagram) {
            if (shape) {
                if (shape.type === "phase" && diagram)
                    var bounds = diagram._getPhaseBounds(shape);
                if (handles.length) {
                    var g = svg.g({ "id": svg.document.id + "userHandle_g", "class": "userHandle", "pointer-events": "visible" });
                    parent.appendChild(g);
                    for (var handleIndex = 0; handleIndex < handles.length; handleIndex++) {
                        if ((isMultipleSelection && handles[handleIndex].enableMultiSelection) || !isMultipleSelection) {
                            this._renderUserHandle(handles[handleIndex], shape, svg, scale, g, bounds, diagram);
                        }
                    }
                }
            }
        },

        _renderUserHandle: function (handle, node, svg, scale, g, bounds, diagram) {
            var icon;
            var position = this._getHandlePosition(handle, node, scale, bounds, diagram);
            var x = position.x * scale;// - (node.segments ? 0 : handle.size / 4);
            var y = position.y * scale;// - (node.segments ? 0 : handle.size / 4)
            var shape = this._getHandleShape(handle, x, y);
            handle._size = handle.size;
            var circle = g.appendChild(svg.circle(shape));
            var titleattr = {
                "id": handle.name + "_title"
            };
            var title = svg.title(titleattr);
            title.innerHTML = handle.name;
            circle.appendChild(title);
            switch (handle.shape) {
                case "path":
                    var d = handle._absolutePath = ej.datavisualization.Diagram.Geometry.updatePath(0, 0, handle.size / 2, handle.size / 2, handle.pathData, svg);
                    icon = this._getHandleIcon(handle, x - handle.size / 4, y - handle.size / 4);
                    icon["d"] = d;
                    g.appendChild(svg.path(icon));
                    break;
                case "image":
                    icon = this._getHandleIcon(handle, x - handle.size / 4, y - handle.size / 4);
                    icon["preserveAspectRatio"] = "none";
                    var image = new Image();
                    image.src = handle.source;
                    var imageshape = svg.image(icon);
                    imageshape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", image.src);
                    g.appendChild(imageshape);
                    break;
                case "native":
                    var visible = handle.visible ? "visible" : "hidden";
                    icon = this._getHandleIcon(handle, x - handle.size / 4, y - handle.size / 4);
                    var html = diagram._renderEjTemplate("#" + handle.templateId, handle);
                    var div = document.createElement('div');
                    div.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg"><g id="tempNative">' + html + '</g></svg>';
                    document.body.appendChild(div);
                    var content = document.getElementById("tempNative").cloneNode(true);
                    content.id = handle.name + "_shape";
                    g.appendChild(content);
                    var bounds = content.getBBox();
                    var width = icon.width;
                    var height = icon.height;
                    var delwidth = bounds.width ? width / bounds.width : 1;
                    var delheight = bounds.height ? height / bounds.height : 1;
                    content.setAttribute("transform", "scale(" + delwidth + "," + delheight + ")");
                    div.parentNode.removeChild(div);
                    var nativecontent = svg.g(icon);
                    nativecontent.appendChild(content);
                    g.appendChild(nativecontent);
                    break;
            }
        },

        _getHandleIcon: function (handle, x, y) {
            var visible = handle.visible ? "visible" : "hidden";
            var icon = {
                "id": handle.name + "_icon", "class": "userHandle-icon", "fill": handle.pathColor, "transform": "translate(" + x + "," + y + ")",
                "visibility": visible, "width": handle.size / 2, "height": handle.size / 2
            };
            return icon;
        },

        _getHandlePosition: function (handle, node, scale, phsBounds, diagram) {
            if (node) {
                if (!node.segments || handle.offset) {
                    var positionPoints = ej.datavisualization.Diagram.Point();
                    if (node.type === "phase" && phsBounds)
                        var bounds = ej.datavisualization.Diagram.Util.bounds(phsBounds);
                    else
                        var bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                    var offset = handle.offset;
                    var size = handle.size;
                    var margin = handle.margin;
                    var point = ej.datavisualization.Diagram.Point(0, 0)
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                    switch (handle.position) {
                        case "topleft":
                            offset = { x: 0, y: 0 };
                            margin = { left: -25, top: -25, bottom: 0, right: 0 };
                            break;
                        case "topcenter":
                            offset = { x: 0.5, y: 0 };
                            margin = { left: 0, top: -25, bottom: 0, right: 0 };
                            break;
                        case "topright":
                            offset = { x: 1, y: 0 };
                            margin = { left: 0, top: -25, bottom: 0, right: -25 };
                            break;
                        case "middleleft":
                            offset = { x: 0, y: 0.5 };
                            margin = { left: -25, top: 0, bottom: 0, right: 0 };
                            break;
                        case "middleright":
                            offset = { x: 1, y: 0.5 };
                            margin = { left: 0, top: 0, bottom: 0, right: -25 };
                            break;
                        case "bottomleft":
                            margin = { left: -25, top: 0, bottom: -25, right: 0 };
                            offset = { x: 0, y: 1 };
                            break;
                        case "bottomcenter":
                            offset = { x: 0.5, y: 1 };
                            margin = { left: 0, top: 0, bottom: -25, right: 0 };
                            break;
                        case "bottomright":
                            offset = { x: 1, y: 1 };
                            margin = { left: 0, top: 0, bottom: -25, right: -25 };
                            break;
                    }

                    point.x += margin.left - margin.right;
                    point.y += margin.top - margin.bottom;

                    switch (handle.horizontalAlignment) {
                        case ej.datavisualization.Diagram.HorizontalAlignment.Left:
                            point.x += size / 2;
                            break;
                        case ej.datavisualization.Diagram.HorizontalAlignment.Right:
                            point.x -= size / 2;
                            break;
                    }
                    switch (handle.verticalAlignment) {
                        case ej.datavisualization.Diagram.VerticalAlignment.Top:
                            point.y += size / 2;
                            break;
                        case ej.datavisualization.Diagram.VerticalAlignment.Bottom:
                            point.y -= size / 2;
                            break;
                    }

                    positionPoints.x += bounds.x + bounds.width * offset.x + point.x / scale;
                    positionPoints.y += bounds.y + bounds.height * offset.y + point.y / scale;
                    if (!node.segments) {
                        var pt = ej.datavisualization.Diagram.Point(positionPoints.x, positionPoints.y);
                        positionPoints = ej.Matrix.transform(matrix, pt);
                    }
                    return positionPoints;
                }
            }
        },
        _getConnectorHandlePosition: function (handle, node, scale, diagram) {
            var length = 0;
            var position = ej.datavisualization.Diagram.Util._findOffsetOnConnector(node, handle, handle.segmentOffset, diagram);
            var i = position.segment;
            var j = position.point;
            var pt = position.offset;
            var targetSegment = node.segments[i]; var targetPoint = node.segments[i].points[j];
            var angle = ej.datavisualization.Diagram.Geometry.findAngle(targetPoint, node.segments[i].points[j + 1]);
            if (handle.alignment && handle.alignment != "auto") {
                if (handle.offset == 1) angle += 180;
                return {
                    position: ej.datavisualization.Diagram.Geometry.transform(position.offset, handle.offset != 0 && handle.offset != 1 ? angle + 45 : angle, this._getAlignedPosition(node, handle)), angle: angle
                };
            }
            else {
                //avoid overlapping
                var obj = this._avoidOverlapWithSourceAndTarget(node, handle.offset, handle.size, position.offset, angle, i, j, diagram);
                pt = {
                    position: obj.position, angle: handle.offset == 1 ? (180 + angle) % 360 : angle, direction: obj.direction
                };
            }
            return pt;
        },
        _getAlignedPosition: function (connector, handle) {
            var cnst = handle.text === undefined ? 10 : 0;
            switch (handle.alignment) {
                case "center":
                    return 0;
                case "before":
                    return -((handle.size || 0) / 2 + cnst);
                case "after":
                    return (handle.size || 0) / 2 + cnst;
            }
            return 0;
        },
        _avoidOverlapWithSourceAndTarget: function (connector, offset, size, position, angle, i, j, diagram) {
            var next, ang;
            var pt = position; var targetSegment = connector.segments[i];
            var cnst = 90;
            if (offset == 0) {
                next = connector.segments[i].points[j + 2] ? connector.segments[i].points[j + 2] : connector.segments[i + 1] ? connector.segments[i + 1].points[1] : null;
                if (next) {
                    ang = ej.datavisualization.Diagram.Geometry.findAngle(connector.segments[i].points[j], next);
                }
                if (connector.sourceNode) cnst = 45;
            }
            else if (offset == 1) {
                next = connector.segments[i].points[j - 1] ? connector.segments[i].points[j - 1] : connector.segments[i - 1] ? connector.segments[i - 1][connector.segments[i].points.length - 2] : null;
                if (next) {
                    ang = ej.datavisualization.Diagram.Geometry.findAngle(connector.segments[i].points[j + 1], next);
                }
                angle += 180;
                angle %= 360;
                if (connector.targetNode) cnst = 45;
            }
            if (next) {
                if (angle % 90 == 0) {
                    var direction;
                    if (ang > 270 && angle == 0) angle = 360;
                    if (angle == 90) {
                        if (ang < angle) {
                            angle += cnst; direction = "right";
                        }
                        else {
                            angle -= cnst; direction = "left";
                        }
                    }
                    else if (angle == 270) {
                        if (ang < angle) {
                            angle += cnst; direction = "left";
                        }
                        else {
                            angle -= cnst; direction = "right";
                        }
                    }
                    else if (angle == 180) {
                        if (ang < angle) {
                            angle += cnst; direction = "bottom";
                        }
                        else {
                            angle -= cnst; direction = "top";
                        }
                    }
                    else {
                        if (ang < angle) {
                            angle += cnst; direction = "top";
                        }
                        else {
                            angle -= cnst; direction = "bottom";
                        }
                    }
                    pt = ej.datavisualization.Diagram.Geometry.transform(pt, angle, size != undefined ? Math.max(5, size / 2 + 10) : 0);
                } else {
                    var fourty5 = 45;
                    var one35 = 135;
                    var two25 = 225;
                    var three15 = 315;
                    var bounds;
                    if (offset == 0 && connector.sourceNode || offset == 1 && connector.targetNode) {
                        var source = offset == 0 && connector.sourceNode ? diagram.nameTable[connector.sourceNode] : diagram.nameTable[connector.targetNode];
                        if (source) bounds = ej.datavisualization.Diagram.Util.bounds(source);
                        if (bounds) {
                            var part = 180 / (2 + 2 / (bounds.height / bounds.width));
                            fourty5 = part;
                            one35 = (180 - part);
                            two25 = one35 + (2 * part);
                            three15 = 360 - part;
                        }
                    }
                    if (angle >= fourty5 && angle <= one35 || angle >= two25 && angle <= three15) cnst = angle % 180 > 90 ? -cnst : cnst;
                    else if (angle > one35 && angle < two25) angle > 180 ? cnst = -45 : cnst = 45;
                    else angle > 0 ? cnst = -45 : cnst = 45;
                    pt = ej.datavisualization.Diagram.Geometry.transform(pt, angle + cnst, size != undefined ? Math.max(5, size / 2 + 10) : 0);
                }
            } else {
                var fourty5 = 45;
                var one35 = 135;
                var two25 = 225;
                var three15 = 315;
                var bounds;
                if (offset == 0 && connector.sourceNode || offset == 1 && connector.targetNode) {
                    var source = offset == 0 && connector.sourceNode ? diagram.nameTable[connector.sourceNode] : diagram.nameTable[connector.targetNode];
                    if (source) bounds = ej.datavisualization.Diagram.Util.bounds(source);
                    if (bounds) {
                        var part = 180 / (2 + 2 / (bounds.height / bounds.width));
                        fourty5 = part;
                        one35 = (180 - part);
                        two25 = one35 + (2 * part);
                        three15 = 360 - part;
                    }
                }
                if (angle >= fourty5 && angle <= one35 || angle >= two25 && angle <= three15) cnst = angle % 180 > 90 ? -cnst : cnst;
                else if (angle > one35 && angle < two25) angle > 180 ? cnst = -45 : cnst = 45;
                else angle <= fourty5 ? cnst = -45 : cnst = 45;
                angle += 360;
                angle %= 360;
                pt = ej.datavisualization.Diagram.Geometry.transform(pt, angle + cnst, size != undefined ? Math.max(5, size / 2 + (Math.abs(cnst % 45) > 0 ? 13 : 10)) : 0);
            }
            return {
                position: pt, direction: direction
            };
        },
        _getHandleShape: function (handle, cx, cy) {
            var visible = handle.visible ? "visible" : "hidden";
            var shape = {
                "id": handle.name + "_shape", "class": "userHandle", "cx": cx, "cy": cy, "r": handle.size / 2, "fill": handle.backgroundColor,
                "stroke": handle.borderColor, "stroke-width": handle.borderWidth || 0,
                "visibility": visible
            };
            return shape;
        },

        _updateHandleShape: function (handle, cx, cy, svg) {
            var visible = handle.visible ? "visible" : "hidden";
            var attr = {
                "id": handle.name + "_shape", "cx": cx, "cy": cy, "r": handle.size / 2, "fill": handle.backgroundColor,
                "stroke": handle.borderColor, "stroke-width": handle.borderWidth || 0, "visibility": visible
            };
            svg.circle(attr);
        },

        _updateHanleIcon: function (handle, d, svg, x, y) {
            var visible = handle.visible ? "visible" : "hidden";
            var attr = { "id": handle.name + "_icon", "d": d, "fill": handle.pathColor, "transform": "translate(" + x + "," + y + ")", "visibility": visible };
            svg.path(attr);
        },

        _getHanleIcon: function (handle, d, cx, cy) {
            var icon = {
                "id": handle.name, "d": d, "stroke": handle.borderColor,
                "stroke-width": handle.borderWidth, "fill": handle.fillColor
            };
            return icon;
        },

        renderPivotPoint: function (node, scale, svg, resizeCorner, dragging, diagram) {
            var x = node.width * (node.pivot ? node.pivot.x : 0.5);
            var y = node.height * (node.pivot ? node.pivot.y : 0.5);
            var visible = "visible";
            if (ej.datavisualization.Diagram.Util.canShowResizeThumbs(diagram)) {
                var width = node.width ? node.width : node._width;
                var height = node.height ? node.height : node._height;
                var rect1 = ej.datavisualization.Diagram.Rectangle(0, 0, 14, 14);
                var rect2 = ej.datavisualization.Diagram.Rectangle(((width / 2) * scale), 0, 14, 14);
                var rect3 = ej.datavisualization.Diagram.Rectangle(0, (height / 2) * scale, 14, 14);
                visible = this._resizeHandleVisiblity(rect1, rect2, rect3);
            }
            if (!svg.getElementById("pivot")) {
                ej.datavisualization.Diagram.SvgContext._renderResizeCorner("pivot", node, x * scale, y * scale, svg, undefined, 4, visible);
            }
            else
                ej.datavisualization.Diagram.SvgContext._updateResizeCorner("pivot", x * scale, y * scale, svg, visible, resizeCorner, dragging, diagram, undefined);
            this._updatePivotLine(node, svg, scale, true);
        },

        _removePivotPoint: function (node, svg, scale) {
            var pivot = svg.getElementById("pivot");
            if (pivot) {
                pivot.parentNode.removeChild(pivot);
                this._updatePivotLine(node, svg, scale, false);
            }
        },

        _renderPivotLine: function (node, svg, scale, padding) {
            if (!node.container) {
                var width = node.width ? node.width : node._width;
                var height = node.height ? node.height : node._height;
                var pivotPoint = node.pivot ? node.pivot : { x: 0.5, y: 0.5 };
                var rotateThumb = ej.datavisualization.Diagram.Point(width * pivotPoint.x, -20 / scale);
                if (padding)
                    rotateThumb.y += padding;
                var pivot = ej.datavisualization.Diagram.Point(width * pivotPoint.x, 0);
                var handle = svg.getElementById(svg.document.id + "handle_g");
                var line = svg.line({
                    "id": "pivotLine", "x1": rotateThumb.x * scale, "y1": rotateThumb.y * scale, "x2": pivot.x * scale, "y2": pivot.y * scale,
                    "stroke": node._type == "label" ? "red" : "black", "stroke-width": 1, "stroke-dasharray": "2,3", "fill": "none"
                });
                handle.appendChild(line);
            }
        },

        _renderResizeBorder: function (id, node, svg, scale) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            if (node.type == "umlclassifier")
                var rect = ej.datavisualization.Diagram.ClassifierHelper.renderResizeBorder(id, node, svg, scale);
            else {
                var rect = svg.rect({
                    "id": id, "class": "resizeRect", "width": width * scale, "height": height * scale, "stroke": node._type == "label" ? "red" : "#097F7F", "stroke-width": 0.6, "stroke-dasharray": "6,3", "fill": "none", "pointer-events": "none"
                });
            }
            handle.appendChild(rect);
        },

        _renderResizeCorner: function (corner, node, cx, cy, svg, state, r, visible) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var pEvnts;
            var fill = "white";
            if (!(ej.datavisualization.Diagram.Util.canResize(node))) {
                fill = "darkgray";
            }
            if (state) {
                fill = "darkgray";
                pEvnts = "none";
            }
            var attr = { "id": corner, "class": "resizeCorners", "fill": fill, "stroke": node._type == "label" ? "#097F7F" : "black", "stroke-width": 1, "cx": cx, "cy": cy, "r": r || 7, "visibility": visible };
            attr = this._setPadding(attr);
            handle.appendChild(svg.circle(attr));
            attr = { "id": corner + "_transparent", "class": corner, "fill": "transparent", "cx": attr.cx, "cy": attr.cy, "r": r || 10, "visibility": attr.visibility };
            if (pEvnts) attr["pointer-events"] = pEvnts;
            handle.appendChild(svg.circle(attr));
        },
        _setPadding: function (attr) {
            if ((attr.id === "n-resize" || attr.id === "w-resize" || attr.id === "e-resize" || attr.id === "s-resize") && attr.visibility === "hidden") {
                var padding = 20;
                if (attr.id === "n-resize")
                    attr.cy = attr.cy - padding;
                if (attr.id === "w-resize")
                    attr.cx = attr.cx - padding;
                if (attr.id === "e-resize")
                    attr.cx = attr.cx + padding;
                if (attr.id === "s-resize")
                    attr.cy = attr.cy + padding;
                attr.visibility = "visible";
            }
            return attr;
        },
        _renderRotateThumb: function (corner, node, cx, cy, scale, svg) {
            if (!node.container) {
                var handle = svg.getElementById(svg.document.id + "handle_g");
                var d = "M 16.856 10.239 L 18 3.438 l -2.189 0.817 c -0.974 -1.694 -2.482 -2.995 -4.326 -3.696 C 9.375 -0.245 7.071" +
                    "-0.18 5.01 0.744 C 2.942 1.668 1.365 3.342 0.558 5.453 c -0.803 2.115 -0.738 4.414 0.185 6.478 c 0.925 2.064 " +
                    "2.6 3.645 4.714 4.45 c 0.969 0.371 1.993 0.554 3.013 0.554 c 1.345 0 2.685 -0.317 3.897 -0.948 l -1.016 -1.962 c -1.584 0.822" +
                    "-3.445 0.929 -5.114 0.293 c -1.56 -0.596 -2.793 -1.762 -3.479 -3.289 C 2.078 9.502 2.031 7.803 2.622 6.244 C 3.216 4.68 4.387" +
                    " 3.443 5.914 2.761 C 7.437 2.079 9.137 2.03 10.7 2.626 c 1.246 0.475 2.271 1.328 2.986 2.424 L 11.54 5.851 L 16.856 10.239 Z";
                var fill = "#231f20";
                if (!(ej.datavisualization.Diagram.Util.canRotate(node)))
                    fill = "darkgray";
                var width = 20;
                var height = 20;
                var dist = 20;
                var attr = {
                    "id": "rotatehandle", "class": corner, "fill": fill, "stroke": "black", "stroke-width": 0.5, "width": width, "height": height, "d": d,
                    "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
                };
                var path = svg.path(attr);
                var circle = svg.circle({
                    "id": "rotate", "class": corner, "fill": "transparent", "stroke": "none", "cx": width / 2, "cy": height / 2, "r": 13,
                    "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
                });
                handle.appendChild(path);
                handle.appendChild(circle);
            }
        },

        _refreshEndPointHandles: function (shape, svg, scale) {
            if (shape && shape.segments) {
                var handle = svg.getElementById(svg.document.id + "handle_g");
                if (handle && handle.childNodes.length > 0) {
                    for (var i = handle.childNodes.length - 1; i >= 0; i--) {
                        var child = handle.childNodes[i];
                        if (child.id !== "sourceEndPoint" && child.id !== "targetEndPoint") {
                            child.parentNode.removeChild(child);
                        }
                    }
                }
                this._renderEndPointHandle(shape, svg, scale);
            }
        },
        _renderEndPointHandle: function (connector, svg, scale) {
            if (!connector.isPhase) {
                var enabled = ej.datavisualization.Diagram.Util.canDragSegmentThumbs(connector);
                for (var i = 0; i < connector.segments.length; i++) {
                    var segment = connector.segments[i];
                    if (segment.type == "bezier") {
                        this._renderBezierLine("bezierline1_" + i, segment._startPoint, segment._point1, scale, svg, enabled);
                        this._renderBezierLine("bezierline2_" + i, segment._endPoint, segment._point2, scale, svg, enabled);
                        this._renderEndPointCorner("bezierpoint1_" + i, segment._point1.x * scale, segment._point1.y * scale, false, svg, enabled);
                        this._renderEndPointCorner("bezierpoint2_" + i, segment._point2.x * scale, segment._point2.y * scale, false, svg, enabled);
                    }
                    var points = segment.points;
                    if (i == 0) {
                        this._renderEndPointCorner("sourceEndPoint", segment._startPoint.x * scale, segment._startPoint.y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                            ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                    }
                    if (i == connector.segments.length - 1) {
                        this._renderEndPointCorner("targetEndPoint", segment._endPoint.x * scale, segment._endPoint.y * scale, ej.datavisualization.Diagram.Util.isTargetConnected(connector), svg,
                            ej.datavisualization.Diagram.Util.canDragTargetEnd(connector));
                        if (segment.type == "orthogonal") {
                            this._renderTerminalOrthoThumbs(segment, svg, scale, i, enabled);
                        }
                    }
                    else {
                        if (segment.type != 'orthogonal') {
                            this._renderSegmentEndThumb("segmentEnd_" + i, segment._endPoint.x * scale, segment._endPoint.y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                                ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                        } else {
                            this._renderTerminalOrthoThumbs(segment, svg, scale, i, enabled);
                        }

                    }
                }
            }
        },

        _renderTerminalOrthoThumbs: function (segment, svg, scale, index, isEnabled) {
            var orientation;
            if (segment.points.length > 2)
                for (var i = 0; i < segment.points.length - 1; i++) {
                    var length = ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]);
                    if (segment.points[i].y.toFixed(2) == segment.points[i + 1].y.toFixed(2)) {
                        orientation = "horizontal";
                    }
                    else orientation = "vertical";
                    var visible;
                    if (length >= 50) visible = "visible"; else visible = "hidden";
                    this._renderOrthogonalThumb(("OrthoThumb_" + i) + "_" + index, ((segment.points[i].x + segment.points[i + 1].x) / 2) * scale, ((segment.points[i].y + segment.points[i + 1].y) / 2) * scale, svg, visible, orientation, isEnabled);
                }
            else {
                var length = segment.length || ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                if (length >= 50) visible = "visible"; else visible = "hidden";
                if (segment._startPoint.y.toFixed(2) == segment._endPoint.y.toFixed(2)) {
                    orientation = "horizontal";
                }
                else orientation = "vertical";
                this._renderOrthogonalThumb("OrthoThumb_" + index, ((segment._endPoint.x + segment._startPoint.x) / 2) * scale, ((segment._endPoint.y + segment._startPoint.y) / 2) * scale, svg, visible, orientation, isEnabled);
            }
        },

        _renderEndPointCorner: function (corner, x, y, isConnected, svg, isenabled) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var fill = isConnected ? "#8CC63F" : "white";
            if (!isenabled) fill = "darkgray";
            var attr = { "id": corner, "class": corner, opacity: 0.75, "fill": fill, "stroke": "black", "stroke-width": 2, "cx": x, "cy": y, "r": 7 };
            if (!svg.getElementById(corner))
                handle.appendChild(svg.circle(attr));
            else
                svg.circle(attr);

        },

        _renderSegmentEndThumb: function (corner, x, y, isConnected, svg, isenabled) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var fill = "#e2e2e2";
            if (!isenabled) fill = "darkgray";
            var attr = { "id": corner, "class": "segmentEnd", "fill": fill, "stroke": "black", "stroke-width": 2, "cx": x, "cy": y, "r": 5 };
            handle.appendChild(svg.circle(attr));
        },
        _renderOrthogonalThumb: function (corner, x, y, svg, visibility, orientation, isEnabled) {
            var path, h, v; if (orientation == "horizontal") {
                path = "M0,7 L15,0 L30,7 L15,14 z"; h = -15; v = -7;
            } else { path = "M7,0 L0,15 L7,30 L14,15 z"; h = -7; v = -15; };
            var handle = svg.getElementById(svg.document.id + "handle_g");
            var fill = "#e2e2e2";
            if (!isEnabled) fill = "darkgray";
            var attr = {
                "id": corner, "class": "segmentEnd", "fill": fill, "stroke": "black", "stroke-width": 1, d: path, transform: "translate(" + (x + h) + "," + (y + v) + ")",
                "visibility": visibility
            };
            handle.appendChild(svg.path(attr));
        },
        _renderBezierLine: function (id, start, end, scale, svg) {
            var line = svg.line({
                "id": id, "x1": start.x * scale, "y1": start.y * scale, "x2": end.x * scale, "y2": end.y * scale,
                "stroke": "black", "stroke-width": 1, "stroke-dasharray": "3,3", "fill": "none"
            });
            var handle = svg.getElementById(svg.document.id + "handle_g");
            handle.appendChild(line);
        },
        _renderControlPointCorner: function (corner, point, index, svg) {
            var g = svg.g({ "class": corner });
            svg.getElementById(svg.document.id + "handle_g").appendChild(g);
            var attr = {
                "id": corner + "_" + index, "fill": "white", "stroke": "black", "stroke-width": 2,
                "cx": point.x, "cy": point.y, "r": 5
            };
            g.appendChild(svg.circle(attr));
        },
        _selectorLocation: function (shape, scale, diagram) {
            var width = shape.width;
            var height = shape.height, transform;
            if (shape._type !== "label")
                transform = "translate(" + (shape.offsetX - width * shape.pivot.x) * scale + "," + (shape.offsetY - height * shape.pivot.y) * scale + "),rotate(" + shape.rotateAngle + "," + (width * shape.pivot.x) * scale + "," + (height * shape.pivot.y) * scale + ")";
            else {
                var node = diagram.findNode(shape._parent);
                height = height ? height : node.height;
                var location = diagram.activeTool._findLabelAtNode(node, shape);
                if (!node.segments)
                    transform = "translate(" + (location.x) * scale + "," + (location.y) * scale + "),rotate(" + node.rotateAngle + "),rotate(" + shape.rotateAngle + "," + (width / 2) * scale + "," + (height / 2) * scale + ")";
                else if (node.segments && shape.relativeMode !== "segmentpath")
                    transform = "translate(" + (location.x) * scale + "," + (location.y) * scale + "),rotate(" + shape.rotateAngle + "," + (width / 2) * scale + "," + (height / 2) * scale + ")";
                else {
                    var location = ej.datavisualization.Diagram.SvgContext._getConnectorHandlePosition(shape, node, scale, diagram)
                    location.position.x = location.position.x + shape.margin.left - shape.margin.right;
                    location.position.y = location.position.y + shape.margin.top - shape.margin.bottom;
                    transform = "translate(" + (location.position.x - width / 2) * scale + "," + (location.position.y - height / 2) * scale + "),rotate(" + shape.rotateAngle + "," + (width / 2) * scale + "," + (height / 2) * scale + ")";
                }
            }
            return transform;
        },
        updateSelector: function (shape, svg, scale, diagram, constraints, resizeCorner, dragging) {
            if (shape) {
                var width = shape.width ? shape.width : shape._width;
                var height = shape.height ? shape.height : shape._height;
                var transform;
                if (shape.segments) {
                    this._updateEndPointHandle(shape, svg, scale);
                    if (constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles)
                        this.updateUserHandles(diagram.model.selectedItems.userHandles, shape, svg, false, false, scale, diagram);
                } else if (shape.type === "phase") {
                    var bounds = diagram._getPhaseBounds(shape);
                    svg.g({
                        "id": svg.document.id + "handle_g", "class": "handle", "pointer-events": "visible",
                        "transform": "translate(" + (bounds.x) * scale + "," + (bounds.y) * scale + "),rotate(0," + (bounds.width / 2) * scale + "," + (bounds.height / 2) * scale + ")"
                    });
                    svg.rect({
                        "id": "phaseSelector", "class": "phaseSelector",
                        "stroke-width": 2, "stroke-dasharray": "3,3", "pointer-events": "none",
                        "width": (bounds.width < 0) ? 1 : bounds.width * scale, "height": (bounds.height < 0) ? 1 : bounds.height * scale, "fill": "transparent", "stroke": "red",
                    });
                } else {
                    if (!(shape.isSwimlane || shape.isLane)) {
                        transform = this._selectorLocation(shape, scale, diagram);
                        var g = svg.g({
                            "id": svg.document.id + "handle_g",
                            "transform": transform
                        });
                    }

                    if (ej.datavisualization.Diagram.Util.canShowResizeThumbs(diagram)) {
                        var rCorner = svg.document.parentNode.getElementsByClassName("resizeCorners");
                        var rotateHandle = svg.document.getElementById("rotatehandle");

                        var visibility = dragging ? "hidden" : "visible";
                        for (var i = 0; i < rCorner.length; i++) {
                            rCorner[i].setAttribute("visibility", visibility);
                        }

                        if (rotateHandle != null) {
                            var pivotPoint = svg.document.getElementById("pivotLine");
                            rotateHandle.setAttribute("visibility", visibility);
                            pivotPoint.setAttribute("visibility", visibility);
                        }
                    }

                    var type = diagram.getObjectType(shape);
                    if (type === "group" || shape.type === "pseudoGroup" || !((diagram.activeTool.name == "move" || diagram.activeTool.name == "rotate" || diagram.activeTool.name == "labelMove" || diagram.activeTool.name == "labelRotate") && diagram.activeTool.inAction)) {
                        this._updateMultiSelectHandle(shape, scale, constraints, diagram)
                        this._updateResizeHandle(shape, svg, scale, constraints, resizeCorner, dragging, diagram);
                    }
                    if ((diagram.activeTool.name == "rotatetool" || diagram.activeTool.name == "labelRotate") && diagram.activeTool.inAction) {
                        this.renderPivotPoint(shape, scale, svg, resizeCorner, dragging, diagram);
                    }
                    if (diagram.model.selectedItems.userHandles && diagram.model.selectedItems.userHandles.length > 0) {
                        var isMultipleSelection = false;
                        if (diagram.selectionList[0] && diagram.selectionList[0].name == "multipleSelection")
                            isMultipleSelection = true;
                        if (constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles) {
                            this.updateUserHandles(diagram.model.selectedItems.userHandles, shape, svg, isMultipleSelection, false, scale, diagram);
                            return true;
                        }
                    }
                }
            }
        },

        _updatePhaseResize: function (node, svg, scale, constraints) {
            var nPoint, points = [], attr;
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            //#region left
            nPoint, points = [];
            points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
            points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
            nPoint = this._convertToSVGPoints(points);
            attr = { "id": "w-resize", "points": nPoint, };
            svg.polyline(attr);
            //#endregion  

            //#region top
            nPoint, points = [];
            points.push({ x: bounds.topLeft.x * scale, y: bounds.topLeft.y * scale });
            points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
            nPoint = this._convertToSVGPoints(points);
            attr = { "id": "n-resize", "points": nPoint };
            svg.polyline(attr);
            //#endregion 

            //#region right 
            nPoint, points = [];
            points.push({ x: bounds.topRight.x * scale, y: bounds.topRight.y * scale });
            points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
            nPoint = this._convertToSVGPoints(points);
            attr = { "id": "e-resize-hitTest", "points": nPoint };
            svg.polyline(attr);
            attr = { "id": "e-resize", "points": nPoint };
            svg.polyline(attr);
            //#endregion


            //#region bottom
            nPoint, points = [];
            points.push({ x: bounds.bottomLeft.x * scale, y: bounds.bottomLeft.y * scale });
            points.push({ x: bounds.bottomRight.x * scale, y: bounds.bottomRight.y * scale });
            nPoint = this._convertToSVGPoints(points);
            attr = { "id": "s-resize-hitTest", "points": nPoint, };
            svg.polyline(attr);
            attr = { "id": "s-resize", "points": nPoint, };
            svg.polyline(attr);
            //#endregion

        },
        _updateResizeHandle: function (node, svg, scale, constraints, resizeCorner, dragging, diagram) {
            if (!(node.isSwimlane || node.isLane)) {
                var width = node.width ? node.width : node._width;
                var height = node.height ? node.height : node._height;
                var pivot = node.pivot ? node.pivot : { x: 0.5, y: 0.5 };
                var corner = node._corners;
                var visible = "visible", resizable;
                if (ej.datavisualization.Diagram.Util.canShowResizeThumbs(diagram)) {
                    var rect1 = ej.datavisualization.Diagram.Rectangle(0, 0, 14, 14);
                    var rect2 = ej.datavisualization.Diagram.Rectangle(((width / 2) * scale), 0, 14, 14);
                    var rect3 = ej.datavisualization.Diagram.Rectangle(0, (height / 2) * scale, 14, 14);
                    visible = this._resizeHandleVisiblity(rect1, rect2, rect3);
                }

                var rotate = ej.datavisualization.Diagram.Point(width * pivot.x, -20 / scale);
                if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Rotator && node.type != "umlclassifier") {
                    var padding = 0;
                    if (visible == "hidden")
                        padding = -20;
                    this._updateRotateHandle("rotate", rotate.x, rotate.y + padding, scale, svg, node);
                    this._updatePivotLine(node, svg, scale, undefined, padding);
                }
                //this._updateResizeCorner("pivot", node.offsetX * scale, node.offsetY * scale, svg);
                if (constraints & ej.datavisualization.Diagram.SelectorConstraints.Resizer) {
                    if (node.type != "umlclassifier") {
                        if (node._type == "label") resizable = !(node.constraints & ej.datavisualization.Diagram.LabelConstraints.Resizable);
                        this._updateResizeCorner("nw-resize", 0, 0, svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest));
                        this._updateResizeCorner("n-resize", (width / 2) * scale, 0, svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorth));
                        this._updateResizeCorner("ne-resize", width * scale, 0, svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast));
                        this._updateResizeCorner("w-resize", 0, (height / 2) * scale, svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeWest));
                        this._updateResizeCorner("e-resize", (width * scale), (height / 2) * scale, svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeEast));
                        this._updateResizeCorner("sw-resize", 0, height * scale, svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest));
                        this._updateResizeCorner("s-resize", (width / 2) * scale, (height * scale), svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouth));
                        this._updateResizeCorner("se-resize", width * scale, height * scale, svg, visible, resizeCorner, dragging, diagram, node._type == "label" ? resizable : !(node.constraints & ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast));
                    }
                    this._updateResizeBorder("resizeBorder", node, svg, scale);
                }
            }
            else this._updatePhaseResize(node, svg, scale, constraints);
        },

        _resizeHandleVisiblity: function (rectangle1, rectangle2, rectangle3) {
            var overlap1 = ej.datavisualization.Diagram.Geometry.intersectsRect(rectangle1, rectangle2);
            var overlap2 = ej.datavisualization.Diagram.Geometry.intersectsRect(rectangle1, rectangle3);
            var visible = "visible";
            if (overlap1 === true || overlap2 === true) {
                visible = "hidden";
            }
            return visible;
        },

        _updateRotateHandle: function (thumb, cx, cy, scale, svg, node) {
            var width = 20;
            var height = 20;
            var dist = 20;
            var attr = {
                "id": "rotatehandle",
                "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
            };
            svg.path(attr);
            svg.circle({
                "id": "rotate",
                "transform": "translate(" + (cx * scale - width / 2) + "," + (cy * scale - height) + ")"
            });
        },

        _updatePivotLine: function (node, svg, scale, considerpivot, padding) {
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var pivotPoint = node.pivot ? node.pivot : { x: 0.5, y: 0.5 };
            var rotateThumb = ej.datavisualization.Diagram.Point(width * pivotPoint.x, -20 / scale);
            if (padding)
                rotateThumb.y += padding;
            var pivot;
            if (considerpivot) {
                pivot = ej.datavisualization.Diagram.Point(width * pivotPoint.x, height * pivotPoint.y);
            } else pivot = ej.datavisualization.Diagram.Point(width * pivotPoint.x, 0);
            var line = svg.line({
                "id": "pivotLine", "x1": rotateThumb.x * scale, "y1": rotateThumb.y * scale, "x2": pivot.x * scale, "y2": pivot.y * scale
            });
        },
        _updateResizeBorder: function (id, node, svg, scale) {
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            if (node.type == "umlclassifier")
                var rect = ej.datavisualization.Diagram.ClassifierHelper.renderResizeBorder(id, node, svg, scale);
            else
                svg.rect({
                    "id": id, "width": width * scale, "height": height * scale,
                });
        },

        _updateResizeCorner: function (corner, cx, cy, svg, visible, resizeCorner, dragging, diagram, constraints) {
            var attr = { "id": corner, "cx": cx, "cy": cy, "visibility": visible };
            attr = this._setPadding(attr);
            if (ej.datavisualization.Diagram.Util.canShowResizeThumbs(diagram)) {
                if (dragging && resizeCorner != corner)
                    attr.visibility = "hidden";
                else if (attr.visibility == "visible" || dragging)
                    attr.visibility = "visible";
            }
            svg.circle(attr);
            attr = { "id": corner + "_transparent", "cx": attr.cx, "cy": attr.cy, "visibility": attr.visibility };
            if (attr.visibility === "hidden" || constraints)
                attr["pointer-events"] = "none";
            else
                attr["pointer-events"] = "all";
            svg.circle(attr);
        },

        _updateEndPointHandle: function (connector, svg, scale) {
            var enabled = ej.datavisualization.Diagram.Util.canDragSegmentThumbs(connector);
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                var points = segment.points;
                if (i == connector.segments.length - 1) {
                    this._updateEndPointCorner("targetEndPoint", points[points.length - 1].x * scale, points[points.length - 1].y * scale, ej.datavisualization.Diagram.Util.isTargetConnected(connector), svg,
                        ej.datavisualization.Diagram.Util.canDragTargetEnd(connector));
                    if (segment.type == "orthogonal") {
                        this._updateTerminalOrthoThumbs(segment, svg, scale, i, enabled);
                    }
                }
                else {
                    if (segment.type != "orthogonal") {
                        this._updateSegmentEndThumb("segmentEnd_" + i, segment._endPoint.x * scale, segment._endPoint.y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                            ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                    }
                    else {
                        this._updateTerminalOrthoThumbs(segment, svg, scale, i, enabled);
                    }
                }
                if (i == 0)
                    this._updateEndPointCorner("sourceEndPoint", points[0].x * scale, points[0].y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                        ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                if (segment.type == "bezier") {
                    this._updateEndPointCorner("bezierpoint1_" + i, segment._point1.x * scale, segment._point1.y * scale, false, svg, enabled);
                    this._updateEndPointCorner("bezierpoint2_" + i, segment._point2.x * scale, segment._point2.y * scale, false, svg, enabled);
                    this._updateBezierLine("bezierline1_" + i, segment._startPoint, segment._point1, scale, svg);
                    this._updateBezierLine("bezierline2_" + i, segment._endPoint, segment._point2, scale, svg);
                }
            }
            //if (points.length > 2) {
            //    for (var i = 1, len = points.length; i < len - 1; ++i) {
            //        this._updateControlPointCorner("controlPoint", points[i], i, svg);
            //    }
            //}
        },

        _updateEndPointCorner: function (corner, x, y, isConnected, svg, isenabled) {
            var fill = isConnected ? "#8CC63F" : "white";
            if (!isenabled) fill = "darkgray";
            var attr = { "id": corner, "fill": fill, "cx": x, "cy": y };
            svg.circle(attr);
        },
        _updateSegmentEndThumb: function (corner, x, y, isConnected, svg, isenabled) {
            var attr = { "id": corner, "cx": x, "cy": y };
            svg.circle(attr);
        },
        _updateOrthoThumb: function (corner, x, y, svg, visibility, orientation, enabled) {
            var fill = "#e2e2e2";
            if (!enabled) fill = "darkgray";
            var path, h, v; if (orientation == "horizontal") {
                path = "M0,7 L15,0 L30,7 L15,14 z"; h = -15; v = -7;
            } else { path = "M7,0 L0,15 L7,30 L14,15 z"; h = -7; v = -15; };
            var attr = { "id": corner, visibility: visibility, transform: "translate(" + (x + h) + "," + (y + v) + ")", d: path, fill: fill };
            svg.path(attr);
        },
        _updateTerminalOrthoThumbs: function (segment, svg, scale, index, enabled) {
            var orientation;
            if (segment.points.length > 2)
                for (var i = 0; i < segment.points.length - 1; i++) {
                    var length = ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]);
                    if (segment.points[i].y.toFixed(2) == segment.points[i + 1].y.toFixed(2)) {
                        orientation = "horizontal";
                    }
                    else orientation = "vertical";
                    var visible;
                    if (length >= 50) visible = "visible"; else visible = "hidden";
                    this._updateOrthoThumb(("OrthoThumb_" + i) + "_" + index, ((segment.points[i].x + segment.points[i + 1].x) / 2) * scale, ((segment.points[i].y + segment.points[i + 1].y) / 2) * scale, svg, visible, orientation, enabled);

                }
            else {
                var length = segment.length || ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                if (segment._startPoint.y.toFixed(2) == segment._endPoint.y.toFixed(2)) {
                    orientation = "horizontal";
                }
                else orientation = "vertical";
                if (length >= 50) visible = "visible"; else visible = "hidden";
                this._updateOrthoThumb("OrthoThumb_" + index, ((segment._endPoint.x + segment._startPoint.x) / 2) * scale, ((segment._endPoint.y + segment._startPoint.y) / 2) * scale, svg, visible, orientation, enabled);
            }
        },
        _updateBezierLine: function (id, start, end, scale, svg) {
            var line = svg.line({
                "id": id, "x1": start.x * scale, "y1": start.y * scale, "x2": end.x * scale, "y2": end.y * scale
            });
        },
        _updateControlPointCorner: function (corner, point, index, svg) {
            svg.circle({ "id": corner + "_" + index, "cx": point.x, "cy": point.y });
        },

        updateUserHandles: function (handles, node, svg, isMultipleSelection, isDragging, scale, diagram) {
            var userHandle = svg.document.getElementById(svg.document.id + "userHandle_g");
            if (diagram.model.selectedItems.constraints & ej.datavisualization.Diagram.SelectorConstraints.UserHandles) {
                if (!userHandle) {
                    this.renderUserHandles(handles, node, svg, isMultipleSelection, scale, diagram._adornerLayer, diagram);
                } else {
                    if (handles && handles.length > 0) {
                        for (var handleIndex = 0; handleIndex < handles.length; handleIndex++) {
                            if ((isMultipleSelection && handles[handleIndex].enableMultiSelection) || !isMultipleSelection)
                                this._updateHandle(handles[handleIndex], node, svg, isDragging, scale, diagram);
                        }
                    }
                }
            }
        },

        _updateHandle: function (handle, node, svg, isDragging, scale, diagram) {
            if (!isDragging && node && handle.visible) {
                var position = this._getHandlePosition(handle, node, scale, null, diagram);
                var d = handle._absolutePath;
                if (!d || handle.size != handle._size) d = handle._absolutePath = ej.datavisualization.Diagram.Geometry.updatePath(0, 0, handle.size / 2, handle.size / 2, handle.pathData, svg);
                handle._size = handle._size;
                var x = position.x * scale;// - (node.segments ? 0 : handle.size / 4);
                var y = position.y * scale;// - (node.segments ? 0 : handle.size / 4)
                this._updateHandleShape(handle, x, y, svg);
                this._updateHanleIcon(handle, d, svg, x - handle.size / 4, y - handle.size / 4);
                if (svg.getElementById(handle.name + "_shape") && handle.visible) {
                    svg.getElementById(handle.name + "_shape").style.display = "block";
                    svg.getElementById(handle.name + "_icon").style.display = "block";
                }
            }
            else {
                if (svg.getElementById(handle.name + "_shape")) {
                    svg.getElementById(handle.name + "_shape").style.display = "none";
                    svg.getElementById(handle.name + "_icon").style.display = "none";
                }
            }
        },

        clearSelector: function (svg, parent, diagram) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            if (handle)
                parent.removeChild(handle);
            handle = svg.getElementById(svg.document.id + "userHandle_g");
            if (handle)
                parent.removeChild(handle);
            if (diagram) {
                handle = diagram._svg.getElementById(diagram.element[0].id + "_multiselector");
                if (handle)
                    handle.parentNode.removeChild(handle);
            }
        },

        clearSegments: function (svg) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            $(handle).find(".segmentEnd").remove();
        },

        addSegments: function (svg, connector, scale) {
            var handle = svg.getElementById(svg.document.id + "handle_g");
            this._renderSegmentHandle(connector, svg, scale);
        },

        _renderSegmentHandle: function (connector, svg, scale) {
            if (!connector.isPhase) {
                var enabled = ej.datavisualization.Diagram.Util.canDragSegmentThumbs(connector);
                for (var i = 0; i < connector.segments.length; i++) {
                    var segment = connector.segments[i];
                    if (segment.type == "bezier") {
                        this._renderBezierLine("bezierline1_" + i, segment._startPoint, segment._point1, scale, svg, enabled);
                        this._renderBezierLine("bezierline2_" + i, segment._endPoint, segment._point2, scale, svg, enabled);
                        this._renderEndPointCorner("bezierpoint1_" + i, segment._point1.x * scale, segment._point1.y * scale, false, svg, enabled);
                        this._renderEndPointCorner("bezierpoint2_" + i, segment._point2.x * scale, segment._point2.y * scale, false, svg, enabled);
                    }
                    var points = segment.points;
                    if (!(i === 0 || i === connector.segments.length - 1)) {
                        if (segment.type != 'orthogonal') {
                            this._renderSegmentEndThumb("segmentEnd_" + i, segment._endPoint.x * scale, segment._endPoint.y * scale, ej.datavisualization.Diagram.Util.isSourceConnected(connector), svg,
                                ej.datavisualization.Diagram.Util.canDragSourceEnd(connector));
                        } else {
                            this._renderTerminalOrthoThumbs(segment, svg, scale, i, enabled);
                        }
                    }
                }
            }
        },

        _initializePageBreaks: function (svg, attr, g) {
            var g1 = svg.g(attr);
            g.appendChild(g1);
            return g1;
        },

        _renderVPageBreakLine: function (start, end, svg, g) {
            var line = svg.line({
                "x1": start.x, "y1": start.y,
                "x2": end.x, "y2": end.y,
                "style": "stroke:#aaaaaa;stroke-width:1;stroke-dasharray:10,10 "
            });
            g.appendChild(line);
        },

        _renderPageSettingsRect: function (start, end, svg, g, _stroke, _fill, _strokewidth) {
            var rect = svg.rect({
                "id": "pageback",
                "x": start.x, "y": start.y, "width": end.x, "height": end.y,
                "style": "fill:" + _fill + ";stroke:" + _stroke + ";stroke-width:" + _strokewidth + ""
            });
            g.appendChild(rect);
        },

        _updatePageBakground: function (start, end, svg, g, _stroke, _fill, _strokewidth) {
            var rect = svg.document.getElementById("pageback");
            var attr = {
                "x": start.x, "y": start.y, "width": (end.x < 0) ? 0 : end.x, "height": (end.y < 0) ? 0 : end.y,
                "style": "fill:" + _fill + ";stroke:" + _stroke + ";stroke-width:" + _strokewidth + ""
            };
            if (rect)
                ej.datavisualization.Diagram.Util.attr(rect, attr);
        },

        _renderHPageBreakLine: function (start, end, svg, g) {
            var line = svg.line({
                "x1": start.x, "y1": start.y,
                "x2": end.x, "y2": end.y,
                "style": "stroke:#aaaaaa;stroke-width:1;stroke-dasharray:10,10 "
            });
            g.appendChild(line);
        },

        _removePageBreaks: function (svg, g, layer) {
            if (g != null) {
                if (layer != null) {
                    layer.removeChild(g);
                }
            }
        },
        removeChild: function (element, view) {
            var elementTar = view.svg.document.getElementById(element.name);
            var htmlLayer = view.svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
            var label = this._findChild(htmlLayer.childNodes, element);
            var adornerLayer = view.svg.document.parentNode.getElementsByClassName("AdornerLayer")[0];
            if (adornerLayer)
                var ports = adornerLayer.parentNode.getElementById(element.name + "_ej_ports");
            if (elementTar)
                elementTar.parentNode.removeChild(elementTar);
            if (ports)
                ports.parentNode.removeChild(ports);
            if (label)
                htmlLayer.removeChild(label);
            if (element._type === "node" && element.type === "html") {
                var htmlelement = htmlLayer.children[element.name + "_parentdiv"];
                if (htmlelement && htmlelement.parentNode)
                    htmlelement.parentNode.removeChild(htmlelement);
            }
        }
        //#endregion
    };
    //#endregion

    //#region Common Renderer
    ej.datavisualization.Diagram.DiagramContext = {

        _renderNodes: function (view, isLoad, isoverView, diagram) {
            if (diagram.nodes()) {
                var nodes = diagram.nodes();
                for (var i = 0, len = nodes.length; i < len; ++i) {
                    var node = diagram.nameTable[nodes[i].name];
                    var panel = view.svg || view._canvas;
                    this._renderNodeObject(node, view, isLoad, isoverView, diagram);
                }
            }
        },

        _renderNodeObject: function (node, view, isLoad, isoverView, diagram) {
            var panel = view.svg || view._canvas;
            if (node._type === "group" && !node.parent) {
                if (!node.container) {
                    //ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram, true);
                }
                view.context.renderGroup(node, panel, view.diagramLayer, diagram.nameTable, diagram, isLoad, isoverView);
                // ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                ej.datavisualization.Diagram.DiagramContext.update(node, diagram);
            }
            else {
                if (!node.parent)
                    view.context.renderNode(node, panel, view.diagramLayer, null, diagram);
            }
        },

        _renderConnectors: function (view, diagram) {
            if (diagram.connectors()) {
                var connectors = diagram.connectors();
                var panel = view.svg || view._canvas;
                var connector;
                for (var i = 0, len = connectors.length; i < len; ++i) {
                    connector = connectors[i];
                    diagram._setZorder(connector);
                }
                for (var i = 0, len = connectors.length; i < len; ++i) {
                    connector = connectors[i];
                    this._renderConnectorObject(connector, view, diagram);
                }
            }
        },

        _renderConnectorObject: function (connector, view, diagram) {
            var panel = view.svg || view._canvas;
            ej.datavisualization.Diagram.Util.updateBridging(connector, diagram);
            if (!connector.parent)
                view.context.renderConnector(connector, panel, view.diagramLayer, diagram);
        },

        updateViewPort: function (diagram) {
            var view, panel;
            diagram._svgParentDimention = null;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                if (view.context == ej.datavisualization.Diagram.SvgContext && view.type == "mainview") {
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
                }
            });
        },
        renderNode: function (node, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                if (parent)
                    parent = panel.document.getElementById(parent.id)
                var isoverView = (view.type == "overview") ? true : false;
                view.context.renderNode(node, panel, parent || view.diagramLayer, undefined, diagram, isoverView);
            });
        },
        addLabel: function (node, label, diagram, index) {
            var view, panel;
            if (diagram._views) {
                diagram._views.forEach(function (viewid) {
                    view = diagram._views[viewid];
                    panel = view.svg || view.canvas;
                    view.context._addLabel(node, label, panel, diagram, index);
                });
            }
        },
        renderPort: function (node, port, diagram, index) {
            var view, panel, isOverView;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                isOverView = view.type === "overview" ? true : false;
                panel = view.svg || view._canvas;
                view.context._insertPort(node, port, !isOverView ? diagram._adornerSvg : panel, index, diagram, isOverView);
            });
        },
        renderConnector: function (connector, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context.renderConnector(connector, panel, parent || view.diagramLayer, diagram);
            });
        },

        renderGroup: function (group, diagram, parent) {
            var view, panel;

            diagram._views.forEach(function (viewid) {
                var isOverView
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                parent = view.svg.getElementById(group.parent);
                if (view.type == "overview") {
                    isOverView = true;
                }
                view.context.renderGroup(group, panel, parent || view.diagramLayer, diagram.nameTable, diagram, null, isOverView);
            });
        },
        update: function (data, diagram, layout) {
            var update = true;
            if (data.isSwimlane && diagram._disableSwimlaneUptate) {
                update = false;
            }
            if (update) {
                var view, panel;
                if (diagram._views) {
                    diagram._views.forEach(function (viewid) {
                        view = diagram._views[viewid];
                        panel = view.svg || view._canvas;
                        if (diagram && !diagram._isInit && data._status !== "new")
                            data._status = "update";
                        var isoverView = (view.type == "overview") ? true : false;
                        if (data._type === "group" || data.type === "pseudoGroup")
                            view.context.updateGroup(data, panel, diagram, layout, isoverView);
                        else if (data.segments)
                            view.context.updateConnector(data, panel, diagram, isoverView);
                        else if (data._type == "label") {
                            var node = diagram.findNode(data._parent);
                            view.context.updateLabel(node, data, panel, diagram);
                        }
                        else
                            view.context.updateNode(data, panel, diagram, layout, isoverView);
                    });
                }
            }
        },
        _refreshSegments: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                if (connector.segments)
                    view.context._refreshSegments(connector, panel, diagram);
            });
        },
        _refreshOnlySegments: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                if (connector.segments)
                    view.context._refreshOnlySegments(connector, panel, diagram);
            });
        },
        renderShadow: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context._renderShadow(node, panel);
            });
        },
        updateShadow: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context._updateShadow(node, panel);
            });
        },
        removeShadow: function (node, diagram) {
            var view, panel;

            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view._canvas;
                view.context._removeShadow(node, panel);
            });
        },
        addNodeLabel: function (shape, label, parent, diagram) {
            var view, panel;
            if (diagram._views) {
                diagram._views.forEach(function (viewid) {
                    view = diagram._views[viewid];
                    panel = view.svg || view.canvas;
                    view.context.addNodeLabel(shape, label, panel, parent, diagram);
                });
            }
        },

        updateLabel: function (node, label, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                if (diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                    view.context._updateSVGLabel(node, label, panel, diagram);
                }
                else
                    view.context.updateLabel(node, label, panel, diagram);
            });
        },

        updatePort: function (node, port, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                var isoverView = (view.type === "overview") ? true : false
                panel = (!isoverView) ? diagram._adornerSvg : (view.svg || view.canvas);
                view.context.updatePort(node, port, panel, diagram);
            });
        },
        setLabelTemplate: function (node, label, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context._updateLabelTemplate(node, label, panel, diagram);
            });
        },
        setNodeShape: function (node, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.setNodeShape(node, panel, parent, diagram);
            });
        },

        setLine: function (connector, diagram, parent) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.setLine(connector, panel, parent, diagram);
            });
        },

        renderDecorators: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.renderDecorators(connector, panel, diagram);
            });
        },

        clearDecorators: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.clearDecorators(connector, panel, diagram);
            });
        },

        updateTargetDecoratorStyle: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.updateTargetDecoratorStyle(node, panel);
            });
        },

        updateSourceDecoratorStyle: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.updateSourceDecoratorStyle(node, panel);
            });
        },

        updateNodeStyle: function (node, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context._updateNodeStyle(node, panel);
            });
        },

        updateLabelStyle: function (node, label, diagram) {
            diagram._views.forEach(function (viewid) {
                var view = diagram._views[viewid];
                var panel = view.svg || view.canvas;
                view.context.updateLabelStyle(node, label, panel, diagram);
            });
        },

        updateConnectorStyle: function (connector, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context._updateConnectorStyle(connector, panel);
            });
        },

        updateTextBlock: function (node, label, diagram) {
            var view, panel;
            diagram._views.forEach(function (viewid) {
                view = diagram._views[viewid];
                panel = view.svg || view.canvas;
                view.context.updateTextBlock(node, label, panel, diagram);
            });

        },

        updateBPMNNodeStyle: function (node, diagram) {
            var child, children, i = 0;
            node = ej.datavisualization.Diagram.Util._updateBpmnChild(node, diagram);
            if (node.children) {
                children = diagram._getChildren(node.children);
                for (i = 0; i < children.length; i++) {
                    child = diagram.nameTable[children[i]];
                    ej.datavisualization.Diagram.DiagramContext.updateNodeStyle(child, diagram, node);
                }
            } else ej.datavisualization.Diagram.DiagramContext.updateNodeStyle(node, diagram);
        },

        updateBPMNNodeShape: function (node, diagram) {
            var child, children, i = 0;
            node = ej.datavisualization.Diagram.Util._updateBpmnChild(node, diagram);
            children = diagram._getChildren(node.children);
            if (children.length > 0 && diagram.nameTable[children[0]]) {
                for (i = 0; i < children.length; i++) {
                    child = diagram.nameTable[children[i]];
                    if (child)
                        ej.datavisualization.Diagram.DiagramContext.setNodeShape(child, diagram, node);
                }
            }
            else {
                var element = diagram._svg.getElementById(node.name);
                element.parentNode.removeChild(element);
                diagram.add(node);
            }
        }
    };
    //#endregion
})(jQuery, Syncfusion);;
/**
* @fileOverview Plugin to style the Html SymbolPalette elements
* @copyright Copyright Syncfusion Inc. 2001 - 2020. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej, undefined) {
    "use strict";
    //#region SymbolPalette widget
    ej.widget("ejSymbolPalette", "ej.datavisualization.SymbolPalette", {
        element: null,
        model: null,
        _requiresID: true,
		validTags: ["div"],
        nameTable: {},
        //#region Initialization
        defaults: {
            width: "250px",
            height: "400px",
            labelRenderingMode: "html",
            paletteItemWidth: undefined,
            paletteItemHeight: undefined,
            previewWidth: undefined,
            previewHeight: undefined,
            previewOffset: { x: 110, y: 110 },
            diagramId: "",
            headerHeight: 30,
            selectedPaletteName: "",
            cssClass: "e-datavisualization-symbolpalette",
            showPaletteItemText: true,
            allowDrag: true,
            palettes: [],
            defaultSettings: {
                connector: null,
                node: null
            },
            selectionChange: null,
            create: null,
            destroy: null,
        },
        _oldItem: null,
        _labelHashTable: {},
        dataTypes: {
            paletteItemWidth: "number",
            paletteItemHeight: "number",
            previewWidth: "number",
            previewHeight: "number",
            headerHeight: "number",
            showPaletteItemText: "boolean",
            allowDrag: "boolean",
            palettes: "array",
        },
        _canvas: null,
        _init: function () {
            if (!(ej.browserInfo().name === "msie" && Number(ej.browserInfo().version) < 9)) {
                this.nameTable = {};
                this.selectedItem = null;
                this.activePalette = null;
                this._selectedElement = null;
                this._renderSymbolPalette();
                this._wireEvents();
                this.updateScrollerViewport();
            }
        },
        _setModel: function (options) {
            for (var option in options) {
                switch (option) {
                    case "width":
                        this._setWidth(options[option]);
                        break;
                    case "height":
                        this._setHeight(options[option]);
                        break;
                    case "paletteItemWidth":
                        this.model.paletteItemWidth = options[option];
                        this._redrawContent();
                        break;
                    case "paletteItemHeight":
                        this.model.paletteItemHeight = options[option];
                        this._redrawContent();
                        break;
                    case "headerHeight":
                        this._setHeaderHeight(options[option]);
                        break;
                    case "cssClass":
                        this._setCssClass(options[option]);
                        break;
                    case "showPaletteItemText":
                        this._showItemText(options[option]);
                        break;
                    case "allowDrag":
                        this._setAllowDrag(options[option]);
                        break;
                    case "palettes":
                        this._updatePalettes(options[option]);
                        break;
                    case "selectedPaletteName":
                        var palette = this._getPalette(options.selectedPaletteName);
                        if (palette && palette !== this.activePalette) {
                            $(this._getPaletteHeaderDiv(this.activePalette.name)).removeClass("selected");
                            this.activePalette = palette;
                            $(this._getPaletteHeaderDiv(this.activePalette.name)).addClass("selected");
                        }
                        break;
                }
            }
        },
        _destroy: function () {
            this.element.empty().removeClass(this.model.cssClass);
        },
        //#endregion
        //#region Rendering
        _renderSymbolPalette: function () {
            this._canvas = document.createElement("div");
            this._canvas.setAttribute("class", "e-scanvas");
            this._canvas.setAttribute("id", this.element[0].id + "_canvas");
            this.element[0].setAttribute("style", "height:" + this.model.height + "; width:" + this.model.width + ";");
            this.element.append(this._canvas);
            this.element.ejScroller({ width: this._setViewPortWidth(), height: this._setViewPortHeight(), enableTouchScroll: false });
            this._renderPalettes();
        },
        _updatePalettes: function (option) {
            this.model.palettes = option;
            $("#" + this.element[0].id + "_canvas").empty();
            this._renderPalettes();
            this.updateScrollerViewport();
        },
        _renderPalettes: function () {
            var palettes = this.model.palettes;
            if (palettes) {
                for (var i = 0, len = palettes.length; i < len; i++) {
                    palettes[i] = ej.datavisualization.Diagram.Palette(palettes[i]);
                    this._initPaletteitems(palettes[i]);
                    this._renderPalette(palettes[i]);
                }
            }
        },

        _updatePaletteItemWidth: function (item) {
            var bounds = ej.datavisualization.Diagram.Util.bounds(item);
            if (!item.segments) {
                if (item.width > (this.element.width() - 40)) {
                    item.width = this.element.width() - 40;
                }
                else if (item.paletteItem && item.paletteItem.width && item.paletteItem.width > (this.element.width() - 40)) {
                    item.paletteItem.width = this.element.width() - 40;
                }
            }
            else {
                if (bounds.width > (this.element.width() - 40) && !item.paletteItem) {
                    ej.datavisualization.Diagram.Util.scale(item, (this.element.width() - 45) / bounds.width, 1, bounds.center);
                }
            }
        },
        _renderHtmlLayer: function (canvas, parent) {
            var div = document.createElement("div");
            var attr = { "id": canvas.id + "_htmlLayer", "class": "htmlLayer" };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            var htmlLayer = div;
            div.style.pointerEvents = "none";
            div.style.position = "absolute";
            div.style.left = parent ? parent.style.paddingLeft : "0px";
            div.style.top = parent ? parent.style.paddingTop : "0px";
            canvas.appendChild(htmlLayer);
            return htmlLayer;
        },
        _initPaletteitems: function (options) {
            if (options.items) {
                for (var i = 0; i < options.items.length; i++) {
                    options.items[i] = this._extendPaletteItem (options.items[i])
                }
            }
        },
        _initGroupNode: function (group) {
            var child = null;
            var nodeDefault = this.model.defaultSettings && this.model.defaultSettings.node ? this.model.defaultSettings.node : null;
            var connectorDefault = this.model.defaultSettings && this.model.defaultSettings.connector ? this.model.defaultSettings.connector : null;
            for (var i = 0; i < group.children.length; i++) {
                child = group.children[i];
                if (typeof (child) == "object") {
                    if (child._type == "group") {
                        child = ej.datavisualization.Diagram.Group($.extend(true, {}, nodeDefault, child));
                        child = ej.datavisualization.Diagram.Util._updateBpmnChild(child, this)
                        this._initGroupNode(child);
                    }
                    else if (child.segments)
                        child = ej.datavisualization.Diagram.Connector($.extend(true, {}, connectorDefault, child));
                    else
                        child = ej.datavisualization.Diagram.Node($.extend(true, {}, nodeDefault, child));
                    child = ej.datavisualization.Diagram.NodeType(child, this);
                    child.parent = group.name;
                    group.children[i] = child;
                    this.nameTable[child.name] = child;
                }
            }
        },
        _setViewPortWidth: function () {
            this.element[0].setAttribute("style", "width:" + this.model.width + ";");
            var w = this.element.width();
            // var left = this.element[0].offsetLeft;
            return Math.abs(w);
        },
        _setViewPortHeight: function () {
            this.element[0].setAttribute("style", "height:" + this.model.height + ";");
            var h = this.element.height();
            //var top = this.element[0].offsetTop;
            return Math.abs(h);
        },
        _renderPalette: function (palette) {
            this._renderHeader(palette);
            this._updateHeaderWrapper(palette, this.model.headerHeight);
            this._renderContent(palette);
            this._collapse(palette);
            this._updatePaletteVisibility(palette);
        },
        _renderHeader: function (palette) {
            var header = document.createElement("div");
            var attr = { "id": palette.name.replace(/\s/gi, "_") + "_header", "class": "e-header", "style": "height:" + this.model.headerHeight + "px;" };
            if (!(palette.constraints & this._canHeaderVisible(palette))) {
                attr.style += "display:none";
            }
            ej.datavisualization.Diagram.Util.attr(header, attr);
            this._renderHeaderArrow(header, palette.expanded, palette.name, this._canExpand(palette));
            if (palette.templateId && $.templates)
                this._renderHeaderTemplate(header, palette);
            else
                this._renderHeaderText(header, palette.name);
            this._addExpandedClass(header, palette.expanded);
            this._disableClickClass(header, this._canExpand(palette));
            if (this.model.selectedPaletteName === palette.name) {
                $(header).addClass("selected");
                this.activePalette = palette;
            }
            this._canvas.appendChild(header);
        },
        _renderHeaderText: function (header, text) {
            var span = document.createElement("span");
            span.setAttribute("class", "e-header-text");
            span.innerHTML = text;
            header.appendChild(span);
        },
        _renderHeaderTemplate: function (header, palette) {
            var html = this._renderEjTemplate("#" + palette.templateId, palette);
            var wrapper = document.createElement("div");
            var attr = {
                "id": palette.name + "_Wrapper",
                "class": "e-header-wrapper"
            };
            ej.datavisualization.Diagram.Util.attr(wrapper, attr);
            this._renderTemplateContent(palette, wrapper, html);
            header.appendChild(wrapper);
        },
        _renderTemplateContent: function (palette, wrapper, html) {
            var div = document.createElement('div');
            div.innerHTML = html;
            div.style.display = "inline-block";
            document.body.appendChild(div);
            var content = div.cloneNode(true);
            content.id = palette.name + "_templateHeader";
            var width = div.offsetWidth, height = div.offsetHeight;
            var scaleX = $("#" + this._id).width() - 18 / width;
            var scaleY = this.model.headerHeight / height;
            var scale = Math.min(scaleX, scaleY);
            var left = (scale - 1) * width / 2;
            ej.datavisualization.Diagram.Util.attr(content, { style: "position: relative; left: " + left + "px; transform: scale(" + scale + ")" });
            wrapper.appendChild(content);
            div.parentNode.removeChild(div);
        },
        _renderHeaderArrow: function (header, expanded, index, enableClick) {
            if (enableClick) {
                var arrow = header.getElementsByClassName("e-header-arrow e-icon")[0];
                if (!arrow) {
                    arrow = document.createElement("span");
                    arrow.setAttribute("class", "e-header-arrow e-icon");
                    arrow.setAttribute("style", "top:" + (this.model.headerHeight - 16) / 2 + "px;");
                    this._addExpandedClass(arrow, expanded);
                    if (this.model.selectedPaletteName === name)
                        $(arrow).addClass("selected");
                    header.appendChild(arrow);
                }
            }
            else {
                var icon = header.getElementsByClassName("e-header-arrow e-icon")[0];
                if (icon) {
                    icon.parentNode.removeChild(icon);
                }
            }
        },
        _renderContent: function (palette) {
            var content = this._getPaletteContentDiv(palette.name);
            if (!content) {
                content = document.createElement("div");
                this._canvas.appendChild(content);
            }
            content.setAttribute("id", palette.name.replace(/\s/gi, "_") + "_content");
            content.setAttribute("class", "e-scontent");
            if ((this.model.palettes.length - 1) === this.model.palettes.indexOf(palette))
                content.setAttribute("style", "border-bottom-width: 0px;");

            var paletteItems = palette.items;
            if (paletteItems && paletteItems.length > 0) {
                for (var i = 0, len = paletteItems.length; i < len; i++) {
                    if (paletteItems[i].parent)
                        this.nameTable[paletteItems[i].name] = paletteItems[i];
                    else {
                        this._renderItem(paletteItems[i], content);
                        this.nameTable[paletteItems[i].name] = paletteItems[i];
                    }
                }
            }
        },

        _getPaletteContentDiv: function (name) {
            var content = $(this.element).find("#" + name.replace(/\s/gi, "_") + "_content")[0];
            return content;
        },

        _getPaletteHeaderDiv: function (name) {
            var content = $(this.element).find("#" + name.replace(/\s/gi, "_") + "_header")[0];
            return content;
        },

        _updateRenderSize: function (paletteItem, preSize, nameTable) {
            if (!paletteItem.paletteItem || (paletteItem.type === "group" && !paletteItem.isLane) || (paletteItem._type === "group" && paletteItem.type === "bpmn")) {
                if (!paletteItem.segments) {
                    if (paletteItem._type == "group") {
                        if (this._checkItemUpdate(paletteItem)) {
                            var deltaWidth = preSize.width / paletteItem.width;
                            var deltaHeight = preSize.height / paletteItem.height;
                            this.scale(paletteItem, deltaWidth, deltaHeight, paletteItem.pivot, nameTable, null, null, null, this);
                            ej.datavisualization.Diagram.Util._translate(paletteItem, preSize.width / 2 - paletteItem.offsetX, preSize.height / 2 - paletteItem.offsetY, nameTable, null, this);
                        }
                        else {
                            ej.datavisualization.Diagram.Util._translate(paletteItem, paletteItem.width / 2 - paletteItem.offsetX, paletteItem.height / 2 - paletteItem.offsetY, nameTable, null, this);
                        }
                    }
                    else {
                        paletteItem.width = preSize.width;
                        paletteItem.height = preSize.height;
                        paletteItem.offsetX = preSize.width / 2;
                        paletteItem.offsetY = preSize.height / 2;
                    }
                }
                else {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                    ej.datavisualization.Diagram.Util._translate(paletteItem, preSize.width / 2 - bounds.center.x, preSize.height / 2 - bounds.center.y, this.nameTable);
                }
            }
            else if (paletteItem.segments && paletteItem.paletteItem && paletteItem.paletteItem.enableScale && !paletteItem.isPhase) {
                var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                var dx = (paletteItem.paletteItem.width ? paletteItem.paletteItem.width : this.model.paletteItemWidth) / bounds.width;
                var dy = (paletteItem.paletteItem.height ? paletteItem.paletteItem.height : this.model.paletteItemHeight) / bounds.height;
                ej.datavisualization.Diagram.Util.scale(paletteItem, dx, dy, { x: .5, y: .5 });
                this._updatePaletteItemWidth(paletteItem);
            }
            else if ((paletteItem.segments && paletteItem.paletteItem && paletteItem.paletteItem.enableScale && !paletteItem.isPhase) || (paletteItem.isPhase && paletteItem.paletteItem.width != paletteItem.paletteItem.height)) {
                var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                var dx = (paletteItem.paletteItem.width ? paletteItem.paletteItem.width : this.model.paletteItemWidth) / bounds.width;
                var dy = (paletteItem.paletteItem.height ? paletteItem.paletteItem.height : this.model.paletteItemHeight) / bounds.height;
                ej.datavisualization.Diagram.Util.scale(paletteItem, dx, dy, { x: .5, y: .5 });
                this._updatePaletteItemWidth(paletteItem);
            }
            else if (paletteItem._type == "node" && this._checkItemUpdate(paletteItem)) {
                paletteItem.width = preSize.width;
                paletteItem.height = preSize.height;
                paletteItem.offsetX = preSize.width / 2;
                paletteItem.offsetY = preSize.height / 2;
            }
        },
        _checkItemUpdate: function (paletteItem) {
            if (!(paletteItem.paletteItem && paletteItem.paletteItem.enableScale))
                return true;
            return false;
        },
        _updatePreviewSize: function (paletteItem, preSize) {
            if (!paletteItem.paletteItem || (paletteItem.type === "group" && !paletteItem.isLane)) {
                if (!paletteItem.segments) {
                    if (paletteItem.container && !paletteItem.isLane) {
                        var deltaWidth = preSize.width / paletteItem.width;
                        var deltaHeight = preSize.height / paletteItem.height;
                        this.scale(paletteItem, deltaWidth, deltaHeight, paletteItem.pivot, this.nameTable, null, null, null, this);
                        ej.datavisualization.Diagram.Util._translate(paletteItem, preSize.width / 2 - paletteItem.offsetX, preSize.height / 2 - paletteItem.offsetY, this.nameTable, null, this);
                    }
                    else {
                        paletteItem.width = preSize.width;
                        paletteItem.height = preSize.height;
                        paletteItem.offsetX = preSize.width / 2;
                        paletteItem.offsetY = preSize.height / 2;
                    }
                }
                else {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                    ej.datavisualization.Diagram.Util._translate(paletteItem, preSize.width / 2 - bounds.center.x, preSize.height / 2 - bounds.center.y, this.nameTable);
                }
            }
            else if (paletteItem.segments && paletteItem.paletteItem && paletteItem.paletteItem.enableScale && !paletteItem.isPhase) {
                var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                var dx = (paletteItem.paletteItem.previewWidth ? paletteItem.paletteItem.previewWidth : this.model.previewWidth) / bounds.width;
                var dy = (paletteItem.paletteItem.previewHeight ? paletteItem.paletteItem.previewHeight : this.model.previewHeight) / bounds.height;
                ej.datavisualization.Diagram.Util.scale(paletteItem, dx, dy, { x: .5, y: .5 });
                this._updatePaletteItemWidth(paletteItem);
            }
            else if ((paletteItem.segments && paletteItem.paletteItem && paletteItem.paletteItem.enableScale && !paletteItem.isPhase) || (paletteItem.isPhase && paletteItem.paletteItem.previewWidth != paletteItem.paletteItem.previewHeight)) {
                var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                var dx = (paletteItem.paletteItem.previewWidth ? paletteItem.paletteItem.previewWidth : this.model.previewWidth) / bounds.width;
                var dy = (paletteItem.paletteItem.previewHeight ? paletteItem.paletteItem.previewHeight : this.model.previewHeight) / bounds.height;
                ej.datavisualization.Diagram.Util.scale(paletteItem, dx, dy, { x: .5, y: .5 });
                this._updatePaletteItemWidth(paletteItem);
            }
            else if (paletteItem._type == "node" || paletteItem._type == "group") {
                paletteItem.width = preSize.width;
                paletteItem.height = preSize.height;
                paletteItem.offsetX = preSize.width / 2;
                paletteItem.offsetY = preSize.height / 2;
            }
        },
        _getRenderItemSize: function (paletteItem) {
            var width = this.model.paletteItemWidth, height = this.model.paletteItemHeight;
            if (!paletteItem.segments) {
                if (paletteItem.type === "group") {
                    bounds = ej.datavisualization.Diagram.Util._getChildrenBounds(paletteItem, this);
                    if (paletteItem.paletteItem && (!paletteItem.isLane)) {
                        width = paletteItem.paletteItem.width ? paletteItem.paletteItem.width : width;
                        height = paletteItem.paletteItem.height ? paletteItem.paletteItem.height : height;
                        width = width ? width : bounds.width;
                        height = height ? height : bounds.height;
                        paletteItem.paletteItem.width = width;
                        paletteItem.paletteItem.height = height;
                    }
                    else if (paletteItem.paletteItem && paletteItem.isLane) {
                        if (!paletteItem.paletteItem.enableScale) {
                            var dx = (paletteItem.paletteItem.width ? paletteItem.paletteItem.width : this.model.paletteItemWidth) / paletteItem.width;
                            var dy = (paletteItem.paletteItem.height ? paletteItem.paletteItem.height : this.model.paletteItemHeight) / paletteItem.height;
                            ej.datavisualization.Diagram.Util.scale(paletteItem, dx, dy, { x: .5, y: .5 }, this.nameTable, false, false, false, this);
                            var x = 0.0001, y = 0.001;
                            if (paletteItem.isLane && paletteItem.paletteItem && !paletteItem.paletteItem.enableScale) {
                                if (paletteItem.orientation === "horizontal") x -= 2.2;
                                else x += .8; y -= 1;
                            }
                            ej.datavisualization.Diagram.Util._translate(paletteItem, x, y, this.nameTable, false, this);
                            width = paletteItem.width ? paletteItem.width : width;
                            height = paletteItem.height ? paletteItem.height : height;
                        }
                        else {
                            width = paletteItem.paletteItem.width ? paletteItem.paletteItem.width : width;
                            height = paletteItem.paletteItem.height ? paletteItem.paletteItem.height : height;
                            width = width ? width : bounds.width;
                            height = height ? height : bounds.height;
                            paletteItem.paletteItem.width = width;
                            paletteItem.paletteItem.height = height;
                        }
                    }
                    else {
                        width = width ? width : bounds.width;
                        height = height ? height : bounds.height;
                    }
                }
                else {
                    if (paletteItem.paletteItem) {
                        width = paletteItem.paletteItem.width ? paletteItem.paletteItem.width : width;
                        height = paletteItem.paletteItem.height ? paletteItem.paletteItem.height : height;
                        width = width ? width : paletteItem.width;
                        height = height ? height : paletteItem.height;
                        paletteItem.paletteItem.width = width;
                        paletteItem.paletteItem.height = height;
                    }
                    else {
                        var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                        width = bounds.width ? bounds.width : width;
                        height = bounds.height ? bounds.height : height;
                    }
                }
            }
            else {
                var dec, size, bounds;
                bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                if (paletteItem.paletteItem) {
                    width = paletteItem.paletteItem.width ? paletteItem.paletteItem.width : width;
                    height = paletteItem.paletteItem.height ? paletteItem.paletteItem.height : height;
                    width = width ? width : paletteItem.width;
                    height = height ? height : paletteItem.height;
                    paletteItem.paletteItem.width = width;
                    paletteItem.paletteItem.height = height;
                }
                else {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                    width = width ? width : bounds.width;
                    height = height ? height : bounds.height;
                }
            }
            return { width: width, height: height };
        },
        _renderPetternDefinition: function (id, svg) {
            if (id && svg) {
                var defs = svg.document.getElementById(id + "patterndefinition")
                if (!defs) {
                    defs = svg.defs({ "id": id + "patterndefinition" });
                    svg.appendChild(defs);
                }
            }
        },
        _cloneFromChildTable: function (paletteItem, nameTable) {
            var child;
            for (var i = 0; paletteItem.children && i < paletteItem.children.length; i++) {
                child = $.extend(true, {}, this.nameTable[ej.datavisualization.Diagram.Util.getChild(paletteItem.children[i])])
                if (child) {
                    nameTable[ej.datavisualization.Diagram.Util.getChild(paletteItem.children[i])] = child;
                    if (child.children && child.children.length > 0) {
                        this._cloneFromChildTable(child, nameTable);
                    }
                }
            }
            return nameTable;
        },
        _renderItem: function (paletteItem, content) {

            var item = $.extend(true, {}, paletteItem);
            var itemSize = this._getRenderItemSize(item);
            var nameTable = this._cloneFromChildTable(paletteItem, {});
            this._updateRenderSize(item, itemSize, nameTable);
            var svg = this._renderItemContainer(item.name, content, null, itemSize, item);
            if (item.segments) {
                this._renderConnector(item, svg, itemSize);
            }
            else if (item._type == "node" && !(item.children && item.children.length > 0))
                this._renderNode(item, svg, itemSize);
            else
                this._renderGroup(item, svg, itemSize, nameTable);
            if (item.isLane && item.paletteItem && !item.paletteItem.enableScale) {
                if (item.orientation === "vertical") {
                    svg.document.setAttribute("height", itemSize.height + 2);
                }
            }
            return item;
        },
        _getPreviewItemSize: function (paletteItem) {
            var width = this.model.previewWidth, height = this.model.previewHeight;
            if (!paletteItem.segments) {
                if (paletteItem.type === "group") {
                    bounds = ej.datavisualization.Diagram.Util._getChildrenBounds(paletteItem, this);
                    if (paletteItem.paletteItem && (!paletteItem.isLane)) {
                        width = paletteItem.paletteItem.previewWidth ? paletteItem.paletteItem.previewWidth : width;
                        height = paletteItem.paletteItem.previewHeight ? paletteItem.paletteItem.previewHeight : height;
                        width = width ? width : bounds.width;
                        height = height ? height : bounds.height;
                        paletteItem.paletteItem.previewWidth = width;
                        paletteItem.paletteItem.previewHeight = height;
                    }
                    else if (paletteItem.paletteItem && paletteItem.isLane) {
                        if (!paletteItem.paletteItem.enableScale) {
                            width = paletteItem.paletteItem.previewWidth ? paletteItem.paletteItem.previewWidth : width;
                            height = paletteItem.paletteItem.previewHeight ? paletteItem.paletteItem.previewHeight : height;
                        }
                        else {
                            width = paletteItem.paletteItem.previewWidth ? paletteItem.paletteItem.previewWidth : width;
                            height = paletteItem.paletteItem.previewHeight ? paletteItem.paletteItem.previewHeight : height;
                            width = width ? width : bounds.width;
                            height = height ? height : bounds.height;
                            paletteItem.paletteItem.previewWidth = width;
                            paletteItem.paletteItem.previewHeight = height;
                        }
                    }
                    else {
                        width = width ? width : bounds.width;
                        height = height ? height : bounds.height;
                    }
                }
                else {
                    if (paletteItem.paletteItem) {
                        width = paletteItem.paletteItem.previewWidth ? paletteItem.paletteItem.previewWidth : width;
                        height = paletteItem.paletteItem.previewHeight ? paletteItem.paletteItem.previewHeight : height;
                        width = width ? width : paletteItem.width;
                        height = height ? height : paletteItem.height;
                        paletteItem.paletteItem.previewWidth = width;
                        paletteItem.paletteItem.previewHeight = height;
                    }
                    else {
                        var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                        width = bounds.width ? bounds.width : width;
                        height = bounds.height ? bounds.height : height;
                    }
                }
            }
            else {
                var dec, size, bounds;
                bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                if (paletteItem.paletteItem) {
                    width = paletteItem.paletteItem.previewWidth ? paletteItem.paletteItem.previewWidth : width;
                    height = paletteItem.paletteItem.previewHeight ? paletteItem.paletteItem.previewHeight : height;
                    width = width ? width : paletteItem.width;
                    height = height ? height : paletteItem.height;
                    width = width ? width : bounds.width;
                    height = height ? height : bounds.height;
                    paletteItem.paletteItem.previewWidth = width;
                    paletteItem.paletteItem.previewHeight = height;
                }
                else {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(paletteItem);
                    width = width ? width : bounds.width;
                    height = height ? height : bounds.height;
                }
            }
            return { width: width, height: height };
        },
        _renderItemContainer: function (id, content, isDrag, itemSize, item) {
            var container = document.createElement("div");
            var height = this.model.showPaletteItemText ? itemSize.height + 18 : itemSize.height;
            var width = itemSize.width;
            var mLeft = (item && item.paletteItem) ? item.paletteItem.margin.left : 4;
            var mTop = (item && item.paletteItem) ? item.paletteItem.margin.top : 4;
            var mRight = (item && item.paletteItem) ? item.paletteItem.margin.right : 4;
            var mBottom = (item && item.paletteItem) ? item.paletteItem.margin.bottom : 4;
            var attr = {
                "id": id + "_paletteItem", "draggable": "true", "height": height + "px", "width": width + "px", "class": "e-paletteItem",
                "style": "padding-left:" + mLeft + "px;padding-right:" + (mRight + 2) + "px;padding-top:" + (mTop + 1) + "px;padding-bottom:" + (mBottom + 1) + "px;height:" + (height + 1) + "px;width:" + (width + 1) +
                          "px;-ms-touch-action: none;touch-action: none;"
            };
            ej.datavisualization.Diagram.Util.attr(container, attr);
            content.appendChild(container);
            if (this.model.allowDrag)
                this._setItemDraggable(container);
            return this._renderAnchor(container, id, itemSize, item);
        },
        _renderAnchor: function (container, id, itemSize, item) {
            var anchor = document.createElement("div");
            var attr = {
                "id": id + "_anchor", "height": itemSize.height + "px", "class": "e-anchor"
            };
            ej.datavisualization.Diagram.Util.attr(anchor, attr);
            container.appendChild(anchor);
            var svg = this._renderSvg(anchor, id, itemSize);
            this._renderText(anchor, id, itemSize, item);
            return svg;
        },
        _renderSvg: function (anchor, id, itemSize) {
            var parent;
            var wrapper = document.createElement("div");
            var attr = {
                "id": id + "_svgWrapper", "width": this.model.paletteItemWidth + "px;",
                "height": +this.model.paletteItemHeight + "px;", "class": "e-svg-container",
                "style": "width:" + itemSize.width + "px;height:" + itemSize.height + "px;"
            };
            ej.datavisualization.Diagram.Util.attr(wrapper, attr);
            attr = {
                "id": id + "_svg", "width": itemSize.width, "height": itemSize.height,
                "version": "1.1", "xlink": "http://www.w3.org/1999/xlink"
            };
            var svg = new ej.datavisualization.Diagram.Svg(attr);
            wrapper.appendChild(svg.document);
            if (anchor.id.split("_clone").length > 1)
                parent = $(anchor).parents(".e-paletteItem")[0];
            this._renderHtmlLayer(wrapper, parent);
            anchor.appendChild(wrapper);
            return svg;
        },
        _renderText: function (anchor, text, itemSize, item) {
            var div = document.createElement("div");
            div.setAttribute("class", "e-text-container");
            div.setAttribute("style", "width:" + itemSize.width + "px; text-align : center;overflow: hidden;text-overflow: ellipsis;font-size: 12px;");
            var span = document.createElement("span");
            span.setAttribute("class", "e-paletteItemText");
            if (item && item.paletteItem)
                text = item.paletteItem.label ? item.paletteItem.label : text;
            if (text.split("_clone").length > 1)
                span.innerHTML = text.split("_clone")[0];
            else
                span.innerHTML = text;
            if (item && item.paletteItem.wrapping == ej.datavisualization.Diagram.TextWrapping.NoWrap) {
                span.style.whiteSpace = "nowrap";
                span.style.wordWrap = "normal";
            }
            if (item && item.paletteItem.wrapping == ej.datavisualization.Diagram.TextWrapping.Wrap) {
                span.style.whiteSpace = "pre-wrap";
                span.style.wordBreak = "break-all";
                span.style.wordWrap = "break-word";
            }
            if (item && item.paletteItem.wrapping == ej.datavisualization.Diagram.TextWrapping.WrapWithOverflow) {
                span.style.whiteSpace = "pre-wrap";
                span.style.wordWrap = "break-word";
            }
            div.appendChild(span);
            if (!this.model.showPaletteItemText)
                div.style.display = "none";
            anchor.appendChild(div);
            if (item && !item.paletteItem.enableScale) {
                var element = document.getElementById(item.name + "_paletteItem");
                var bounds = document.getElementById(item.name + "_anchor").lastChild.getBoundingClientRect();
                element.style.height = itemSize.height + bounds.height + "px";
            }
        },
        _renderNode: function (node, svg, scaleSize, palette) {
            this._renderPetternDefinition(svg.id + "_" + node.name, svg);
            var group = ej.datavisualization.Diagram.SvgContext.renderNode(node, svg, null, true, this);
            var isDrag = false;
            if (svg.document.getAttribute("drag") != null) {
                isDrag = true;
            }
            this._transformItem(group, node.width, node.height, node, isDrag, scaleSize);
        },
        _updateChildBounds: function (node, nameTable) {
            var child = null;
            if (node._type == "group") {
                var children = this._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = nameTable[children[i]];
                    if (child.shape == "group")
                        this._updateChildBounds(child, nameTable);
                }
                ej.datavisualization.Diagram.Util._updateChildBounds(node, this);
            }
        },
        _getChild: function (child) {
            return ej.datavisualization.Diagram.Util.getChild(child);
        },
        _getChildren: function (children) {
            if (children) {
                var children1 = [];
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child) {
                        if (typeof (child) == "object") {
                            children1.push(child.name);
                        }
                        else if (typeof (child) == "string") {
                            children1.push(child);
                        }
                    }
                }
                return children1;
            }
        },
        _renderGroup: function (node, svg, itemSize, nameTable) {
            this._renderPetternDefinition(svg.id + "_" + node.name, svg);
            if (!nameTable) nameTable = this.nameTable;
            if (!node.container || node.isLane) this._updateChildBounds(node, nameTable);
            var group = ej.datavisualization.Diagram.SvgContext.renderGroup(node, svg, null, nameTable, this, false, true);
            var isDrag = false;
            if (svg.document.getAttribute("drag") != null) {
                isDrag = true;
            }
            this._transformItem(group, node.width, node.height, node, isDrag, itemSize);

        },
        _renderConnector: function (connector, svg, itemSize) {
            var group = ej.datavisualization.Diagram.SvgContext.renderConnector(connector, svg, null, this);
            var bounds = ej.datavisualization.Diagram.Util.bounds(connector);
            var isDrag = false;
            if (svg.document.getAttribute("drag") != null) {
                isDrag = true;
            }
            this._transformItem(group, bounds.width, bounds.height, connector, isDrag, itemSize);
        },
        //#endregion
        //#region Events
        _wireEvents: function () {
            this._on(this.element, ej.eventType.click, ".e-header", this._headerClick);
            this._on(this.element, ej.eventType.mouseDown, ".e-header", this._headerMouseDown);
            this._on(this.element, "mouseover", ".e-header", this._headerMouseOver);
            this._on(this.element, "mouseout", ".e-header", this._headerMouseOut);
            this._on(this.element, ej.eventType.mouseDown, ".e-paletteItem", this._itemMouseDown);
            this._on(this.element, "mouseover", ".e-paletteItem", this._itemMouseOver);
            this._on(this.element, "mouseout", ".e-paletteItem", this._itemMouseOut);
            this._on(this.element, ej.eventType.click, ".e-anchor", this._itemClick);
        },
        _headerClick: function (evt) {
            this._expandOrCollapsePalette("", evt.currentTarget);
            var palette = this._getActivePalette(evt.currentTarget.id);
            if (palette && palette !== this.activePalette)
                this.activePalette = palette;
        },
        _headerMouseDown: function (evt) {
            evt.preventDefault();
            evt.stopPropagation();
        },
        _headerMouseOver: function (evt) {
            var palette = this._getActivePalette(evt.currentTarget.id);
            if (palette && this._canExpand(palette)) {
                $(evt.currentTarget).addClass("hover");
                $(evt.currentTarget).find(".e-header-arrow").addClass("hover");
            }
        },
        _headerMouseOut: function (evt) {
            $(evt.currentTarget).removeClass("hover");
            $(evt.currentTarget).find(".e-header-arrow").removeClass("hover");
        },
        _itemMouseDown: function (evt) {
            if (this.model.diagramId) {
                var diagram = $("#" + this.model.diagramId).ejDiagram("instance");
                if (diagram.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                    diagram.activeTool._showAllPorts(true);
                    diagram.deactivateTool();
                }
            }
            if (!this.model.allowDrag) {
                evt.preventDefault();
                evt.stopPropagation();
            }
            if (this._selectedElement) {
                if (this._selectedElement !== evt.currentTarget) {
                    $(this._selectedElement).removeClass("selected");
                    this._selectedElement = evt.currentTarget;
                }
            }
            else
                this._selectedElement = evt.currentTarget;
            if (!($(evt.currentTarget).hasClass("selected")))
                $(evt.currentTarget).addClass("selected");

            var palette = this._getActivePalette(evt.currentTarget.parentElement.id);
            if (palette && palette !== this.activePalette) {
                this._clearHeaderSelection();
                this._updateHeaderSelection($(evt.currentTarget.parentElement).prev());
                this.activePalette = palette;
            }

            if (this.activePalette && this._selectedElement) {
                var name = this._selectedElement.id.slice(0, this._selectedElement.id.lastIndexOf('_'));
                var items = this.activePalette.items;
                for (var i = 0, len = items.length; i < len; i++) {
                    var item = items[i];
                    if (item.name === name)
                        this.selectedItem = item;
                }
            }
        },
        _itemMouseOver: function (evt) {
            $(evt.currentTarget).addClass("hover");
        },
        _itemMouseOut: function (evt) {
            $(evt.currentTarget).removeClass("hover");
        },
        _itemDraStart: function (evt) {
            var dataTransfer = evt.originalEvent.dataTransfer;
            dataTransfer.setData("Text", this.element[0].id);
            dataTransfer.effectAllowed = "copy";
        },
        _itemClick: function (evt) {
            if (evt.type === "click" || (evt.type === "touchend" && !$(".dragClone")[0])) {
                if (this.model.diagramId) {
                    var diagram = $("#" + this.model.diagramId).ejDiagram("instance");
                    var item = $.extend(true, {}, this.selectedItem);
                    item.name += ej.datavisualization.Diagram.Util.randomId();
                    if (item.type == "bpmn") item.children = [];
                    var type = diagram.getObjectType(item);
                    var swimlane;
                    if (type == "group") {
                        var children = this._getChildren(item.children);
                        for (var j = 0; j < children.length; j++) {
                            var newObj = $.extend(true, {}, this.nameTable[children[j]]);
                            newObj.parent = item.name;
                            newObj.name = item.name + newObj.name;
                            item.children[j] = newObj.name;
                            diagram.nameTable[newObj.name] = newObj;
                            diagram.nodes().push(newObj);
                            diagram._nodes = $.extend(true, [], diagram.nodes());
                            if (diagram.nameTable[newObj])
                                diagram._updateQuad(diagram.nameTable[newObj]);
                        }
                        if (!item.isLane) {
                            item.height = item.width = 0;
                            diagram._updateChildBounds(item, diagram.nameTable);
                        }
                    }
                    if (item) {
                        if (item.isLane) {
                            var randomId = ej.datavisualization.Diagram.Util.randomId();
                            diagram._cloneGroupNode(item, randomId);
                            var obj = ej.datavisualization.Diagram.SwimLaneHelper._createDiagramLane(item, diagram.nameTable);
                            obj.isLane = item.isLane;
                            obj.orientation = item.orientation;
                            obj.height = 120;
                            obj = ej.datavisualization.Diagram.Lane(obj);
                            var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(obj, diagram, null, true);
                            if (swimlane) {
                                swimlane.offsetX += 10;
                                swimlane.offsetY += 40;
                            }
                        }
                    }
                    var oldElement = $.extend(true, {}, this._oldItem);
                    var newElement = swimlane ? swimlane : item;
                    this._oldItem = $.extend(true, {}, newElement);
                    var args = { oldElement: oldElement, newElement: newElement };
                    this._trigger("selectionChange", args);
                }
            }
        },
        _updatePaletteVisibility: function (palette) {
            if (this._canHeaderVisible(palette)) {
                if (this._canPaletteVisible(palette)) {
                    this._getPaletteHeaderDiv(palette.name).style.display = "";
                    this._getPaletteContentDiv(palette.name).style.display = "";
                }
                else {
                    this._getPaletteHeaderDiv(palette.name).style.display = "none"
                    this._getPaletteContentDiv(palette.name).style.display = "none"
                }
            }
        },
        _collectionChanged: function (args) {
            if (args.changeType == "insert") {
                this._renderPalette(args.element);
            }
            else if (args.changeType == "remove") {
                var palette = args.element;
                if (palette != null) {
                    var paletteHeader = this._getPaletteHeaderDiv(palette.name);
                    if (paletteHeader)
                        paletteHeader.parentNode.removeChild(paletteHeader);
                    var paletteContent = this._getPaletteContentDiv(palette.name);
                    if (paletteContent)
                        paletteContent.parentNode.removeChild(paletteContent);
                }
            }
        },
        //#endregion
        //#region Public methods
        _extendPaletteItem : function (item) {
            var nodeDefault = (this.model.defaultSettings && this.model.defaultSettings.node) ? this.model.defaultSettings.node : null;
            var connectorDefault = (this.model.defaultSettings && this.model.defaultSettings.connector) ? this.model.defaultSettings.connector : null;
            if (item.shape && typeof item.shape == "object")
                ej.datavisualization.Diagram.Util._updateShapeProperties(item);
            else item = ej.datavisualization.Diagram.NodeType(item, this);
            if (item.type == "connector")
                item = ej.datavisualization.Diagram.Connector($.extend(true, {}, connectorDefault, item));
            else {
                if (item.isLane)
                    item = ej.datavisualization.Diagram.SwimLaneHelper._createPaletteLane(item, this.nameTable);
                else if (item.type == "phase")
                    item = ej.datavisualization.Diagram.Util._mapPalettePhase(item);
                else if (item.container)
                    item = ej.datavisualization.Diagram.ContainerHelper._initContainer(this, item);
                else if (item._type === "group" || (item.children && item.children.length > 0)) {
                    item = ej.datavisualization.Diagram.Group($.extend(true, {}, nodeDefault, item));
                    item = ej.datavisualization.Diagram.Util._updateBpmnChild(item, this);
                    this._getNewGroup(item);
                    this._initGroupNode(item, this);
                    ej.datavisualization.Diagram.Util._updateGroupBounds(item, this);
                }
                else
                    item = ej.datavisualization.Diagram.Node($.extend(true, {}, nodeDefault, item));
            }
            return item;
        },
        addPaletteItem: function (paletteName, items) {
            var content, palette;
            for (var i = 0; i < this.model.palettes.length; i++) {
                var items1 = [];
                if (!items.length)
                    items1.push(items);
                else
                    items1 = items;
                for (var j = 0; j < items1.length; j++) {
                    palette = this.model.palettes[i];
                    if (palette.name === paletteName) {
                        var node = this._extendPaletteItem (items1[j])
                        palette.items.push(node);
                        content = this._getPaletteContentDiv(paletteName);
                        this.nameTable[node.name] = node;
                        this._renderItem(node, content);
                    }
                }
            }
        },
        removePaletteItem: function (paletteName, items) {
            var content, palette;
            for (var i = 0; i < this.model.palettes.length; i++) {
                var items1 = [];
                if (!items.length)
                    items1.push(items);
                else
                    items1 = items;
                for (var j = 0; j < items1.length; j++) {
                    palette = this.model.palettes[i];
                    if (palette.name === paletteName) {
                        var item = items1[j];
                        ej.datavisualization.Diagram.Util.removeItem(palette.items, item);
                        delete this.nameTable[item.name];
                        if (item.children && item.children.length) {
                            for (var k = 0; k < item.children.length; k++) {
                                var child = item.children[k];
                                if (child) {
                                    if (typeof (child) == "object") {
                                        delete this.nameTable[child.name];
                                    } else {
                                        delete this.nameTable[child];
                                    }
                                }
                            }
                        }
                        content = this._getPaletteContentDiv(paletteName);
                        var node = $(content).find("#" + item.name + "_paletteItem")[0];
                        if (node) {
                            content.removeChild(node);
                            this.selectedItem = null;
                        }
                    }
                }
            }
        },
        expandPalette: function (paletteName) {
            var palette = this._findPalette(paletteName);
            if (palette && !palette.expanded) {
                if (this._canExpand(palette)) {
                    palette.expanded = true;
                    this._expandOrCollapsePalette(paletteName);
                }
            }
        },
        collapsePalette: function (paletteName) {
            var palette = this._findPalette(paletteName);
            if (palette && palette.expanded) {
                if (this._canExpand(palette)) {
                    palette.expanded = false;
                    this._expandOrCollapsePalette(paletteName);
                }
            }
        },
        addPalette: function (palette) {
            this.model.palettes.push(palette);
            this._renderPalette(palette);
        },
        removePalette: function (paletteName) {
            var paletteHeader, paletteContent, palette;
            for (var i = 0; i < this.model.palettes.length; i++) {
                palette = this.model.palettes[i];
                if (palette.name === paletteName) {
                    ej.datavisualization.Diagram.Util.removeItem(this.model.palettes, palette);
                    paletteHeader = this._getPaletteHeaderDiv(palette.name);
                    if (paletteHeader)
                        paletteHeader.parentNode.removeChild(paletteHeader);
                    paletteContent = this._getPaletteContentDiv(palette.name);
                    if (paletteContent)
                        paletteContent.parentNode.removeChild(paletteContent);
                }
            }
        },
        setWidth: function (value) {
            this.model.width = value;
            this._setWidth(value);
        },
        setHeight: function (value) {
            this.model.height = value;
            this._setHeight(value);
        },
        setPaletteItemWidth: function (value) {
            this.model.paletteItemWidth = value;
            this._redrawContent();
        },
        setPaletteItemHeight: function (value) {
            this.model.paletteItemHeight = value;
            this._redrawContent();
        },
        setHeaderHeight: function (value) {
            this.model.headerHeight = value;
            this._setHeaderHeight(value);
        },
        setCssClass: function (value) {
            this._setCssClass(value);
            this.model.cssClass = value;
        },
        showPaletteItemText: function (value) {
            this._showItemText(value);
            this.model.showPaletteItemText = value;
        },
        searchPalette: function (palette, key) {
            var paletteCollection = new ej.datavisualization.Diagram.Collection();
            var paletteItems = null;
            if (key != "") {
                palette = this._getSearchPaletteItems(key);
                paletteCollection.add(palette);
            }
            return paletteCollection;
        },
        updatePalette: function (paletteName, args) {
            var palette = this._findPalette(paletteName);
            if (palette && args) {
                if (args.constraints && (palette.constraints != args.constraints)) {
                    palette.constraints = args.constraints;
                    var header = this._getPaletteHeaderDiv(palette.name);
                    this._renderHeaderArrow(header, palette.expanded, palette.name, this._canExpand(palette));
                    this._disableClickClass(header, this._canExpand(palette));
                    this._updatePaletteVisibility(palette);
                    if (this._canHeaderVisible(palette) && this._canPaletteVisible(palette))
                        header.style.display = "";
                    else
                        header.style.display = "none";

                }
                if (args.expanded != undefined) {
                    if (this._canExpand(palette)) {
                        palette.expanded = args.expanded;
                        this._expandOrCollapsePalette(paletteName);
                    }
                }
                if (args.items && args.items.length > 0) {
                    var paletteContent = this._getPaletteContentDiv(palette.name);
                    paletteContent.innerHTML = "";
                    palette.items = args.items;
                    this._initPaletteitems(palette);
                    this._renderContent(palette);
                }

            }
            this.updateScrollerViewport();
        },
        //#endregion
        //#region Helper methods
        _findPalette: function (paletteName) {
            var palette;
            for (var i = 0; i < this.model.palettes.length; i++) {
                if (this.model.palettes[i].name == paletteName || this.model.palettes[i].name == paletteName.replace(/\_/gi, " ")) {
                    palette = this.model.palettes[i];
                    break;
                }
            }
            return palette;
        },
        _canExpand: function (palette) {
            return palette.constraints & ej.datavisualization.Diagram.PaletteConstraints.Expandable;
        },
        _canHeaderVisible: function (palette) {
            return palette.constraints & ej.datavisualization.Diagram.PaletteConstraints.HeaderVisibility;
        },
        _canPaletteVisible: function (palette) {
            return palette.constraints & ej.datavisualization.Diagram.PaletteConstraints.Visible;
        },

        _canClick: function (header) {
            if (header) {
                var paletteName = (header.id).split("_header")[0];
                if (paletteName) {
                    var palette = this._findPalette(paletteName);
                    if (this._canExpand(palette)) {
                        return true;
                    }
                }
            }
        },
        _expandOrCollapsePalette: function (paletteName, header) {
            var header = header || (paletteName ? this._getPaletteHeaderDiv(paletteName) : null);
            if (header) {
                if (this._canClick(header)) {
                    var proxy = this;
                    $(header).next(".e-scontent").slideToggle(200, function () {
                        proxy._refresh();
                    });
                    this._updateHeaderState(header);
                }
                else return false;
            }
        },
        _getSearchPaletteItems: function (key) {
            var palette = new ej.datavisualization.Diagram.Palette();
            var palettes = this.model.palettes, i, j;
            for (i = 0; i < palettes.length; i++) {
                if ((((palettes[i].name).toLocaleLowerCase()).search(key.toLocaleLowerCase())) >= 0) {
                    for (j = 0; j < palettes[i].items.length; j++) {
                        this.element.find("#" + palettes[i].items[j].name + "_paletteItem")[0].style.display = "block";
                    }
                }
                else {
                    for (j = 0; j < palettes[i].items.length; j++) {
                        if ((((palettes[i].items[j].name).toLocaleLowerCase()).search(key.toLocaleLowerCase())) >= 0) {
                            this.element.find("#" + palettes[i].items[j].name + "_paletteItem")[0].style.display = "block";
                        }
                        else
                            this.element.find("#" + palettes[i].items[j].name + "_paletteItem")[0].style.display = "none";
                    }
                }
            }
            return palette;
        },
        _disableClickClass: function (element, disable) {
            if (disable)
                $(element).removeClass("e-disableclick");
            else
                $(element).addClass("e-disableclick");
        },
        _addExpandedClass: function (element, expanded) {
            if (expanded)
                $(element).addClass("expanded");
            else
                $(element).addClass("collapsed");
        },
        _collapse: function (palette) {
            if (!palette.expanded)
                $(this._getPaletteHeaderDiv(palette.name)).next(".e-scontent").slideToggle(10);

        },
        _transformItem: function (group, width, height, node, isDrag, scaleSize) {
            if (!isDrag) {
                if (scaleSize && !node.segments && node.paletteItem && node.paletteItem.width && node.paletteItem.height && node.paletteItem.enableScale) {
                    var fx = (30 * scaleSize.width) / 100;
                    var fy = (30 * scaleSize.height) / 100;
                    var sx = (scaleSize.width - fx) / node.width;
                    var sy = (scaleSize.height - fy) / node.height;
                    sx = sy = Math.min(sx, sy);
                    sx = sx > 1 ? 1 : sx;
                    sy = sy > 1 ? 1 : sy;
                    var translate1 = ((scaleSize.width) / 2 - (width * sx) / 2);
                    var translate2 = ((scaleSize.height) / 2 - (height * sy) / 2);
                    var transform = "";
                    //translate
                    transform += "translate(" + translate1 + "," + translate2 + ")";
                    //scale
                    transform += "scale(" + sx + "," + sy + ")";
                    group.setAttribute("transform", transform);
                    var htmlLayer = group.parentNode.nextSibling;
                    if (!htmlLayer) htmlLayer = document.getElementById(group.id + "_svgWrapper_htmlLayer");
                    htmlLayer.style.webkitTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                    htmlLayer.style.MozTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                    htmlLayer.style.OTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                    htmlLayer.style.msTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                    htmlLayer.style.transform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                    if (node && ej.browserInfo().name === "msie") {
                        if (node._type == "group" && node.type === "html") {
                            var htmlDiv = document.getElementById(node.name + "_html");
                            htmlDiv.setAttribute("style", "zoom:" + scale + ";");
                        }
                    }
                }
                else if (!node.segments) {
                    var xd = width / (width + (node.borderWidth * 3));
                    var yd = height / (height + (node.borderWidth * 3));
                    var x = (width - (width * xd)) / 2;
                    var y = (height - (height * yd)) / 2;
                    group.childNodes[0].setAttribute("transform", "scale(" + xd + "," + yd + ") translate(" + x + "," + y + ")");
                    if (node && node.type === "image" && group.childNodes[1]) {
                        group.childNodes[1].setAttribute("transform", "scale(" + xd + "," + yd + ") translate(" + x + "," + y + ")");
                    }
                    else if (node && node._type === "group") {
                        group.setAttribute("transform", "scale(" + xd + "," + yd + ") translate(" + x + "," + y + ")");
                    }
                }
                else {
                    if (scaleSize && node.paletteItem && node.paletteItem.width && node.paletteItem.height || (node.isPhase && node.paletteItem && node.paletteItem.enableScale)) {
                        var fx = (10 * scaleSize.width) / 100;
                        var fy = (10 * scaleSize.height) / 100;
                        var sx = (scaleSize.width - fx) / width;
                        var sy = (scaleSize.height - fy) / height;
                        sx = sy = Math.min(sx, sy);
                        sx = sx > 1 ? 1 : sx;
                        sy = sy > 1 ? 1 : sy;
                        var translate1 = ((scaleSize.width) / 2 - (width * sx) / 2);
                        var translate2 = ((scaleSize.height) / 2 - (height * sy) / 2);
                        var transform = "";
                        //translate
                        transform += "translate(" + translate1 + "," + translate2 + ")";
                        //scale
                        transform += "scale(" + sx + "," + sy + ")";
                        group.setAttribute("transform", transform);
                        var htmlLayer = document.getElementById(group.id + "_svgWrapper_htmlLayer");
                        htmlLayer.style.webkitTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                        htmlLayer.style.MozTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                        htmlLayer.style.OTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                        htmlLayer.style.msTransform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                        htmlLayer.style.transform = "translate(" + translate1 + "px," + translate2 + "px) scale(" + sx + ", " + sy + ")";
                        if (node && ej.browserInfo().name === "msie") {
                            if (node._type == "group" && node.type === "html") {
                                var htmlDiv = document.getElementById(node.name + "_html");
                                htmlDiv.setAttribute("style", "zoom:" + scale + ";");
                            }
                        }
                    }
                }
            }
        },
        _getScaleFactor: function (width, height) {
            var fx = (30 * this.model.paletteItemWidth) / 100;
            var fy = (30 * this.model.paletteItemHeight) / 100;
            var sx = (this.model.paletteItemWidth - fx) / width;
            var sy = (this.model.paletteItemHeight - fy) / height;
            sx = sx > 1 ? 1 : sx;
            sy = sy > 1 ? 1 : sy;
            return Math.min(sx, sy);
        },
        _getTranslateFactor: function (width, height) {
            var x = (15 / 100) * this.model.paletteItemWidth;
            var y = (15 / 100) * this.model.paletteItemHeight;
            return Math.min(x, y);
        },
        _setWidth: function (val) {
            this.element.css("width", val);
        },
        _setHeight: function (val) {
            this.element.css("height", val);
        },
        _setHeaderHeight: function (val) {
            this.element.find(".e-header").css("height", val);
            this.element.find(".e-header-arrow").css("top", (val - 16) / 2);
            for (var i = 0; i < this.model.palettes.length; i++) {
                var palette = this.model.palettes[i];
                if (palette) {
                    this._updateHeaderWrapper(palette, val);
                }
            }
            this.updateScrollerViewport();
        },
        _updateHeaderWrapper: function (palette, val) {
            var paletteWrapper = document.getElementById(palette.name + "_Wrapper");
            if (paletteWrapper) {
                var bounds = paletteWrapper.getBoundingClientRect();
                if (bounds.height > 0)
                    paletteWrapper.style.marginTop = val / 2 - bounds.height / 2 + "px";
            }
        },
        _setCssClass: function (val) {
            this.element.removeClass(this.model.cssClass).addClass(val);
        },
        _showItemText: function (val) {
            if (val !== this.model.showPaletteItemText)
                if (val) {
                    this.element.find(".e-text-container").show();
                }
                else
                    this.element.find(".e-text-container").hide();
        },
        _setAllowDrag: function (val) {
            this.model.allowDrag = val;
            var palettes = this.model.palettes;
            var container;
            if (palettes) {
                for (var i = 0; i < palettes.length; i++) {
                    var paletteItems = palettes[i].items;
                    if (paletteItems) {
                        for (var j = 0; j < paletteItems.length; j++) {
                            container = document.getElementById(paletteItems[j].name + "_paletteItem");
                            if (this.model.allowDrag)
                                this._setItemDraggable(container);
                            else
                                $(container).ejDraggable("instance").destroy();
                        }
                    }
                }
            }
        },
        _cloneNode: function (node) {
            var id = ej.datavisualization.Diagram.Util.randomId(), obj;
            if (node.children && node.children.length > 0) {
                for (var i = 0; i < node.children.length; i++) {
                    obj = this._cloneChildren(node.children[i], id);
                    this.nameTable[obj.name] = obj;
                    node.children[i] = obj.name;
                }
            }
            node.name += id;
            return node;
        },
        _cloneChildren: function (child, id) {
            if (typeof (child) === "object") {
                obj = $.extend(true, {}, child);
                obj.parent += id;
                obj.name += id;
                return obj;
            }
            else if (typeof (child) === "string") {
                var obj = this.nameTable[child];
                if (obj) {
                    obj = this._cloneChildren(obj, id);
                    return obj;
                }
            }
        },
        _setItemDraggable: function (container) {
            var paletteId = this.element[0].id;
            var context = this;
            $(container).ejDraggable({
                clone: true,
                cursorAt: { top: context.model.previewOffset.y, left: context.model.previewOffset.x },
                helper: function (event) {
                    var diagram = $("#" + context.model.diagramId).ejDiagram("instance");
                    var paletteItemWidth, paletteItemHeight;
                    paletteItemWidth = context.model.paletteItemWidth;
                    paletteItemHeight = context.model.paletteItemHeight;
                    diagram._selectedSymbol = context.selectedItem;
                    diagram._symbolPalette = context.model;
                    var item = $.extend(true, {}, context.selectedItem);
                    //if (item.type != "bpmn")
                    item = context._cloneNode(item);
                    if (item.isLane) {
                        context.model.paletteItemWidth = (item.paletteItem && item.paletteItem.previewWidth) ? item.paletteItem.previewWidth : context.model.previewWidth;
                        context.model.paletteItemHeight = (item.paletteItem && item.paletteItem.previewHeight) ? item.paletteItem.previewHeight : context.model.previewHeight;
                    }
                    var previewSize = context._getPreviewItemSize(context.selectedItem);
                    var svg = context._renderItemContainer(context.selectedItem.name + "_clone", document.body, true, previewSize);
                    svg.document.setAttribute("drag", "true");
                    diagram._paletteTable = context.nameTable;
                    diagram._palNameTable = $.extend(true, {}, context.nameTable);
                    if (item.segments) {
                        var bounds = ej.datavisualization.Diagram.Util.bounds(item);
                        var delWidth = (previewSize.width - 10) / bounds.width;
                        var delHeight = (previewSize.height - 10) / bounds.height;
                        ej.datavisualization.Diagram.Util.scale(item, delWidth, delHeight, bounds.topLeft, diagram.nameTable);
                        context._renderConnector(item, svg, previewSize);
                    }
                    else {
                        if ((item.isLane && item.paletteItem && !item.paletteItem.enableScale)) {
                            item.width = previewSize.width;
                            item.height = previewSize.height;
                            item.offsetX = item.width / 2;
                            item.offsetY = item.height / 2;
                        }
                        else if (item._type == "group") {
                            var nameTable = []
                            var deltaWidth = previewSize.width / item.width;
                            var deltaHeight = previewSize.height / item.height;
                            context.scale(item, deltaWidth, deltaHeight, item.pivot, context.nameTable, null, null, null, context);
                            ej.datavisualization.Diagram.Util._translate(item, item.width / 2 - item.offsetX, item.height / 2 - item.offsetY, context.nameTable, null, context);
                        }
                        else {
                            item.width = previewSize.width - 10;
                            item.height = previewSize.height - 10;
                            if (previewSize) {
                                previewSize.width = previewSize.width - 10;
                                previewSize.height = previewSize.height - 10;
                            }
                            item.offsetX = item.width / 2 + 10;
                            item.offsetY = item.height / 2 + 1;
                        }
                        context._updatePreviewSize(item, previewSize);
                        if (item._type == "node")
                            context._renderNode(item, svg, previewSize);
                        else {
                            context._renderGroup(item, svg);
                        }
                    }
                    var helper = document.getElementById(context.selectedItem.name + "_clone_paletteItem");
                    $(helper).addClass("dragClone");
                    context.model.paletteItemWidth = paletteItemWidth;
                    context.model.paletteItemHeight = paletteItemHeight;
                    return $(helper);
                },
                drag: function () {
                    var element = this.helper[0];
                    $("#" + context.selectedItem.name + "_clone_svg").css("padding", "2px");
                    $("#" + context.selectedItem.name + "_clone_svg").siblings(".htmlLayer").css("padding", "2px");
                    if (element) {
                        element.setAttribute("paletteId", paletteId);
                    }
                },
                dragStop: function (event, ui) {
                    var isTouch = false;
                    if (event.event && event.event.originalEvent && event.event.originalEvent.changedTouches) {
                        isTouch = true;
                    }
                    else if (event.event && event.event.changedTouches) {
                        isTouch = true;
                    }
                    var diagram = $("#" + context.model.diagramId).ejDiagram("instance");
                    if (isTouch && diagram._isDropOver) {
                        diagram._svgdrop(event.event, this);
                        diagram._isDropped = true;
                    }
                    diagram._selectedSymbol = null;
                    $(this.helper).remove();
                }
            });
        },
        _redrawContent: function () {
            var contents = this.element.find(".e-scontent");
            for (var i = 0, len = contents.length; i < len; ++i) {
                var content = contents[i];
                $(content).empty();
                var palette = this.model.palettes[i];
                var paletteItems = palette.items;
                if (paletteItems && paletteItems.length > 0) {
                    for (var count = 0, l = paletteItems.length; count < l; count++) {
                        this._renderItem(paletteItems[count], content);
                    }
                }
            }
        },
        _getPalette: function (name) {
            var palettes = this.model.palettes;
            for (var i = 0, len = palettes.length; i < len; i++) {
                var palette = palettes[i];
                if ((palette.name === name || palette.name === name.replace(/\_/gi, " ")) && palette !== this.activePalette)
                    return palette;
            }
            return null;
        },
        _getActivePalette: function (elementId) {
            var name = elementId.slice(0, elementId.lastIndexOf('_'));
            return this._getPalette(name);;
        },
        _updateHeaderState: function (target) {
            this._clearHeaderSelection();
            this._updateExpandState(target);
            this._updateHeaderSelection(target);
        },
        _updateExpandState: function (target) {
            if (($(target).hasClass("expanded"))) {
                $(target).removeClass("expanded").addClass("collapsed");
                $(target).find(".e-header-arrow").removeClass("expanded").addClass("collapsed");
                $(target).attr("aria-expanded", "false");
                $(target).attr("aria-selected", "false");
            }
            else {
                $(target).removeClass("collapsed").addClass("expanded");
                $(target).find(".e-header-arrow").removeClass("collapsed").addClass("expanded");
                $(target).attr("aria-selected", "true");
                $(target).attr("aria-expanded", "true");
            }
        },
        _updateHeaderSelection: function (target) {
            if (!($(target).hasClass("selected"))) {
                $(target).addClass("selected");
                $(target).find(".e-header-arrow").addClass("selected");
            }
        },
        _clearHeaderSelection: function () {
            this.element.find(".e-header").removeClass("selected");
            this.element.find(".e-header-arrow").removeClass("selected");
        },
        _addItem: function (palette, item) {
            var content = this._getPaletteContentDiv(palette.name);
            this._renderItem(item, content);
        },
        _removeItem: function (palette, item) {
            var content = this._getPaletteContentDiv(palette.name);
            content.removeChild(document.getElementById(item.name + "_paletteItem"));
            if (item === this._selectedElement)
                this._selectedElement = null;
        },
        updateScrollerViewport: function () {
            var scroller = this.element.ejScroller("instance");
            scroller.model.touchScroll = false;
            scroller.model.width = this._setViewPortWidth();
            scroller.model.height = this._setViewPortHeight();
            this._refresh();
        },
        _refresh: function () {
            this.element.ejScroller("refresh");
        },
        _getNodeDimension: function (node) {
            var prevWidth = node._width, prevHeight = node._height;
            var width = node.width ? node.width : (node.maxWidth ? node.maxWidth : node.minWidth);
            var text = document.createElement("span");
            var w = 0, h = 0, label, i;
            if (node.labels.length) {
                ej.datavisualization.Diagram.Util.attr(text, { "id": node.name + "_label", "class": "ej-d-label", "style": "display: inline-block; position: absolute; pointer-events: all; line-height: normal;" });
                this.element[0].appendChild(text);
                for (i = 0; i < node.labels.length; i++) {
                    label = node.labels[i];
                    if (label.bold) text.style.fontWeight = "bold";
                    if (label.italic) text.style.fontStyle = "italic";
                    text.style.textDecoration = label.textDecoration;
                    text.style.fontFamily = label.fontFamily;
                    text.style.fontSize = label.fontSize + "px";
                    text.style.color = label.fontColor;
                    text.style.backgroundColor = label.fillColor;
                    text.style.borderColor = label.borderColor;
                    text.style.borderWidth = label.borderWidth;
                    text.textContent = label.text;
                    text.style.wordWrap = "break-word";
                    text.style.whiteSpace = "pre";
                    if (width) text.style.maxWidth = width - (label.margin.left + label.margin.right) - label.fontSize + "px";
                    w += text.offsetWidth + label.margin.left + label.margin.right;
                    h += text.offsetHeight + label.margin.top + label.margin.bottom;
                }
                node._width = w;
                node._height = h;
                if (node.minWidth && (node.minWidth > node._width || !node._width)) node._width = node.minWidth;
                if (node.maxWidth && (node.maxWidth < node._width || !node._width)) node._width = node.maxWidth;
                if (node.minHeight && (node.minHeight > node._height || !node._height)) node._height = node.minHeight;
                if (node.maxHeight && (node.maxHeight < node._height || !node._height)) node._height = node.maxHeight;
                if (!node.width && node.labels[0].horizontalAlignment == "left") node.offsetX += (node._width - prevWidth) * (1 - node.pivot.x);
                if (!node.width && node.labels[0].horizontalAlignment == "right") node.offsetX -= (node._width - prevWidth) * node.pivot.x;
                if (!node.height && node.labels[0].verticalAlignment == "top") node.offsetY += (node._height - prevHeight) * (1 - node.pivot.y);
                if (!node.height && node.labels[0].verticalAlignment == "bottom") node.offsetY -= (node._height - prevHeight) * node.pivot.y;
                this.element[0].removeChild(text);
            }
        },
        _getNewNode: function (options) {
            if (options.shape && typeof options.shape === "object")
                ej.datavisualization.Diagram.Util._updateShapeProperties(options);
            return ej.datavisualization.Diagram.Node($.extend(true, {}, this.model.defaultSettings.node, options));
        },
        _getNewGroup: function (options) {
            if (options.type == "bpmn") options = ej.datavisualization.Diagram.Util._updateBpmnChild(ej.datavisualization.Diagram.Node(options), this);
            if (options.children && options.children.length > 0) {
                for (var i = 0; i < options.children.length; i++) {
                    var child = options.children[i];
                    if (child) {
                        if (child.type === 'bpmn' || child.type === 'group') {
                            options.children[i] = this.nameTable[child.name] = this._getNewGroup(child)
                        }
                        else {
                            options.children[i] = this.nameTable[child.name] = this._getNewNode(child)
                        }
                    }
                }
            }
            return ej.datavisualization.Diagram.Group($.extend(true, {}, this.model.defaultSettings.group, options));
        },
        scale: function (node, sw, sh, pivot, nameTable, skipScalOnChild, updateMinMax, isHelper, diagram) {
            var matrix = ej.Matrix.identity();
            if (!node.segments) {
                if (node._type === "group") {
                    var nodes = node.children;
                    var child;
                    for (var i = 0; i < nodes.length; i++) {
                        child = nameTable[typeof nodes[i] == "string" ? nodes[i] : nodes[i].name];
                        if (child) {
                            this.scale(child, sw, sh, pivot, nameTable, undefined, undefined, undefined, diagram);
                            if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], diagram);
                        }
                    }
                    ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                }
                ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                var width = node.width * sw;
                var height = node.height * sh;
                if (width > 1) {
                    node.width = width;
                    node.offsetX = newPosition.x;
                }
                if (height > 1) {
                    node.height = height;
                    node.offsetY = newPosition.y;
                }
            } else {
                ej.Matrix.scale(matrix, sw, sh, pivot.x, pivot.y);
                for (var i = 0; i < node.segments.length; i++) {
                    var segment = node.segments[i];
                    for (var j = 0; j < segment.points.length; j++) {
                        segment.points[j] = ej.Matrix.transform(matrix, segment.points[j]);
                        if (i == 0 && j == 0 && !node.sourceNode) {
                            segment._startPoint = segment.points[0];
                            segment._endPoint = segment.points[segment.points.length - 1];
                            ej.datavisualization.Diagram.Util._setLineEndPoint(node, ej.Matrix.transform(matrix, node.sourcePoint), false);
                        }
                        if (i == node.segments.length - 1 && j == segment.points.length - 1 && !node.targetNode) {
                            segment._startPoint = segment.points[0];
                            segment._endPoint = segment.points[segment.points.length - 1];
                            node.targetPoint = segment._endPoint;
                        }
                    }
                    segment._startPoint = segment.points[0];
                    segment._endPoint = segment.points[segment.points.length - 1];
                    if (segment.type == "orthogonal") {
                        if (segment.length || segment.length === 0)
                            segment.length = segment._length = ej.datavisualization.Diagram.Geometry.distance(segment._startPoint, segment._endPoint);
                        else
                            ej.datavisualization.Diagram.Util._addOrthogonalPoints(segment, node.segments[i - 1], node.segments[i + 1], node.sourcePoint, node.targetPoint);
                    } else {
                        if (segment.point) {
                            segment.point = segment._endPoint;
                        }
                        segment._point = segment._endPoint;
                    }
                }
            }
        },
        _translate: function (node, dx, dy, nameTable, isContainer, diagram) {
            // if (ej.datavisualization.Diagram.Util.canMove(node))
            {
                if (!node.segments) {
                    node.offsetX += dx;
                    node.offsetY += dy;
                    if (node._type === "group" && !isContainer) {
                        var nodes = diagram._getChildren(node.children);
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = nameTable[nodes[i]];
                            this._translate(child, dx, dy, nameTable, null, diagram);
                            if (child.parent && (child.parent != node.name && node.type != "pseudoGroup"))
                                ej.datavisualization.Diagram.Util._updateGroupBounds(nameTable[child.parent], diagram);
                        }
                        if (node._type != "group" && node.container)
                            ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                    }
                } else {
                    ej.datavisualization.Diagram.Util._translateLine(node, dx, dy, node);
                }
            }
        },
        //#endregion
    });
    //#endregion
})(jQuery, Syncfusion);;


(function ($, ej) {
    "use strict";
    //#region Extends
    ej.datavisualization.Diagram.extend = function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        __.prototype = b.prototype;
        d.prototype = new __();
    }
    //#endregion

    //#region Tool
    var ToolBase = (function () {
        function ToolBase(name, diagram) {
            this.name = name;
            this.diagram = diagram;
            this.helper = null;
            this.inAction = false;
            this.selectedObject = null;
            this.startPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.currentPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.previousPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.cursor = "default";
            this._currentPossibleConnection = null;
            this._previousPossibleConnection = null;
            this._possibleConnectionPort = null;
            this.singleAction = false;
            this.svgHelper = null;
            this.single = null;
            this._centralPoint = ej.datavisualization.Diagram.Point(0, 0);
            this._enableAutoNode = null;
            this._prevTool = null;
            this.activeLabel = null;
            this._adjustLines = {
                lines: []
            }
        }
        ToolBase.prototype.abort = function (evt) {
            this._endAction();
            if (this.diagram.selectionList && this.diagram.selectionList[0])
                ej.datavisualization.Diagram.SvgContext.updateSelector(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom, this.diagram, this.diagram.model.selectedItems.constraints);
            this.diagram._removeTooltip();
        };
        ToolBase.prototype._snapTop = function (horizontalsnap, verticalsnap, delx, dely, shape, ended) {
            var dify = dely;
            verticalsnap.top = true;
            horizontalsnap.left = horizontalsnap.right = false;
            var snapSettings = this.diagram.model.snapSettings;
            var zoomFactor = this.diagram._currZoom;
            if (this.diagram._enableSnapToObject() && !shape.rotateAngle &&
                (!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
                var y = this.initialBounds.y - this.initialBounds.height * shape.pivot.y + dely - (shape.offsetY - shape.height * shape.pivot.y);
                ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, delx, y, this.selectedObject, ended);
            }
            if (!verticalsnap.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) {
                    var top = this.initialBounds.y - this.initialBounds.height * shape.pivot.y;
                    var actualTop = top + dely;
                    var roundedTop = ej.datavisualization.Diagram.SnapUtil._round(actualTop, ej.datavisualization.Diagram.SnapUtil._getSnapIntervals(this.diagram, false), zoomFactor);
                    dify = roundedTop - top;
                }
            }
            else {
                dify = (dely - y) + verticalsnap.offset;
            }
            return dify;
        };
        ToolBase.prototype._checkGroupChildren = function (collection, group, bounds) {
            var child, childBounds;
            var children = this.diagram._getChildren(group.children);
            for (var i = 0; i < children.length; i++) {
                child = this.diagram.nameTable[children[i]];
                if (child && ej.datavisualization.Diagram.Util.canSelect(child) && ej.datavisualization.Diagram.Util.enableLayerOption(child, "lock", this.diagram)) {
                    childBounds = ej.datavisualization.Diagram.Util.bounds(child);
                    if (ej.datavisualization.Diagram.Geometry.containsRect(bounds, childBounds) && collection.indexOf(child) < 0) {
                        collection.push(child);
                    }
                    else if (child._type === "group") {
                        this._checkGroupChildren(collection, child, bounds);
                    }
                }
            }
        }
        ToolBase.prototype._getSwimLaneStackIndex = function (node) {
            var index = null;
            if (node.container.type == "canvas") {
                if (node.parent)
                    var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    if (parent.container.orientation === "vertical") {
                        if (this.currentPoint.y >= bounds.y && this.currentPoint.y < bounds.center.y) {
                            index = this._getIndex(parent.children, node);
                        }
                        else {
                            index = this._getIndex(parent.children, node) + 1;
                        }
                    }
                    else {
                        if (this.currentPoint.x >= bounds.x && this.currentPoint.x < bounds.center.x) {
                            index = this._getIndex(parent.children, node);
                        }
                        else {
                            index = this._getIndex(parent.children, node) + 1;
                        }
                    }
                }
            }
            return index;
        };
        ToolBase.prototype._getIndex = function (list, node) {
            if (list && node) {
                var child = null;
                for (var i = 0; i < list.length; i++) {
                    child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                    if (child) {
                        if (child.name == node.name)
                            return i;
                    }
                }
            }
            else return -1;
        };
        ToolBase.prototype._snapLeft = function (horizontalsnap, verticalsnap, delx, dely, shape, ended) {
            var difx = delx;
            horizontalsnap.left = true;
            verticalsnap.top = verticalsnap.bottom = false;
            var snapSettings = this.diagram.model.snapSettings;
            var zoomFactor = this.diagram._currZoom;
            if (this.diagram._enableSnapToObject() && !shape.rotateAngle &&
                (!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
                var x = this.initialBounds.x - this.initialBounds.width * shape.pivot.x + delx - (shape.offsetX - shape.width * shape.pivot.x);
                ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, x, dely, this.selectedObject, ended);;
            }
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            if (!horizontalsnap.snapped) {
                if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines) {
                    var left = this.initialBounds.x - this.initialBounds.width * shape.pivot.x;
                    var actualLeft = left + delx;
                    var roundedLeft = ej.datavisualization.Diagram.SnapUtil._round(actualLeft, ej.datavisualization.Diagram.SnapUtil._getSnapIntervals(this.diagram, false), zoomFactor);
                    difx = roundedLeft - left;
                }
            }
            else {
                difx = (delx - x) + horizontalsnap.offset;
            }
            return difx;
        };
        ToolBase.prototype._snapBottom = function (horizontalsnap, verticalsnap, delx, dely, shape, ended, disableSnap) {
            var dify = dely;
            if (!this.diagram._disableSnap) {
                verticalsnap.bottom = true;
                horizontalsnap.left = horizontalsnap.right = false;
                var snapSettings = this.diagram.model.snapSettings;
                var zoomFactor = this.diagram._currZoom;
                if (this.diagram._enableSnapToObject() && !shape.rotateAngle &&
                       (!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
                    var y = this.initialBounds.y + this.initialBounds.height * (1 - shape.pivot.y) + dely - (shape.offsetY + shape.height * (1 - shape.pivot.y));
                    ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, delx, y, this.selectedObject, ended);;
                }
                var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
                if (!verticalsnap.snapped) {
                    if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) {
                        var bottom = this.initialBounds.y + this.initialBounds.height * (1 - shape.pivot.y);
                        var actualBottom = bottom + dely;
                        var roundedBottom = ej.datavisualization.Diagram.SnapUtil._round(actualBottom, ej.datavisualization.Diagram.SnapUtil._getSnapIntervals(this.diagram, false), zoomFactor);
                        dify = roundedBottom - bottom;
                    }
                }
                else {
                    dify = (dely - y) + verticalsnap.offset;
                }
            }
            return dify;
        };

        ToolBase.prototype._snapRight = function (horizontalsnap, verticalsnap, delx, dely, shape, ended, disableSnap) {
            var difx = delx;
            if (!this.diagram._disableSnap) {
                horizontalsnap.right = true;
                verticalsnap.top = verticalsnap.bottom = false;
                var snapSettings = this.diagram.model.snapSettings;
                var zoomFactor = this.diagram._currZoom;
                if (this.diagram._enableSnapToObject() && !shape.rotateAngle &&
                       (!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
                    var x = this.initialBounds.x + this.initialBounds.width * (1 - shape.pivot.x) + delx - (shape.offsetX + shape.width * (1 - shape.pivot.x));
                    ej.datavisualization.Diagram.SnapUtil._snapSize(this.diagram, horizontalsnap, verticalsnap, x, dely, this.selectedObject, ended);
                }
                if (!horizontalsnap.snapped) {
                    if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines) {
                        var right = this.initialBounds.x + this.initialBounds.width * (1 - shape.pivot.x);
                        var actualRight = right + delx;
                        var roundedRight = ej.datavisualization.Diagram.SnapUtil._round(actualRight, ej.datavisualization.Diagram.SnapUtil._getSnapIntervals(this.diagram, true), zoomFactor);
                        difx = roundedRight - right;
                    }
                }
                else {
                    difx = (delx - x) + horizontalsnap.offset;
                }
            }

            return difx;
        };

        ToolBase.prototype.keydown = function (evt) {
            var keycode = evt.keyCode ? evt.keyCode : evt.which;
            if (keycode === 27 && this.inAction) {

                if (this.diagram._selectedSymbol) {
                    this.diagram._documentmouseup(evt);
                    this._removeHighLighter();
                    ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
                    this.diagram._selectedSymbol = null;
                }
                else {
                    if (this.seletedObject || this.selectedObject) {
                        if (this.selectedObject) {
                            ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                            ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                        }
                        if (this.seletedObject) {
                            ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.seletedObject, this.diagram._svg, this.diagram);
                            ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.seletedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                        }
                        this._removeHighLighter();
                        ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
                    }
                }
                this.abort();
            }
            else if (keycode === 46 && this.inAction) {
                if (this.diagram._selectedSymbol) {
                    this.diagram._documentmouseup(evt);
                    this.diagram._selectedSymbol = null;
                }
                this.abort();
            }
            else if (!this.inAction && keycode == 27) {
                this.diagram._clearSelection();
            }
        };
        ToolBase.prototype._getSwimlaneHeader = function (group) {
            var header;
            if (group && group.isSwimlane) {
                if (group.children && group.children.length > 0) {
                    header = this.diagram.nameTable[this.diagram._getChild(group.children[0])];
                }
            }
            return header;
        };
        ToolBase.prototype._removeHelpers = function () {
            ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
            ej.datavisualization.Diagram.SvgContext._removeConnectorHighlighter(this.diagram._adornerLayer, this.diagram._adornerSvg);
            this._removeHighLighter();
        };
        ToolBase.prototype._cloneGroupNode = function (node, id) {
            var child = null, child1, clnObj, node1;
            node1 = $.extend(true, {}, node);
            node1.name += id;
            if (node && node._type === "group") {
                node1.children = [];
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[this.diagram._getChild(children[i])];
                    child1 = $.extend(true, {}, child);
                    child1.name += id;
                    if (child1.parent)
                        child1.parent += id;
                    if (child1._type === "group")
                        this._cloneGroupNode(child1, id);
                    this.diagram.nameTable[child1.name] = child1;
                    node1.children.push(child1);
                }
            }
            return node1;
        };
        ToolBase.prototype._updateNextPhases = function (seperator, dx, dy) {
            var dif = 0, index, cphase;
            var group;
            if (seperator.orientation == "horizontal") {
                dif = dx;
            }
            else {
                dif = dy;
            }
            index = this.diagram._getPhaseIndex(seperator.name);
            group = this.diagram.nameTable[seperator.parent];
            for (var i = index + 1; i < group.phases.length; i++) {
                cphase = this.diagram.nameTable[this.diagram._getChild(group.phases[i])];
                if (cphase)
                    cphase.offset += dif;
                ej.datavisualization.Diagram.SvgContext._updatephase(cphase, this.diagram);
            }
        };

        ToolBase.prototype._getphase = function (id) {
            return this.diagram.nameTable[id];
        };


        ToolBase.prototype._containsSwimlane = function (list) {
            for (var i = 0; i < list.length; i++) {
                var child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                if (child.isSwimlane || child.isLane)
                    return true;
            }
            return false;
        };

        ToolBase.prototype._raiseEndPointDrag = function (connector, isTarget, isSource, dragState) {
            if (isTarget || isSource) {
                var type, node, port, point;
                node = this._currentPossibleConnection ? this._currentPossibleConnection : null;
                port = this._possibleConnectionPort ? this._possibleConnectionPort : null;
                point = this.currentPoint;
                if (isTarget)
                    type = "Target";
                else type = "Source";
                return this._raiseEvent("connector" + type + "Change", { element: connector, node: node, port: port, point: point, dragState: dragState, cancel: false });
            }
        };

        ToolBase.prototype._decideSelectedItem = function (evt, node, skip) {
            var obj = null;
            if (node) {
                if (node.parent) {
                    if (this.diagram.selectionList && this.diagram.selectionList[0] && node.parent == this.diagram.selectionList[0].name && !skip) {
                        obj = node;
                        if (this.diagram.selectionList[0].type == "bpmn")
                            obj = this.diagram.selectionList[0];
                    }
                    else {
                        if (skip && this.diagram.selectionList[0] && this.diagram.selectionList[0].name == node.name) {
                            obj = node;
                        }
                        else {
                            var item = this.diagram.nameTable[node.parent];
                            if (node.isPhase) {
                                var name = (node.name).split("phaseStack")[1];
                                if (name) {
                                    node = this.diagram.nameTable[name];
                                }
                                obj = node;
                            }
                            else {
                                obj = this._decideSelectedItem(evt, item, skip);
                                if (this.diagram.selectionList && this.diagram.selectionList[0]) {
                                    if (obj && this.diagram.selectionList[0].name == obj.name && !skip)
                                        obj = node;
                                }
                            }
                        }
                    }
                } else {
                    obj = node;
                }
            }
            else {
                return null;
            }
            return obj;
        };
        ToolBase.prototype._isParentAsLane = function (pGroup) {
            var child, lane, laneStack;
            for (var i = 0; pGroup.children && i < pGroup.children.length > 0; i++) {
                child = this.diagram.nameTable[this.diagram._getChild(pGroup.children[i])];
                if (child) {
                    lane = this.diagram.nameTable[child.parent];
                    if (lane && lane.isLane) {
                        laneStack = this.diagram.nameTable[lane.parent];
                        this.diagram._activeSwimLane = this.diagram.nameTable[laneStack.parent];
                        return true;
                    }
                }
            }
            return null;
        };
        ToolBase.prototype._getAdjustjecentLines = function (child) {
            if (!child.segments) {
                for (var i = 0; child.inEdges && child.inEdges.length > 0 && i < child.inEdges.length ; i++) {
                    if (!this._containsCollection(this._adjustLines.lines, this.diagram.nameTable[child.inEdges[i]]))
                        this._adjustLines.lines.push(jQuery.extend(true, {}, this.diagram.nameTable[child.inEdges[i]]));
                }
                for (i = 0; child.outEdges && child.outEdges.length > 0 && i < child.outEdges.length ; i++) {
                    if (!this._containsCollection(this._adjustLines.lines, this.diagram.nameTable[child.outEdges[i]]))
                        this._adjustLines.lines.push(jQuery.extend(true, {}, this.diagram.nameTable[child.outEdges[i]]));
                }
            }
        };
        ToolBase.prototype._containsCollection = function (collection, obj) {
            for (var i = 0; collection && collection.length > 0 && i < collection.length; i++) {
                if (obj && collection[i].name === obj.name)
                    return true;
            }
        };
        ToolBase.prototype._updateMultipleUndoObject = function (psedoGroup) {
            var child, collection = [];
            for (var i = 0; psedoGroup.children && psedoGroup.children.length > 0 && i < psedoGroup.children.length; i++) {
                child = this.diagram.nameTable[this.diagram._getChild(psedoGroup.children[i])];
                if (child) {
                    collection.push(jQuery.extend(true, {}, child));
                    this._getAdjustjecentLines(child);
                }
            }
            if (!this._undoObject) {
                this._undoObject = {
                    collection: collection,
                    adjustLines: jQuery.extend(true, {}, this._adjustLines)
                };
            }
        };
        ToolBase.prototype._updateNameTable = function (node) {
            this.diagram._updateNameTable(node);
        };
        ToolBase.prototype._getParentSwimlane = function (lane) {
            var laneStack;
            if (lane && lane.isLane) {
                laneStack = this.diagram.nameTable[lane.parent];
                return this.diagram.nameTable[laneStack.parent];
            }
            return null;
        };
        ToolBase.prototype._removeHighLighter = function () {
            ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
        };
        ToolBase.prototype._getPadding = function (node) {
            var padX = 0, padY = 0;
            if (node && node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    padX = parent.paddingRight;
                    padY = parent.paddingBottom;
                }
            }
            return { x: padX, y: padY };
        };

        ToolBase.prototype._findStackOverNode = function (node, evt) {
            if (node) {
                var parent = this.diagram.nameTable[node.parent];
                var child = null, pos, childBounds;
                if (parent) {
                    var length = parent.children.length;
                    for (var i = 0; i < length; i++) {
                        child = this.diagram.nameTable[this.diagram._getChild(parent.children[i])];
                        pos = this.mousePosition(evt);
                        childBounds = ej.datavisualization.Diagram.Util.bounds(child);
                        var lastChild = this.diagram.nameTable[this.diagram._getChild(parent.children[length - 1])];
                        var firstChild = this.diagram.nameTable[this.diagram._getChild(parent.children[0])];
                        if (parent.container.orientation == "vertical") {
                            if (pos.y >= childBounds.y && pos.y <= childBounds.bottom) {
                                return child;
                            }
                            else if (pos.y <= firstChild.offsetY - firstChild.height / 2) {
                                return firstChild;
                            }
                            else if (pos.y >= lastChild.offsetY + lastChild.height / 2) {
                                return lastChild;
                            }

                        }
                        else {
                            if (pos.x >= childBounds.x && pos.x <= childBounds.right) {
                                return child;
                            }
                            else if (pos.x <= firstChild.offsetX - firstChild.width / 2) {
                                return firstChild;
                            }
                            else if (pos.x >= lastChild.offsetX + lastChild.width / 2) {
                                return lastChild;
                            }
                        }
                    }
                }
            }
        };

        ToolBase.prototype._getPageBounds = function () {
            var size = ej.datavisualization.Diagram.Rectangle(0, 0, 0, 0);
            var pageSettings = this.diagram.model.pageSettings;
            size.x = (pageSettings.boundaryConstraints === "diagram") ? Math.min(this.diagram._getDigramBounds().x, 0) : 0;
            size.y = (pageSettings.boundaryConstraints === "diagram") ? Math.min(this.diagram._getDigramBounds().y, 0) : 0;
            size.width = (pageSettings.boundaryConstraints === "page") ? (pageSettings.pageWidth ? pageSettings.pageWidth : this.diagram.element.width()) : this.diagram.element.width();
            size.height = (pageSettings.boundaryConstraints === "page") ? (pageSettings.pageHeight ? pageSettings.pageHeight : this.diagram.element.height()) : this.diagram.element.height();
            return size;
        };
        ToolBase.prototype._nodeHighLighter = function (overNode, evt) {
            var source = null, childBounds = null, target = null;
            if (overNode && this.selectedObject.parent) //&& this.selectedObject.parent != overNode.name)
            {
                var parent = this.diagram.nameTable[this.selectedObject.parent];
                if (parent) {
                    if (parent.container && parent.container.type == "stack" && this.selectedObject.name != overNode.name) {
                        var stackOverNode = this._stackOverNode;
                        ej.datavisualization.Diagram.SvgContext._drawStackHighlighter(stackOverNode, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom, this.currentPoint, (parent.container.orientation === "vertical") ? true : false);
                    }
                    else if (parent.container && parent.container.type == "canvas" && this.selectedObject.parent != overNode.name && !overNode.isPhase && ej.datavisualization.Diagram.Util.canAllowDrop(overNode)) {
                        if (ej.datavisualization.Diagram.Util._canBeTarget(this.diagram, overNode))
                            ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(overNode, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom);
                    }
                    else this._removeHighLighter();
                }
            }
            else if (overNode && overNode.container && !overNode.isSwimlane) {
                if (this.selectedObject.isLane) {
                    parent = this.diagram.nameTable[overNode.parent];
                    if (parent && overNode.name.indexOf("phaseStack") === -1 && (ej.datavisualization.Diagram.Util.canDrawStackHighlighter(this.diagram, this.selectedObject, overNode)))
                        ej.datavisualization.Diagram.SvgContext._drawStackHighlighter(overNode, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom, this.currentPoint, (parent.container.orientation === "vertical") ? true : false);
                }
                else
                    ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(overNode, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom);
            }
            else if (!overNode.segments) {
                ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(overNode, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom);
            }
            else
                this._removeHighLighter();
            if (this._nodeToHit && overNode && overNode.name != this._nodeToHit.name) {
                childBounds = ej.datavisualization.Diagram.Util.bounds(this._nodeToHit);
                target = this._getTargetNode(this._nodeToHit, childBounds);
                this._raiseEvent("mouseLeave", { element: this.diagram.getNode(this.selectedObject), source: this.diagram.getNode(this._nodeToHit), target: this.diagram.getNode(target) });
            }
            if (overNode) {
                if (this._nodeToHit && this._nodeToHit.name !== overNode.name || !this._nodeToHit) {
                    this._nodeToHit = overNode;
                    if (this.selectedObject.parent)
                        source = this.diagram.nameTable[this.selectedObject.parent];
                    if (this.selectedObject.type == "pseudoGroup") {
                        var fChild = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                        if (fChild && fChild.parent)
                            source = this.diagram.nameTable[fChild.parent];
                    }
                    childBounds = ej.datavisualization.Diagram.Util.bounds(overNode);
                    target = this._getTargetNode(overNode, childBounds);
                    this._raiseEvent("mouseEnter", { element: this.diagram.getNode(this.selectedObject), source: this.diagram.getNode(source), target: this.diagram.getNode(target) });
                }
            }
            else {
                this._nodeToHit = null;
            }
            if (overNode) {
                if (this.selectedObject.parent)
                    source = this.diagram.nameTable[this.selectedObject.parent];
                childBounds = ej.datavisualization.Diagram.Util.bounds(overNode);
                target = this._getTargetNode(overNode, childBounds);
                this._raiseEvent("mouseOver", { element: this.diagram.getNode(this.selectedObject), source: this.diagram.getNode(source), target: this.diagram.getNode(target) });
            }
        };

        ToolBase.prototype._doubleClick = function (element) {
            if (element && element.parent) {
                var parent = this.diagram.nameTable[element.parent];
                if (parent) {
                    var name = element.name;
                    this.diagram.updateSelectedObject(name);
                    if (!parent.isLane && !parent.isSwimlane && !parent.isPhaseStack) {
                        this.diagram._clearSelection(true);
                        this.diagram.addSelection(element, true);
                    }
                }
            }
        };

        ToolBase.prototype._itemClick = function (element, actualObject, selectedObject, prevSelected) {

            if (actualObject && actualObject.parent) {
                var parent = this.diagram.nameTable[actualObject.parent];
                if (parent) {
                    if (parent.container) {
                        if (actualObject && !this.diagram._selectedSymbol) {
                            var name = actualObject.name;
                            if (name.indexOf("_header_swimlane") != -1) {
                                if (element)
                                    this.diagram.updateSelectedObject(element.parent, parent);
                            }
                            else if (name.indexOf("_Headerr_") != -1)
                                this.diagram.updateSelectedObject(actualObject.parent);
                            else if (actualObject && actualObject.isPhase) {
                                if (element.isPhase) {
                                    var obj = this.diagram.nameTable[element.parent];
                                    if (obj && (this.diagram.selectionList.length === 0 || this.diagram.selectionList[0].name != obj.name)) {
                                        this.diagram._clearSelection(true);
                                        this.diagram.addSelection(element, true);
                                        this.selectedObject = null;
                                    }
                                }
                            }
                            else
                                this.diagram.updateSelectedObject(name);
                        }
                        this.diagram._selectedGNode = null;
                    }
                    else if (parent.type === "group") {
                        if (parent.parent) {
                            if (!(this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y)) {
                                while (parent.parent) {
                                    var lane = this.diagram.nameTable[parent.parent];
                                    if (lane && lane.isLane)
                                        break
                                    else {
                                        var tParent = this.diagram.nameTable[parent.parent];
                                        if (this.diagram._selectedGNode && tParent) {
                                            if (tParent.name === this.diagram._selectedGNode.name) {
                                                this.diagram.updateSelectedObject(parent.name);
                                                break;
                                            }
                                            else parent = tParent;
                                        }
                                        else parent = tParent;
                                    }
                                }
                            }
                            else lane = this.diagram.nameTable[parent.parent];
                            if (lane && lane.isLane) {
                                var obj = this._getSelectedItem(actualObject, prevSelected);
                                if (obj)
                                    this.diagram.updateSelectedObject(obj.name)
                            }
                        }
                        if (this.selectedObject && this.selectedObject.parent)
                            this.diagram._selectedGNode = this.selectedObject;
                    }
                }
            }
            else if (actualObject) {
                if (!this.diagram._selectedSymbol)
                    this.diagram.updateSelectedObject(actualObject.name);
            }
            else this.diagram._selectedGNode = null;
            if (element && (element.type == "pseudoGroup" || element.name == "multipleSelection") && actualObject && !this._containsChild(element, actualObject.name)) {
                this.diagram.updateSelectedObject(element.name)
            }

        };

        ToolBase.prototype._getSelectedItem = function (item, prevSelected) {
            var parent;
            if (item) {
                if (item.parent) {
                    parent = this.diagram.nameTable[item.parent];
                    if (prevSelected && prevSelected.name == parent.name) {
                        return item
                    }
                    else if (parent.isLane)
                        return item;
                    else return this._getSelectedItem(parent);
                }
            }
        };

        ToolBase.prototype._getTargetNode = function (node, childBounds) {
            var bounds = null, nodes = [];
            var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(this.diagram._spatialSearch, childBounds);
            for (var i = 0; i < quads.length; i++) {
                var quad = quads[i];
                if (quad.objects.length > 0) {
                    for (var j = 0; j < quad.objects.length; j++) {
                        var nd = quad.objects[j];
                        if (!nd.segments && nd.visible) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(nd);
                            if (nodes.indexOf(nd) == -1 && ej.datavisualization.Diagram.Geometry.intersectsRect(childBounds, bounds))
                                nodes.push(nd);

                        }
                    }
                }
            }
            var collection = [];
            collection.push(node);
            for (i = 0; i < nodes.length; i++) {
                if (nodes[i].name != node.name)
                    collection.push(nodes[i]);
            }
            return collection;
        };
        ToolBase.prototype._updateMargin = function (node, group) {
            if (node.type == "pseudoGroup") {
                var child = null;
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    this._updateMargin(child, group);
                }
            }
            else if (group && group.container && group.container.type == "canvas") {
                var groupBounds = ej.datavisualization.Diagram.Util.bounds(group); //ej.datavisualization.Diagram.SvgContext.getCanvasBoundingBox(group, this.diagram, node, true);
                var bounds1 = ej.datavisualization.Diagram.Util.bounds(node);
                var bounds = ej.datavisualization.Diagram.Geometry.rect([bounds1.topLeft, bounds1.topRight, bounds1.bottomRight, bounds1.bottomLeft]);
                node.marginLeft = bounds.x - (groupBounds.x + group.paddingLeft);
                //node.marginRight = (groupBounds.x + group.width) - (bounds.x + bounds.width) - group.paddingRight;
                node.marginTop = bounds.y - (groupBounds.y + group.paddingTop);
                //node.marginBottom = groupBounds.bottom - (bounds.y + bounds.height) - group.paddingBottom;
                if (group.isLane) {
                    var left = 0, top = 0;
                    if (group.orientation === "horizontal") {
                        left = 50, top = 0;
                    }
                    else {
                        left = 0, top = 50;
                    }
                    node.marginLeft = node.marginLeft >= left ? node.marginLeft : left;
                    node.marginTop = node.marginTop >= top ? node.marginTop : top;
                }

            }

        };
        ToolBase.prototype._getNodeUnderMouse = function (evt) {
            var node = this.diagram._nodeUnderMouse; var obj, skip;
            if (this.diagram._focusedElement && (this.diagram._focusedElement.isPhase || this.diagram._focusedElement.isLane || this.diagram._focusedElement.isSwimlane)) skip = true;
            if (this.diagram._focusedElement && node && this._containsChild(this.diagram._focusedElement, node.name)) {
                if (node && (skip || !ej.datavisualization.Diagram.Util.canAllowDrop(node))) {
                    var type = this.diagram.getObjectType(node);
                    if (type == "connector" || type === "group") {
                        obj = node;
                    }
                    else {
                        if (node.parent) {
                            var parent1 = this.diagram.nameTable[node.parent];
                            if (parent1 && parent1.container && parent1.container.type == "stack" && ej.datavisualization.Diagram.Util.canAllowDrop(node)) {
                                return obj = node;
                            }
                            type = this.diagram.getObjectType(parent1);
                            if (parent1 && type != "node") {
                                obj = parent1;
                            }
                        }
                    }
                }
            }
            if (!obj) {
                if (node && this.selectedObject != node && ej.datavisualization.Diagram.Util.canAllowDrop(node))
                    return node;
            }
            else if (this.selectedObject != obj && ej.datavisualization.Diagram.Util.canAllowDrop(obj) && (obj.type != "bpmn" || this.selectedObject.type == "bpmn"))
                return obj;

        };

        ToolBase.prototype._isChange = function (obj1, obj2) {
            var status = null;
            if (obj1._type === "group" || obj1.type === "pseudoGroup" || obj2._type === "group" || obj2.type === "pseudoGroup") {
                if ((obj1._type === "group" || obj1.type === "pseudoGroup") && !(obj2._type === "group" || obj2.type === "pseudoGroup")) {
                    status = !this._containsChild(obj1, obj2.name);
                }
                if (!(obj1._type === "group" || obj1.type === "pseudoGroup") && (obj2._type === "group" || obj2.type === "pseudoGroup")) {
                    status = !this._containsChild(obj2, obj1.name);
                }
                else if ((obj1._type === "group" || obj1.type === "pseudoGroup") && (obj2._type === "group" || obj2.type === "pseudoGroup")) {
                    if (obj1.name == obj2.name)
                        status = true;
                }
            }
            else {
                if (obj1.name == obj2.name)
                    status = true;
            }
            return status;
        };
        ToolBase.prototype._containsChild = function (node, childName) {
            var status = true;
            var child = null;
            var type;
            if (node.children) {
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    type = this.diagram.getObjectType(child);
                    if (type === "group")
                        status = this._containsChild(child, childName);
                    else {
                        if (child && child.name == childName)
                            status = false;
                    }
                }
            }
            return status;
        };

        ToolBase.prototype._findNodeUnderMouse = function (evt, skip) {
            var obj = null;
            var node = null;
            var type;
            var foreignObject = this.diagram._isForeignObject(evt.target);
            if (foreignObject)
                evt.target = foreignObject;
            var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group")[0];
            var className = evt.target.className;
            if (parent && (foreignObject || evt.target.localName != "div")) {
                type = typeof parent.className === "object" ? parent.className.baseVal : parent.className;
                if (type && (type === "ej-d-node" || type === "ej-d-group" || ej.datavisualization.Diagram.Util.isClassifier(evt))) {
                    node = this.diagram._findNode(parent.id);
                    if (!node) node = this.diagram._findNode(parent.id.split("_label")[0]);
                    if (!node) node = this.diagram._findNode(parent.id.split('_parentdiv')[0]);
                } else if (type === "ej-d-connector") {
                    node = this.diagram._findConnector(parent.id);
                    if (!node) node = this.diagram._findConnector(parent.id.split("_label")[0]);
                }
                else if (className.animVal === "ej-d-multiselector")
                    node = this.diagram.selectionList[0];
            }
            else if (!node && evt.target && evt.target.parentNode) {
                var id = (evt.target.parentNode.id).split("_ej_ports");
                node = this.diagram.findNode(id[0]);
            }
            else {
                if (this.diagram._isLabelTemplate(evt)) {
                    node = this.diagram._findNode(parent.id);
                    if (!node) {
                        node = this.diagram._findConnector(parent.id);
                    }
                }
            }
            if (node && !node.parent)
                obj = node;
            else
                obj = this._decideSelectedItem(evt, node, skip);
            this.prevSelectObject = obj;

            if (skip && this.diagram.selectionList[0]) {
                if (obj && obj._type === "group" && !this._containsChild(obj, this.diagram.selectionList[0].name))
                    obj = obj;
                else if (obj && this.diagram.selectionList[0].name != obj.name && this._isChange(this.diagram.selectionList[0], obj))
                    obj = this.diagram.selectionList[0];
                else if (node && node.name == this.diagram.selectionList[0].name && !this._isChange(this.diagram.selectionList[0], obj)) {
                    obj = this.diagram.selectionList[0];

                }
            }
            if (node && this.diagram._selectedSymbol && node.name != this.diagram._selectedSymbol.name && this.diagram._symbolDrop)
                this.actualObject = this.diagram._selectedSymbol;
            else
                this.actualObject = node;
            return obj;

        };

        ToolBase.prototype._findLabelUnderMouse = function (evt, skip, mousePosition, drag) {
            var obj;
            var target = $(evt.target);
            var targetClass = target[0].getAttribute("class");
            if (this.diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                if (!targetClass || !targetClass == "ej-d-label") {
                    if (target[0].parentNode)
                        var className = target[0].parentNode.getAttribute("class");
                    if (className === "ej-d-label") {
                        var nameArray = target[0].parentNode.id.split("_");
                        var name = "";
                        for (var i = 1; i < nameArray.length; i++) {
                            name += nameArray[i]
                            if (i != nameArray.length - 1) {
                                name += "_"
                            }
                        }
                        var node = this.diagram.nameTable[nameArray[0]];
                        if (node && node.labels.length > 0) {
                            for (var i = 0; i < node.labels.length; i++) {
                                if (node.labels[i].name === name) {
                                    this.activeLabel = node.labels[i];
                                    return node.labels[i];
                                }
                            }
                        }
                    }
                    else {
                        var parentNode = evt.target.parentNode;
                        while (parentNode) {
                            if (parentNode)
                                var targetClass = parentNode.getAttribute("class");
                            if (targetClass === "ej-label-template") {
                                var id = parentNode.id.split('_');
                                obj = this.diagram._findNode(id[0]);
                                if (!obj)
                                    obj = this.diagram._findConnector(id[0]);
                                for (var i = 0; obj && i < obj.labels.length; i++) {
                                    id1 = obj.labels[i].name.split('_');
                                    if (id[id.length - 1] == id1[id1.length - 1]) {
                                        curlabel = obj.labels[i];
                                        if (!this.diagram._selectedSymbol)
                                            this.activeLabel = curlabel;
                                        return curlabel;
                                    }
                                }
                            }
                            if (parentNode && parentNode.id === this.diagram.element[0].id + "_canvas_svg") {
                                break;
                            }
                            else
                                parentNode = parentNode.parentNode;
                        }
                    }
                }
            }
            else if (targetClass == "ej-d-label") {
                var parent = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group");
                if (parent) {
                    var id = parent[0].getAttribute("id");
                    var type = parent[0].getAttribute("class");
                    if (type) {
                        if (type === "ej-d-node" || type === "ej-d-group") {
                            obj = this.diagram._findNode(id);
                            if (!obj) obj = this.diagram._findNode(id.split("_label")[0]);
                            var curlabel = this.diagram._findLabelAtPoint(mousePosition ? mousePosition : this.currentPoint, obj);
                            if (!this.diagram._selectedSymbol)
                                this.activeLabel = curlabel;
                        }
                        else if (type === "ej-d-connector") {
                            obj = this.diagram._findConnector(id);
                            if (!obj) obj = this.diagram._findConnector(id.split("_label")[0]);
                            var curlabel = this.diagram._findLabelAtPoint(mousePosition ? mousePosition : this.currentPoint, obj);
                            if (ej.datavisualization.Diagram.Util.canMoveLabel(obj) || drag) {
                                if (curlabel == null) {
                                    var target = $(evt.target);
                                    var id1;
                                    var targetClass = target[0].getAttribute("class");
                                    if (targetClass == "ej-d-label") {
                                        var id = evt.target.id.split('_');
                                        for (var i = 0; i < obj.labels.length; i++) {
                                            id1 = obj.labels[i].name.split('_');
                                            if (id[id.length - 1] == id1[id1.length - 1])
                                                curlabel = obj.labels[i];
                                        }
                                    }
                                }
                            }
                            else
                                curlabel = null;
                            if (!this.diagram._selectedSymbol)
                                this.activeLabel = curlabel;
                        }
                    }
                }
            }
            else if (this.diagram._isLabelTemplate(evt)) {

                var parents = $(evt.target).parents(".ej-label-template");
                var parent = parents[0]
                if (parent) {
                    //var id = parent.parentNode.id.split('_');

                    var id = parent.parentNode.id.split('_')
                    obj = this.diagram._findNode(id[0]);
                    if (!obj)
                        obj = this.diagram._findConnector(id[0]);
                    if (obj) {
                        for (var i = 0; i < obj.labels.length; i++) {
                            id1 = obj.labels[i].name.split('_');
                            if (id[2] == id1[id1.length - 1])
                                curlabel = obj.labels[i];
                        }
                    }
                    if (!this.diagram._selectedSymbol)
                        this.activeLabel = curlabel;
                }
            }
            else {
                this.activeLabel = null;
            }
            return obj;
        };

        ToolBase.prototype._findLabelAtNode = function (node, text) {
            var labels, label = null;
            var size, pt, x, y;
            var bounds, matrix, point;
            if (node && node.labels.length > 0) {
                bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                labels = node.labels;
                for (var i = 0, len = labels.length; i < len; i++) {
                    label = labels[i];
                    if (label.name == text.name) {
                        pt = ej.datavisualization.Diagram.Util._getLabelPosition(label, bounds);
                        pt.x = bounds.x + pt.x;
                        pt.y = bounds.y + pt.y;
                        var width, height;
                        if (this.diagram.model.labelRenderingMode == ej.datavisualization.Diagram.LabelRenderingMode.Svg) {
                            var textElement = document.getElementById(node.name + "_" + label.name).getBBox();
                            width = textElement.width ? textElement.width : 0;
                            height = textElement.height ? textElement.height : 0;
                        }
                        else {
                            var htmlLayer = this.diagram._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                            var textElement = $(htmlLayer).find("#" + node.name + "_" + label.name)[0];
                            width = textElement ? textElement.offsetWidth : 0;
                            height = textElement ? textElement.offsetHeight : 0;
                        }
                        if (!width) width = node.width;
                        if (!height) height = label.fontSize;
                        var size = ej.datavisualization.Diagram.Size(width, height);
                        if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Top) pt.y += size.height / 2;
                        else if (label.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Bottom) pt.y -= size.height / 2;

                        if (label.horizontalAlignment == ej.datavisualization.Diagram.HorizontalAlignment.Left) pt.x += size.width / 2;
                        else if (label.horizontalAlignment == ej.datavisualization.Diagram.HorizontalAlignment.Right) pt.x -= size.width / 2;
                        x = pt.x - (label.width ? label.width / 2 : node.width / 2);
                        y = pt.y - (label.height ? label.height / 2 : node.height / 2);
                        point = ej.datavisualization.Diagram.Point(x, y);
                        if (!node.segments) {
                            matrix = ej.Matrix.identity();
                            ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                            point = ej.Matrix.transform(matrix, point);
                        }
                        var location = { x: point.x, y: point.y, width: size.width, height: size.height };
                    }
                }
            }
            return location;
        };

        ToolBase.prototype._getLabelCenter = function (label) {
            var node = this.diagram.findNode(label._parent);
            var labelPosition = this._findLabelAtNode(node, label);
            if (!node.segments) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, -node.rotateAngle, node.offsetX, node.offsetY);
                var point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(labelPosition.x, labelPosition.y));
                var centerPoint = ej.datavisualization.Diagram.Point(point.x + label.width / 2, point.y + label.height / 2);
                var trans = ej.Matrix.identity();
                ej.Matrix.rotate(trans, node.rotateAngle, node.offsetX, node.offsetY);
                var pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(centerPoint.x, centerPoint.y));
            }
            else {
                if (label.relativeMode == "segmentpath") {
                    var labelPosition = ej.datavisualization.Diagram.SvgContext._getConnectorHandlePosition(label, node, 1, this.diagram);
                    pivot = ej.datavisualization.Diagram.Point((labelPosition.position.x + label.margin.left - label.margin.right), (labelPosition.position.y + label.margin.top - label.margin.bottom));
                }
                else
                    pivot = ej.datavisualization.Diagram.Point(labelPosition.x + label.width / 2, labelPosition.y + label.height / 2);
            }
            return pivot;
        };

        ToolBase.prototype._resizeObject = function (shape, difx, dify, phase, disableSnap) {
            var deltaWidth, deltaHeight, diff, rotateAngle, center, x, y;
            var horizontalsnap = { snapped: false, offset: 0, left: false, right: false };
            var verticalsnap = { snapped: false, offset: 0, top: false, bottom: false };
            var startPoint = this.previousPoint;
            var endPoint = this.currentPoint;
            var pivot = ej.datavisualization.Diagram.Point(0, 0);
            if (shape._type !== "label")
                rotateAngle = shape.rotateAngle;
            else
                rotateAngle = this.diagram._findLabelRotateAngle(shape);
            var matrix = ej.Matrix.identity();
            ej.Matrix.rotate(matrix, -rotateAngle);

            var trans = ej.Matrix.identity();
            if (!shape.text)
                center = ej.datavisualization.Diagram.Point(shape.offsetX, shape.offsetY);
            else
                center = this._getLabelCenter(shape);
            ej.Matrix.rotate(trans, rotateAngle, center.x, center.y);
            var w = shape.width;
            var h = shape.height;
            if (shape._type !== "label") {
                x = shape.offsetX - w * shape.pivot.x;
                y = shape.offsetY - h * shape.pivot.y;
            }
            else {
                x = center.x - shape.width / 2;
                y = center.y - shape.height / 2;
            }

            switch (this._resizeDirection) {
                case "n-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w / 2, y + h));
                    var deltaWidth = 1;
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify));
                    difx = diff.x; dify = diff.y;
                    if (shape._type !== "label")
                        dify = this._snapTop(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    deltaHeight = (this.initialBounds.height - dify) / shape.height;
                    break;
                case "e-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x, y + h / 2));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    if (shape._type !== "label")
                        difx = this._snapRight(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint, disableSnap);
                    dify = 0;
                    deltaWidth = (this.initialBounds.width + difx) / shape.width;
                    deltaHeight = 1;
                    break;
                case "w-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w, y + h / 2));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    if (shape._type !== "label")
                        difx = this._snapLeft(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    dify = 0;
                    deltaWidth = (this.initialBounds.width - difx) / shape.width;
                    deltaHeight = 1;
                    break;
                case "s-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w / 2, y));
                    deltaWidth = 1;
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify));
                    difx = diff.x; dify = diff.y;
                    if (shape._type !== "label")
                        dify = this._snapBottom(horizontalsnap, verticalsnap, diff.x, diff.y, shape, (endPoint && startPoint && endPoint == startPoint) ? true : false);
                    deltaHeight = (this.initialBounds.height + dify) / shape.height;
                    break;
                case "ne-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x, y + h));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    if (shape._type !== "label") {
                        difx = this._snapRight(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint, disableSnap);
                        dify = this._snapTop(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    }
                    deltaWidth = (this.initialBounds.width + difx) / shape.width;
                    deltaHeight = (this.initialBounds.height - dify) / shape.height;
                    break;
                case "nw-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w, y + h));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    if (shape._type !== "label") {
                        dify = this._snapTop(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                        difx = this._snapLeft(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    }
                    deltaWidth = (this.initialBounds.width - difx) / shape.width;
                    deltaHeight = (this.initialBounds.height - dify) / shape.height;
                    break;
                case "se-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x, y));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    if (shape._type !== "label") {
                        dify = this._snapBottom(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint, disableSnap);
                        difx = phase ? difx : this._snapRight(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    }
                    deltaWidth = (this.initialBounds.width + difx) / shape.width;
                    deltaHeight = (this.initialBounds.height + dify) / shape.height;
                    break;
                case "sw-resize":
                    pivot = ej.Matrix.transform(trans, ej.datavisualization.Diagram.Point(x + w, y));
                    diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
                    if (shape._type !== "label") {
                        dify = this._snapBottom(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint, disableSnap);
                        difx = this._snapLeft(horizontalsnap, verticalsnap, difx, dify, shape, endPoint == startPoint);
                    }
                    deltaWidth = (this.initialBounds.width - difx) / shape.width;
                    deltaHeight = (this.initialBounds.height + dify) / shape.height;
                    break;
            }
            var point = ej.datavisualization.Diagram.Rectangle(pivot.x, pivot.y, deltaWidth, deltaHeight);
            return point;

        };

        ToolBase.prototype._selectionContainsChild = function (name) {
            if (this.diagram.selectionList[0].children) {
                var children = this.diagram._getChildren(this.diagram.selectionList[0].children);
                var child = null;
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child && child.name == name)
                        return true;
                }
            }
            else if (this.diagram.selectionList[0]._type === "group" && this.diagram.selectionList[0].type != "pseudoGroup") {
                if (this.diagram.selectionList[0].name == name)
                    return true;
            }
            else if (this.diagram.nameTable[name] && this.diagram.nameTable[name]._type === "group") {
                children = this.diagram._getChildren(this.diagram.nameTable[name].children);
                for (var j = 0; j < children.length; j++) {
                    child = this.diagram.nameTable[children[j]];
                    if (child)
                        var status = this._selectionContainsChild(child.name);
                    if (status)
                        return status;
                }
            }
            else if (this.diagram.selectionList[0].name == name)
                return true;

            return false;
        };

        ToolBase.prototype._isSelected = function (name) {
            var child = null;
            var node = this.diagram.nameTable[name];
            if (this._selectionContainsChild(node.name))
                return true;
            else if (node._type === "group") {
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    if (this._selectionContainsChild(child))
                        return true;
                }
            }
            return false;
        };
        ToolBase.prototype._isColleagueSelected = function (name) {
            var node = this.diagram.nameTable[name];
            var child = null;
            if (node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    var children = this.diagram._getChildren(parent.children);
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        if (this._isSelected(child))
                            return true;
                    }
                }
            }
            return false;
        };
        ToolBase.prototype._isInSelection = function (name) {
            if (this.diagram.selectionList[0].type == "pseudoGroup" && this.diagram.selectionList[0].children) {
                var children = this.diagram._getChildren(this.diagram.selectionList[0].children);
                var child = null;
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    if (child.name == name)
                        return true;
                }
            }
        };
        ToolBase.prototype._getCloneNode = function (node) {
            var obj = null;
            obj = jQuery.extend(true, {}, node);
            obj.children = [];
            obj.minHeight = 0;
            obj.minWidth = 0;
            obj.maxHeight = 0;
            obj.maxWidth = 0;
            return obj;
        };
        ToolBase.prototype._getProcessedObject = function (name, obj) {
            var node = this.diagram.nameTable[name];
            if (node) {
                if (this._isInSelection(name)) {
                    return null;
                }
                else if (this._selectionContainsChild(node.name))
                    return { add: node, remove: null };
                else {
                    if (node.parent) {
                        if (this._selectionContainsChild(node.parent)) {
                            if (this._isInSelection(node.parent))
                                return { add: node, remove: this.diagram.nameTable[node.parent] };
                            else {
                                var parent = this.diagram.nameTable[node.parent];
                                if (parent)
                                    return { add: parent, remove: this.diagram.nameTable[parent.parent] };
                            }
                        } else {
                            if (this._isColleagueSelected(node.parent) && !this._selectionContainsChild(node.parent)) {
                                if (this._isSelected(node.parent)) {
                                    return { add: node, remove: null };
                                }
                                else
                                    return { add: this.diagram.nameTable[node.parent], remove: null };
                            }
                            else if (this.diagram.selectionList[0] && this._isInSelection(node.parent)) {
                                return { add: this.diagram.nameTable[node.name], remove: this.diagram.nameTable[node.parent] };

                            }
                            else
                                return this._getProcessedObject(node.parent);
                        }
                    }
                    else {
                        return { add: node, remove: null };
                    }
                }
            }
        };

        ToolBase.prototype.hasSameParent = function () {
            if (this.selectedObject.type == "pseudoGroup") {
                var list = this.selectedObject;
                var child = null;
                if (this.diagram.nameTable[this.diagram._getChild(list.children[0])]) {
                    var parent = this.diagram.nameTable[this.diagram._getChild(list.children[0])].parent;
                    var lChildren = this.diagram._getChildren(list.children);
                    for (var i = 0; i < lChildren.length; i++) {
                        child = this.diagram.nameTable[lChildren[i]];
                        if (child.parent != parent || child.parent == "")
                            return false;
                    }
                }
                return true;
            }
            return false;
        };
        ToolBase.prototype._fromDiagram = function (list) {
            var state = true;
            var child = null;
            for (var i = 0; i < list.length; i++) {
                child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                if (child && child.parent) {
                    state = false;
                    break;
                }
            }
            return state;
        };
        ToolBase.prototype._fromContainer = function (list) {
            var child = null, parent = null;
            for (var i = 0; i < list.length; i++) {
                child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                if (child.parent) {
                    parent = this.diagram.nameTable[child.parent];
                    if (parent) {
                        if (parent.container)
                            return true;
                    }
                }
            }
        };

        ToolBase.prototype._fromSameContainer = function (list) {
            var child = null;
            var parent = null;
            for (var i = 0; i < list.length; i++) {
                child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                if (!parent && child.parent)
                    parent = child.parent;
                if (child.parent) {
                    if (child.parent != parent)
                        return false;
                }
            }
            return true;
        };
        ToolBase.prototype._anyFromContainer = function (list) {
            var child = null;
            var parent = null;
            for (var i = 0; i < list.length; i++) {
                child = this.diagram.nameTable[this.diagram._getChild(list[i])];
                if (child.parent)
                    var parent = this.diagram.nameTable[child.parent];
                if (parent && parent.container && parent.container.type === "canvas") {
                    return true;
                }
            }
            return false;
        };

        ToolBase.prototype._processCtrlKey = function (evt) {
            var obj;
            if (this.diagram.selectionList.length > 0 && ej.datavisualization.Diagram.Util.canDoMultipleSelection(this.diagram)) {
                var selectionList = this.diagram.selectionList;
                var isMultipleSelection, nObj, changeType, newItems = [], oldItems = [], selectedItems = [];
                if (selectionList[0].type == "pseudoGroup") {
                    isMultipleSelection = true;
                    obj = this._findNodeUnderMouse(evt);
                }
                else {

                    obj = this._findNodeUnderMouse(evt);
                }
                var obj1 = this._findNodeUnderMouse(evt, true);
                var tempVal = this.selectedObject;
                var args = this._raiseEvent("itemClick", { element: this.selectedObject, actualObject: this.actualObject, selectedObject: obj1, cancel: false, event: evt });
                this._itemClick(this.selectedObject, this.actualObject, obj1);
                if (args.cancel)
                    this.selectedObject = tempVal;
                if (this.actualObject) {
                    if (this.actualObject.parent) {
                        if (isMultipleSelection) {

                            var mulSelection = selectionList[0];
                            var temp = this._getProcessedObject(this.actualObject.name);
                            if (temp) {
                                if (this.selectedObject) {
                                    mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                    ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, this.selectedObject.name);
                                }
                                else if (temp.remove) {
                                    mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                    ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, temp.remove.name);
                                }


                                if (this.selectedObject) {
                                    if (!this._hasMultipleSelection(this.selectedObject)) {
                                        mulSelection.children.push(this.selectedObject.name);
                                    }
                                } else if (temp.add) {
                                    if (!this._hasMultipleSelection(temp.add)) {
                                        mulSelection.children.push(temp.add.name);
                                    }
                                }
                            } else {
                                nObj = this.actualObject;
                                if (this.selectedObject) {
                                    if (!this._hasMultipleSelection(this.selectedObject))
                                        mulSelection.children.push(this.selectedObject.name);
                                    else {
                                        mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                        ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, this.selectedObject.name);
                                    }
                                } else {
                                    if (!this._hasMultipleSelection(nObj))
                                        mulSelection.children.push(nObj.name);
                                    else {
                                        mulSelection.children = this.diagram._getChildren(mulSelection.children);
                                        ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, nObj.name);
                                    }
                                }
                            }
                            ej.datavisualization.Diagram.Util._updateGroupBounds(mulSelection, this.diagram);
                            if (mulSelection.children.length <= 1) {
                                var child = this.diagram.nameTable[this.diagram._getChild(mulSelection.children[0])];
                                if (this.diagram._hasSelection()) {
                                    this.diagram._clearSelection(true);
                                }
                                this.selectedObject = child;
                                this.diagram._addSelection(this.selectedObject);
                            } else {
                                this.selectedObject = selectionList[0];
                                this.diagram.updateSelection()
                            }

                        } else {
                            if (this.diagram.selectionList[0]._type === "group" && this.diagram.selectionList[0].type !== "bpmn") {
                                selectionList = this.diagram.selectionList[0];
                                temp = this._getProcessedObject(this.actualObject.name);
                                nObj = temp.add;
                                if (temp) {
                                    if (this.diagram._hasSelection()) {
                                        this.diagram._clearSelection();
                                    }
                                }

                            } else {
                                temp = null;
                                if (obj._type === "group") {
                                    temp = this._getProcessedObject(this.actualObject.name);
                                }
                                if (temp)
                                    nObj = temp.add;
                                else
                                    nObj = obj;
                                selectionList = this.diagram.selectionList[0];
                                if (this.diagram._hasSelection()) {
                                    this.diagram._clearSelection();
                                }
                            }
                            this.diagram._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.Keydown
                            pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                            if (selectionList.name != nObj.name)
                                pseudoGroup.children.push(selectionList.name);
                            if (this.selectedObject)
                                pseudoGroup.children.push(this.selectedObject.name);
                            else
                                if (this._containsChild(pseudoGroup, nObj.name))
                                    pseudoGroup.children.push(nObj.name);

                            this._checkRepeatedChild(pseudoGroup.children);

                            this.diagram.nodes().push(pseudoGroup);
                            this.diagram._nodes = $.extend(true, [], this.diagram.nodes());
                            this.diagram.nameTable[pseudoGroup.name] = pseudoGroup;
                            ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this.diagram);
                            this.selectedObject = pseudoGroup;
                            this.diagram._addSelection(this.selectedObject);
                        }
                    }
                    else {
                        if (isMultipleSelection) {
                            mulSelection = selectionList[0];
                            nObj = this.selectedObject ? this.selectedObject : this.actualObject;
                            changeType = (!this._hasMultipleSelection(nObj)) ? "insert" : "remove";
                            if (changeType == "insert") {
                                mulSelection.children.push(nObj.name);
                                newItems.push(nObj);
                            }
                            else {
                                ej.datavisualization.Diagram.Util.removeItem(mulSelection.children, nObj.name);
                                oldItems.push(nObj);
                            }
                            for (var i = 0; i < mulSelection.children.length; i++)
                                selectedItems.push(this.diagram.nameTable[this.diagram._getChild(mulSelection.children[i])]);
                            args = { changeType: changeType, state: "changing", element: this.diagram.nameTable["multipleSelection"], selectedItems: selectedItems, oldItems: oldItems, newItems: newItems, cancel: false };
                            this._raiseEvent("selectionChange", args);
                            if (!args.cancel) {
                                if (changeType == "remove") ej.datavisualization.Diagram.Util.removeItem(this.diagram.model.selectedItems.children, nObj);
                                this.diagram.updateSelection(this.selectedObject);
                                ej.datavisualization.Diagram.Util._updateGroupBounds(mulSelection, this.diagram);
                                this.selectedObject = selectionList[0];
                                if (this.diagram.model.selectedItems.children.length)
                                    ej.datavisualization.Diagram.SvgContext.updateSelector(this.selectedObject, this.diagram._adornerSvg, this.diagram._currZoom, this.diagram, this.diagram.model.selectedItems.constraints);
                                else {
                                    ej.datavisualization.Diagram.Util.clear(this.diagram.selectionList);
                                    ej.datavisualization.Diagram.SvgContext.clearSelector(this.diagram._adornerSvg, this.diagram._adornerLayer, this);
                                }
                                args = { changeType: changeType, state: "changed", element: this.diagram.nameTable["multipleSelection"], selectedItems: selectedItems, oldItems: oldItems, newItems: newItems, cancel: false };
                                this._raiseEvent("selectionChange", args);
                            }
                        }
                        else {
                            var nObj = this.actualObject;
                            this.diagram._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.Keydown
                            selectionList = this.diagram.selectionList[0];
                            if (nObj != selectionList) {
                                if (this.diagram._hasSelection()) {
                                    this.diagram._clearSelection(true);
                                }
                                var pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                                pseudoGroup.children.push(selectionList.name);
                                if (this.selectedObject)
                                    pseudoGroup.children.push(this.selectedObject.name);
                                else
                                    pseudoGroup.children.push(nObj.name);
                                this.diagram.nodes().push(pseudoGroup);
                                this.diagram._nodes = $.extend(true, [], this.diagram.nodes());
                                this.diagram.nameTable[pseudoGroup.name] = pseudoGroup;
                                ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, this.diagram, null, true);
                                this.selectedObject = pseudoGroup;
                                this.diagram._addSelection(this.selectedObject);
                            }
                        }
                    }
                }

                this.selectedObject = this.diagram.selectionList[0];
            }
            else {
                obj = this._findNodeUnderMouse(evt);
                if ((ej.datavisualization.Diagram.Util.canDoSingleSelection(this.diagram)))
                    this.selectedObject = obj;
            }
            return obj;
        };

        ToolBase.prototype._checkRepeatedChild = function (list) {
            var child = null;
            var cloneList = $.extend(true, {}, list);
            cloneList = this.diagram._getChildren(cloneList);
            for (var i = 0; i < cloneList.length; i++) {
                child = this.diagram.nameTable[cloneList.children[i]];
                if (child._type === "group") {
                    for (var j = 0; j < cloneList.children.length; j++) {
                        if (!this._containsChild(child, cloneList.children[j])) {
                            list.children = this.diagram._getChildren(list.children);
                            ej.datavisualization.Diagram.Util.removeItem(list.children, cloneList.children[j]);
                        }
                    }
                }
            }
        };
        ToolBase.prototype._hasMultipleSelection = function (node) {
            var children = this.diagram._getChildren(this.diagram.selectionList[0].children);
            for (var i = 0; i < children.length; i++) {
                if (node.name == children[i])
                    return true;
            }
            return false;
        };

        ToolBase.prototype._getNextParent = function (node) {
            if (node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (this._hasMultipleSelection(parent))
                    return node;
                else
                    return this._getNextParent(parent);
            }
            else
                return node;
        };
        ToolBase.prototype._findObj = function (element, group) {
            var obj;
            var id = element.getAttribute("id");
            if (group) {
                obj = this.diagram._findChildren(group, id);
            }
            else {
                var type = element.getAttribute("class");
                if (type) {
                    if (type === "ej-d-node" || type === "ej-d-group") {
                        obj = this.diagram._findNode(id);
                    }
                    else if (type === "ej-d-connector") {
                        obj = this.diagram._findConnector(id);
                    }
                }
            }
            return obj;
        };
        ToolBase.prototype.mousedown = function (evt) {
            this.startPoint = this.mousePosition(evt);
            this.currentPoint = this.startPoint;
            this.previousPoint = this.startPoint;
            this.diagramBounds = this.diagram._getDigramBounds();
        };
        ToolBase.prototype._isPolyline = function () {
            if (this.diagram.model.drawType.type === "connector" && this.diagram.model.drawType.segments &&
                this.diagram.model.drawType.segments.length > 0 && this.diagram.model.drawType.segments[0].type === "polyline")
                return true;
        };
        ToolBase.prototype.mousemove = function (evt) {
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(this.startPoint) ||
                this instanceof ej.datavisualization.Diagram.LineTool || this._isPolyline() || this.diagram.model.rulerSettings.showRulers)
                this.currentPoint = this.mousePosition(evt);
            this._drawRulerMarkers(evt);
        };
        ToolBase.prototype._removeRulerMarkers = function () {
            var markers = document.getElementsByClassName("ej-d-ruler-marker"), marker, i;
            if (markers && markers.length > 0) {
                for (i = markers.length - 1; i >= 0; i--) {
                    marker = markers[i];
                    if (marker)
                        marker.parentNode.removeChild(marker);
                }
            }
        };
        ToolBase.prototype._drawRulerMarker = function (ruler, rulerObj, rulerInstance, isVertical) {
            if (ruler) {
                var rulerSvg, rulerSize, scale, diff, i, attr, line, rulerSvgElements = rulerObj[0].getElementsByTagName("svg");
                if (rulerSvgElements.length > 0) {
                    for (i in rulerSvgElements) {
                        rulerSvg = rulerSvgElements[i]
                        break;
                    }
                }
                if (rulerSvg) {
                    rulerSize = ej.datavisualization.Diagram.ScrollUtil._getRulerSize(this.diagram);
                    if (!isVertical)
                        attr = { "id": rulerObj[0].id + "_marker", 'x1': 0, 'y1': 0, 'x2': 0, 'y2': rulerSize.top, 'stroke': ruler.markerColor, 'stroke-width': 1.5, "class": "ej-d-ruler-marker" };
                    else
                        attr = { "id": rulerObj[0].id + "_marker", 'x1': 0, 'y1': 0, 'x2': rulerSize.left, 'y2': 0, 'stroke': ruler.markerColor, 'stroke-width': 1.5, "class": "ej-d-ruler-marker" };
                    line = this._createMarkarLine(rulerObj, attr);
                    scale = this.diagram._currZoom;
                    diff = rulerInstance.model.offset - rulerInstance._starValue;
                    if (!isVertical) {
                        var xMove = (this.currentPoint.x * scale) - (this.diagram._hScrollOffset) + diff;
                        line.setAttribute('transform', "translate(" + (xMove) + " 0)");
                    }
                    else {
                        var yMove = (this.currentPoint.y * scale) - (this.diagram._vScrollOffset) + diff;
                        line.setAttribute('transform', "translate(0 " + (yMove) + ")");
                    }
                    rulerSvg.appendChild(line)
                }
            }
        };
        ToolBase.prototype._createMarkarLine = function (rulerObj, attr) {
            if (rulerObj) {
                var line = document.getElementById(rulerObj[0].id + "_marker")
                if (line)
                    line.parentNode.removeChild(line);
                line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                ej.datavisualization.Diagram.Util.attr(line, attr);
                return line;
            }
        };
        ToolBase.prototype._drawRulerMarkers = function (evt) {
            if (this.diagram.model.rulerSettings.showRulers) {
                this._drawRulerMarker(this.diagram.model.rulerSettings.horizontalRuler, this.diagram._hRuler, this.diagram._hRulerInstance, false);
                this._drawRulerMarker(this.diagram.model.rulerSettings.verticalRuler, this.diagram._vRuler, this.diagram._vRulerInstance, true);
            }
        };
        ToolBase.prototype.mouseup = function (evt) {
            this._endAction();
            if (this.diagram._pageBackgroundLayer) {
                ej.datavisualization.Diagram.PageUtil._updatePageSize(this.diagram);
            }
            if (this.singleAction) {
                this.diagram.activateTool("select");
            }
            delete this.diagramBounds;
            this._adjustLines = {
                lines: []
            }
            this._undoObject = null;
            this._redoObject = null;
        };
        ToolBase.prototype.mousePosition = function (evt) {
            return this.diagram._mousePosition(evt);
        };
        ToolBase.prototype.updateCursor = function (cursor) {
            this.diagram._currentCursor = cursor;
            this.diagram._updateCursor();
        };
        ToolBase.prototype.nearestGridPoint = function (point) {
            var snapPt = ej.datavisualization.Diagram.Point();
            if (this.diagram.model.snap & ej.datavisualization.Diagram.Snap.Grid) {
                var magnification = this.diagram.model.magnification / 100;
                var hSpacing = this.diagram.model.grid.horizontalSpacing * magnification;
                var vSpacing = this.diagram.model.grid.verticalSpacing * magnification;
                var width = point.x % hSpacing;
                var height = point.y % vSpacing;
                if (width >= (hSpacing / 2)) {
                    snapPt.x = point.x + hSpacing - width;
                }
                else {
                    snapPt.x = point.x - width;
                }
                if (height >= (vSpacing / 2)) {
                    snapPt.y = point.y + vSpacing - height;
                }
                else {
                    snapPt.y = point.y - height;
                }
            }
            return snapPt;
        };
        ToolBase.prototype.snap = function (point) {
            var snapSettings = this.diagram.model.snapSettings;
            var zoomFactor = this.diagram._currZoom;
            if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines)
                point.x = ej.datavisualization.Diagram.SnapUtil._round(point.x, ej.datavisualization.Diagram.SnapUtil._getSnapIntervals(this.diagram, true), zoomFactor);
            if (snapSettings.snapConstraints & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines)
                point.y = ej.datavisualization.Diagram.SnapUtil._round(point.y, ej.datavisualization.Diagram.SnapUtil._getSnapIntervals(this.diagram, false), zoomFactor);
            return point;

        };
        ToolBase.prototype._endAction = function () {
            this.inAction = false;

            if (this.svgHelper) {
                var helper = this.helper;
                var search = this.diagram._spatialSearch;
                if (helper._type != "group") {
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(search, search.quadTable[helper.name], helper);
                }
                else {
                    var length = this.helper.children.length - 1;
                    for (var i = length; i >= 0; i--) {
                        ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(search, search.quadTable[helper.children[i].name], helper.children[i]);
                    }
                }
            }
            if (this.helper) {
                if (this.svgHelper) {
                    var diagram = this.diagram;
                    var _currTool = this;
                    this.diagram._views.forEach(function (viewid) {
                        var view = diagram._views[viewid];
                        if (_currTool.helper) {
                            var element = view.svg.getElementById(_currTool.helper.name);
                            var htmlLayer = view.svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                            var label = $(htmlLayer).find("#" + _currTool.helper.name)[0];
                        }
                        if (element && element.parentNode)
                            element.parentNode.removeChild(element);
                        if (label)
                            htmlLayer.removeChild(label);

                    });
                }
                if (this.helper.gradient) {
                    var defs = this.diagram._svg.getElementsByTagName("defs")[0];
                    var hlprEle = this.diagram._svg.getElementById(this.helper.name + "_gradient");
                    if (defs && hlprEle)
                        defs.removeChild(this.diagram._svg.getElementById(this.helper.name + "_gradient"));
                }
                var htmlElement = document.getElementById(this.helper.name + "_parentdiv");
                if (htmlElement)
                    htmlElement.parentNode.removeChild(htmlElement);
            }
            if (this._previousPossibleConnection) {
                this._previousPossibleConnection = null;
                ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
            }
            this._currentPossibleConnection = null;
            this._possibleConnectionPort = null;
            this.helper = null;
            this.svgHelper = null;
            this.selectedObject = null;
            this.startPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.currentPoint = ej.datavisualization.Diagram.Point(0, 0);
            this.previousPoint = ej.datavisualization.Diagram.Point(0, 0);
        };
        ToolBase.prototype._isResizeCorner = function (type) {
            var isResizeCorner = false;
            switch (type) {
                case "n-resize":
                case "e-resize":
                case "w-resize":
                case "s-resize":
                case "ne-resize":
                case "nw-resize":
                case "se-resize":
                case "sw-resize":
                case "targetEndPoint":
                case "sourceEndPoint":
                    isResizeCorner = true;
                    break;
            }
            return isResizeCorner;
        };
        ToolBase.prototype._initHelper = function () {
            if (this.selectedObject) {
                this.helper = $.extend(true, {}, this.selectedObject);
                this._updateHelperName(this.helper);
            }
        };
        ToolBase.prototype._updateHelperName = function (helper, child) {
            if (child) {
                helper.name += "helper";
            }
            else
                helper.name = "helper";
            helper.opacity = 0.5;
            var labels = helper.labels;
            for (var i = 0, len = labels.length; i < len; ++i) {
                labels[i].name += "helper";
            }
            if (helper.ports) {
                var ports = helper.ports;
                for (i = 0, len = ports.length; i < len; ++i) {
                    ports[i].name += "helper";
                }
            }
            if (helper._type === "group") {
                var children = this.diagram._getChildren(helper.children);
                for (i = 0, len = children.length; i < len; i++) {
                    this._updateHelperName(children[i], true);
                }
            }
        };
        ToolBase.prototype._raiseEvent = function (type, args) {
            if (this.diagram.model[type]) {
                args.elementType = this.diagram.getObjectType(args.element);
                args.diagramId = this.diagram.element[0].id;
                this.diagram._trigger(type, args);
            }
            return args;
        };
        ToolBase.prototype._findPort = function (pt, node) {
            var port = this.diagram._findPortAtPoint(pt, node);
            if (!port && node._type === "group") {
                var childPort;
                var children = this.diagram._getChildren(node.children);
                for (var j = 0; j < children.length; j++) {
                    var child = this.diagram.nameTable[children[j]];
                    if (child && !child.segments && !child._isInternalShape) {
                        childPort = this._findPort(pt, child);
                        if (childPort && this.diagram.getObjectType(child) != "group") {
                            this._currentPossibleConnection = child;
                            port = childPort;
                        }
                        else if (childPort) {
                            return childPort;
                        }
                    }
                }
            }
            return port;
        };
        ToolBase.prototype._checkConnectionPossible = function (evt) {
            var port = null, possibleConnector = null;
            var connectedNode = this._sourcePossibleConnection;
            var pt = ej.datavisualization.Diagram.Point(this.currentPoint.x, this.currentPoint.y);
            var node = this.diagram._findConnectableNodeUnderMouse(evt);
            if (node && (this._sourcePossibleConnection || this.selectedObject)) {
                if (this.selectedObject) {
                    if (this._endPoint == "targetEndPoint" && this.selectedObject.sourceNode)
                        connectedNode = this.diagram.nameTable[this.selectedObject.sourceNode];
                    if (this._endPoint == "sourceEndPoint" && this.selectedObject.targetNode)
                        connectedNode = this.diagram.nameTable[this.selectedObject.targetNode];
                }
                if (this.selectedObject && !this.selectedObject._isAnnotationLine)
                    node = ej.datavisualization.Diagram.bpmnHelper.canAllowConnection(this.diagram, connectedNode, node);
            }
            if (node && !(node.segments)) {
                if (!(node.type == "pseudoGroup") && !node.isLane && !node.isSwimlane) {
                    this._showPorts(node);
                    this._currentPossibleConnection = node;
                    if (this._previousPossibleConnection == null || this._previousPossibleConnection.name !== this._currentPossibleConnection.name) {
                        this._previousPossibleConnection = this._currentPossibleConnection;
                    }
                }
                else {
                    this._currentPossibleConnection = null;
                    this._possibleConnectionPort = null;
                }
            }
            else if (this.diagram.activeTool instanceof ej.datavisualization.Diagram.LineTool) {
                this._showPorts();
                this._currentPossibleConnection = null;
                this._possibleConnectionPort = null;
            }
            else {
                var epoint = ej.datavisualization.Diagram.Point(0, 0);
                if (this._endPoint == "targetEndPoint") {
                    epoint.x = this.selectedObject.targetPoint.x - 25;
                    epoint.y = this.selectedObject.targetPoint.y - 25;
                }
                else if (this._endPoint == "sourceEndPoint") {

                    epoint.x = this.selectedObject.sourcePoint.x - 25;
                    epoint.y = this.selectedObject.sourcePoint.y - 25;
                }
                var bounds = ej.datavisualization.Diagram.Rectangle(epoint.x, epoint.y, 50, 50);
                var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(this.diagram._spatialSearch, bounds);
                for (var i = 0; this._nearestNodes && i < this._nearestNodes.length; i++)
                    this._showPort(this._nearestNodes[i], true);
                this._nearestNodes = [];
                for (var i = 0; i < quads.length; i++) {
                    var quad = quads[i];
                    if (quad.objects.length > 0) {
                        for (var j = 0; j < quad.objects.length; j++) {
                            var nd = quad.objects[j];
                            var nodebounds = ej.datavisualization.Diagram.Util.bounds(nd);
                            if (ej.datavisualization.Diagram.Geometry.intersectsRect(bounds, nodebounds)) {
                                if (!nd.segments && nd.visible) {
                                    this._showPort(nd);
                                    this._nearestNodes.push(nd);
                                }
                            }
                            else {
                                if (!nd.segments) {
                                    this._showPort(nd, true);
                                }
                            }
                        }
                    }
                }

                this._currentPossibleConnection = null;
                this._possibleConnectionPort = null;
            }
            if (this._currentPossibleConnection) {
                port = this._findPort(pt, this._currentPossibleConnection);
                if (this._currentPossibleConnection && (this._sourcePossibleConnection || this.selectedObject)) {
                    if (this.selectedObject && !this.selectedObject._isAnnotationLine) {
                        possibleConnector = ej.datavisualization.Diagram.bpmnHelper.canAllowConnection(this.diagram, connectedNode, this._currentPossibleConnection);
                        if (this._currentPossibleConnection != possibleConnector) {
                            this._showPort(this._currentPossibleConnection, true);
                            if (possibleConnector) this._showPort(possibleConnector);
                            port = null;
                        }
                        this._currentPossibleConnection = possibleConnector;
                    }
                }
                if ((port && ej.datavisualization.Diagram.Util.canConnect(port, true)) || ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection)) {
                    ej.datavisualization.Diagram.SvgContext._drawPortHighlighter(port, this._currentPossibleConnection, this.diagram._adornerSvg, this.diagram._adornerLayer,
                        this.diagram._currZoom, this.diagram);
                }
                else {
                    ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
                }
                this._possibleConnectionPort = port;
                if (port && ej.datavisualization.Diagram.Util.canConnect(port, true)) {
                    var connectionNode = this._currentPossibleConnection;
                    var point = ej.datavisualization.Diagram.Util._getPortPosition(this._possibleConnectionPort, ej.datavisualization.Diagram.Util.bounds(connectionNode, true));
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, connectionNode.rotateAngle, connectionNode.offsetX, connectionNode.offsetY);
                    point = ej.Matrix.transform(matrix, point);
                    this.currentPoint = point;
                }
            }
            else {
                if (this._previousPossibleConnection) {
                    this._previousPossibleConnection = null;
                    ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
                    this._possibleConnectionPort = null;
                }
            }

        };
        ToolBase.prototype._showPorts = function (node) {
            if (node) {
                if (this._currentPossibleConnection && this._currentPossibleConnection.name !== node.name) {
                    this._showPort(this._currentPossibleConnection, true);
                }
                this._showPort(node);
            }
            else {
                if (this._currentPossibleConnection != null) {
                    this._showPort(this._currentPossibleConnection, true);
                }
            }
        };
        ToolBase.prototype._showPort = function (node, hide) {
            var ports;
            var port;
            var portShape;
            var i;
            var len;
            if (hide) {
                ports = node.ports;
                if (ports) {
                    for (i = 0, len = ports.length; i < len; ++i) {
                        port = ports[i];
                        if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover ||
                            (port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect &&
                            (this.name == "endPoint" || this instanceof ej.datavisualization.Diagram.LineTool))) {
                            portShape = this.diagram._adornerSvg.getElementById(node.name + "_" + port.name);
                            if (portShape)
                                portShape.setAttribute("visibility", "hidden");
                        }
                    }
                }
            }
            else {
                if (node.visible) {
                    ports = node.ports;
                    if (ports) {
                        for (i = 0, len = ports.length; i < len; ++i) {
                            port = ports[i];
                            if (port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover ||
                                (port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect &&
                                (this.name == "endPoint" && this.inAction || this instanceof ej.datavisualization.Diagram.LineTool))) {
                                portShape = this.diagram._adornerSvg.getElementById(node.name + "_" + port.name);
                                if (portShape)
                                    portShape.setAttribute("visibility", "visible");
                            }
                        }
                    }
                }
            }
        };
        ToolBase.prototype._getAllLaneChildren = function (node, list) {
            var swilane = this.diagram.getNode(node.name)
            if (swilane && swilane.lanes && swilane.lanes.length > 0) {
                for (var i = 0; i < swilane.lanes.length; i++) {
                    for (var j = 0; j < swilane.lanes[i].children.length; j++) {
                        list.push(swilane.lanes[i].children[j]);
                    }
                }
            }
            return list;
        };
        ToolBase.prototype._getAllChildren = function (list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].isSwimlane)
                    list.concat(this._getAllLaneChildren(list[i], list));
            }
            return list;
        };
        ToolBase.prototype._showAllPorts = function (hide) {
            var i;
            var len;
            var nodes = this.diagram.nodes();
            nodes = nodes.slice();
            nodes = this._getAllChildren(nodes);
            if (!ej.datavisualization.Diagram.Util.isPageEditable(this.diagram)) hide = true;
            if (hide) {
                for (i = 0, len = nodes.length; i < len; i++) {
                    this._showPort(nodes[i], hide);
                }
            }
            else {
                for (i = 0, len = nodes.length; i < len; ++i) {
                    this._showPort(nodes[i]);
                }
            }
        };
        ToolBase.prototype._disconnect = function (connector) {
            var args;
            var node = this.diagram.nameTable[connector.targetNode];
            var port = null;
            if (node) {
                port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.targetPort);
                args = this._raiseEvent("connectionChange", { element: connector, connection: null, port: null, cancel: false });
                ej.datavisualization.Diagram.Util.removeItem(node.inEdges, connector.name);
                if (!args.cancel) {
                    connector.targetNode = null;
                    connector.targetPort = null;
                }
            }
            node = this.diagram.nameTable[connector.sourceNode];
            if (node) {
                port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.sourcePort);
                args = this._raiseEvent("connectionChange", { element: connector, connection: null, port: null, cancel: false });
                ej.datavisualization.Diagram.Util.removeItem(node.outEdges, connector.name);
                if (!args.cancel) {
                    connector.sourceNode = null;
                    connector.sourcePort = null;
                }
            }
        };
        ToolBase.prototype.getLabelUnderMouse = function () {
            if (!this.diagram._findLabelEditing)
                return this.activeLabel;
            return null;
        };
        ToolBase.prototype._getNodesfrombounds = function (rect, point) {
            var collection = [], bounds, interSectPoints, i, node, len, points;
            var nodes = this.diagram._sortByZIndex(this.diagram.nodes())
            for (i = 0, len = nodes.length; i < len; i++) {
                node = this.diagram.nameTable[nodes[i].name];
                if (ej.datavisualization.Diagram.Util.canConnect(node)) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(node, false);
                    points = [bounds.points[0], bounds.points[1], bounds.points[2], bounds.points[3], bounds.points[0]];
                    var rectPoint = [{ x: rect.left, y: rect.top },
                             { x: rect.right, y: rect.top },
                             { x: rect.right, y: rect.bottom },
                             { x: rect.left, y: rect.bottom },
                             { x: rect.left, y: rect.top }];
                    this.diagram._autoConnectEndPoint = true;
                    interSectPoints = ej.datavisualization.Diagram.Util.interSect(points, rectPoint, null, this.diagram)
                    delete this.diagram._autoConnectEndPoint;
                    var pointInsideRect = false;
                    if (interSectPoints.length == 0) {
                        pointInsideRect = ej.datavisualization.Diagram.Geometry.containsPoint(bounds, point);
                    }
                    if ((interSectPoints && interSectPoints.length) || pointInsideRect) {
                        collection.push(node);
                    }
                }
            }
            collection = this._getAllChildren(collection);
            return collection;
        };
        ToolBase.prototype._slopDistance = function (point1, point2, point) {
            var x1, y1, x2, y2, x, y;
            x = point.x; y = point.y; x1 = point1.x; y1 = point1.y; x2 = point2.x; y2 = point2.y;
            var A = x - x1; var B = y - y1; var C = x2 - x1; var D = y2 - y1;
            var dot = A * C + B * D;
            var len_sq = C * C + D * D;
            var param = -1;
            if (len_sq != 0)
                param = dot / len_sq;
            var xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            }
            else if (param > 1) {
                xx = x2;
                yy = y2;
            }
            else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            var dx = x - xx;
            var dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        };
        ToolBase.prototype._getNearestNodePorts = function (connector, collection, point, rect) {
            var i, j, node, port, minDist, nearestPort = null, portPoint, bounds, distance, nearestNode = null;
            var matrix, points, slope, nearestPoint = null;
            rect.x = rect.left; rect.y = rect.top;
            rect.width = rect.right - rect.left; rect.height = rect.bottom - rect.top;
            for (i = 0; i < collection.length; i++) {
                node = this.diagram.nameTable[collection[i].name];
                bounds = ej.datavisualization.Diagram.Util.bounds(node);
                for (j = 0; node.ports && node.ports.length > 0 && j < node.ports.length; j++) {
                    port = node.ports[j];
                    portPoint = ej.datavisualization.Diagram.Util._getPortPosition(port, bounds)
                    matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, node.rotateAngle, node.offsetX, node.offsetY);
                    portPoint = ej.Matrix.transform(matrix, portPoint);
                    distance = ej.datavisualization.Diagram.Geometry.distance(portPoint, this.currentPoint);
                    if (!minDist || (minDist && minDist > distance)) {
                        minDist = distance;
                        if (ej.datavisualization.Diagram.Geometry.containsPoint(rect, portPoint)) {
                            nearestPort = port;
                            nearestNode = node;
                        }
                    }
                }
            }
            return { nearestNode: nearestNode, nearestPort: nearestPort };
        };
        ToolBase.prototype._updateConnectionTarget = function (connector, isHelper) {
            var istarget = this._endPoint == "targetEndPoint" ? true : false;
            connector = isHelper ? connector : this.diagram.nameTable[this.diagram._getChild(connector)];
            if (connector) {
                var point = this.currentPoint;
                var rect = {
                    left: point.x - connector._endPointHitPadding.left,
                    top: point.y - connector._endPointHitPadding.top,
                    right: connector._endPointHitPadding.right + point.x,
                    bottom: connector._endPointHitPadding.bottom + point.y
                };
                var collection = this._getNodesfrombounds(rect, point);
                var nearestValues = this._getNearestNodePorts(connector, collection, point, rect);
                if (nearestValues.nearestNode) {
                    this._currentPossibleConnection = nearestValues.nearestNode;
                    if (nearestValues.nearestPort) {
                        if ((ej.datavisualization.Diagram.Util.canConnect(nearestValues.nearestPort, true)) || ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection)) {
                            this._possibleConnectionPort = nearestValues.nearestPort
                        }
                    }
                }
                this._removeHighLighter();
                ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
                if (this._possibleConnectionPort && ej.datavisualization.Diagram.Util.canConnect(this._possibleConnectionPort, true))
                    ej.datavisualization.Diagram.SvgContext._drawPortHighlighter(this._possibleConnectionPort, this._currentPossibleConnection, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom);
                else if (this._currentPossibleConnection && ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection))
                    ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(this._currentPossibleConnection, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom);
                this.diagram._dock(connector, this.diagram.nameTable, true);
            }
        };
        ToolBase.prototype._raiseConnectionChangeEvent = function (connector, isTarget) {
            var args = { element: connector, endPoint: this._endPoint, connection: this._currentPossibleConnection, port: this._possibleConnectionPort, cancel: false };
            var connectionName = args.connection ? args.connection.name : null;
            var portName = args.port ? args.port.name : null;
            if (isTarget) {
                if (connectionName != connector.targetNode || portName != connector.targetPort)
                    args = this._raiseEvent("connectionChange", args);
            }
            else {
                if (connectionName != connector.sourceNode || portName != connector.sourcePort)
                    args = this._raiseEvent("connectionChange", args);
            }

            if (!args.cancel) {
                if (isTarget) {
                    if (!this._currentPossibleConnection || connector.targetNode != this._currentPossibleConnection.name) {
                        if (this._currentPossibleConnection)
                            this._currentPossibleConnection.inEdges.push(connector.name);
                        if (connector.targetNode) {
                            var node = this.diagram.nameTable[connector.targetNode];
                            if (node)
                                ej.datavisualization.Diagram.Util.removeItem(node.inEdges, connector.name);
                        }
                    }
                    var node = this.diagram.nameTable[connector.targetNode];
                    this.diagram._comparePropertyValues(connector, "targetNode", { targetNode: this._currentPossibleConnection ? this._currentPossibleConnection.name : null }, true);
                    connector.targetNode = this._currentPossibleConnection ? this._currentPossibleConnection.name : null;
                    if (node && node._ports) {
                        this._updateInternalPorts(node, connector, true);
                    }
                    this.diagram._comparePropertyValues(connector, "targetPort", { targetPort: this._possibleConnectionPort ? this._possibleConnectionPort.name : null }, true);
                    connector.targetPort = this._possibleConnectionPort ? this._possibleConnectionPort.name : null;
                }
                else {
                    if (!this._currentPossibleConnection || connector.sourceNode != this._currentPossibleConnection.name) {
                        if (this._currentPossibleConnection)
                            this._currentPossibleConnection.outEdges.push(connector.name);
                        if (connector.sourceNode) {
                            var node = this.diagram.nameTable[connector.sourceNode];
                            if (node)
                                ej.datavisualization.Diagram.Util.removeItem(node.outEdges, connector.name);
                        }
                    }
                    var node = this.diagram.nameTable[connector.sourceNode];
                    this.diagram._comparePropertyValues(connector, "sourceNode", { sourceNode: this._currentPossibleConnection ? this._currentPossibleConnection.name : null }, true);
                    connector.sourceNode = this._currentPossibleConnection ? this._currentPossibleConnection.name : null;
                    if (node && node._ports) {
                        this._updateInternalPorts(node, connector, false);
                    }
                    this.diagram._comparePropertyValues(connector, "sourcePort", { sourcePort: this._possibleConnectionPort ? this._possibleConnectionPort.name : null }, true);
                    connector.sourcePort = this._possibleConnectionPort ? this._possibleConnectionPort.name : null;
                }

                return true;
            }
        }

        ToolBase.prototype._updateInternalPorts = function (node, connector, isTarget) {
            var port = ej.datavisualization.Diagram.Util.findPortByName(node, isTarget ? connector.targetPort : connector.sourcePort);
            if (port && port.type === "internal" && port.name === (isTarget ? connector.targetPort : connector.sourcePort)) {
                var idx = node._ports.indexOf(port);
                node._ports.splice(idx, 1);
                if (isTarget) {
                    connector._removeTargetPort = port;
                    connector.targetPort = null;
                }
                else {
                    connector._removeSourcePort = port;
                    connector.sourcePort = null;
                }
                var points = ej.datavisualization.Diagram.Util.getPoints(connector);
                var segments = [];
                segments.push({ points: points, type: "orthogonal" });
                this.diagram._isUndo = true;
                this.diagram.updateConnector(connector.name, { segments: segments });
                delete this.diagram._isUndo;
            }
        }
        return ToolBase;
    })();

    ej.datavisualization.Diagram.ToolBase = ToolBase;
    //#endregion

    //#region SelectTool
    var SelectTool = (function (base) {
        ej.datavisualization.Diagram.extend(SelectTool, base);
        function SelectTool(diagram) {
            base.call(this, "select", diagram);
            this.cursor = "default";
            this._svgHelper = null;
        }
        SelectTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            var node = this._findNodeUnderMouse(evt);
            if (node && ej.datavisualization.Diagram.Util.canSelect(node) && ej.datavisualization.Diagram.Util.enableLayerOption(node, "lock", this.diagram)) {
                this.selectedObject = node;
            }
            else
                this.selectedObject = null;

            this._itemClick(this.selectedObject, this.actualObject, this.selectedObject);
            this._nodeUnderMouseDown = this.diagram._findNodeUnderMouse(evt);
        };
        SelectTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            var node = this._nodeUnderMouseDown;
            if ((!this.selectedObject && !ej.datavisualization.Diagram.Geometry.isEmptyPoint(this.startPoint)) ||
            (node && node.isLane && ej.datavisualization.Diagram.Util.canMultiSelectOnLane(node)) || (node && node._type != "connector" && ej.datavisualization.Diagram.Util.canMultiSelectOnNode(node))) {
                if (ej.datavisualization.Diagram.Util.canDoMultipleSelection(this.diagram)) {
                    if (!this.inAction && (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y)) {
                        this.inAction = true;
                        this._initHelper();
                    }
                    else
                        this._updateHelper();
                }
            }
        };
        SelectTool.prototype.mouseup = function (evt) {
            this.diagram._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.Mouse;
            if (this.inAction) {
                this.currentPoint = this.mousePosition(evt);
                var rect = ej.datavisualization.Diagram.Geometry.rect([{ x: this.startPoint.x, y: this.startPoint.y }, { x: this.currentPoint.x, y: this.currentPoint.y }]);
                if (rect.width !== 0 || rect.height !== 0) {
                    var collection = [];
                    collection = this.diagram._getNodesfrombounds(rect);
                    if (this.diagram._hasSelection()) {
                        collection = this.diagram._getChildren(collection);
                        ej.datavisualization.Diagram.Util.removeItem(collection, "multipleSelection");
                        this.diagram._clearSelection(collection.length ? true : false);
                    }
                    if (collection.length > 0) {
                        var children = collection;
                        var selection;
                        this.diagram._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.RubberBand
                        if (children.length > 1) {
                            var pseudoGroup = ej.datavisualization.Diagram.Group({ type: "pseudoGroup", "name": "multipleSelection" });
                            for (var i = 0 ; i < children.length; i++) {
                                //children[i].parent = "multipleSelection";
                                pseudoGroup.children.push(this.diagram._getChild(children[i]));
                            }
                            this.diagram.nodes().push(pseudoGroup);
                            this.diagram._nodes = $.extend(true, [], this.diagram.nodes());
                            this.diagram.nameTable[pseudoGroup.name] = pseudoGroup;
                            selection = pseudoGroup;
                        }
                        else {
                            if (ej.datavisualization.Diagram.Util.canDoSingleSelection(this.diagram))
                                selection = collection[0];
                        }
                        if (selection) {
                            if (selection._type === "group" || selection.type === "pseudoGroup")
                                ej.datavisualization.Diagram.Util._updateGroupBounds(selection, this.diagram);
                            this.diagram._addSelection(selection);
                        }
                    }
                }
                else {
                    if (this.diagram._hasSelection() && !this.diagram._isDropped) {
                        this.diagram._clearSelection();
                    }
                }
            }
            else {
                if (this.selectedObject || this.diagram._hasSelection()) {
                    if (evt.ctrlKey || evt.shiftKey) {
                        if (ej.datavisualization.Diagram.Util.canDoMultipleSelection(this.diagram)) {
                            this._processCtrlKey(evt);
                        }
                    }
                    else if (this.diagram._hasSelection() && (!this.selectedObject || (this.diagram.selectionList[0].name != this.selectedObject.name)))
                        this.diagram._clearSelection(this.selectedObject ? true : false);
                    this.diagram._enableAPIMethods = false;
                    this.diagram._addSelection(this.selectedObject);
                    this.diagram._enableAPIMethods = true;
                }
                else if (this.diagram._hasSelection() && !this.diagram._isDropped) {
                    this.diagram._clearSelection();
                }
            }
            this.diagram._isDropped = false;
            this._nodeUnderMouseDown = null;
            if (this.selectedObject || this.actualObject) {
                var obj = this._findNodeUnderMouse(evt);
                var mousePosition = this.diagram._mousePosition(evt.originalEvent);
                this._raiseEvent("click", { element: this.diagram.getNode(obj), actualObject: this.actualObject, count: this.diagram._getEventDetail(evt), offsetX: mousePosition.x, offsetY: mousePosition.y, event: evt });
            }
            base.prototype.mouseup.call(this, evt);

        };
        SelectTool.prototype._endAction = function () {
            if (this._svgHelper) {
                this.diagram._adornerLayer.removeChild(this._svgHelper);
                this.selectedObject = null;
                this._svgHelper = null;
            }
            base.prototype._endAction.apply(this);
        };
        SelectTool.prototype._initHelper = function () {
            if (!this._svgHelper) {
                var g = this.diagram._adornerSvg.g();
                this.diagram._adornerLayer.appendChild(g);

                var scale = this.diagram._currZoom;
                var selectionRect = this.diagram._svg.rect({
                    "id": "helper", "class": "rubberBandSelection", "x": this.startPoint.x * scale, "y": this.startPoint.y * scale,
                    "fill": "transparent", "stroke": "gray", "stroke-dasharray": "2 2", "shape-rendering": "crispEdges"
                });
                g.appendChild(selectionRect);
                g.setAttribute("pointer-events", "none");
                this._svgHelper = g;
            }
        };
        SelectTool.prototype._updateHelper = function () {
            var helper = this.diagram._adornerSvg.getElementById("helper");
            var width = Math.abs(this.startPoint.x - this.currentPoint.x);
            var height = Math.abs(this.startPoint.y - this.currentPoint.y);
            var scale = this.diagram._currZoom;
            var x = ((this.startPoint.x > this.currentPoint.x) ? this.currentPoint.x : this.startPoint.x) * scale;
            var y = ((this.startPoint.y > this.currentPoint.y) ? this.currentPoint.y : this.startPoint.y) * scale;

            if (helper) {
                this.diagram._adornerSvg.rect({
                    "id": helper.id, "x": x,
                    "y": y, "width": width * scale, "height": height * scale
                });
            }
        };
        return SelectTool;
    })(ToolBase);

    ej.datavisualization.Diagram.SelectTool = SelectTool;
    //#endregion

    //#region MoveTool
    var MoveTool = (function (base) {

        ej.datavisualization.Diagram.extend(MoveTool, base);

        function MoveTool(diagram) {
            base.call(this, "move", diagram);
            this.cursor = "move";
            this._isMouseDown = false;
            this.diffx = 0;
            this.diffy = 0;
            this.helper = null;
            this.hoverNode = null;
            this.stackOverNode = null;
            this.undoObject = [];
            this.activeLabel = null;
            this._canMoveLabel = false;
            this.dragState = "";
        }

        MoveTool.prototype.mousedown = function (evt) {
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            this.diffx = 0;
            this.diffy = 0;
            this._allowPan(this.selectedObject, "mousedown", evt);
            base.prototype.mousedown.call(this, evt);
            this._isMouseDown = true;
            this._canMoveLabel = false;
            this.activeLabel = null;
            if (evt)
                var node = this._findNodeUnderMouse(evt);
            if (node && !ej.datavisualization.Diagram.Util.canSelect(node) && ej.datavisualization.Diagram.Util.enableLayerOption(node, "lock", this.diagram)) {
                this.updateCursor("default");
            }
            else if (this.diagram._currentCursor != "pointer")
                this.updateCursor(this.cursor);
            this.dragState = ej.datavisualization.Diagram.DragState.Starting;
        };

        MoveTool.prototype.mousemove = function (evt) {
            this.diagram._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.Mouse;
            this._allowPan(this.selectedObject, "mousemove", evt);
            base.prototype.mousemove.call(this, evt);
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            var start = !this.inAction;
            //Initiate move action
            if (this._isMouseDown && !this.inAction &&
                (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y || this.diagram._selectedSymbol)) {
                if (!this.selectedObject && ((this.diagram.selectionList && this.diagram.selectionList[0] && this.diagram.selectionList[0].type === "pseudoGroup") || this.diagram._selectedSymbol || (ej.datavisualization.Diagram.Util.canDoSingleSelection(this.diagram)))) {
                    //set the selected object
                    this._updateSelectedObject();
                    // raise item click event
                    //var tempVal = this.selectedObject;
                    //var args = this._raiseEvent("itemClick",
                    //    { actualObject: this.actualObject, selectedObject: this.selectedObject, model: this.diagram.model, cancel: false });
                    this._itemClick(this.selectedObject, this.actualObject, this.diagram.model);
                    //if (args.cancel)
                    //this.selectedObject = tempVal;
                    if (this.selectedObject != null) {
                        var newbounds, oldbounds;
                        newbounds = oldbounds = ej.datavisualization.Diagram.Util.bounds(this.selectedObject);
                        var oldValue = { bounds: { x: oldbounds.x, y: oldbounds.y, width: oldbounds.width, height: oldbounds.height }, offsetX: this.selectedObject.offsetX, offsetY: this.selectedObject.offsetY, width: this.selectedObject.width, height: this.selectedObject.height };
                        var newValue = { bounds: { x: newbounds.x, y: newbounds.y, width: newbounds.width, height: newbounds.height }, offsetX: this.selectedObject.offsetX, offsetY: this.selectedObject.offsetY, width: this.selectedObject.width, height: this.selectedObject.height };
                        if (this.diagram.selectionList[0] != this.selectedObject)
                            this.diagram._clearSelection(true);
                        this._raiseDragEvent({ element: this.diagram.getNode(this.selectedObject), offset: { x: 0, y: 0 }, oldValue: oldValue, newValue: newValue, cancel: false });
                        var childTable = {};
                        if (this.selectedObject && (this.selectedObject._type === "group" || this.selectedObject.type === "pseudoGroup"))
                            childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                        var data = $.extend(true, {}, { "childTable": childTable, "node": this.selectedObject });
                        this.undoObject = jQuery.extend(true, {}, data);
                    }
                }
            }

            if (this._isMouseDown && this.selectedObject && ej.datavisualization.Diagram.Util.canSelect(this.selectedObject) && !this.diagram._isEditing && ej.datavisualization.Diagram.Util.enableLayerOption(this.selectedObject, "lock", this.diagram)) {
                this.dragState = ej.datavisualization.Diagram.DragState.Dragging;
                if (!this.inAction) {
                    this.inAction = true;
                    this.updateCursor("move");
                    this._updateSelection();
                    //Disconnect the connector, if it is being dragged
                    if (this.selectedObject.segments) {
                        if (ej.datavisualization.Diagram.Util.isTargetConnected(this.selectedObject) ||
                            ej.datavisualization.Diagram.Util.isSourceConnected(this.selectedObject)) {
                            this._disconnect(this.selectedObject);
                        }
                    }
                    //disable pointer events to the selected object
                    ej.datavisualization.Diagram.SvgContext._disableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                }

                if (this.diagram && !this.diagram._isEditing) {
                    this._containerMouseMove(evt);

                    //visually update the selected object
                    if (!this.helper)
                        this._updateObject();
                    //update the tooltip
                    if (!this.selectedObject.segments && !this.selectedObject.isLane)
                        this.diagram._renderTooltip(this.selectedObject, start);
                    //not needed since it is enough to update the selection for the first time
                    //this._updateSelection();
                    this.diagram._updateSelectionHandle(true);
                }
            }
            this.previousPoint = this.currentPoint;
            this._stackOverNode = this._findStackOverNode(this.helper, evt);
            delete this.diagram._notAllow;
        };

        //set the selected object
        MoveTool.prototype._updateSelectedObject = function () {
            var selectedObject = this.diagram._focusedElement;
            if (selectedObject) {
                if (this.diagram.selectionList[0] && this.diagram.selectionList[0].type == "pseudoGroup") {
                    this.selectedObject = this.diagram.selectionList[0];
                } else {
                    if (this.diagram.selectionList[0] != selectedObject) {
                        this.diagram._clearSelection(true);
                        this.selectedObject = this.diagram.nameTable[selectedObject.name];
                    } else {
                        this.selectedObject = this.diagram.nameTable[this.diagram.selectionList[0].name];
                    }
                }
            }
        };
        MoveTool.prototype._nodeCanHighlight = function (hoverNode) {
            var status = false;
            if ((this.diagram._getChildren(hoverNode.children)).indexOf(this.selectedObject.name) == -1) {
                if (this.selectedObject._type != "group") {
                    status = true;
                }
                else {
                    if (hoverNode._type === "group") {
                        if (!this._containsChild(this.selectedObject, hoverNode.name))
                            status = true;
                    }
                }
            }
            return status;
        },
        MoveTool.prototype._swimlanPhaseDrag = function (evt) {
            if (this.selectedObject && this.selectedObject.isPhase) {
                var swimlane = null;
                var btmNode = this._getNodeUnderMouse();
                if (btmNode)
                    swimlane = this._getSwimLaneNode(btmNode, this.selectedObject, true);
                if (swimlane) {
                    ej.datavisualization.Diagram.SvgContext._drawNodeHighlighter(swimlane, this.diagram._adornerSvg, this.diagram._adornerLayer, this.diagram._currZoom);
                }
            }
        };
        MoveTool.prototype._containerMouseMove = function (evt) {
            //#region for Container
            var overNode, gHighLight;
            var parent = this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent];
            if (parent && parent.container) {
                var container = parent.container;
                if (container.type == "canvas" || container.type == "stack") {
                    ej.datavisualization.Diagram.canvasHelper._updateHelper(this.diagram);
                    ej.datavisualization.Diagram.canvasHelper._updateHighlighter(this.diagram, evt);
                }
            } else {
                if (!this.selectedObject.isSwimlane) {
                    if ((this.selectedObject.type == "pseudoGroup") && this._isParentAsLane(this.selectedObject)) {
                        this._removeHighLighter();
                    }
                    else if (!this.isDiagram(evt) && !this.selectedObject.segments) {
                        overNode = this._getNodeUnderMouse();
                        //this.hoverNode = this.stackOverNode;
                        if (overNode && overNode.container && (this.selectedObject.isSwimlane || this.selectedObject.isLane)) {
                            if (this._getSwimLaneNode(overNode, this.selectedObject))
                                this._nodeHighLighter(overNode);
                        }
                        else if (overNode && overNode.container && overNode.container.type != "stack") {
                            if (this.selectedObject.name != overNode.name && this.selectedObject.type != "pseudoGroup" && ej.datavisualization.Diagram.bpmnHelper.canAllowDropOnContainer(this.selectedObject, overNode))
                                this._nodeHighLighter(overNode);

                            if (overNode && (this.selectedObject.type == "pseudoGroup" || this.selectedObject.name == "multipleSelection")) {
                                if (this._fromDiagram(this.selectedObject.children)) {
                                    this._nodeHighLighter(overNode);
                                }
                            }
                        }
                        else if (overNode) {
                            this._removeHighLighter();
                            if (!overNode.segments)
                                this._nodeHighLighter(overNode);
                            else {
                                ej.datavisualization.Diagram.SvgContext._drawConnectorHighlighter(overNode, this.diagram, this.diagram._currZoom);
                            }
                        }
                    }
                    else if (!this.isDiagram(evt) && this.selectedObject.isPhase) {
                        ej.datavisualization.Diagram.SvgContext._disableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                    }
                    else
                        this._removeHighLighter();
                }
                if (!gHighLight) {
                    if (this.selectedObject.type == "pseudoGroup") {
                        if (this._fromDiagram(this.diagram._getChildren(this.selectedObject.children))) {
                            if (!this._undoObject)
                                ej.datavisualization.Diagram.Util._getUndoObject(this.diagram, this.selectedObject);
                            this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);
                        }
                        else if ((this._fromSameContainer(this.diagram._getChildren(this.selectedObject.children)) && this.hasSameParent()) || this._anyFromContainer(this.diagram._getChildren(this.selectedObject.children))) {

                            this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);

                        }
                    }
                    else if (ej.datavisualization.Diagram.Util.canMove(this.selectedObject))
                        this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);
                }
            }
            //#endregion  
            this._swimlanPhaseDrag(evt);
        };

        MoveTool.prototype.isDiagram = function (evt) {
            if (evt.target.id == this.diagram._id + "_canvas_svg" || evt.target.id.match(this.selectedObject.name))
                return true;
            else
                return false;
        };
        MoveTool.prototype._allowPan = function (node, moveType, evt) {
            if (moveType === "mousedown")
                this.diagram.tools["panTool"].mousedown(evt);
            if (node && (node._type === "group" || node._type == "node") && (node.constraints & ej.datavisualization.Diagram.NodeConstraints.AllowPan)) {
                if (moveType === "mousemove")
                    this.diagram.tools["panTool"].mousemove(evt);
                else if (moveType === "mouseup")
                    this.diagram.tools["panTool"].mouseup(evt);
            }
        };
        MoveTool.prototype._checkForDropEvent = function (hoverNode, skip) {
            if (!this.diagram._selectedSymbol) {
                var source = this.diagram, target = hoverNode, childBounds = null, objectType = ej.datavisualization.Diagram.ObjectTypes.Diagram;
                if (this.selectedObject && this.selectedObject.parent) {
                    source = this.diagram.nameTable[this.selectedObject.parent];
                    if (source.isLane) objectType = ej.datavisualization.Diagram.ObjectTypes.Lane;
                    else if (source._type == "group") objectType = ej.datavisualization.Diagram.ObjectTypes.Group;
                }
                if (hoverNode && !skip) {
                    childBounds = ej.datavisualization.Diagram.Util.bounds(hoverNode);
                    target = this._getTargetNode(hoverNode, childBounds);
                }
                do {
                    if (hoverNode && !ej.datavisualization.Diagram.Util.canAllowDrop(hoverNode)) {
                        if (hoverNode.parent) hoverNode = this.diagram.nameTable[hoverNode.parent];
                        else
                            if (hoverNode.container) {
                                break;
                            }
                            else
                                hoverNode = null;
                    }
                    else break;
                } while (hoverNode);
                if (hoverNode) {
                    var args = this._raiseEvent("drop", { cancel: false, element: this.selectedObject, source: this.diagram.getNode(source), target: this.diagram.getNode(target), sourceType: objectType });
                    return args.cancel;
                }
            }
            return false;
        };

        MoveTool.prototype._getSwimLaneNode = function (node, selNode, isPhase) {
            if (node.isSwimlane) {
                if (isPhase) {
                    if (this.diagram.nameTable[this.diagram._getChild(node.children[2])].container.orientation == selNode.orientation)
                        return node;
                }
                else if (this.diagram.nameTable[this.diagram._getChild(node.children[2])].container.orientation != selNode.orientation)
                    return node;
            }
            if (node.parent) {
                var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    return this._getSwimLaneNode(parent, selNode, isPhase);
                }
            }
            return null;
        };
        MoveTool.prototype._cloneGroupNode = function (node, id) {
            var child = null, child1, clnObj, node1;
            node1 = $.extend(true, {}, node);
            node1.name += id;
            if (node && node._type === "group") {
                node1.children = [];
                var children = this.diagram._getChildren(node.children);
                for (var i = 0; i < children.length; i++) {
                    child = this.diagram.nameTable[children[i]];
                    child1 = $.extend(true, {}, child);
                    child1.name += id;
                    if (child1.parent)
                        child1.parent += id;
                    if (child1._type === "group")
                        this._cloneGroupNode(child1, id);
                    this.diagram.nameTable[child1.name] = child1;
                    node1.children.push(child1);
                }
            }
            return node1;
        };
        MoveTool.prototype._outOfBoundsLaneDrop = function (node, swimlane) {
            if (node && node.isLane && ej.datavisualization.Diagram.Util.canMoveOutofBoundary(this.diagram)) {
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                var size = this._getPageBounds();
                var offsetX = swimlane.offsetX, offsetY = swimlane.offsetY, height = 0, width = 0, phaseSize = 0, headHeight = 0;
                var laneStack = this.diagram.nameTable[this.diagram._getChild(swimlane.children[2])];
                var header = this.diagram.nameTable[this.diagram._getChild(swimlane.children[0])];
                headHeight = header ? header.height : headHeight;
                phaseSize = swimlane.phaseSize ? swimlane.phaseSize : phaseSize;
                if (laneStack) {
                    var lane = this.diagram.nameTable[this.diagram._getChild(laneStack.children[0])];
                    if (lane) {
                        height = lane.minHeight > 100 ? lane.minHeight : 100;
                        width = lane.minWidth > 100 ? lane.minWidth : 100;
                    }
                }
                if (node.orientation === "horizontal") {
                    var aX = width;
                    var aY = height + header.height + phaseSize;
                }
                else {
                    var aX = width + phaseSize;
                    var aY = height + header.height;
                }

                if (offsetX + aX / 2 + 5 >= size.width || offsetX - aX / 2 - 5 <= size.x) {
                    return false
                }
                if (offsetY + aY / 2 + 5 >= size.height || offsetY - aY / 2 - 5 <= size.y) {
                    return false
                }

            }
            return true;
        };
        MoveTool.prototype._getMouseOverElement = function (evt, mouseup) {
            var node = null;
            if (evt && evt.target) {
                var parents = $(evt.target).parents(".ej-d-node,.ej-d-connector,.ej-d-group,.ej-d-group ej-d-classifier,.ej-d-node ej-d-classifier,.ej-d-label ej-d-classifier");
                var parent = parents[0];
                var i = 1;
                while (parent) {
                    var foreignObject = this.diagram._isForeignObject(evt.target);
                    if (foreignObject)
                        node = this.diagram._findNode(parent.getAttribute("id").split('_parentdiv')[0]);
                    else {
                        node = this.diagram._findNode(parent.getAttribute("id"));
                        if (!node) node = this.diagram._findNode(parent.getAttribute("id").split("_label")[0]);
                    }
                    if (node && node.container) {
                        parent = null;
                    } else {
                        if (node && mouseup && node._isHeader && node.parent) {
                            var pObj = this.diagram.nameTable[node.parent];
                            if (pObj && pObj.isSwimlane) {
                                break;
                            }
                        }
                        parent = parents[i];
                        if (!parent && node && node.parent) {
                            var parentObj = this.diagram.nameTable[node.parent];
                            if (parentObj && parentObj.isLane)
                                node = parentObj;
                        }
                        i++;
                    }
                }
            }
            return node;
        };
        MoveTool.prototype._multiNodedrag = function (evt, overNode) {
            if (ej.datavisualization.Diagram.canvasHelper && !this._containsSwimlane(this.selectedObject.children))
                ej.datavisualization.Diagram.canvasHelper._multiNodedrag(this.diagram, evt, this.selectedObject);
        },
        MoveTool.prototype._changeNodeState = function (evt, doc, mouseup) {
            var newObj, pNode, mergNode = null;
            var overNode = this._getMouseOverElement(evt, mouseup);
            if (overNode) overNode = (this.selectedObject && !this.selectedObject.isLane || overNode.isLane) ? overNode : null;
            //#region drop fropm palette
            if (this.diagram._selectedSymbol && this.diagram._selectedSymbol.isLane && !doc) {
                this.diagram._isDragg = true;
                if (overNode)
                    mergNode = this._getSwimLaneNode(overNode, this.selectedObject);
                if (overNode && mergNode) {
                    ej.datavisualization.Diagram.canvasHelper._addNewLane(this.diagram, overNode, mergNode);
                }
                else {
                    //add new stack
                    var header = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                    this.diagram._isUndo = true;
                    this.diagram.remove(this.selectedObject);
                    ej.datavisualization.Diagram.containerCommon._removeObject(this.diagram, this.selectedObject);
                    if (this.diagram._selectedSymbol)
                        ej.datavisualization.Diagram.containerCommon._removeObject(this.diagram, this.diagram._selectedSymbol);
                    this.diagram._isUndo = false;


                    var swimlane = ej.datavisualization.Diagram.SwimLaneHelper._createSwimlane(this.selectedObject, this.diagram, null, null, header);
                    if (swimlane) {
                        var args;
                        args = { element: this.diagram.getNode(this.selectedObject), cancel: false };

                        this.diagram._selectedSymbol = null;
                        if (this._outOfBoundsLaneDrop(this.selectedObject, swimlane)) {
                            this.diagram._raiseDropEvent(args);
                            if (!args.cancel) {
                                this.diagram._eventCause["nodeCollectionChange"] = ej.datavisualization.Diagram.CollectionChangeCause.Drop;
                                if (this.diagram.add(swimlane)) {
                                    swimlane = this.diagram.nameTable[swimlane.name] || swimlane;
                                    this.diagram._selectedSymbol = swimlane;
                                    this.diagram._updateDroppedSymbol(swimlane);
                                    this.selectedObject = swimlane;
                                }
                                else {
                                    this.selectedObject = null;
                                }
                            }
                            else {
                                this.selectedObject = null;
                            }
                        }
                        else this.selectedObject = null;
                    }
                }
            }//#endregion
                //#region for Container 
            else if (this.selectedObject && this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent].container) {
                var selectedParent = this.diagram.nameTable[this.selectedObject.parent];
                if (selectedParent) {
                    var container = selectedParent.container;
                    this._removeHelpers();
                    if (container && container.type == "canvas") {
                        ej.datavisualization.Diagram.SvgContext._showNode(this.selectedObject, this.diagram._svg);
                        if (this.selectedObject.type != "pseudoGroup" && !this.diagram._isDragg)
                            this._swimlaneNodeDragged = ej.datavisualization.Diagram.canvasHelper._singleNodedrag(this.diagram, evt, overNode);
                    } else if (container.type == "stack") {
                        ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                    } else { //add to diagram
                        if (this.isDiagram(evt)) {
                            this._addToDiagram();
                        }
                        this.diffx = this.diffy = 0;
                    }
                }
            }
            else {///added from diagram to container
                if (this.selectedObject && !this.selectedObject.isSwimlane) {
                    if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent()) {
                        this.currentPoint = this.previousPoint;
                        this.diffx = 0; this.diffy = 0;
                        this._removeHelpers();
                        this._multiNodedrag(evt, overNode);
                    }
                    else if ((this.selectedObject.type != "connector" || this.selectedObject.isPhase) && !this.isDiagram(evt) && this.selectedObject.type != "pseudoGroup") {
                        var overNode = this._getMouseOverElement(evt);
                        if (!this.diagram._isDragg) {
                            if (overNode && overNode.container && ej.datavisualization.Diagram.Util.canAllowDrop(overNode) && (!this._checkForDropEvent(overNode)) && !overNode.isSwimlane && ej.datavisualization.Diagram.bpmnHelper.canAllowDropOnContainer(this.selectedObject, overNode)) {
                                var drgNode = this.helper ? this.helper : this.selectedObject;
                                if (ej.datavisualization.Diagram.canvasHelper._outOfBoundaryNodeDrop(this.diagram, drgNode, overNode)) {
                                    ej.datavisualization.Diagram.canvasHelper._addNodeToContainer(this.diagram, this.selectedObject, overNode);
                                    var cause1 = this.diagram._isUndo ? ej.datavisualization.Diagram.GroupChangeCause.HistoryChange : ej.datavisualization.Diagram.GroupChangeCause.Drop;
                                    this.diagram._raiseGroupChangeEvent(this.selectedObject, null, overNode, cause1);
                                }
                                else {
                                    this.diagram._translate(this.selectedObject, (this.undoObject.node.offsetX - this.selectedObject.offsetX), (this.undoObject.node.offsetY - this.selectedObject.offsetY), this.diagram.nameTable);
                                    this.diagram._updateAssociatedConnectorEnds(this.selectedObject, this.diagram.nameTable);
                                }
                            }
                            else if (overNode && this.selectedObject.name != overNode.name) {
                                this._checkForDropEvent(overNode, true);
                            }
                        }
                    }
                    else {
                        if (this.selectedObject.type != "connector" || this.selectedObject.isPhase) {
                            var oldParent = ""
                            if ((this.selectedObject.type == "pseudoGroup" || this.selectedObject.name == "multipleSelection") && this.diagram._activeSwimLane) {
                                //this._updateChildContainer(this.selectedObject);
                                this._multiNodedrag(evt, overNode);
                                this.diagram._raiseGroupChangeEvent(this.selectedObject, null, this.diagram._activeSwimLane, "group")
                                this.selectedObject = null;
                            }
                            else if (!this.diagram._activeSwimLane && overNode && overNode.isLane) {
                                this.diagram._activeSwimLane = this._getParentSwimlane(overNode);
                                //this._updateChildContainer(this.selectedObject);
                                this._multiNodedrag(evt, overNode);
                                this.diagram._raiseGroupChangeEvent(this.selectedObject, null, overNode, "group")
                                this.selectedObject = null;
                            }
                            else if (overNode && (overNode.type == "bpmn" || overNode.container)) {
                                this._multiNodedrag(evt, overNode);
                                this.diagram._raiseGroupChangeEvent(this.selectedObject, null, overNode, "group")
                                this.selectedObject = null;
                            }
                        }
                        else if (overNode && (this.selectedObject.type == "pseudoGroup" || this.selectedObject.name == "multipleSelection")) {
                            if (this._fromDiagram(this.selectedObject.children)) {
                                if (ej.datavisualization.Diagram.Util.canAllowDrop(overNode)) {
                                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                                    ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
                                    this._multiNodedrag(evt, overNode);
                                }

                            }
                        }
                    }
                }
            }
            this._removeHelpers();
            this._checkPhaseDrop(evt);
            return newObj;
            //#endregion   
        };
        MoveTool.prototype._checkPhaseDrop = function (evt) {
            var swimlane = null, nOffset, orientation;
            if (this.selectedObject && this.selectedObject.isPhase) {
                var btmNode = this._findNodeUnderMouse(evt);
                if (btmNode)
                    swimlane = this._getSwimLaneNode(btmNode, this.selectedObject, true);
                if (swimlane) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                    ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
                    var swimlaneHeader = this._getSwimlaneHeader(swimlane)
                    if (this.selectedObject.orientation == "vertical") {
                        nOffset = this.currentPoint.x - (swimlane.offsetX - (swimlane.width / 2));
                        orientation = "horizontal";
                    }
                    else {
                        nOffset = this.currentPoint.y - (swimlane.offsetY - (swimlane.height / 2));
                        nOffset -= swimlaneHeader ? swimlaneHeader.height : 0;
                        orientation = "vertical";
                    }
                    var args;
                    args = { element: this.selectedObject, cancel: false, target: swimlane };
                    this.diagram._dropPhase = true;
                    this.diagram.remove(this.selectedObject);
                    delete this.diagram._dropPhase;
                    this.diagram._selectedSymbol = null;
                    this.inAction = false;
                    var label = (this.selectedObject.labels && this.selectedObject.labels.length > 0) ? this.selectedObject.labels[0] : { text: "Phase" };
                    this.diagram._addPhase(swimlane.name, {
                        name: ej.datavisualization.Diagram.Util.randomId(), offset: nOffset, orientation: orientation,
                        label: label,
                        lineColor: this.selectedObject.lineColor,
                        lineDashArray: this.selectedObject.lineDashArray,
                        lineWidth: this.selectedObject.lineWidth,
                    });
                    this.diagram._selectedSymbol = null;
                }
                else {
                    this.diagram._remove(this.selectedObject);
                    this.diagram._clearSelection(true);
                    this.selectedObject = null;
                    this.diagram._selectedSymbol = null;
                }
            }
        };
        MoveTool.prototype._removeHelpers = function () {
            ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
            ej.datavisualization.Diagram.SvgContext._removeConnectorHighlighter(this.diagram._adornerLayer, this.diagram._adornerSvg);
            this._removeHighLighter();
            this.diffx = 0;
            this.diffy = 0;
        };
        MoveTool.prototype._updateNodeState = function (evt, newObj) {
            if (this.diagram.nameTable[this.selectedObject.parent])
                var container = this.diagram.nameTable[this.selectedObject.parent].container;
            var overNode = this._getNodeUnderMouse();
            if (overNode) overNode = (!this.selectedObject.isLane || overNode.isLane) ? overNode : null;
            if (container) {
                if (container.type == "canvas") {
                    if (overNode && newObj) {
                        var pNode = this.selectedObject.parent;
                        var swimlane = this.diagram._getSwimlane(pNode);
                        if (swimlane)
                            this.diagram._updateChildAdjacentConnectors(swimlane, true);
                        ej.datavisualization.Diagram.DiagramContext.update(newObj, this.diagram);
                    }
                }
                else if (container.type == "stack") {
                    var evtArgs = this._checkForDropEvent(overNode);
                    if (!evtArgs) {
                        var stackOverNode = this._stackOverNode;
                        if (stackOverNode) {
                            var parent = this.diagram.nameTable[stackOverNode.parent];
                            if (!parent) parent = overNode;
                            var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(parent);
                            var grAngle = parent.rotateAngle;
                            if (!(parent.rotateAngle == 0) && (grAngle == 0))
                                this.diagram._rotate(parent, -parent.rotateAngle, this.diagram.nameTable);
                            parent.children = this.diagram._getChildren(parent.children);
                            if (this.selectedObject.name != stackOverNode.name) {
                                ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this.diagram)
                                ej.datavisualization.Diagram.canvasHelper._swapLane(this.diagram, parent.children, this.selectedObject.name, stackOverNode.name, ((parent.container.orientation === "vertical") ? true : false), parent);
                                if (parent.children && parent.children.length > 0) {
                                    for (var i = 0; i < parent.children.length; i++) {
                                        parent.children[i] = this.diagram.nameTable[parent.children[i]];
                                    }
                                }
                            }

                        } else {
                            this.diffx = this.diffy = 0;
                        }
                    }
                }
            }
            else if (this.selectedObject.type == "pseudoGroup") {
                var fNode = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                if (fNode && fNode.parent)
                    container = this.diagram.nameTable[fNode.parent].container;
                if (container && container.type == "canvas") {
                    if (overNode && newObj) {
                        pNode = this.selectedObject.parent;
                        this.diagram._updateChildAdjacentConnectors(pNode, true);
                        ej.datavisualization.Diagram.DiagramContext.update(newObj, this.diagram);
                    }
                }
            }
            if (this.selectedObject && this.selectedObject.lebels && this.selectedObject.lebels.length > 0 && this.diagram.nameTable[this.selectedObject.name]) {
                this.diagram._updateQuad(this.selectedObject);
            }
        };
        MoveTool.prototype.mouseup = function (evt, doc) {
            var skip = this.inAction;
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            var clickedObject, newObj;
            this.diagram._eventCause["selectionChange"] = ej.datavisualization.Diagram.SelectionChangeCause.Mouse;
            if (this.inAction) {
                this.dragState = ej.datavisualization.Diagram.DragState.Completed;
                ej.datavisualization.Diagram.SvgContext._enableSelectedNode(this.selectedObject, this.diagram._svg, this.diagram);
                newObj = this._changeNodeState(evt, doc, true);
                this.inAction = false;
                if (this.selectedObject) {
                    var newbounds, oldbounds;
                    newbounds = oldbounds = ej.datavisualization.Diagram.Util.bounds(this.selectedObject);
                    var oldValue = { bounds: { x: oldbounds.x, y: oldbounds.y, width: oldbounds.width, height: oldbounds.height }, offsetX: this.selectedObject.offsetX, offsetY: this.selectedObject.offsetY, width: this.selectedObject.width, height: this.selectedObject.height };
                    var newValue = { bounds: { x: newbounds.x, y: newbounds.y, width: newbounds.width, height: newbounds.height }, offsetX: this.selectedObject.offsetX, offsetY: this.selectedObject.offsetY, width: this.selectedObject.width, height: this.selectedObject.height };
                    if (!this.selectedObject.isLane) {
                        if (!this._swimlaneNodedragged)
                            var endAction = this._updateXY(this.selectedObject, this.previousPoint, this.currentPoint);
                        if (!(this.selectedObject && this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent].container) || !newObj) {
                            this._raiseDragEvent({ element: this.diagram.getNode(this.selectedObject), offset: { x: 0, y: 0 }, oldValue: oldValue, newValue: newValue, cancel: false });
                            this.dragState = "";

                        }
                        if (ej.datavisualization.Diagram.Util.canRouteDiagram(this.diagram)) {
                            this.undoObject.connectors = {};
                            this._redoConnectors = {};
                            this.diagram._updateAllEdges(this.selectedObject);
                        }
                    }
                    //#region for Container
                    if (!doc) this._updateNodeState(evt, newObj);
                    //#endregion 
                    this._updateObject();
                    var data;
                    var childTable = {};
                    if (this.selectedObject._type === "group" || this.selectedObject.type === "pseudoGroup")
                        childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                    if (!this.diagram._selectedSymbol && !this.selectedObject.isPhase && !this.selectedObject.isLane && !this._isLane && !this.diagram._isDragg) {
                        var temp = { "childTable": childTable, "node": this.selectedObject };
                        if (ej.datavisualization.Diagram.Util.canRouteDiagram(this.diagram) && this._redoConnectors) {
                            temp.connectors = this._redoConnectors;
                        }
                        data = $.extend(true, {}, temp);
                        var entry = { type: "positionchanged", undoObject: jQuery.extend(true, {}, this.undoObject), redoObject: jQuery.extend(true, {}, data), isMultipleNode: (this.selectedObject._type === "group") ? true : false, category: "internal", activeLabel: this.activeLabel };
                        if (!this._multipleUndo)
                            this.diagram.addHistoryEntry(entry);
                        if (this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent].type == "bpmn" && this.diagram._isGroupActionEnabled) {
                            this.diagram._closeGroupAction();
                            delete this.diagram._isGroupActionEnabled;
                        }
                    }
                    if (this.diagram._selectedSymbol && this.diagram._selectedSymbol.isSwimlane) this.diagram._selectedSymbol = null;
                    this.diagram._updateSelectionHandle();
                    clickedObject = this.selectedObject;
                    this._isLane = false;
                    this._multipleUndo = false;
                }
            }
            else {
                if (!this.selectedObject) {
                    if (evt.ctrlKey || evt.shiftKey) {
                        clickedObject = this._processCtrlKey(evt);
                    }
                    else {
                        var isMulSelect = true;
                        var className = evt.target.className;
                        if (ej.datavisualization.Diagram.Util.isClassifier(evt))
                            var mNode = ej.datavisualization.Diagram.ClassifierHelper.getSelectableElementUnderMouse(evt, this.diagram);
                        else
                            mNode = this._findNodeUnderMouse(evt);
                        if (evt.which === 3 && this.diagram.selectionList[0] && (this.diagram.selectionList[0].type === "pseudoGroup" || this.diagram.selectionList[0]._type === "group") && this._hasMultipleSelection(mNode))
                            isMulSelect = false;
                        if (ej.datavisualization.Diagram.Util.canDoSingleSelection(this.diagram) && this._isMouseDown) {
                            if (isMulSelect)
                                this.selectedObject = mNode;
                            else
                                this.selectedObject = this.diagram.selectionList[0];
                        }
                        clickedObject = this.selectedObject;
                    }
                    var selectedObject = this.diagram.selectionList.length > 0 ? this.diagram.selectionList[0] : null;
                    if (this.selectedObject && !this.diagram._selectionContains(this.selectedObject))
                        this.diagram._clearSelection(true);
                }
                else {
                    clickedObject = this._findNodeUnderMouse(evt);
                }
            }
            if (!endAction && this.selectedObject) {
                if (this.selectedObject && this.selectedObject.type != "pseudoGroup") {
                    if (!skip) {
                        var obj1 = this._findNodeUnderMouse(evt, true);
                        var tempVal = this.selectedObject;
                        var args = this._raiseEvent("itemClick", { element: this.selectedObject, actualObject: this.actualObject, selectedObject: obj1, model: this.diagram.model, cancel: false, event: evt });
                        this._itemClick(this.selectedObject, this.actualObject, obj1, selectedObject);
                        if (args.cancel)
                            this.selectedObject = tempVal;
                    }
                }
                if (this.selectedObject) {
                    this._allowPan(this.selectedObject, "mouseup", evt);
                    if (!this.selectedObject.isPhase)
                        this._updateSelection();
                    this._enableLabel(this.selectedObject, this.activeLabel);
                    if (this.selectedObject && this.selectedObject.parent === "") {
                        if (!this.selectedObject.isSwimlane) {
                            if (!this.diagram._isHyperLink(evt))
                                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                        }
                        else {
                            ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this.diagram);
                            ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                            ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this.diagram, this.selectedObject);
                        }
                        var selectObj = this.selectedObject;
                        if (this.diagram._isDragg && !this.diagram._selectionContains(selectObj)) {
                            this.diagram._clearSelection();
                            if (!selectObj.isPhase)
                                this.diagram._addSelection(selectObj);
                        }
                    }
                }
                if (clickedObject && !skip) {
                    //raise click event
                    var mousePosition = this.diagram._mousePosition(evt.originalEvent);
                    this._raiseEvent("click", { element: this.diagram.getNode(clickedObject), actualObject: this.diagram.getNode(this.actualObject), count: this.diagram._getEventDetail(evt), offsetX: mousePosition.x, offsetY: mousePosition.y, event: evt });
                }
            }
            this._multipleUndo = false;
            delete this.diffx;
            delete this.diffy;
            delete this._isMouseDown;
            delete this.actualObject;
            delete this._swimlaneNodedragged;
            this.diagram._removeTooltip();
            if (!this.diagram._isEditing && !this.diagram._isDragg)
                this.diagram._endEdit();
            delete this.hoverNode;

            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            this.diagram._activeSwimLane = null;
            base.prototype.mouseup.call(this, evt);
        };
        MoveTool.prototype._updateObject = function () {
            if (this.selectedObject) {
                if (this.selectedObject.type == "pseudoGroup") {
                    var child;
                    var children = this.diagram._getChildren(this.selectedObject.children);
                    for (var i = 0, len = children.length; i < len; i++) {
                        child = this.diagram.nameTable[children[i]];
                        if (child) {
                            ej.datavisualization.Diagram.DiagramContext.update(child, this.diagram);
                        }
                    }
                }
                else {
                    if (this.selectedObject.parent) {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                        this.diagram._updateParentBounds(this.diagram.nameTable[this.selectedObject.parent]);
                    }
                    if (!this.selectedObject.isSwimlane)
                        ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                    else {
                        ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this.diagram);
                        ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                        ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this.diagram, this.selectedObject);
                    }
                }
            }
        };
        MoveTool.prototype._endAction = function () {
            base.prototype._endAction.apply(this);
            this._isMouseDown = false;
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
        };
        MoveTool.prototype._updateHelperXY = function (shape, startPoint, endPoint) {
            var towardsLeft = endPoint.x < startPoint.x;
            var towardsTop = endPoint.y < startPoint.y;
            var difx = this.diffx + (endPoint.x - startPoint.x);
            var dify = this.diffy + (endPoint.y - startPoint.y);
            var offset;
            if (((this.diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) ||
                (this.diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines)) &&
                this.diagram._enableSnapToObject())
                offset = ej.datavisualization.Diagram.SnapUtil._snapPoint(this.diagram, this.helper, towardsLeft, towardsTop, ej.datavisualization.Diagram.Point(difx, dify),
                    endPoint, startPoint);
            if (!offset)
                offset = ej.datavisualization.Diagram.Point(difx, dify);
            this.diffx = difx - offset.x;
            this.diffy = dify - offset.y;
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                var oldbounds = ej.datavisualization.Diagram.Util.bounds(shape);
                oldbounds = ej.datavisualization.Diagram.Rectangle(oldbounds.left, oldbounds.top, oldbounds.right - oldbounds.left, oldbounds.bottom - oldbounds.top);
                var oldValue = { bounds: { x: oldbounds.x, y: oldbounds.y, width: oldbounds.width, height: oldbounds.height }, offsetX: shape.offsetX, offsetY: shape.offsetY, width: shape.width, height: shape.height };
                if (this._outOfBoundsDrag(shape, offset.x, offset.y))
                    this.diagram._translate(shape, offset.x, offset.y, this.diagram.nameTable);
                var newbounds = ej.datavisualization.Diagram.Util.bounds(shape);
                newbounds = ej.datavisualization.Diagram.Rectangle(newbounds.left, newbounds.top, newbounds.right - newbounds.left, newbounds.bottom - newbounds.top);
                var newValue = { bounds: { x: newbounds.x, y: newbounds.y, width: newbounds.width, height: newbounds.height }, offsetX: shape.offsetX, offsetY: shape.offsetY, width: shape.width, height: shape.height };
                var args = this._raiseDragEvent({ element: this.diagram.getNode(this.helper), offset: offset, oldValue: oldValue, newValue: newValue, cancel: false });
                if (args && !args.cancel) {
                    if (!this.inAction)
                        if (shape._type === "group") {
                            ej.datavisualization.Diagram.Util._updateGroupBounds(shape, this.diagram);
                        }
                }
                else { this.diagram._translate(shape, -offset.x, -offset.y, this.diagram.nameTable); }
            }
        };


        MoveTool.prototype._outOfBoundsDrag = function (node, ptX, ptY, orientation) {
            ptX = ptX ? ptX : 0;
            ptY = ptY ? ptY : 0;
            if (node && ej.datavisualization.Diagram.Util.canMoveOutofBoundary(this.diagram)) {
                var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                var size = this._getPageBounds();
                if (orientation) {
                    ptX = (orientation === "horizontal") ? 0 : ptX;
                    ptY = (orientation === "vertical") ? 0 : ptY;
                }
                if (bounds) {
                    var padding = this._getPadding(node);
                    if (node.isPhase)
                        return true;
                    if ((!this.diagram._selectedSymbol || this._skipSelectedSymbol) && (bounds.right + ptX + padding.x > size.width || bounds.left + ptX - padding.x < size.x)) {
                        this.updateCursor("not-allowed");
                        return false
                    }
                    if ((!this.diagram._selectedSymbol || this._skipSelectedSymbol) && (bounds.bottom + ptY + padding.y > size.height || bounds.top + ptY - padding.y < size.y)) {
                        this.updateCursor("not-allowed");
                        return false
                    }
                }
            }
            if (!this.diagram._notAllow)
                this.updateCursor("move");
            return true
        };

        MoveTool.prototype._updateXY = function (shape, startPoint, endPoint, preventSegmentAdjusting) {
            var towardsLeft = endPoint.x < startPoint.x;
            var towardsTop = endPoint.y < startPoint.y;
            var difx = this.diffx + (endPoint.x - startPoint.x);
            var dify = this.diffy + (endPoint.y - startPoint.y);
            var offset;
            if (((this.diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) ||
                (this.diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines)) || this.diagram._enableSnapToObject())
                offset = ej.datavisualization.Diagram.SnapUtil._snapPoint(this.diagram, this.selectedObject, towardsLeft, towardsTop, ej.datavisualization.Diagram.Point(difx, dify),
                    endPoint, startPoint);

            if (!offset)
                offset = ej.datavisualization.Diagram.Point(difx, dify);

            this.diffx = difx - offset.x;
            this.diffy = dify - offset.y;
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset) || this.diagram._selectedSymbol && !this.inAction) {
                var args;
                var oldbounds = ej.datavisualization.Diagram.Util.bounds(shape);
                oldbounds = ej.datavisualization.Diagram.Rectangle(oldbounds.left, oldbounds.top, oldbounds.right - oldbounds.left, oldbounds.bottom - oldbounds.top);
                var oldValue = { bounds: { x: oldbounds.x, y: oldbounds.y, width: oldbounds.width, height: oldbounds.height }, offsetX: shape.offsetX, offsetY: shape.offsetY, width: shape.width, height: shape.height };
                if (!shape.segments) {
                    if (ej.datavisualization.Diagram.Util.canAllowPan(shape)) {
                        if (this.diagram._hScrollOffset === 0) {
                            offset.x = 0;
                        }
                        if (this.diagram._vScrollOffset === 0) {
                            offset.y = 0;
                        }
                    }
                }
                if (preventSegmentAdjusting && !shape.isSwimlane && shape.type != "pseudoGroup")
                    this.diagram._preventDocking = true;
                if (this._outOfBoundsDrag(shape, offset.x, offset.y)) {
                    this.diagram._raiseOffsetPropertyChange(shape, offset.x, offset.y, true);
                    this.diagram._translate(shape, offset.x, offset.y, this.diagram.nameTable);
                    delete this.diagram._preventDocking;
                    var newbounds = ej.datavisualization.Diagram.Util.bounds(shape);
                    newbounds = ej.datavisualization.Diagram.Rectangle(newbounds.left, newbounds.top, newbounds.right - newbounds.left, newbounds.bottom - newbounds.top);
                    var newValue = { bounds: { x: newbounds.x, y: newbounds.y, width: newbounds.width, height: newbounds.height }, offsetX: shape.offsetX, offsetY: shape.offsetY, width: shape.width, height: shape.height };
                    if (!this.diagram._selectedSymbol) {
                        args = this._raiseDragEvent({ element: this.diagram.getNode(this.selectedObject), offset: offset, oldValue: oldValue, newValue: newValue, cancel: false });
                    }
                    else {
                        args = { element: this.diagram.getNode(this.selectedObject), allowDrop: true, target: this._getNodeUnderMouse(), oldValue: oldValue, newValue: newValue, cancel: false };
                        if (args.target && args.target.segments) {
                            ej.datavisualization.Diagram.SvgContext._drawConnectorHighlighter(args.target, this.diagram, this.diagram._currZoom);
                        }
                        this._raiseEvent("dragOver", args);
                        if (!args.allowDrop) {
                            this.updateCursor("not-allowed");
                            if (!this.inAction) { this.diagram._removeSymbolFromDiagram(); return true; }
                        }
                        else {
                            if (!this.diagram._notAllow)
                                this.updateCursor("move");
                        }
                    }
                    if ((args && !args.cancel) || this.diagram._selectedSymbol) {
                        if (shape._type === "group" && shape.type != "bpmn" || (shape.type === "pseudoGroup")) {
                            ej.datavisualization.Diagram.Util._updateGroupBounds(shape, this.diagram);
                            if ((this._fromSameContainer(this.diagram._getChildren(this.selectedObject.children)) && this.hasSameParent()) || this._anyFromContainer(this.diagram._getChildren(this.selectedObject.children)))
                                ej.datavisualization.Diagram.canvasHelper._removeFromParentContainer(this.diagram, this.selectedObject);
                        }
                    }
                    else if (args && args.cancel) {
                        this.diagram._translate(shape, -offset.x, -offset.y, this.diagram.nameTable);
                    }
                }
            }
        };

        MoveTool.prototype._boundsInterSects = function (polyLine, bounds, self) {
            var intersect = []
            if (bounds) {
                var polyLine2 = [
                    { x: bounds.x, y: bounds.y },
                    { x: bounds.x + bounds.width, y: bounds.y },
                    { x: bounds.x + bounds.width, y: bounds.y + bounds.height },
                    { x: bounds.x, y: bounds.y + bounds.height },
                    { x: bounds.x, y: bounds.y }
                ];
                intersect = this._intersect(polyLine, polyLine2, intersect);
            }
            return intersect;
        };
        MoveTool.prototype._intersect = function (polyLine1, polyLine2, self) {
            var intersect = [];
            for (var i = 0; i < polyLine1.length - 1; i++) {
                for (var j = 0; j < polyLine2.length - 1; j++) {
                    var p = ej.datavisualization.Diagram.Util.interSect2(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);
                    if (!ej.datavisualization.Diagram.Geometry.isEqualPoint(ej.datavisualization.Diagram.Point(0, 0), p)) {
                        intersect.push(p);
                    }
                }

                if (self && polyLine2.length >= 1) { }
            }
            return intersect;
        };

        MoveTool.prototype._getInterceptWithSegment = function (currenPosition, conPoints) {
            var intercepts = [], tarAngle, srcAngle, imgLine, segemnt, i, maxLength;
            maxLength = ej.datavisualization.Diagram.Util.findLength(ej.datavisualization.Diagram.Point(0, 0), ej.datavisualization.Diagram.Point(this.diagram._viewPort.width, this.diagram._viewPort.height));
            for (i = 1; i < conPoints.length; i++) {
                segemnt = [conPoints[i - 1], conPoints[i]];
                imgLine = [];
                srcAngle = Math.round(ej.datavisualization.Diagram.Util.findAngle(segemnt[0], segemnt[1]) % 360, 2);
                tarAngle = Math.round(ej.datavisualization.Diagram.Util.findAngle(segemnt[1], segemnt[0]) % 360, 2);
                var angleAdd = (srcAngle > 0 && srcAngle <= 90) || (srcAngle > 180 && srcAngle <= 270) ? 90 : -90;

                imgLine.push(ej.datavisualization.Diagram.Geometry.transform(currenPosition, srcAngle + angleAdd, maxLength));
                imgLine.push(ej.datavisualization.Diagram.Geometry.transform(currenPosition, tarAngle + angleAdd, maxLength));

                var intercept = this._intersect(segemnt, imgLine, false);
                for (var m = 0; m < intercept.length; m++) {
                    intercepts.push(intercept[m]);
                }
            }
            return intercepts;
        };

        MoveTool.prototype._raiseDragEvent = function (args) {
            if (!this.diagram._selectedSymbol && !this.diagram._isDragg) {
                args.dragState = this.dragState;
                return this._raiseEvent("drag", args);
            }
        };

        MoveTool.prototype._updateSelection = function () {
            if (!this.diagram._selectionContains(this.selectedObject)) {
                this.diagram._clearSelection(true);
                this.diagram._addSelection(this.selectedObject);
            }
        };
        MoveTool.prototype._disableLabel = function (selectedObject, label) {
            if (selectedObject && label) {
                var htmlLayer = this.diagram._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                var name = selectedObject._shape == "text" ? selectedObject.name : selectedObject.name + "_" + label.name;
                var text = $(htmlLayer).find("#" + name + ".ej-d-label")[0];
                if (text) text.style.pointerEvents = "none";
            }
        };
        MoveTool.prototype._enableLabel = function (selectedObject, label) {
            if (selectedObject && label) {
                var htmlLayer = this.diagram._svg.document.parentNode.getElementsByClassName("htmlLayer")[0];
                var name = selectedObject._shape == "text" ? selectedObject.name : selectedObject.name + "_" + label.name;
                var text = $(htmlLayer).find("#" + name + ".ej-d-label")[0];
                if (text) text.style.pointerEvents = "all";
            }
        };
        return MoveTool;
    })(ToolBase);

    ej.datavisualization.Diagram.MoveTool = MoveTool;
    //#endregion
    var PortTool = (function (base) {
        ej.datavisualization.Diagram.extend(PortTool, base);
        function PortTool(diagram) {
            base.call(this, "Port", diagram);
            this.cursor = "pointer";
            this._isMouseDown = false;
        }
        PortTool.prototype.mousedown = function (evt) {
            this._isMouseDown = true;
            base.prototype.mousedown.call(this, evt);
            this.activePort = this.diagram._getvalues(evt);
        };

        PortTool.prototype.mousemove = function (evt) {
            if (this.activePort) {
                base.prototype.mousemove.call(this, evt);
                if (!this.inAction) {
                    this.inAction = true;
                    this.selectedObject = this.diagram.nameTable[this.diagram._getChild(this.activePort.source.parent)];
                    this.undoObject = jQuery.extend(true, {}, { "node": this.selectedObject });
                }
                this._updatePortXY(this.activePort.source, this.previousPoint, this.currentPoint);
            }
            this.previousPoint = this.currentPoint;
        };

        PortTool.prototype.mouseup = function (evt) {
            this._isMouseDown = false;
            this.diagram.deactivateTool(evt);
            if (this.inAction) {
                this.inAction = false;
                var entry = { type: "portpositionchanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, { "node": this.selectedObject }), category: "internal", activePort: this.activePort.source };
                if (!this._multipleUndo)
                    this.diagram.addHistoryEntry(entry);
            }
        };

        PortTool.prototype._updatePortXY = function (port, startPoint, endPoint) {
            var difx = endPoint.x - startPoint.x;
            var dify = endPoint.y - startPoint.y;
            if (this.activePort) {
                if (!this.selectedObject)
                    this.selectedObject = this.diagram.nameTable[this.diagram._getChild(this.activePort.source.parent)]
                this.diagram._translatePort(this.selectedObject, port, difx, dify);
            }
        }
        return PortTool;
    })(ToolBase);
    ej.datavisualization.Diagram.PortTool = PortTool;

    //#region ResizeTool
    var ResizeTool = (function (base) {
        ej.datavisualization.Diagram.extend(ResizeTool, base);
        function ResizeTool(diagram) {
            base.call(this, "resize", diagram);
            this.cursor = "default";//update resize cursor during action i.e in action
            this._resizeDirection = null;
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
            this.diffx = 0;
            this.diffy = 0;
            this._startPoint = ej.datavisualization.Diagram.Size(0, 0);
            this.undoObject = null;
            this.pseudoGroupConstraints = null;
            this._mouseDown = false;
            this.resizeState = "";
        }

        ResizeTool.prototype.mousedown = function (evt) {
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            base.prototype.mousedown.call(this, evt);
            this._mouseDown = true;
            this.resizeState = ej.datavisualization.Diagram.ResizeState.Starting;
        };
        ResizeTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            var start = !this.inAction;
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);

            if (!this.inAction && this.diagram.selectionList[0] && this._mouseDown) {
                this.selectedObject = this.diagram.nameTable[this.diagram.selectionList[0].name];
                var data;
                var childTable = {};
                var newbounds, oldbounds;
                newbounds = oldbounds = ej.datavisualization.Diagram.Util.bounds(this.selectedObject);
                var oldValue = { bounds: { x: oldbounds.x, y: oldbounds.y, width: oldbounds.width, height: oldbounds.height }, offsetX: this.selectedObject.offsetX, offsetY: this.selectedObject.offsetY, width: this.selectedObject.width, height: this.selectedObject.height };
                var newValue = { bounds: { x: newbounds.x, y: newbounds.y, width: newbounds.width, height: newbounds.height }, offsetX: this.selectedObject.offsetX, offsetY: this.selectedObject.offsetY, width: this.selectedObject.width, height: this.selectedObject.height };
                this._raiseEvent("sizeChange", { element: this.diagram.getNode(this.selectedObject), resizeState: this.resizeState, offset: { x: 0, y: 0 }, oldValue: oldValue, newValue: newValue, cancel: false, direction: this._resizeDirection });
                if (this.selectedObject._type === "group" || this.selectedObject.type === "pseudoGroup")
                    childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                var temp = { "childTable": childTable, "node": this.selectedObject };
                if (this.selectedObject && this.selectedObject.type === "pseudoGroup") {
                    if (this.diagram.model.selectedItems.getConstraints && $.isFunction(this.diagram.model.selectedItems.getConstraints)) {
                        this.pseudoGroupConstraints = this.diagram.model.selectedItems.getConstraints();
                    }
                    else this.pseudoGroupConstraints = ej.datavisualization.Diagram.Util._getPseudoGroupConstraints(this.diagram, this.selectedObject, this.selectedObject);
                }
                data = $.extend(true, {}, temp);
                this.undoObject = jQuery.extend(true, {}, data);
                //this.undoObject = ej.datavisualization.Diagram.Util.clone(this.selectedObject);
                this._resizeDirection = evt.target.getAttribute("class");
                if (!this.selectedObject.width) this.selectedObject.width = this.selectedObject._width;
                if (!this.selectedObject.height) this.selectedObject.height = this.selectedObject._height;
                this.initialBounds = { width: this.selectedObject.width, height: this.selectedObject.height, y: this.selectedObject.offsetY, x: this.selectedObject.offsetX };
                ej.datavisualization.Diagram.SvgContext._removePivotPoint(this.selectedObject, this.diagram._svg, this.diagram._currZoom);
                this.inAction = true;
            }
            if (this.selectedObject) {
                this.resizeState = ej.datavisualization.Diagram.DragState.Resizing;
                var canvasChild = false;
                if (this.selectedObject && this.selectedObject.parent) {
                    var parNode = this.diagram.nameTable[this.selectedObject.parent];
                    if (parNode.container && (parNode.container.type == "canvas" || parNode.container.type == "stack"))
                        canvasChild = true;
                }
                else if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent() && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                    canvasChild = true;
                }
                if ((this.selectedObject && canvasChild) || (this.selectedObject.type === "pseudoGroup" && this._anyFromContainer(this.diagram._getChildren(this.selectedObject.children)))) {
                    if (this.selectedObject.type === "pseudoGroup" && this._isParentAsLane(this.selectedObject)) {
                        ej.datavisualization.Diagram.canvasHelper._removeFromParentContainer(this.diagram, this.selectedObject);
                    }
                    else ej.datavisualization.Diagram.canvasHelper._updateResizeHelper(this.diagram);
                }
                else if (this.selectedObject && this.diagram.nameTable[this.selectedObject.name].container) {
                    ej.datavisualization.Diagram.canvasHelper._updateResizeHelper(this.diagram);
                }
                else if (this.selectedObject.parent && this.diagram.nameTable[this.selectedObject.parent] &&
                    this.diagram.nameTable[this.selectedObject.parent].container && this.diagram.nameTable[this.selectedObject.parent].container.type == "stack") {
                    if (!this.helper) {
                        this.helper = this._getCloneNode(this.selectedObject);
                    }
                    ej.datavisualization.Diagram.SvgContext._drawContainerHelper(this.diagram);
                    this._startPoint = this.currentPoint;
                    this._updateSize(this.helper, this.previousPoint, this.currentPoint);
                    ej.datavisualization.Diagram.DiagramContext.update(this.helper, this.diagram);
                }
                else {
                    if (this.selectedObject.type != "pseudoGroup")
                        this._updateSize(this.selectedObject, this.previousPoint, this.currentPoint);
                    else if (this.selectedObject.type == "pseudoGroup" && !this._fromContainer(this.diagram._getChildren(this.selectedObject.children)) && this._fromSameContainer(this.diagram._getChildren(this.selectedObject.children))) {
                        if (!this._undoObject)
                            ej.datavisualization.Diagram.Util._getUndoObject(this.diagram, this.selectedObject);
                        this._updateSize(this.selectedObject, this.previousPoint, this.currentPoint);
                    }
                }
                if (!this.helper) {
                    if (!this.selectedObject.isSwimlane)
                        ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                    else {
                        if (!this._isMouseDown) {
                            ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(this.diagram);
                            ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                            ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(this.diagram, this.selectedObject);
                        }
                    }
                }
                this.diagram._renderTooltip(this.selectedObject, start);
                this.diagram._updateSelectionHandle(true);
            }

            this.previousPoint = this.currentPoint;
        };
        ResizeTool.prototype.mouseup = function (evt) {
            var undoObj = null;
            this._mouseDown = false;
            if (this.inAction) {
                this.resizeState = ej.datavisualization.Diagram.ResizeState.Completed;
                ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
                this.inAction = false;
                var canvasChild = false;
                var newbounds, oldbounds;
                oldbounds = ej.datavisualization.Diagram.Util.bounds(this.undoObject.node);
                var oldValue = { bounds: { x: oldbounds.x, y: oldbounds.y, width: oldbounds.width, height: oldbounds.height }, offsetX: this.undoObject.node.offsetX, offsetY: this.undoObject.node.offsetY, width: this.undoObject.node.width, height: this.undoObject.node.height };
                newbounds = ej.datavisualization.Diagram.Util.bounds(this.selectedObject);
                if (this.selectedObject.parent) {
                    var parent = this.diagram.nameTable[this.selectedObject.parent];
                    if (parent && parent.container)
                        newbounds = ej.datavisualization.Diagram.Util.bounds(this.helper);
                }
                var newValue = { bounds: { x: newbounds.x, y: newbounds.y, width: newbounds.width, height: newbounds.height }, offsetX: newbounds.x + (newbounds.width) / 2, offsetY: newbounds.y + (newbounds.height) / 2, width: newbounds.width, height: newbounds.height };
                this._raiseEvent("sizeChange", { element: this.diagram.getNode(this.selectedObject), resizeState: this.resizeState, offset: { x: 0, y: 0 }, oldValue: oldValue, newValue: newValue, cancel: false, direction: this._resizeDirection });
                this.resizeState = "";
                var needDOMupdate = true;
                if (this.selectedObject.isLane || this.selectedObject.isSwimlane) {
                    var childTable = {};
                    childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                    undoObj = $.extend(true, {}, { "childTable": childTable, "node": this.selectedObject });
                }
                if (this.selectedObject && this.selectedObject.parent) {
                    var parNode = this.diagram.nameTable[this.selectedObject.parent];
                    if (parNode.container && (parNode.container.type == "canvas" || parNode.container.type == "stack"))
                        canvasChild = true;
                }
                else if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent() && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                    canvasChild = true;
                }
                if (this.selectedObject && canvasChild && !parNode.isLaneStack) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                    if (ej.datavisualization.Diagram.canvasHelper._outOfBoundaryNodeDrop(this.diagram, this.diagram.activeTool.helper, parNode)) {
                        if (!this.selectedObject.isLane)
                            ej.datavisualization.Diagram.canvasHelper._singleNodeResize(this.diagram, evt, this.selectedObject);
                        else
                            ej.datavisualization.Diagram.canvasHelper._resizeLane(this.diagram, this.selectedObject);
                        ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
                    }
                }
                else if (this.selectedObject && this.diagram.nameTable[this.selectedObject.name].container) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                    ej.datavisualization.Diagram.canvasHelper._resizeLane(this.diagram, this.selectedObject);
                    needDOMupdate = false;
                }
                else if ((this.selectedObject.type == "pseudoGroup" || this.selectedObject.name == "multipleSelection") && this.diagram._activeSwimLane) {
                    ej.datavisualization.Diagram.canvasHelper._multiNodeResize(this.diagram, evt, this.selectedObject);
                }
                if (this.selectedObject.parent) {
                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                }
                if (!this.diagram.nameTable[this.selectedObject.name].container) {
                    if (ej.datavisualization.Diagram.Util.canRouteDiagram(this.diagram)) {
                        this.undoObject.connectors = {};
                        this._redoConnectors = {};
                        this.diagram._updateAllEdges(this.selectedObject);
                    }
                }
                if (needDOMupdate)
                    ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                this.diagram._updateSelectionHandle();

                var data;
                var childTable = {};
                if (this.selectedObject._type === "group" || this.selectedObject.type === "pseudoGroup")
                    childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                var temp = { "childTable": childTable, "node": this.selectedObject };
                if (ej.datavisualization.Diagram.Util.canRouteDiagram(this.diagram) && this._redoConnectors) {
                    temp.connectors = this._redoConnectors;
                }
                data = $.extend(true, {}, temp);

                var entry = { type: "sizechanged", undoObject: undoObj ? undoObj : this.undoObject, redoObject: jQuery.extend(true, {}, data), isMultipleNode: (this.selectedObject._type === "group") ? true : false, category: "internal" };
                if (!this._multipleUndo)
                    this.diagram.addHistoryEntry(entry);
                this.diagram._removeTooltip();
                this._multipleUndo = false;
            }
            base.prototype.mouseup.call(this, evt);
        };
        ResizeTool.prototype._updateSize = function (shape, startPoint, endPoint, x1, y1, updateMinMax, isHelper, phase, disableSnap) {
            var difx = x1 ? x1 : (this.currentPoint.x - this.startPoint.x);
            var dify = y1 ? y1 : (this.currentPoint.y - this.startPoint.y);
            var point = this._resizeObject(shape, difx, dify, phase, disableSnap);
            var pivot = ej.datavisualization.Diagram.Point(point.x, point.y);
            var deltaWidth = point.width;
            var deltaHeight = point.height;
            if (shape)
                if (!this.pseudoGroupConstraints) {
                    this.pseudoGroupConstraints = shape.constraints;
                }
            if (this.pseudoGroupConstraints & ej.datavisualization.Diagram.NodeConstraints.AspectRatio) {
                if (this._resizeDirection == "n-resize" || this._resizeDirection == "s-resize" || this._resizeDirection == "w-resize" || this._resizeDirection == "e-resize") {
                    var matrix = ej.Matrix.identity();
                    var rotatedDif = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(startPoint.x - endPoint.x, startPoint.y - endPoint.y));
                    if (Math.abs(rotatedDif.x) > Math.abs(rotatedDif.y))
                        deltaHeight = deltaWidth;
                    else
                        deltaWidth = deltaHeight;
                }
                else if (startPoint != endPoint)
                    deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);
                else
                    deltaHeight = deltaWidth = 0;
            }
            var size = ej.datavisualization.Diagram.Size();
            if (deltaWidth < 0) deltaWidth = 1;
            if (deltaHeight < 0) deltaHeight = 1;
            size.width = deltaWidth;
            size.height = deltaHeight;
            var oldbounds = ej.datavisualization.Diagram.Util.bounds(shape);
            oldbounds = ej.datavisualization.Diagram.Rectangle(oldbounds.left, oldbounds.top, oldbounds.right - oldbounds.left, oldbounds.bottom - oldbounds.top);
            var oldValue = { bounds: { x: oldbounds.x, y: oldbounds.y, width: oldbounds.width, height: oldbounds.height }, offsetX: shape.offsetX, offsetY: shape.offsetY, width: shape.width, height: shape.height };
            if (!ej.datavisualization.Diagram.Geometry.isEmptySize(size)) {
                this.resizeState = ej.datavisualization.Diagram.ResizeState.Resizing;
                if (this._outOfBoundsDrag(shape, deltaWidth, deltaHeight, pivot)) {
                    this.diagram._raiseSizePropertyChange(shape, deltaWidth, deltaHeight, true);
                    this.diagram.scale(shape, deltaWidth, deltaHeight, pivot, this.diagram.nameTable, null, updateMinMax, isHelper);
                    var newbounds = ej.datavisualization.Diagram.Util.bounds(shape);
                    newbounds = ej.datavisualization.Diagram.Rectangle(newbounds.left, newbounds.top, newbounds.right - newbounds.left, newbounds.bottom - newbounds.top);
                    var newValue = { bounds: { x: newbounds.x, y: newbounds.y, width: newbounds.width, height: newbounds.height }, offsetX: shape.offsetX, offsetY: shape.offsetY, width: shape.width, height: shape.height };
                    var pathData = shape.pathData;
                    if (oldbounds.width != newbounds.width || oldbounds.height != newbounds.height) {
                        var args = this._raiseEvent("sizeChange", { element: this.diagram.getNode(this.selectedObject), resizeState: this.resizeState, offset: size, oldValue: oldValue, newValue: newValue, direction: this._resizeDirection });
                    }
                    if (pathData && shape.pathData != pathData) {
                        shape._absoluteBounds = null;
                        shape._scaled = true;
                    }
                    if (args && args.cancel && !isHelper) {
                        this.diagram.scale(shape, 1 / deltaWidth, 1 / deltaHeight, pivot, this.diagram.nameTable);
                    }
                    if (shape._type === "group") {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(shape, this.diagram);
                    }
                    this.diagram._updateAssociatedConnectorEnds(shape, this.diagram.nameTable);
                }
                else return true;
            }
            this.pseudoGroupConstraints = null;
        };
        ResizeTool.prototype._getSwimLaneNode = function (node) {
            if (node) {
                var laneStackName = node.parent;
                var laneStack = this.diagram.nameTable[laneStackName];
                if (laneStack) {
                    var swimlaneName = laneStack.parent;
                    if (swimlaneName) {
                        var swimlane = this.diagram.nameTable[swimlaneName];
                        if (swimlane)
                            return swimlane;
                    }
                }
            }
        };
        ResizeTool.prototype._outOfBoundsDrag = function (node, delWidth, delHeight, pivot) {
            if (!this.diagram._skipoutOfBounds && node && ej.datavisualization.Diagram.Util.canMoveOutofBoundary(this.diagram)) {
                var size = this._getPageBounds();
                var incY = (node.height * delHeight) - node.height;
                var incX = (node.width * delWidth) - node.width;
                if (!this.inAction && node.isLane) {
                    var getSwimlane = this._getSwimLaneNode(node);
                    var bounds = ej.datavisualization.Diagram.Util.bounds(getSwimlane);
                    var padding = this._getPadding(node);

                    if (!this.diagram._selectedSymbol && (bounds.right + incX + padding.x > size.width)) {
                        this.updateCursor("not-allowed");
                        return false
                    }
                    if (!this.diagram._selectedSymbol && (bounds.bottom + incY + padding.y > size.height)) {
                        this.updateCursor("not-allowed");
                        return false
                    }
                }
                else {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(node);
                    var padding = this._getPadding(node);
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, -node.rotateAngle, pivot.x, pivot.y);
                    ej.Matrix.scale(matrix, delWidth, delHeight, pivot.x, pivot.y);
                    ej.Matrix.rotate(matrix, node.rotateAngle, pivot.x, pivot.y);
                    var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY));
                    if (!this.diagram._selectedSymbol && (newPosition.x + (bounds.width + incX) / 2 + padding.x > size.width || newPosition.x - (bounds.width + incX) / 2 < size.x)) {
                        this.updateCursor("not-allowed");
                        return false
                    }
                    if (!this.diagram._selectedSymbol && (newPosition.y + (bounds.height + incY) / 2 + padding.y > size.height || newPosition.y - (bounds.height + incY) / 2 < size.y)) {
                        this.updateCursor("not-allowed");
                        return false
                    }
                }
                this.updateCursor(this._resizeDirection)
            }
            return true
        };
        return ResizeTool;
    })(ToolBase);

    ej.datavisualization.Diagram.ResizeTool = ResizeTool;
    //#endregion

    //#region EndPointTool
    var ConnectionEditTool = (function (base) {
        ej.datavisualization.Diagram.extend(ConnectionEditTool, base);
        function ConnectionEditTool(diagram) {
            base.call(this, "endPoint", diagram);
            this.cursor = "move";
            this._endPoint = null;
            this._undoObject = null;
        }
        ConnectionEditTool.prototype.mousedown = function (evt) {
            if (!this.inAction) {
                base.prototype.mousedown.call(this, evt);
                if (evt.ctrlKey && evt.shiftKey) {
                    var parent = $(evt.target).parents(".ej-d-connector");
                    if (parent.length > 0) {
                        this.selectedObject = this.diagram.nameTable[parent[0].id];
                        if (this.diagram._hasSelection())
                            this.diagram._clearSelection(true);
                        this.diagram._addSelection(this.selectedObject);
                    }
                }
                this._initialValue = null;
                if (this.diagram.selectionList[0] && !this.selectedObject) this.selectedObject = this.diagram.nameTable[this.diagram.selectionList[0].name];
                this.undoObject = this._getClonedObject(this.selectedObject);
                this._endPoint = evt.target.getAttribute("class");
                this.targetid = evt.target.id;
                this._selectedSegment = "";
                this._nearestNodes = [];
                var isTarget = (this._endPoint == "targetEndPoint") ? true : false;
                var isSource = (this._endPoint == "sourceEndPoint") ? true : false;
                var dragargs = this._raiseEndPointDrag(this.selectedObject, isTarget, isSource, ej.datavisualization.Diagram.DragState.Starting);
            }
        };
        ConnectionEditTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            var start = !this.inAction;
            if (this.selectedObject && !(evt.ctrlKey && evt.shiftKey)) {
                //  if (ej.datavisualization.Diagram.Util.canMove(this.selectedObject)) {
                var isTwo = false;
                if (this.selectedObject.segments.length == 2) isTwo = true;
                var difx = this.currentPoint.x - this.previousPoint.x;
                var dify = this.currentPoint.y - this.previousPoint.y;
                var _srcPoint = $.extend(true, {}, this.selectedObject.sourcePoint);
                var _trgPoint = $.extend(true, {}, this.selectedObject.targetPoint);
                var _segments = $.extend(true, {}, this.selectedObject.segments);
                if (this._outOfBoundsDrag(this.selectedObject, this.currentPoint.x, this.currentPoint.y)) {
                    if (!this.inAction && (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y)) {
                        this.inAction = true;
                        if (this.selectedObject.segments.length > 0) {
                            for (var m = 0; m < this.selectedObject.segments.length; m++) {
                                this.selectedObject.segments[m]._bridges = [];
                            }
                        }
                        var hitTest = (this.diagram._svg.getElementById(this.selectedObject.name + "_hitTest"));
                        if (hitTest) hitTest.setAttribute("pointer-events", "none");
                        var sNode = this.diagram._svg.getElementById(this.selectedObject.name);
                        if (sNode) sNode.setAttribute("pointer-events", "none");
                        var handle = this.diagram._adornerSvg.getElementById(this.diagram._adornerSvg.document.id + "handle_g");
                        if (handle) handle.setAttribute("pointer-events", "none");
                        var coll = this.targetid.split("_");
                        coll.reverse();
                        var index = Number(coll[0]);
                        this.selectedSegment = this.selectedObject.segments[index];
                        var segment = this.selectedSegment;
                        if (this.selectedSegment && this.selectedSegment.type == "orthogonal") {
                            var refresh = false;
                            if (index === 0) {
                                var editfirstsegment = true;
                            }
                            if (!this.selectedSegment.length || !this.selectedSegment.direction) {
                                this._addTerminalSegment(difx, dify, coll);
                                refresh = true;
                            }
                            else if (index == 0) {
                                this.insertFirstSegment(difx, dify, coll);
                                refresh = true;
                            }
                            else {
                                this.nextSegment = this.selectedObject.segments[index + 1];
                            }
                        }
                        else
                            this.nextSegment = this.selectedObject.segments[index + 1];
                        if (refresh) {
                            ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, !(isTwo || editfirstsegment || !this.selectedObject.sourcePort), !(isTwo || !(segment.length || segment.length === 0) || !this.selectedObject.targetPort), this.diagram);
                            ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                            ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom);
                        }
                        if (!this.selectedSegment && this._endPoint == "targetEndPoint") this.selectedSegment = this.selectedObject.segments[this.selectedObject.segments.length - 1];
                        if (!this.selectedSegment && this._endPoint == "sourceEndPoint") {
                            this.selectedSegment = this.selectedObject.segments[0];
                            this.nextSegment = this.selectedObject.segments[1];
                        }
                        if (this.selectedSegment)
                            this._initialValue = { x: this.selectedSegment._endPoint.x, y: this.selectedSegment._endPoint.y };
                        this.diagram._updateSelectionHandle(true);
                        this._raiseSegmentEditEvent(ej.datavisualization.Diagram.DragState.Starting);
                    }
                    else if (this.inAction) {
                        if (this.selectedSegment && this._endPoint == "segmentEnd") {
                            var args = this._raiseSegmentEditEvent(ej.datavisualization.Diagram.DragState.Dragging);
                            if (!args.cancel && (difx != 0 || dify != 0)) {
                                var actualdifX = this.currentPoint.x - this.startPoint.x;
                                var actualdifY = this.currentPoint.y - this.startPoint.y;
                                if (this._initialValue) {
                                    actualdifX = this._initialValue.x + actualdifX - this.selectedSegment._endPoint.x;
                                    actualdifY = this._initialValue.y + actualdifY - this.selectedSegment._endPoint.y;
                                }
                                if (difx * actualdifX < 0) difx = 0; else difx = actualdifX;
                                if (dify * actualdifY < 0) dify = 0; else dify = actualdifY;
                                this._updateAdjacentSegments(difx, dify);
                            }
                        }
                        else if (this._endPoint != "segmentEnd") {
                            if (this._endPoint == "targetEndPoint" || this._endPoint == "sourceEndPoint")
                                this._checkConnectionPossible(evt);
                            var cancelEvent = this._updatePoints(this.selectedObject, ej.datavisualization.Diagram.DragState.Dragging);
                            if (!cancelEvent.cancel) {
                                this._disconnect(this.selectedObject);
                                this._updateConnection(this.selectedObject, cancelEvent.updateSelection);
                            }
                        }
                        this.diagram._updateSelectionHandle(true);
                        this.diagram._updateQuad(this.selectedObject);
                        ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                        //}
                    }
                }
                this.diagram._comparePropertyValues(this.selectedObject, "sourcePoint", { sourcePoint: _srcPoint }, true);
                this.diagram._comparePropertyValues(this.selectedObject, "targetPoint", { targetPoint: _trgPoint }, true);
                this.diagram._comparePropertyValues(this.selectedObject, "segments", { segments: _segments }, true);
            }
            this.previousPoint = this.currentPoint;
        };
        ConnectionEditTool.prototype._raiseSegmentEditEvent = function (state) {
            return this._raiseEvent("segmentChange", { element: this.selectedObject, dragState: state, point: this.currentPoint, cancel: false });
        };
        ConnectionEditTool.prototype._updateAdjacentSegments = function (difx, dify) {
            var current = this.selectedSegment;
            var pt = { x: difx + current._endPoint.x, y: dify + current._endPoint.y };
            pt = this.snap(pt);
            if (current.type == "orthogonal") {
                if (current._direction == "left" || current._direction == "right") {
                    dify = pt.y - current._endPoint.y;
                    current._startPoint.y += dify;
                    current._endPoint.y = current._startPoint.y;
                }
                else {
                    difx = pt.x - current._endPoint.x;
                    current._startPoint.x += difx;
                    current._endPoint.x = current._startPoint.x;
                }
                current.points[0] = current._startPoint;
                current.points[current.points.length - 1] = current._endPoint;
                var index = this.selectedObject.segments.indexOf(this.selectedSegment);
                var prev = this.selectedObject.segments[index - 1];
                if (prev) this.updatePreviousSegment(current, prev, difx, dify);
            }
            else if (current.type == "straight") {
                current.points[current.points.length - 1] = current._endPoint = pt;
                current._point = current.point = pt;
            }
            else {
                current.points[current.points.length - 1] = current._endPoint = pt;
                current._point = current.point = pt;
                ej.datavisualization.Diagram.Util._updateBezierPoints(current);
            }
            if (this.nextSegment)
                this.updateNextSegment(current, this.nextSegment, difx, dify);
        }
        ConnectionEditTool.prototype._addTerminalSegment = function (difx, dify, coll) {
            var segment = this.selectedSegment;
            this.selectedObject.segments.pop();
            var first = this.selectedObject.segments[this.selectedObject.segments.length - 1] && this.selectedObject.segments[this.selectedObject.segments.length - 1].type == "orthogonal" ? this.selectedObject.segments[this.selectedObject.segments.length - 1] : null;
            for (var i = 0; i < segment.points.length - 2; i++) {
                var seg = ej.datavisualization.Diagram.Segment({
                    type: "orthogonal",
                    length: ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]),
                    direction: ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[i], segment.points[i + 1])
                });
                if (seg.length == 0) {
                    if (first.direction == "top" || first.direction == "bottom") {
                        seg._direction = seg.direction = difx > 0 ? "right" : "left";
                    }
                    else {
                        seg._direction = seg.direction = dify > 0 ? "bottom" : "top";
                    }
                }
                first = seg;
                this.selectedObject.segments.push(seg);
            }
            var sec = Number(coll[1]);
            if (segment.points.length == 2 || sec == segment.points.length - 2) {
                if (first) {
                    first.length += 5;
                    first._length = first.length;
                }
                if (sec != 0) {
                    var length = ej.datavisualization.Diagram.Geometry.distance(segment.points[segment.points.length - 2], segment._endPoint);
                    var direction = ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[segment.points.length - 2], segment._endPoint);
                    var newsegment = ej.datavisualization.Diagram.Segment({ type: "orthogonal", length: 2 * length / 3, direction: direction });
                    this.selectedObject.segments.push(newsegment);

                }
            }
            var lastseg = ej.datavisualization.Diagram.Segment({ type: "orthogonal" });
            this.selectedObject.segments.push(lastseg);
            var index = Number(coll[0]) + (Number(coll[1]) || 0);
            this.selectedSegment = this.selectedObject.segments[index];
            this.nextSegment = this.selectedObject.segments[index + 1];
            if (index == this.selectedObject.segments.length - 2) {
                if (Number(coll[0]) == 0) {
                    this.nextSegment._direction = ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[segment.points.length - 2], segment._endPoint);;
                }
                else
                    this.nextSegment._direction = segment._direction;
            }
            else {
                lastseg._direction = ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[segment.points.length - 2], segment._endPoint);;
            }
            if (index == 0) this.insertFirstSegment(difx, dify, coll);

        },
        ConnectionEditTool.prototype.insertFirstSegment = function (difx, dify, coll) {
            var segment = this.selectedSegment;
            if (this.selectedObject.sourcePort && segment.length && this.selectedObject.segments[0].points.length > 2) {
                this.selectedObject.segments.splice(0, 1);
                var segments = [];
                var prev;
                for (var i = 0; i < segment.points.length - 1; i++) {
                    var first = ej.datavisualization.Diagram.Segment({
                        type: "orthogonal",
                        length: ej.datavisualization.Diagram.Geometry.distance(segment.points[i], segment.points[i + 1]),
                        direction: ej.datavisualization.Diagram.Util._getBezierDirection(segment.points[i], segment.points[i + 1])
                    });
                    if (first.length == 0) {
                        if (prev && (prev.direction == "top" || prev.direction == "bottom")) {
                            first._direction = first.direction = difx > 0 ? "right" : "left";
                        }
                        else {
                            first._direction = first.direction = dify > 0 ? "bottom" : "top";
                        }
                    }
                    prev = first;
                    segments.push(first);
                }
                this.selectedObject.segments = segments.concat(this.selectedObject.segments);
                this.selectedSegment = this.selectedObject.segments[Number(coll[1])];
                this.nextSegment = this.selectedObject.segments[Number(coll[1]) + 1];
            }
            else {
                var segment = this.selectedObject.segments[0];
                var segments = [];
                segments.push(ej.datavisualization.Diagram.Segment({ type: "orthogonal", "direction": segment.direction, length: segment.length / 3 }));
                if (segment.direction == "bottom" || segment.direction == "top") {
                    var length = Math.max(5, Math.abs(difx));
                    var direction = difx > 0 ? "right" : "left";
                }
                else {
                    var length = Math.max(5, Math.abs(dify));
                    var direction = dify > 0 ? "bottom" : "top";
                }
                segments.push(ej.datavisualization.Diagram.Segment({ type: "orthogonal", "direction": direction, length: length }));
                var nextseg = this.selectedObject.segments[1];
                if (nextseg && nextseg.length) {
                    if (direction != nextseg.direction) {
                        length *= -1;
                    }
                    nextseg.length -= length;
                    nextseg._length = nextseg.length;
                }
                segment.length = segment._length = 2 * segment._length / 3;
                this.selectedObject.segments = segments.concat(this.selectedObject.segments);
                var index = Number(coll[0]) + Number(coll[1]);
                this.selectedSegment = this.selectedObject.segments[2];
                this.nextSegment = this.selectedObject.segments[3];
            }
        },
        ConnectionEditTool.prototype.updatePreviousSegment = function (current, prev, difx, dify) {
            prev._endPoint = prev.points[prev.points.length - 1] = current._startPoint;
            if (prev.type == "orthogonal") {
                if (prev.direction == "bottom") {
                    prev.length += dify;
                    if (prev.length < 0) {
                        prev._direction = prev.direction = "top";
                        prev.length *= -1;
                    }
                }
                else if (prev.direction == "top") {
                    prev.length -= dify;
                    if (prev.length < 0) {
                        prev._direction = prev.direction = "bottom";
                        prev.length *= -1;
                    }
                }
                else if (prev.direction == "right") {
                    prev.length += difx
                    if (prev.length < 0) {
                        prev._direction = prev.direction = "left";
                        prev.length *= -1;
                    }
                }
                else if (prev.direction == "left") {
                    prev.length -= difx;
                    if (prev.length < 0) {
                        prev._direction = prev.direction = "right";
                        prev.length *= -1;
                    }
                }
                prev._length = prev.length;
            }
            else {
                if (prev.type == "bezier") {
                    ej.datavisualization.Diagram.Util._updateBezierPoints(prev);
                }
            }
        };
        ConnectionEditTool.prototype.updateNextSegment = function (current, next, difx, dify) {
            var pt = current._endPoint;
            next._startPoint = next.points[0] = this.selectedSegment._endPoint;
            if (next) {
                if (next.type == "orthogonal") {
                    if (next.length || next.length === 0) {
                        if (next._direction == "left" || next._direction == "right") {
                            if (difx != 0) {
                                if (next._direction == "right") {
                                    next._length -= difx;
                                }
                                else {
                                    next._length += difx;
                                }

                                if (next.length || next.length === 0) {
                                    next.length = next._length;
                                    if (next.length < 0) {
                                        if (next.direction == "left") next.direction = "right";
                                        else if (next.direction == "right") next.direction = "left";
                                        next.length *= -1;
                                        next._direction = next.direction;
                                        next._length = next.length;
                                    }
                                }

                            }
                            if (dify != 0) {
                                if (current.type != "orthogonal") {
                                    next._startPoint.y = next.points[0].y = next._endPoint.y = next.points[next.points.length - 1].y = pt.y;
                                    var index = this.selectedObject.segments.indexOf(next);
                                    var segment = this.selectedObject.segments[index + 1];
                                    segment._startPoint.y = segment.points[0].y = next._endPoint.y;
                                    if (segment.length) {
                                        if (segment.direction == "bottom") {
                                            segment.length -= dify;
                                            if (segment.length < 0) {
                                                segment.direction = "top";
                                                segment.length *= -1;
                                            }
                                        }
                                        else {
                                            segment.length += dify;
                                            if (segment.length < 0) {
                                                segment.direction = "bottom";
                                                segment.length *= -1;
                                            }
                                        }
                                    }
                                }
                            }

                        }
                        else {
                            if (dify != 0) {
                                if (next._direction == "bottom") {
                                    next._length -= dify;
                                }
                                else {
                                    next._length += dify;
                                }

                                if (next.length || next.length === 0) {
                                    next.length = next._length;
                                    if (next.length < 0) {
                                        if (next.direction == "top") next.direction = "bottom";
                                        else if (next.direction == "bottom") next.direction = "top";
                                        next.length *= -1;
                                        next._length = next.length;
                                        next._direction = next.direction;
                                    }
                                }

                            }
                            if (difx != 0) {
                                if (current.type != "orthogonal") {
                                    next._startPoint.x = next.points[0].x = next._endPoint.x = next.points[next.points.length - 1].x = pt.x;
                                    var index = this.selectedObject.segments.indexOf(next);
                                    var segment = this.selectedObject.segments[index + 1];
                                    if (segment.length) {
                                        if (segment.direction == "right") {
                                            segment.length += difx;
                                            if (segment.length < 0) {
                                                segment.direction = "left";
                                                segment.length *= -1;
                                            }
                                        }
                                        else {
                                            segment.length -= difx;
                                            if (segment.length < 0) {
                                                segment.direction = "right";
                                                segment.length *= -1;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                }
                else {

                    if (next.type == "bezier")
                        ej.datavisualization.Diagram.Util._updateBezierPoints(next);
                }
            }
        };
        ConnectionEditTool.prototype.mouseup = function (evt) {
            if (evt.shiftKey && evt.ctrlKey) {
                this._addOrRemoveStraightSegments(evt);
            }
            else
                if (this.inAction) {
                    this.inAction = false;
                    if (this._endPoint == "segmentEnd" && this.selectedSegment.type == "orthogonal") {
                        var args = this._raiseSegmentEditEvent(ej.datavisualization.Diagram.DragState.Completed);
                        if (!args.cancel) {
                            var index = this.selectedObject.segments.indexOf(this.selectedSegment);
                            var prev = this.selectedObject.segments[index - 1];
                            var next = this.selectedObject.segments[index + 1];
                            var refresh = false;
                            if (prev && prev.type == "orthogonal" && Math.abs(prev.length) < 5) {
                                if (index != 1) {
                                    refresh = this._removePrevSegment(index);
                                }
                            }
                            else if (next && next.type == "orthogonal") {
                                var length = (next.length || next.length === 0) ? next.length : ej.datavisualization.Diagram.Geometry.distance(next.points[0], next.points[1]);
                                if (Math.abs(length <= 5)) {
                                    refresh = this._removeNextSegment(index);
                                }
                            }
                            if (refresh) {
                                ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                                ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                                ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom);
                            }
                        }
                    }
                    else if (this._endPoint != "segmentEnd") {
                        var cancelEvent = this._updatePoints(this.selectedObject, ej.datavisualization.Diagram.DragState.Completed);
                        if (!this.diagram.nameTable[this.selectedObject.name]) this.selectedObject = null;
                        if (this.selectedObject) {
                            if (!cancelEvent.cancel) {
                                this._disconnect(this.selectedObject);
                                var args;
                                if (this._currentPossibleConnection && !this.inAction) {
                                    this._updateConnection(this.selectedObject);
                                }
                                else {
                                    if (this.selectedObject.sourceNode || this.selectedObject.targetNode) {
                                        this._updateConnection(this.selectedObject);
                                    }
                                }
                                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                                if (this.selectedObject.parent)
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);

                                this._removeHighLighter();
                                ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);
                            }
                            else {
                                if (cancelEvent && cancelEvent.cancel && cancelEvent.eventType) {
                                    if (cancelEvent.eventType === "connectorSourceChange") {
                                        if (this.undoObject.sourceNode) {
                                            this.selectedObject.sourceNode = this.undoObject.sourceNode;
                                            this.diagram.nameTable[this.undoObject.sourceNode].outEdges.push(this.selectedObject.name);
                                            this.selectedObject.sourcePort = this.undoObject.sourcePort;
                                        }
                                        else if (this.undoObject.sourceNode == null && this.selectedObject.sourceNode) {
                                            this.selectedObject.sourceNode = this.undoObject.sourceNode;
                                            this.selectedObject.sourcePort = this.undoObject.sourcePort;
                                            this.selectedObject.sourcePoint = this.undoObject.sourcePoint;
                                            this.selectedObject.segments = this.undoObject.segments;
                                        }
                                        else {
                                            this.selectedObject.sourcePoint = this.undoObject.sourcePoint;
                                            this.selectedObject.segments = this.undoObject.segments;
                                        }
                                    }
                                    if (cancelEvent.eventType === "connectorTargetChange") {
                                        if (this.undoObject.targetNode) {
                                            this.selectedObject.targetNode = this.undoObject.targetNode;
                                            this.diagram.nameTable[this.undoObject.targetNode].inEdges.push(this.selectedObject.name);
                                            this.selectedObject.targetPort = this.undoObject.targetPort;
                                        }
                                        else if (this.undoObject.targetNode == null && this.selectedObject.targetNode) {
                                            this.selectedObject.targetNode = this.undoObject.targetNode;
                                            this.selectedObject.targetPort = this.undoObject.targetPort;
                                            this.selectedObject.targetPoint = this.undoObject.targetPoint;
                                            this.selectedObject.segments = this.undoObject.segments;
                                        }
                                        else {
                                            this.selectedObject.segments = this.undoObject.segments;
                                            this.selectedObject.targetPoint = this.undoObject.targetPoint;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (this.selectedObject) {
                        if (this.selectedObject.annotation) {
                            var targetNode = this.diagram.nameTable[this.selectedObject.targetNode];
                            ej.datavisualization.Diagram.DefautShapes.updateBPMNAnnotationShape(this.selectedObject, this.undoObject.targetNode, targetNode, null, this.diagram);
                        }
                        this.diagram._dock(this.selectedObject, this.diagram.nameTable, true);
                        ej.datavisualization.Diagram.Util.updateBridging(this.selectedObject, this.diagram);
                        ej.datavisualization.Diagram.SvgContext.update(this.selectedObject, this.diagram);
                        this.diagram._updateConnectorBridging(this.selectedObject);
                        this.diagram._updateQuad(this.selectedObject);
                        this.diagram._updateSelectionHandle();
                        if (this.selectedObject.annotation)
                            ej.datavisualization.Diagram.DefautShapes.updateAnnotationProperties(this.selectedObject, this.diagram);
                        if (this.selectedObject) {
                            (this.diagram._svg.getElementById(this.selectedObject.name + "_hitTest")).setAttribute("pointer-events", "stroke");
                            (this.diagram._svg.getElementById(this.selectedObject.name)).setAttribute("pointer-events", "auto");
                        }
                        (this.diagram._adornerSvg.getElementById(this.diagram._adornerSvg.document.id + "handle_g")).setAttribute("pointer-events", "visible");
                        this._initialValue = null;
                    }
                }
            if (this.selectedObject) {
                var removedPort = null;
                var removePortType = "";
                if (this.selectedObject._removeTargetPort && this.selectedObject._removeTargetPort.type && this.selectedObject._removeTargetPort.type == "internal") {
                    var removedPort = this.selectedObject._removeTargetPort;
                    removePortType = "targetpoint";
                    delete this.selectedObject._removeTargetPort;
                }
                if (this.selectedObject._removeSourcePort && this.selectedObject._removeSourcePort.type && this.selectedObject._removeSourcePort.type == "internal") {
                    var removedPort = this.selectedObject._removeSourcePort;
                    removePortType = "sourcepoint";
                    delete this.selectedObject._removeSourcePort;
                }
                var entry = { type: "endpointchanged", undoObject: this.undoObject, redoObject: this._getClonedObject(this.selectedObject), removedPort: removePortType == "" ? null : removedPort, removePortType: removePortType, isMultipleNode: (this.selectedObject._type === "group") ? true : false, category: "internal" };

                this.diagram.addHistoryEntry(entry);
                for (var i = 0; i < this._nearestNodes.length; i++)
                    this._showPort(this._nearestNodes[i], true);
            }
            delete this._nearestNodes;
            base.prototype.mouseup.call(this, evt);
        };
        ConnectionEditTool.prototype._addOrRemoveStraightSegments = function (evt) {
            if (this._endPoint == "segmentEnd") {
                var targetid = evt.target.id;
                var coll = targetid.split("_");
                coll.reverse();
                var index = Number(coll[0]);
                var segment = this.selectedObject.segments[index];
                if (segment && segment.type == "straight") {
                    var prevseg = this.selectedObject.segments[index + 1];
                    if (prevseg) {
                        this.selectedObject.segments.splice(index, 1);
                        prevseg._startPoint = prevseg.points[0] = segment._startPoint;
                        update = true;
                    }
                }
            }
            else {
                var className = evt.target.getAttribute("class");
                var targetid = evt.target.id;
                var update = false;
                var index = this._findIndex();
                if (this.selectedObject.segments && this.selectedObject.segments[index] && this.selectedObject.segments[index].type == "straight") {
                    var segment = this.selectedObject.segments[index];
                    var newseg = ej.datavisualization.Diagram.Segment({ type: "straight", _point: segment._endPoint });
                    this.selectedObject.segments.splice(index + 1, 0, newseg);
                    if (index + 1 != this.selectedObject.segments.length - 1) {
                        newseg.point = newseg._point;
                    }
                    segment._point = segment.point = segment.points[1] = segment._endPoint = this.currentPoint;
                    newseg.points[0] = newseg._startPoint = this.currentPoint;
                    newseg.points[1] = newseg._endPoint = newseg._point;
                    update = true;
                }
            }
            if (update) {
                ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                ej.datavisualization.Diagram.Util.updateBridging(this.selectedObject, this.diagram);
                ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                //ej.datavisualization.Diagram.SvgContext.clearSelector(this.diagram._svg, this.diagram._adornerLayer);
                ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom);
            }
        };
        ConnectionEditTool.prototype._findIndex = function () {
            var intersectingSegs = [];
            for (var i = 0; i < this.selectedObject.segments.length; i++) {
                var segment = this.selectedObject.segments[i];
                var rect;
                rect = {
                    x: Math.min(segment._startPoint.x, segment._endPoint.x), y: Math.min(segment._startPoint.y, segment._endPoint.y),
                    width: Math.abs(segment._startPoint.x - segment._endPoint.x), height: Math.abs(segment._startPoint.y - segment._endPoint.y)
                };
                ej.datavisualization.Diagram.Geometry.inflate(rect, this.selectedObject.lineHitPadding / 2, this.selectedObject.lineHitPadding / 2);
                if (ej.datavisualization.Diagram.Geometry.containsPoint(rect, this.currentPoint)) {
                    intersectingSegs.push(segment);
                }
            }
            if (intersectingSegs.length == 1) {
                return this.selectedObject.segments.indexOf(intersectingSegs[0]);
            }
            else {
                var ratio, min, index, seg, v, h;
                for (var i = 0; i < intersectingSegs.length; i++) {
                    seg = intersectingSegs[i];
                    var point = this.currentPoint;
                    v = (point.y - seg._startPoint.y) / (seg._endPoint.y - point.y);
                    h = (point.x - seg._startPoint.x) / (seg._endPoint.x - point.x);
                    ratio = Math.abs(v - h);
                    if (i == 0) { min = ratio; index = 0; }
                    if (ratio < min) { min = ratio; index = i; }
                }
                return this.selectedObject.segments.indexOf(intersectingSegs[index]);
            }
        }
        ConnectionEditTool.prototype._removeNextSegment = function (index) {
            var first = this.selectedObject.segments[index - 1];
            var last = this.selectedObject.segments[index + 2];
            var next = this.selectedObject.segments[index + 1];
            if (next.length || next.length === 0) {
                this.selectedObject.segments.splice(index, 2);
                if (this.selectedSegment.direction == "top" || this.selectedSegment.direction == "bottom") {
                    last._startPoint.y = this.selectedSegment._startPoint.y;
                    first._endPoint.x = last._startPoint.x;
                }
                else {
                    last._startPoint.x = this.selectedSegment._startPoint.x;
                    first._endPoint.y = last._startPoint.y;
                }
            }
            else {
                this.selectedObject.segments.splice(index + 1, 1);
                if (this.selectedSegment.direction == "top" || this.selectedSegment.direction == "bottom") {
                    first._endPoint.x = next._endPoint.x;
                }
                else {
                    first._endPoint.y = next._endPoint.y;
                }
                first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, first._endPoint);
                if (first.length)
                    first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, first._endPoint);
                this.selectedSegment.length = this.selectedSegment._length = this.selectedSegment.direction = null;
            }

            if (first && last) {
                first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, last._startPoint);
                if (first.length)
                    first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, last._startPoint);
                if (last.length || last.length === 0) {
                    last._length = last.length = ej.datavisualization.Diagram.Geometry.distance(first._endPoint, last._endPoint);
                    if (last.length)
                        last._direction = last.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._endPoint, last._endPoint);
                }
            }
            return true;
        },
        ConnectionEditTool.prototype._removePrevSegment = function (index) {
            var first = this.selectedObject.segments[index - 2];
            var next = this.selectedObject.segments[index + 1];
            var length = (next.length || next.length === 0) ? next.length : ej.datavisualization.Diagram.Geometry.distance(next.points[0], next.points[1]);
            if (length <= 5) {
                var end = this.selectedObject.segments[index + 2];
                if (next.length === length)
                    this.selectedObject.segments.splice(index - 1, 4);
                else
                    this.selectedObject.segments.splice(index - 1, 3);
                if (end) {
                    if (first.direction == "top" || first.direction == "bottom") {
                        first._endPoint.y = end._endPoint.y;
                        end._startPoint.x = first._endPoint.x;
                    }
                    else {
                        first._endPoint.x = end._endPoint.x;
                        end._startPoint.y = first._endPoint.y;
                    }
                    if (first.length || first.length === 0) {
                        first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, first._endPoint);
                        if (first.length)
                            first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, first._endPoint);
                    }
                    if (end.length || end.length === 0) {
                        end._length = end.length = ej.datavisualization.Diagram.Geometry.distance(end._startPoint, end._endPoint);
                        if (end._length)
                            end._direction = end.direction = ej.datavisualization.Diagram.Util._getBezierDirection(end._startPoint, end._endPoint);
                    }
                }
                else {
                    first._endPoint = this.selectedObject.endPoint;
                    first.direction = first.length = first._length = null;
                    first._direction = next._direction;
                }
            }
            else {

                var last = this.selectedObject.segments[index + 1];
                this.selectedObject.segments.splice(index - 1, 2);
                var segment = this.selectedSegment;
                if (segment.direction == "left" || segment.direction == "right") {
                    first._endPoint.x = last._startPoint.x;
                    last._startPoint.y = first._endPoint.y;
                }
                else {
                    first._endPoint.y = last._startPoint.y;
                    last._startPoint.x = first._endPoint.x;
                }
                if (this.selectedSegment.length || this.selectedSegment.length === 0) {
                    first._length = first.length = ej.datavisualization.Diagram.Geometry.distance(first._startPoint, first._endPoint);
                    if (first._length)
                        first._direction = first.direction = ej.datavisualization.Diagram.Util._getBezierDirection(first._startPoint, first._endPoint);
                }
                if (last.length || last.length === 0) {
                    last._length = last.length = ej.datavisualization.Diagram.Geometry.distance(last._startPoint, last._endPoint);
                    if (last.length)
                        last._direction = last.direction = ej.datavisualization.Diagram.Util._getBezierDirection(last._startPoint, last._endPoint);
                }
            }

            return true;
        },
        ConnectionEditTool.prototype._getClonedObject = function (connector) {
            if (connector) {
                var clonedObject = $.extend(true, {}, connector);
                clonedObject.targetNode = connector.targetNode;
                clonedObject.sourceNode = connector.sourceNode;
                clonedObject.targetPort = connector.targetPort;
                clonedObject.sourcePort = connector.sourcePort;
                return clonedObject;
            }
        };
        ConnectionEditTool.prototype._updateConnection = function (connector, updateSelection) {
            var connectionChange;
            this._updateConnectionTarget(connector);
            if (this._endPoint == "targetEndPoint") {
                if (this._currentPossibleConnection) {
                    if (this._possibleConnectionPort && ej.datavisualization.Diagram.Util.canConnect(this._possibleConnectionPort, true)) {
                        if (connector.targetNode != this._currentPossibleConnection.name || connector.targetPort != this._possibleConnectionPort.name) {
                            connectionChange = this._raiseConnectionChangeEvent(connector, true);
                        }
                    }
                    else if (ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection)) {
                        if (connector.targetNode != this._currentPossibleConnection.name || connector.targetPort) {
                            connectionChange = this._raiseConnectionChangeEvent(connector, true);
                        }
                    }
                }
                else {
                    if (this.selectedObject.targetNode) {
                        connectionChange = this._raiseConnectionChangeEvent(connector, true);
                    }
                }
                if (connectionChange) {
                    ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                    ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                    if (connector.segments.length > 2 || connector.segments[0].points.length == 2)
                        ej.datavisualization.Diagram.Util._updatePreviousSegment(connector);
                    ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom);
                }
            }
            else if (this._endPoint == "sourceEndPoint") {
                if (this._currentPossibleConnection) {
                    if (this._possibleConnectionPort && ej.datavisualization.Diagram.Util.canConnect(this._possibleConnectionPort, true)) {
                        if (connector.sourceNode != this._currentPossibleConnection.name || connector.sourcePort != this._possibleConnectionPort.name) {
                            connectionChange = this._raiseConnectionChangeEvent(connector);
                        }
                    }
                    else if (ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection)) {
                        if (connector.sourceNode != this._currentPossibleConnection.name || connector.sourcePort) {
                            connectionChange = this._raiseConnectionChangeEvent(connector);
                        }
                    }

                }
                else {
                    if (this.selectedObject.sourceNode) {
                        connectionChange = this._raiseConnectionChangeEvent(connector);
                        //if (connectionChange)
                        {
                            ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                            ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);

                        }
                    }
                    if (connectionChange) {
                        ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom);
                    }
                }

            }

            var endPoint = this.selectedSegment._endPoint;
            this.diagram._dock(connector, this.diagram.nameTable, updateSelection);
            if (connectionChange && this._endPoint == "sourceEndPoint" && this.selectedObject.segments.length > 1) {
                if (this.selectedSegment.points.length == 2 && !this.selectedObject.sourcePort && this.selectedSegment.length) {
                    if (this.selectedSegment.direction == "right" || this.selectedSegment.direction == "left") {
                        if (this.selectedSegment._startPoint.x < endPoint.x) {
                            this.selectedSegment.direction = this.selectedSegment._direction = "right";
                        }
                        else this.selectedSegment.direction = this.selectedSegment._direction = "left";
                        this.selectedSegment.length = this.selectedSegment._length = Math.abs(this.selectedSegment._startPoint.x - endPoint.x);
                    }
                    else {
                        if (this.selectedSegment._startPoint.y < endPoint.y) {
                            this.selectedSegment.direction = this.selectedSegment._direction = "bottom";
                        }
                        else this.selectedSegment.direction = this.selectedSegment._direction = "top";
                        this.selectedSegment.length = this.selectedSegment._length = Math.abs(this.selectedSegment._startPoint.y - endPoint.y);

                    }
                    ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                    ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                    ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom);
                }
                else {
                    if (connectionChange) {
                        ej.datavisualization.Diagram.Util._updateConnectorSegments(this.selectedObject, this.selectedObject.sourcePort, this.selectedObject.targetPort, this.diagram);
                        ej.datavisualization.Diagram.DiagramContext._refreshSegments(this.selectedObject, this.diagram);
                        ej.datavisualization.Diagram.SvgContext._refreshEndPointHandles(this.diagram.selectionList[0], this.diagram._adornerSvg, this.diagram._currZoom);
                    }
                }
            }
        };

        ConnectionEditTool.prototype._disconnect = function (connector) {
            var args;
            //var node = this.diagram.nameTable[connector.targetNode];
            var port = null;
            //if (this._endPoint == "targetEndPoint" && node) {
            //    port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.targetPort);
            //    args = this._raiseEvent("connectionChange", { element: connector, endPoint: this._endPoint, connection: node, port: port, cancel: false });
            //    if (!args.cancel) {
            //        ej.datavisualization.Diagram.Util.removeItem(node.inEdges, connector.name);
            //        connector.targetNode = null;
            //        connector.targetPort = null;
            //    }

            //}
            //var node = this.diagram.nameTable[connector.sourceNode];
            //if ((this._endPoint == "sourceEndPoint") && node) {
            //    port = ej.datavisualization.Diagram.Util.findPortByName(node, connector.sourcePort);
            //    args = this._raiseEvent("connectionChange", { element: connector, endPoint: this._endPoint, connection: node, port: port, cancel: false });
            //    if (!args.cancel) {
            //        ej.datavisualization.Diagram.Util.removeItem(node.outEdges, connector.name);
            //        connector.sourceNode = null;
            //        connector.sourcePort = null;
            //    }
            //}
        };
        ConnectionEditTool.prototype._endAction = function () {
            this._showPorts();
            var possibleConnection;
            if (this._currentPossibleConnection && !this._possibleConnectionPort) {
                possibleConnection = this._currentPossibleConnection;
            }
            base.prototype._endAction.apply(this);
            if (this._endPoint) {
                this._endPoint = null;
                if (possibleConnection) {
                    this.diagram._checkToolToActivate(possibleConnection, this.currentPoint);
                    this.diagram._updateCursor();
                }
            }
        };

        ConnectionEditTool.prototype._outOfBoundsDrag = function (node, ptX, ptY, isTarget) {
            ptX = ptX ? ptX : 0;
            ptY = ptY ? ptY : 0;
            if (node && ej.datavisualization.Diagram.Util.canMoveOutofBoundary(this.diagram)) {
                var size = this._getPageBounds();
                if (!this.diagram._selectedSymbol && (ptX >= size.width || ptX <= size.x)) {
                    this.updateCursor("not-allowed");
                    return false;
                }
                if (!this.diagram._selectedSymbol && (ptY >= size.height || ptY <= size.y)) {
                    this.updateCursor("not-allowed");
                    return false;
                }
            }
            else if (!ej.datavisualization.Diagram.bpmnHelper.canMoveOutofBounds(this.diagram, node, ptX, ptY)) {
                this.updateCursor("not-allowed");
                return false;
            }
            this.updateCursor(this.cursor);
            return true;
        };
        ConnectionEditTool.prototype._updatePoints = function (connector, dragState) {
            var cancel = false, eventType = "";
            if (this._endPoint && this._endPoint != "segmentEnd" && this.selectedSegment) {
                var isTarget = (this._endPoint == "targetEndPoint") ? true : false;
                var isSource = (this._endPoint == "sourceEndPoint") ? true : false;

                var endPoint;
                if (this._endPoint) {
                    var end = this._endPoint.match("bezierpoint1") ? "bezierpoint1" : this._endPoint.match("bezierpoint2") ? "bezierpoint2" : this._endPoint;;

                    switch (end) {
                        case "targetEndPoint":
                            endPoint = this.selectedSegment._endPoint;
                            break;
                        case "sourceEndPoint":
                            endPoint = this.selectedSegment._startPoint;
                            break;
                        case "bezierpoint1":
                            endPoint = this.selectedSegment._point1;
                            break;
                        case "bezierpoint2":
                            endPoint = this.selectedSegment._point2;
                            break;
                    }

                    var ptCur = this.currentPoint;
                    if (this._possibleConnectionPort == null) {
                        ptCur = this.snap(ptCur);
                    }
                    var offset = ej.datavisualization.Diagram.Point(endPoint.x - ptCur.x, endPoint.y - ptCur.y);

                    var dragargs = this._raiseEndPointDrag(connector, isTarget, isSource, dragState);
                    if (dragargs) {
                        cancel = dragargs.cancel;
                        eventType = dragargs.type;
                    }
                    if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                        if (!cancel) {
                            if (isTarget || isSource) {
                                var connected = this._currentPossibleConnection ? ej.datavisualization.Diagram.Util.canConnect(this._currentPossibleConnection, false) : false;
                                if (this._outOfBoundsDrag(this.selectedObject, ptCur.x, ptCur.y, isTarget)) {
                                    if (this.selectedObject.segments.length > 1) {
                                        if (!isTarget && !connected && this.selectedSegment.type == "orthogonal" && (this.selectedSegment.length || this.selectedSegment.length === 0)) {
                                            this.selectedObject.sourcePoint = ptCur;
                                            var difx = ptCur.x - this.selectedSegment._startPoint.x;
                                            var dify = ptCur.y - this.selectedSegment._startPoint.y;
                                            if (this.selectedSegment.direction == "left" || this.selectedSegment.direction == "right") {
                                                this.selectedSegment._endPoint.y = this.selectedSegment.points[this.selectedSegment.points.length - 1].y = ptCur.y;
                                            }
                                            else {
                                                this.selectedSegment._endPoint.x = this.selectedSegment.points[this.selectedSegment.points.length - 1].x = ptCur.x;
                                            }
                                            this.selectedSegment._startPoint = this.selectedSegment.points[0] = ptCur;
                                            this.selectedSegment._length = this.selectedSegment.length = ej.datavisualization.Diagram.Geometry.distance(ptCur, this.selectedSegment._endPoint);
                                            if (this.selectedSegment._length)
                                                this.selectedSegment._direction = this.selectedSegment.direction = ej.datavisualization.Diagram.Util._getBezierDirection(ptCur, this.selectedSegment._endPoint);

                                            this.updateNextSegment(this.selectedObject.segments[0], this.selectedObject.segments[1], difx,
                                                dify);
                                            var next = this.selectedObject.segments[1];
                                            var updated = false;
                                            if (next && (next.length)) {
                                                next.length = next._length = ej.datavisualization.Diagram.Geometry.distance(this.selectedSegment._endPoint, next._endPoint);
                                                if (next.length)
                                                    next.direction = next._direction = ej.datavisualization.Diagram.Util._getBezierDirection(this.selectedSegment._endPoint, next._endPoint);
                                            }
                                            if (this.selectedSegment.length == 0 || next.length === 0) {
                                                if (next.length == 0 && this.selectedObject.segments.length > 2) {
                                                    this.selectedObject.segments.splice(0, 2);
                                                }
                                                else if (this.selectedObject.segments.length > 1) {
                                                    this.selectedObject.segments.splice(0, 1);
                                                }
                                                this.selectedSegment = this.selectedObject.segments[0];
                                                this.selectedSegment._startPoint = this.selectedSegment.points[0] = ptCur;
                                                if (this.selectedSegment._direction == "left" || this.selectedSegment._direction == "right") {
                                                    this.selectedSegment._endPoint.y = this.selectedSegment.points[this.selectedSegment.points.length - 1].y = ptCur.y;
                                                }
                                                else {
                                                    this.selectedSegment._endPoint.x = this.selectedSegment.points[this.selectedSegment.points.length - 1].x = ptCur.x;
                                                }

                                                var next = this.selectedObject.segments[1];
                                                if (this.selectedObject.segments.length > 1) {
                                                    this.selectedSegment._length = this.selectedSegment.length = ej.datavisualization.Diagram.Geometry.distance(ptCur, next._startPoint);
                                                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(this.selectedSegment, null, connector.segments[1], connector.sourcePoint, connector.targetPoint);
                                                    ej.datavisualization.Diagram.Util._addOrthogonalPoints(connector.segments[1], connector.segments[0], connector.segments[2], connector.sourcePoint, connector.targetPoint);
                                                    next._startPoint = next.points[0] = connector.segments[0]._endPoint;
                                                }
                                                else ej.datavisualization.Diagram.Util._addOrthogonalPoints(this.selectedSegment, null, connector.segments[1], connector.sourcePoint, connector.targetPoint);

                                                updated = true;
                                            }
                                            else ej.datavisualization.Diagram.Util._addOrthogonalPoints(this.selectedSegment, null, connector.segments[1], connector.sourcePoint, connector.targetPoint);
                                            if (next && (next.length)) {
                                                next.length = next._length = ej.datavisualization.Diagram.Geometry.distance(this.selectedSegment._endPoint, next._endPoint);
                                                if (next.length)
                                                    next.direction = next._direction = ej.datavisualization.Diagram.Util._getBezierDirection(this.selectedSegment._endPoint, next._endPoint);
                                            }
                                        }
                                        else if (isTarget && !connected && this.selectedSegment.type == "orthogonal" && this.selectedSegment.points.length == 2) {
                                            var difx = ptCur.x - this.selectedSegment._endPoint.x;
                                            var dify = ptCur.y - this.selectedSegment._endPoint.y;

                                            if (this.selectedSegment._direction == "left" || this.selectedSegment._direction == "right") {
                                                this.selectedSegment._startPoint.y = (this.selectedSegment.points[0].y += dify);
                                                this.selectedSegment._endPoint.y = this.selectedSegment.points[1].y = this.selectedSegment._startPoint.y;
                                            }
                                            else {
                                                this.selectedSegment._startPoint.x = (this.selectedSegment.points[0].x += difx);
                                                this.selectedSegment._endPoint.x = this.selectedSegment.points[1].x = this.selectedSegment._startPoint.x;
                                            }
                                            var index = this.selectedObject.segments.length - 1;
                                            if (this.selectedObject.segments[index - 1])
                                                this.updatePreviousSegment(this.selectedObject.segments[index], this.selectedObject.segments[index - 1], difx,
                                                    dify);
                                        }
                                    }
                                    if ((isSource || isTarget) && !connected) {
                                        var srclength = this.selectedSegment.points.length;
                                        this.diagram._setEndPoint(connector, ej.datavisualization.Diagram.Point(ptCur.x, ptCur.y), isTarget);
                                        if (srclength != this.selectedSegment.points.length || updated) {
                                            return { updateSelection: true, cancel: cancel };
                                        }
                                    }
                                }
                            }
                            else
                                ej.datavisualization.Diagram.Util._setBezierPoint(this.selectedSegment, ej.datavisualization.Diagram.Point(ptCur.x, ptCur.y), end);
                        }
                    }
                }
            }
            return { cancel: cancel, eventType: eventType };
        };
        return ConnectionEditTool;
    })(ToolBase);

    ej.datavisualization.Diagram.ConnectionEditTool = ConnectionEditTool;
    //#endregion

    //#region ShapeTool
    var ShapeTool = (function (base) {
        ej.datavisualization.Diagram.extend(ShapeTool, base);
        function ShapeTool(diagram) {
            base.call(this, "shapeTool", diagram);
            this.cursor = "crosshair";
            this._drawingPolygon = false;
            this._points = [];
        }
        ShapeTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);

            if (this._isPolyline() && evt && !this._sourcePossibleConnection) {
                if (this._currentPossibleConnection) {
                    var point = this.mousePosition(evt);
                    this._possibleConnectionPort = this.diagram._findPortAtPoint(point, this._currentPossibleConnection);
                }
                if (this._currentPossibleConnection) {
                    this._sourcePossibleConnection = this._currentPossibleConnection;
                    this._sourcePort = this._possibleConnectionPort;
                }
            }

            if (!this._drawingPolygon) {
                this.selectedObject = this.createNode();
                if (this.selectedObject.type == "bpmn") this.diagram._initGroupNode(this.selectedObject);
                this.selectedObject._type = "node";
            }
            else {
                var pt = this.helper.points[this.helper.points.length - 1];
                pt = { x: pt.x, y: pt.y };
                this.helper.points.push(pt);
                this._points.push(this.snap(this.currentPoint));
            }

            this._prevPoint = this.currentPoint;
        };

        ShapeTool.prototype._getStartPoint = function () {
            var ptStart;
            if (this._sourcePossibleConnection && this._sourcePort) {
                ptStart = ej.datavisualization.Diagram.Util._getPortPosition(this._sourcePort, ej.datavisualization.Diagram.Util.bounds(this._sourcePossibleConnection));
            }
            else {
                ptStart = this.snap(this.startPoint);
            }
            return ptStart;
        };
        ShapeTool.prototype._getCurrentPoint = function () {
            var ptCur;
            if (this._targetPossibleConnection && this._targetPort) {
                ptCur = ej.datavisualization.Diagram.Util._getPortPosition(this._targetPort, ej.datavisualization.Diagram.Util.bounds(this._targetPossibleConnection));
            }
            else {
                ptCur = this.snap(this.currentPoint);
            }
            return ptCur;
        };

        ShapeTool.prototype.createNode = function () {
            if (this._isPolyline()) {
                var connector = $.extend(true, {}, this.diagram.model.drawType);
                connector.sourcePoint = this.currentPoint,
                connector.targetPoint = this.currentPoint,
                connector.segments = [{ type: "straight" }]
                node = this.diagram._getNewConnector(connector);
            }
            else
                var node = this.diagram._getNewNode(this.diagram.model.drawType);
            if (this.diagram.model.drawType.name) {
                node.name = this.diagram.model.drawType.name + ej.datavisualization.Diagram.Util.randomId();
            }
            else {
                node.name = "node" + ej.datavisualization.Diagram.Util.randomId();
            }
            var currentPoint = this.snap(this.currentPoint);
            if (!this._isPolyline()) {
                node.offsetX = currentPoint.x;
                node.offsetY = currentPoint.y;
                node.width = 5;
                node.height = 5;
            }
            if (node.type != "text" && !this._isPolyline())
                node.shape = this.diagram.model.drawType.shape ? this.diagram.model.drawType.shape : node.shape;

            if ((this.diagram.model.drawType.shape == "polygon" || this._isPolyline()) && (!this.diagram.model.drawType.points || !this.diagram.model.drawType.points.length)) {
                this._drawingPolygon = true;
                var startPoint = this.snap(this.startPoint);
                node.points = [{ x: startPoint.x, y: startPoint.y },
                    { x: currentPoint.x, y: currentPoint.y }];
                this._points = [{ x: startPoint.x, y: startPoint.y },
                    { x: currentPoint.x, y: currentPoint.y }];
            }
            return ej.datavisualization.Diagram.NodeType(node, this.diagram);
        };
        ShapeTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this.selectedObject) {
                if (!this.inAction) {
                    this.inAction = true;
                    if (this.selectedObject.shape === "polygon" && (!this.diagram.model.drawType.points || !this.diagram.model.drawType.points.length)) {
                        if (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y) {
                            var startPoint = this.snap(this.startPoint);
                            var currentPoint = this.snap(this.currentPoint);
                            this.selectedObject.points = [{ x: startPoint.x, y: startPoint.y },
                                { x: currentPoint.x, y: currentPoint.y }];
                            this._points = [{ x: startPoint.x, y: startPoint.y },
                                { x: currentPoint.x, y: currentPoint.y }];
                        }
                    }
                    this._initHelper();
                    this._renderHelper();
                }
                else {
                    this._updateHelper();
                }
            }
            if (this._isPolyline() && evt) {
                this._checkConnectionPossible(evt);
            }
            this.previousPoint = this.currentPoint;
        };
        ShapeTool.prototype._addPolyline = function (evt) {
            if (this._currentPossibleConnection) {
                var point = this.mousePosition(evt);
                this._targetPossibleConnection = this._currentPossibleConnection;
                this._targetPort = this.diagram._findPortAtPoint(point, this._currentPossibleConnection);
            }
            var segments = [];
            if (this._currentPossibleConnection && this._sourcePossibleConnection)
                this._sourcePossibleConnection = this._sourcePossibleConnection.name === this._currentPossibleConnection.name ? null : this._sourcePossibleConnection;
            for (var i = 1; i < this.selectedObject.points.length - 2; i++)
                segments.push({ type: "straight", point: this.selectedObject.points[i] });
            var connector = this.diagram._getNewConnector(this.selectedObject)
            connector.name = this.selectedObject.name;
            connector.sourcePoint = this.selectedObject.points[0];
            connector.targetPoint = this.selectedObject.points[this.selectedObject.points.length - 1];
            connector.segments = segments;
            connector.sourceNode = this._sourcePossibleConnection ? this._sourcePossibleConnection.name : null;
            connector.targetNode = this._targetPossibleConnection ? this._targetPossibleConnection.name : null;
            connector.sourcePort = this._sourcePort ? this._sourcePort.name : null;
            connector.targetPort = this._targetPort ? this._targetPort.name : null;
            this.diagram.add(connector);
            this._sourcePossibleConnection = null;
            this._targetPossibleConnection = null;
            this._sourcePort = null;
            this._targetPort = null;
        };
        ShapeTool.prototype.mouseup = function (evt) {
            var resetTool = false;
            if ((!this._drawingPolygon || evt.button == 2 || this.diagram._getEventDetail(evt) == 2) || (this._sourcePossibleConnection && this._currentPossibleConnection
                    && (this._sourcePossibleConnection.name != this._currentPossibleConnection.name)
                    || (this._sourcePort && this._targetPort && this._sourcePort.name !== this._targetPort.name))) {
                if (this.inAction) {
                    this.inAction = false;
                    if (this._drawingPolygon) this.selectedObject.points = this.helper.points;
                    this._updateSize(this.selectedObject, this.startPoint, this.currentPoint);
                    if (this._isPolyline()) {
                        this._addPolyline(evt);
                    }
                    else
                        this.diagram.add(this.selectedObject);
                }
                resetTool = true;
            }
            else if (this._currentPossibleConnection && this.helper) {
                if (this.selectedObject.points.length > 0) {
                    if (this._drawingPolygon) this.selectedObject.points = this.helper.points;
                    this._updateSize(this.selectedObject, this.startPoint, this.currentPoint);
                    if (this._isPolyline()) {
                        this._addPolyline(evt);
                    }
                }
                resetTool = true;
            }

            if (resetTool) {
                this.diagram._toolToActivate = "selectTool";
                this.diagram._drawingTool = false;
                base.prototype.mouseup.call(this, evt);
                if (this._drawingPolygon) {
                    this.diagram._disableDefaultContextMenu = true;
                    delete this._drawingPolygon;
                    delete this._points;
                }
            }
        };
        ShapeTool.prototype._renderHelper = function () {
            if (!this.svgHelper) {
                if (this._isPolyline())
                    this.svgHelper = ej.datavisualization.Diagram.SvgContext.renderConnector(this.helper, this.diagram._svg, this.diagram._diagramLayer, this.diagram);
                else if (this.helper.type != "bpmn")
                    this.svgHelper = ej.datavisualization.Diagram.SvgContext.renderNode(this.helper, this.diagram._svg, this.diagram._diagramLayer, undefined, this.diagram);
                else {
                    this.helper._type = "group";
                    this.diagram._initGroupNode(this.helper);
                    this.svgHelper = ej.datavisualization.Diagram.SvgContext.renderGroup(this.helper, this.diagram._svg, this.diagram._diagramLayer, this.diagram.nameTable, this.diagram);
                }
                this.svgHelper = document.getElementById(this.helper.name);
                this.svgHelper.setAttribute("pointer-events", "none");
            }
        };
        ShapeTool.prototype._outOfBoundsDrag = function (node, ptX, ptY, isTarget) {
            ptX = ptX ? ptX : 0;
            ptY = ptY ? ptY : 0;
            if (node && ej.datavisualization.Diagram.Util.canMoveOutofBoundary(this.diagram)) {
                var size = this._getPageBounds();
                if (!this.diagram._selectedSymbol && (ptX >= size.width || ptX <= size.x)) {
                    this.updateCursor("not-allowed");
                    return false
                }
                if (!this.diagram._selectedSymbol && (ptY >= size.height || ptY <= size.y)) {
                    this.updateCursor("not-allowed");
                    return false
                }
            }
            else if (node.sourceNode != null && !ej.datavisualization.Diagram.bpmnHelper.canMoveOutofBounds(this.diagram, node, ptX, ptY)) {
                this.updateCursor("not-allowed");
                return false;
            }
            this.updateCursor(this.cursor);
            return true
        };
        ShapeTool.prototype._updateHelper = function () {
            var ptStart = this._getStartPoint();
            var ptEnd = this._getCurrentPoint();
            if (this._drawingPolygon && (this._outOfBoundsDrag(this.helper, ptEnd.x, ptEnd.y) && this._outOfBoundsDrag(this.helper, ptStart.x, ptStart.y))) {
                var currentPoint = this.snap(this.currentPoint);
                var previousPoint = this.snap(this.previousPoint);
                var dif = { x: currentPoint.x - previousPoint.x, y: currentPoint.y - previousPoint.y };
                this.helper.points[this.helper.points.length - 1].x += dif.x;
                this.helper.points[this.helper.points.length - 1].y += dif.y;
                this._points[this._points.length - 1].x += dif.x;
                this._points[this._points.length - 1].y += dif.y;
                if (this._isPolyline()) {
                    var segments = [];
                    for (var i = 0; i < this.helper.points.length - 1  ; i++)
                        segments.push({ type: "straight", point: this.helper.points[i] });
                    this.helper.sourcePoint = this.helper.points[0];
                    this.helper.targetPoint = this.helper.points[this.helper.points.length - 1];
                    this.helper.segments = segments;
                    this.helper = this.diagram._getNewConnector(this.helper)
                    this.diagram._dock(this.helper, this.diagram.nameTable);
                }
            }
            var prtyObject = $.extend(true, {}, this.helper);
            this._updateSize(this.helper, this.snap(this.startPoint), this.snap(this.currentPoint));
            this.diagram._comparePropertyValues(this.helper, "height", { height: prtyObject.height }, true);
            this.diagram._comparePropertyValues(this.helper, "width", { width: prtyObject.width }, true);
            this.diagram._comparePropertyValues(this.helper, "offsetX", { offsetX: prtyObject.offsetX }, true);
            this.diagram._comparePropertyValues(this.helper, "offsetY", { offsetY: prtyObject.offsetY }, true);
            if (this.helper.shape == "polygon" && !this._drawingPolygon) {
                this.helper.width = this.helper.width != 0 ? this.helper.width : 5;
                this.helper.height = this.helper.height != 0 ? this.helper.height : 5;
            }
            ej.datavisualization.Diagram.SvgContext.update(this.helper, this.diagram);
        };
        ShapeTool.prototype._updateSize = function (shape, startPoint, currentPoint) {
            if ((this._outOfBoundsDrag(this.helper, currentPoint.x, currentPoint.y) && this._outOfBoundsDrag(this.helper, startPoint.x, startPoint.y))) {
                var pts = this._drawingPolygon ? this._points : [startPoint, currentPoint];
                var rect = ej.datavisualization.Diagram.Geometry.rect(pts);
                var size = { width: rect.width, height: rect.height };
                var offset = { x: rect.x, y: rect.y };
                if (!ej.datavisualization.Diagram.Geometry.isEmptySize(size)) {
                    if (this.helper.type != "bpmn") {
                        shape.offsetX = offset.x + size.width / 2;
                        shape.offsetY = offset.y + size.height / 2;
                        shape.width = size.width;
                        shape.height = size.height;
                        if (shape._shape === "path")
                            shape._scaled = true;
                    }
                    else {
                        shape._type = "group";
                        this.diagram._translate(shape, (offset.x + size.width / 2) - shape.offsetX, (offset.y + size.height / 2) - shape.offsetY, this.diagram.nameTable);
                        this.diagram.scale(shape, size.width / this.helper.width, size.height / this.helper.height, new ej.datavisualization.Diagram.Point(shape.offsetX, shape.offsetY), this.diagram.nameTable);
                        ej.datavisualization.Diagram.Util._updateGroupBounds(shape, this.diagram);
                    }
                }
            }
        };
        return ShapeTool;
    })(ToolBase)

    ej.datavisualization.Diagram.ShapeTool = ShapeTool;
    //#endregion

    //#region LineTool
    var LineTool = (function (base) {
        ej.datavisualization.Diagram.extend(LineTool, base);
        function LineTool(name, diagram) {
            base.call(this, name, diagram);
            this.cursor = "crosshair";
            this._isMouseDown = false;
            this._targetPossibleConnection = null;
            this._sourcePossibleConnection = null;
            this._targetPort = null;
            this._sourcePort = null;
        }
        LineTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            if (ej.datavisualization.Diagram.Util.isPageEditable(this.diagram)) {
                this._isMouseDown = true;
                if (this.diagram._hasSelection()) {
                    this.diagram._clearSelection();
                }
                if (evt && evt.type === "touchstart") {
                    this._currentPossibleConnection = this.diagram._findConnectableNodeUnderMouse(evt);
                    if (this._currentPossibleConnection) {
                        var point = this.mousePosition(evt);
                        this._possibleConnectionPort = this.diagram._findPortAtPoint(point, this._currentPossibleConnection);
                    }
                }
                if (this._currentPossibleConnection) {
                    this._sourcePossibleConnection = this._currentPossibleConnection;
                    this._sourcePort = this._possibleConnectionPort;
                }
                this._raiseEndPointDrag(this.helper, true, false, ej.datavisualization.Diagram.DragState.Starting);
            }
        };

        LineTool.prototype._updateConnection = function (connector, updateSelection) {
            if (connector) {
                this._updateConnectionTarget(this.helper, true);
                this._raiseConnectionChangeEvent(connector, this._endPoint == "sourceEndPoint" ? false : true);
            }
        };
        LineTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            this._checkConnectionPossible(evt);
            if (this._isMouseDown) {
                if (!this.inAction) {
                    this.inAction = true;
                    this._initHelper();
                    this._renderHelper();
                }
                else {
                    this._targetPossibleConnection = this._currentPossibleConnection;
                    this._targetPort = this._possibleConnectionPort;
                    this._updateConnection(this.helper)
                    if (this.helper) {
                        var dragargs = this._raiseEndPointDrag(this.helper, true, false, ej.datavisualization.Diagram.DragState.Dragging);
                        var prptyObject = $.extend(true, {}, this.helper);
                        if (!dragargs.cancel)
                            this._updateHelper();
                        this.diagram._comparePropertyValues(this.helper, "sourcePoint", { sourcePoint: prptyObject.sourcePoint }, true);
                        this.diagram._comparePropertyValues(this.helper, "targetPoint", { targetPoint: prptyObject.targetPoint }, true);
                        this.diagram._comparePropertyValues(this.helper, "segments", { segments: prptyObject.segments }, true);
                        this.diagram._comparePropertyValues(this.helper, "targetNode", { targetNode: this._targetPossibleConnection }, true);
                        this.diagram._comparePropertyValues(this.helper, "targetPort", { targetPort: this._targetPort }, true);
                    }
                }
            }
            this.previousPoint = this.currentPoint;
        };
        LineTool.prototype.mouseup = function (evt) {

            this._targetPort = this._possibleConnectionPort || this._targetPort;
            this._targetPossibleConnection = this._targetPossibleConnection ? this._targetPossibleConnection : this._currentPossibleConnection;
            this._removeHighLighter();
            ej.datavisualization.Diagram.SvgContext._removePortHighlighter(this.diagram._adornerSvg, this.diagram._adornerLayer);

            this._isMouseDown = false;
            if (this.inAction) {
                this.inAction = false;
                var ptStart = this._getStartPoint();
                var ptEnd = this._getCurrentPoint();
                var distance = ej.datavisualization.Diagram.Geometry.distance(ptStart, ptEnd);
                if (this._outOfBoundsDrag(this.helper, ptEnd.x, ptEnd.y) && this._outOfBoundsDrag(this.helper, ptStart.x, ptStart.y)) {
                    if (distance > 0) {
                        var connector = this.createConnector(ptStart, ptEnd);
                        connector.name = "connector" + ej.datavisualization.Diagram.Util.randomId();
                        var args, dragargs;
                        if (this._sourcePossibleConnection) {
                            if (this._sourcePort && ej.datavisualization.Diagram.Util.canConnect(this._sourcePort, true)) {
                                args = this._raiseEvent("connectionChange", { element: connector, connection: this._sourcePossibleConnection, port: this._sourcePort, cancel: false });
                                ej.datavisualization.Diagram.Util.removeItem(this._sourcePossibleConnection.outEdges, this.helper.name);
                                dragargs = this._raiseEndPointDrag(connector, true, false, ej.datavisualization.Diagram.DragState.Completed);
                                if (!args.cancel && !dragargs.cancel) {
                                    connector.sourceNode = this._sourcePossibleConnection.name;
                                    connector.sourcePort = this._sourcePort.name;
                                }
                            }
                            else if (ej.datavisualization.Diagram.Util.canConnect(this._sourcePossibleConnection)) {
                                args = this._raiseEvent("connectionChange", { element: connector, connection: this._sourcePossibleConnection, port: this._sourcePort, cancel: false });
                                ej.datavisualization.Diagram.Util.removeItem(this._sourcePossibleConnection.outEdges, this.helper.name);
                                dragargs = this._raiseEndPointDrag(connector, true, false, ej.datavisualization.Diagram.DragState.Completed);
                                if (!args.cancel && !dragargs.cancel) {
                                    connector.sourceNode = this._sourcePossibleConnection.name;
                                }
                            }
                        }
                        if (this._targetPossibleConnection) {
                            if (this._targetPort && ej.datavisualization.Diagram.Util.canConnect(this._targetPort, true)) {
                                args = this._raiseEvent("connectionChange", { element: connector, connection: this._targetPossibleConnection, port: this._targetPort, cancel: false });
                                ej.datavisualization.Diagram.Util.removeItem(this._targetPossibleConnection.inEdges, this.helper.name);
                                dragargs = this._raiseEndPointDrag(connector, true, false, ej.datavisualization.Diagram.DragState.Completed);
                                if (!args.cancel && !dragargs.cancel) {
                                    connector.targetNode = this._targetPossibleConnection.name;
                                    connector.targetPort = this._targetPort.name;
                                }
                            }
                            else if (ej.datavisualization.Diagram.Util.canConnect(this._targetPossibleConnection)) {
                                args = this._raiseEvent("connectionChange", { element: connector, connection: this._targetPossibleConnection, port: this._targetPort, cancel: false });
                                ej.datavisualization.Diagram.Util.removeItem(this._targetPossibleConnection.inEdges, this.helper.name);
                                dragargs = this._raiseEndPointDrag(connector, true, false, ej.datavisualization.Diagram.DragState.Completed);
                                if (!args.cancel && !dragargs.cancel) {
                                    connector.targetNode = this._targetPossibleConnection.name;
                                }
                            }
                        }
                        var success = this.diagram.add(connector);
                        if (success) {
                            connector = this.diagram.nameTable[connector.name];
                            ej.datavisualization.Diagram.Util.updateBridging(connector, this.diagram);
                            ej.datavisualization.Diagram.SvgContext.update(connector, this.diagram);
                            this.diagram._updateConnectorBridging(connector);
                        }
                    }
                    else {
                        if (this._sourcePossibleConnection) {
                            if ((this._sourcePort && ej.datavisualization.Diagram.Util.canConnect(this._sourcePort, true)) || (ej.datavisualization.Diagram.Util.canConnect(this._sourcePossibleConnection))) {
                                ej.datavisualization.Diagram.Util.removeItem(this._sourcePossibleConnection.outEdges, this.helper.name);
                            }
                        }
                        if (this._targetPossibleConnection) {
                            if ((this._targetPort && ej.datavisualization.Diagram.Util.canConnect(this._targetPort, true)) ||  (ej.datavisualization.Diagram.Util.canConnect(this._targetPossibleConnection))) {
                                ej.datavisualization.Diagram.Util.removeItem(this._targetPossibleConnection.inEdges, this.helper.name);
                            }
                        }
                    }
                }
            }
            if (this.singleAction)
                this.diagram.deactivateTool();
            if (this._prevTool)
                this._prevTool.inAction = false;
            this._showPorts();
            base.prototype.mouseup.call(this, evt);
        };

        LineTool.prototype._getStartPoint = function () {
            var ptStart;
            if (this._sourcePossibleConnection && this._sourcePort) {
                ptStart = ej.datavisualization.Diagram.Util._getPortPosition(this._sourcePort, ej.datavisualization.Diagram.Util.bounds(this._sourcePossibleConnection));
            }
            else {
                ptStart = this.snap(this.startPoint);
            }
            return ptStart;
        };
        LineTool.prototype._getCurrentPoint = function () {
            var ptCur;
            if (this._targetPossibleConnection && this._targetPort) {
                ptCur = ej.datavisualization.Diagram.Util._getPortPosition(this._targetPort, ej.datavisualization.Diagram.Util.bounds(this._targetPossibleConnection));
            }
            else {
                ptCur = this.snap(this.currentPoint);
            }
            return ptCur;
        };
        LineTool.prototype._initHelper = function () {
            this.helper = this.createConnector(ej.datavisualization.Diagram.Point(0, 0), ej.datavisualization.Diagram.Point(0, 0));
            this.diagram._setZorder(this.helper);
            this.helper.name = "helper";
            this.helper._connectorType = "helper";
        };
        LineTool.prototype.createConnector = function (startPoint, endPoint) {
            return null;
        };
        LineTool.prototype._renderHelper = function () {
            if (!this.svgHelper) {
                this.svgHelper = ej.datavisualization.Diagram.SvgContext.renderConnector(this.helper, this.diagram._svg, this.diagram._diagramLayer, this.diagram);
                this.svgHelper = this.diagram._svg.document.getElementById(this.helper.name);
                this.svgHelper.setAttribute("pointer-events", "none");
                $(this.diagram._svg.getElementById(this.svgHelper.id)).attr("pointer-events", "none");
                $(this.diagram._svg.getElementById(this.svgHelper.id + "_hitTest")).attr("pointer-events", "none");
            }
        };

        LineTool.prototype._outOfBoundsDrag = function (node, ptX, ptY, isTarget) {
            ptX = ptX ? ptX : 0;
            ptY = ptY ? ptY : 0;
            if (node && ej.datavisualization.Diagram.Util.canMoveOutofBoundary(this.diagram)) {
                var size = this._getPageBounds();
                if (!this.diagram._selectedSymbol && (ptX >= size.width || ptX <= size.x)) {
                    this.updateCursor("not-allowed");
                    return false
                }
                if (!this.diagram._selectedSymbol && (ptY >= size.height || ptY <= size.y)) {
                    this.updateCursor("not-allowed");
                    return false
                }
            }
            else if (node.sourceNode != null && !ej.datavisualization.Diagram.bpmnHelper.canMoveOutofBounds(this.diagram, node, ptX, ptY)) {
                this.updateCursor("not-allowed");
                return false;
            }
            this.updateCursor(this.cursor);
            return true
        };

        LineTool.prototype._updateHelper = function () {
            var points = [];
            var ptStart = this._getStartPoint();
            var ptEnd = this._getCurrentPoint();
            points.push(ptStart);
            points.push(ptEnd);
            if (this._outOfBoundsDrag(this.helper, ptEnd.x, ptEnd.y) && this._outOfBoundsDrag(this.helper, ptStart.x, ptStart.y)) {
                this.diagram._setEndPoint(this.helper, ptStart, false);
                this.diagram._setEndPoint(this.helper, ptEnd, true);
                this._disconnect(this.helper);
                if (this._sourcePossibleConnection) {
                    if (this._sourcePort && ej.datavisualization.Diagram.Util.canConnect(this._sourcePort, true)) {
                        this.helper.sourceNode = this._sourcePossibleConnection.name;
                        this.helper.sourcePort = this._sourcePort.name;
                        this._sourcePossibleConnection.outEdges.push(this.helper.name);
                    }
                    else if (ej.datavisualization.Diagram.Util.canConnect(this._sourcePossibleConnection)) {
                        this.helper.sourceNode = this._sourcePossibleConnection.name;
                        this._sourcePossibleConnection.outEdges.push(this.helper.name);
                    }
                }
                if (this._targetPossibleConnection) {
                    if (this._targetPort && ej.datavisualization.Diagram.Util.canConnect(this._targetPort, true)) {
                        this.helper.targetNode = this._targetPossibleConnection.name;
                        this.helper.targetPort = this._targetPort.name;
                        this._targetPossibleConnection.inEdges.push(this.helper.name);
                    }
                    else if (ej.datavisualization.Diagram.Util.canConnect(this._targetPossibleConnection)) {
                        this.helper.targetNode = this._targetPossibleConnection.name;
                        this._targetPossibleConnection.inEdges.push(this.helper.name);
                    }
                }
                this.diagram._dock(this.helper, this.diagram.nameTable);
            }
            ej.datavisualization.Diagram.SvgContext.update(this.helper, this.diagram);
        };
        LineTool.prototype._endAction = function () {
            base.prototype._endAction.apply(this);
            this._targetPossibleConnection = null;
            this._sourcePossibleConnection = null;
            this._targetPort = null;
            this._sourcePort = null;
            this._isMouseDown = false;
        };
        LineTool.prototype._showPorts = function (node) {
        };
        LineTool.prototype._showAllPorts = function (hide) {
            base.prototype._showAllPorts.call(this, hide);
        };
        return LineTool;
    })(ToolBase);

    ej.datavisualization.Diagram.LineTool = LineTool;
    //#endregion

    //#region StraightLineTool
    var StraightLineTool = (function (base) {
        ej.datavisualization.Diagram.extend(StraightLineTool, base);
        function StraightLineTool(diagram) {
            base.call(this, "straightLine", diagram);
        }
        StraightLineTool.prototype.createConnector = function (startPoint, endPoint) {
            var connector = { "segments": [{ "type": "straight" }], "sourcePoint": startPoint, "targetPoint": endPoint };
            return this.diagram._getNewConnector($.extend(true, {}, connector, this.diagram.model.drawType));
        };
        return StraightLineTool;
    })(LineTool);

    ej.datavisualization.Diagram.StraightLineTool = StraightLineTool;
    //#endregion

    //#region OrthogonalLineTool
    var OrthogonalLineTool = (function (base) {
        ej.datavisualization.Diagram.extend(OrthogonalLineTool, base);
        function OrthogonalLineTool(diagram) {
            base.call(this, "orthogonalLine", diagram);
        }
        OrthogonalLineTool.prototype.createConnector = function (startPoint, endPoint) {
            var connector = { "segments": [{ "type": "orthogonal" }], "sourcePoint": startPoint, "targetPoint": endPoint };
            return this.diagram._getNewConnector($.extend(true, {}, connector, this.diagram.model.drawType));
        };
        return OrthogonalLineTool;
    })(LineTool);

    ej.datavisualization.Diagram.OrthogonalLineTool = OrthogonalLineTool;
    //#endregion

    //#region BezierLineTool
    var BezierLineTool = (function (base) {
        ej.datavisualization.Diagram.extend(BezierLineTool, base);
        function BezierLineTool(diagram) {
            base.call(this, "bezierLine", diagram);
        }
        BezierLineTool.prototype.createConnector = function (startPoint, endPoint) {
            var connector = { "segments": [{ "type": "bezier" }], "sourcePoint": startPoint, "targetPoint": endPoint };
            return this.diagram._getNewConnector($.extend(true, {}, connector, this.diagram.model.drawType));
        };
        return BezierLineTool;
    })(LineTool);
    ej.datavisualization.Diagram.BezierLineTool = BezierLineTool;
    //#endregion

    //#region RotateTool
    var RotateTool = (function (base) {
        ej.datavisualization.Diagram.extend(RotateTool, base);
        function RotateTool(diagram) {
            base.call(this, "rotatetool", diagram);
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
            this.undoObject = null;
        }
        RotateTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this.selectedObject = this.diagram.selectionList[0];
            //this.undoObject = ej.datavisualization.Diagram.Util.clone(this.selectedObject);

            var data;
            var childTable = {};
            if (this.selectedObject._type === "group" || this.selectedObject.type === "pseudoGroup")
                childTable = this.diagram._getChildTable(this.selectedObject, childTable);
            var temp = { "childTable": childTable, "node": this.selectedObject };
            data = $.extend(true, {}, temp);
            this.undoObject = jQuery.extend(true, {}, data);

            var scale = this.diagram._currZoom;
            //ej.datavisualization.Diagram.SvgContext.renderPivotPoint(this.selectedObject, this.diagram._currZoom, this.diagram._svg);

        };
        RotateTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            var start = !this.inAction;
            if (this.selectedObject) {
                if (!this.inAction) {
                    if (this.selectedObject._type === "group" || this.selectedObject.type === "pseudoGroup") {
                        var children = this.diagram._getChildren(this.selectedObject.children);
                        for (var i = 0; i < children.length; i++) {
                            var child = this.diagram.nameTable[children[i]];
                            if (!child.segments)
                                if (!ej.datavisualization.Diagram.Util.canRotate(child)) return;
                        }
                    }
                    this._initialValue = this.selectedObject.rotateAngle;
                    this.inAction = true;
                }
                {
                    var isContainer = false;
                    if (this.selectedObject.parent) {
                        var parent = this.diagram.nameTable[this.selectedObject.parent];
                        if (parent.container) {
                            isContainer = true;
                        }
                    }
                    else if (this.selectedObject.type == "pseudoGroup" && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                        isContainer = true;
                    }
                    if (isContainer) {
                        if (this.selectedObject.type == "pseudoGroup" && this._isParentAsLane(this.selectedObject)) {
                            ej.datavisualization.Diagram.canvasHelper._removeFromParentContainer(this.diagram, this.selectedObject);
                            this._rotate(this.selectedObject);
                            if (this.selectedObject.parent) {
                                ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                            }
                        }
                        else {
                            if (!this.helper) {
                                this.helper = this._getCloneNode(this.selectedObject);
                                this.helper.inEdges = this.helper.outEdges = [];
                                this.helper.type = null;
                                this.helper.name = "helper";
                            }
                            this._rotate(this.helper);
                            ej.datavisualization.Diagram.SvgContext._drawContainerHelper(this.diagram);
                            this.diagram._renderTooltip(this.selectedObject, start);
                        }
                    }

                    else {
                        if (this.selectedObject.type == "pseudoGroup" && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {// && this._fromContainer(this.selectedObject.children) && this.hasSameParent()) {
                            if (this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                                this._rotate(this.selectedObject);
                                if (this.selectedObject.parent) {
                                    ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                                }
                                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                                this.diagram._updateSelectionHandle(true);
                                this.diagram._renderTooltip(this.selectedObject, start);                          
                            }
                        }
                        else {
                            if (this.selectedObject.type === "pseudoGroup")
                                this._updateMultipleUndoObject(this.selectedObject);
                            this._rotate(this.selectedObject);
                            if (this.selectedObject.parent) {
                                ej.datavisualization.Diagram.Util._updateGroupBounds(this.diagram.nameTable[this.selectedObject.parent], this.diagram);
                            }
                            ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                            this.diagram._updateSelectionHandle(true);
                            this.diagram._renderTooltip(this.selectedObject, start);                           
                        }
                    }
                }
            }
            this.previousPoint = this.currentPoint;
        };
        RotateTool.prototype._rotate = function (node) {
            var cancel = false;
            var oldbounds, newbounds;
            var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
            var crntpoint = this.currentPoint;
            var angle = ej.datavisualization.Diagram.Geometry.findAngle(ej.datavisualization.Diagram.Point(pt.x, pt.y), crntpoint) + 90;
            angle = ej.datavisualization.Diagram.SnapUtil._snapAngle(this.diagram, angle) - node.rotateAngle;
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            oldbounds = ej.datavisualization.Diagram.Rectangle(bounds.left, bounds.top, bounds.right - bounds.left, bounds.bottom - bounds.top);
            var oldValue = { bounds: oldbounds, offsetX: node.offsetX, offsetY: node.offsetY, width: node.width, height: node.height };
            this.diagram._comparePropertyValues(node, "rotateAngle", { rotateAngle: angle }, true);
            this.diagram._rotate(node, angle, this.diagram.nameTable);
            bounds = ej.datavisualization.Diagram.Util.bounds(node);
            newbounds = ej.datavisualization.Diagram.Rectangle(bounds.left, bounds.top, bounds.right - bounds.left, bounds.bottom - bounds.top);
            var newValue = { bounds: newbounds, offsetX: node.offsetX, offsetY: node.offsetY, width: node.width, height: node.height };
            var args = this._raiseEvent("rotationChange", { element: this.diagram.getNode(node), angle: node.rotateAngle, oldValue: oldValue, newValue: newValue, cancel: false });
            if (args.cancel)
                this.diagram._rotate(node, -angle, this.diagram.nameTable);
        };
        RotateTool.prototype.mouseup = function (evt) {
            if (this.inAction) {
                this.inAction = false;
                var isContainer = false;
                var rotateState = true;
                var canvasChild = false;
                if (this.selectedObject.parent) {
                    var parent = this.diagram.nameTable[this.selectedObject.parent];
                    if (parent.container) {
                        isContainer = true;
                    }
                }
                else if (this.selectedObject.type == "pseudoGroup" && this.hasSameParent() && this._fromContainer(this.diagram._getChildren(this.selectedObject.children))) {
                    var fNode = this.diagram.nameTable[this.diagram._getChild(this.selectedObject.children[0])];
                    parent = this.diagram.nameTable[fNode.parent];
                    if (parent.container) {
                        isContainer = true;
                    }
                }
                if ((this.selectedObject.type == "pseudoGroup" || this.selectedObject.name == "multipleSelection") && this.diagram._activeSwimLane) {
                    ej.datavisualization.Diagram.canvasHelper._multiNodeRotate(this.diagram, evt, this.selectedObject);
                }
                else if (isContainer) {
                    ej.datavisualization.Diagram.SvgContext._removeContainerHelper(this.selectedObject, this.diagram._adornerSvg, this.diagram._adornerLayer);
                    this._removeHighLighter(); //ej.datavisualization.Diagram.SvgContext._removeNodeHighlighter(this.diagram._svg, this.diagram._adornerLayer);
                    if (parent.container.type == "canvas")
                        canvasChild = true;
                    if (canvasChild) {
                        if (ej.datavisualization.Diagram.canvasHelper._outOfBoundaryNodeDrop(this.diagram, this.diagram.activeTool.helper, parent)) {
                            ej.datavisualization.Diagram.canvasHelper._singleNodeRotate(this.diagram, evt, this.selectedObject);
                        }
                        else {
                            rotateState = false;
                        }
                    }
                }
                if (this.selectedObject.type != "pseudoGroup") {
                    if (rotateState)
                        this._rotate(this.selectedObject);
                }
                else {
                    if (!this._fromContainer(this.diagram._getChildren(this.selectedObject.children)))
                        this._rotate(this.selectedObject);
                }
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                if (ej.datavisualization.Diagram.Util.canRouteDiagram(this.diagram)) {
                    this.undoObject.connectors = {};
                    this._redoConnectors = {};
                    this.diagram._updateAllEdges(this.selectedObject);
                }
                var data;
                var childTable = {};
                if (this.selectedObject._type === "group" || this.selectedObject.type === "pseudoGroup")
                    childTable = this.diagram._getChildTable(this.selectedObject, childTable);
                var temp = { "childTable": childTable, "node": this.selectedObject };
                if (ej.datavisualization.Diagram.Util.canRouteDiagram(this.diagram) && this._redoConnectors) {
                    temp.connectors = this._redoConnectors;
                }
                data = $.extend(true, {}, temp);
                var entry = { type: "rotationchanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, data), isMultipleNode: (this.selectedObject._type === "group") ? true : false, category: "internal" };
                if (!this._multipleUndo)
                    this.diagram.addHistoryEntry(entry);
                if (this.selectedObject)
                    ej.datavisualization.Diagram.SvgContext._removePivotPoint(this.selectedObject, this.diagram._adornerSvg, this.diagram._currZoom);
                this.diagram._updateSelectionHandle();
                this.diagram._removeTooltip();
            }
            this._multipleUndo = false;
            //this.diagram._removeTooltip(); 
            base.prototype.mouseup.call(this, evt);
        };
        return RotateTool;
    })(ToolBase);

    ej.datavisualization.Diagram.RotateTool = RotateTool;
    //#endregion 

    //#region PivotTool
    var PivotTool = (function (base) {
        ej.datavisualization.Diagram.extend(PivotTool, base);
        function PivotTool(diagram) {
            base.call(this, "PivotTool", diagram);
            this._mouseOffset = ej.datavisualization.Diagram.Size(0, 0);
        }
        PivotTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this.selectedObject = this.diagram.selectionList[0];
        };
        PivotTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);

            if (this.selectedObject) {
                if (!this.inAction) {
                    this.inAction = true;
                }
                else {
                    var delx = this.currentPoint.x - this.previousPoint.x;
                    var dely = this.currentPoint.y - this.previousPoint.y;
                    var matrix = ej.Matrix.identity();
                    ej.Matrix.rotate(matrix, -this.selectedObject.rotateAngle);
                    var delta = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(delx, dely));
                    var difx = (this.selectedObject.width * this.selectedObject.pivot.x + delta.x) / this.selectedObject.width;
                    var dify = (this.selectedObject.height * this.selectedObject.pivot.y + delta.y) / this.selectedObject.height;
                    this.selectedObject.pivot.x = difx;
                    this.selectedObject.pivot.y = dify;
                    this.selectedObject.offsetX += delx;
                    this.selectedObject.offsetY += dely;
                    this.diagram._updateSelectionHandle();
                }
            }
            this.previousPoint = this.currentPoint;
        };
        PivotTool.prototype._rotate = function (node) {
            var pt = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY);
            var crntpoint = this.currentPoint;
            var angle = this.FindAngle(pt, crntpoint);
            this.diagram._rotate(node, angle - node.rotateAngle, pt, this.diagram.nameTable);
        };
        PivotTool.prototype.mouseup = function (evt) {
            if (this.inAction) {
                this.inAction = false;
                this.diagram._updateSelectionHandle();
            }
            base.prototype.mouseup.call(this, evt);
        };
        return PivotTool;
    })(ToolBase);
    ej.datavisualization.Diagram.PivotTool = PivotTool;
    //#endregion

    //#region PanTool
    var PanTool = (function (base) {
        ej.datavisualization.Diagram.extend(PanTool, base);
        function PanTool(diagram) {
            base.call(this, "panTool", diagram);
            this.diagram = diagram;
            this._isMouseDown = false;
            this.cursor = "pointer";
        }
        PanTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            var svgDocument = this.diagram._svg.document;
            var pt = this.diagram._svg.document.createSVGPoint();
            var originalEvent = this.diagram._isTouchEvent(evt);
            pt.x = originalEvent.clientX;
            pt.y = originalEvent.clientY;
            var mousept = pt.matrixTransform(this.diagram._svg.document.getScreenCTM().inverse());
            svgDocument.lastMouseX = mousept.x;
            svgDocument.lastMouseY = mousept.y;
            this._isMouseDown = true;
            return false;
        };

        PanTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this._isMouseDown && (this.startPoint.x != this.currentPoint.x || this.startPoint.y != this.currentPoint.y)) {
                this.inAction = true;
                var svgDocument = this.diagram._svg.document;
                var pt = this.diagram._svg.document.createSVGPoint();
                var originalEvent = this.diagram._isTouchEvent(evt);
                pt.x = originalEvent.clientX;
                pt.y = originalEvent.clientY;
                var mousept = pt.matrixTransform(this.diagram._svg.document.getScreenCTM().inverse());
                var ex = mousept.x;
                var ey = mousept.y;
                var nx, ny;

                nx = ((ex - svgDocument.lastMouseX));
                ny = ((ey - svgDocument.lastMouseY));
                if (!(this.diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableX))
                    nx = 0;
                if (!(this.diagram.model.constraints & ej.datavisualization.Diagram.DiagramConstraints.PannableY))
                    ny = 0;
                ej.datavisualization.Diagram.ZoomUtil.zoomPan(this.diagram, 1, nx, ny, ej.datavisualization.Diagram.Point(ex, ey));
                svgDocument.lastMouseX = ex;
                svgDocument.lastMouseY = ey;
                return false;
            }
        };
        PanTool.prototype.mouseup = function (evt) {
            this.inAction = false;
            document.onmousemove = null;
            document.onmouseup = null;
            this._isMouseDown = false;
            this.diagram._removeTooltip();
            if (!this.diagram._isEditing && !this.diagram._isDragg)
                this.diagram._endEdit();
            delete this.hoverNode;
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            base.prototype.mouseup.call(this, evt);
        };
        return PanTool;
    })(ToolBase);
    ej.datavisualization.Diagram.PanTool = PanTool;
    //#endregion

    //#region TextToolBase
    var TextToolBase = (function (base) {
        ej.datavisualization.Diagram.extend(TextToolBase, base);
        function TextToolBase(name, diagram) {
            base.call(this, name, diagram);
            this.boundingRect = ej.datavisualization.Diagram.Rectangle();
            this.activeLabel = null;
            this._overNode = "";
            this.cursor = "crosshair";
        }
        TextToolBase.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this._findNodeUnderMouse(evt);
            var overNode = this._getNodeUnderMouse();
            if (overNode) this._overNode = (this.selectedObject && !this.selectedObject.isLane || overNode.isLane) ? overNode.name : "";
            if (this.diagram._isEditing) {
                this.diagram._endEdit();
            }
        };
        TextToolBase.prototype.createNode = function (rect) {

        };
        TextToolBase.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (ej.datavisualization.Diagram.Util.isPageEditable(this.diagram)) {
                if (!this.selectedObject && !ej.datavisualization.Diagram.Geometry.isEmptyPoint(this.startPoint) && !this.diagram._isEditing) {
                    if (!this.inAction) {
                        this.inAction = true;
                        this._initHelper();
                    }
                    else {
                        this._updateHelper();
                    }
                }
            }
        };
        TextToolBase.prototype.mouseup = function (evt) {
            this.activeLabel = null;
            var minHeight = 12;
            if (this.inAction) {
                var rect = this.getBoundingRect(this.startPoint, this.currentPoint);
                this._endAction();
                if (rect.width === 0 || rect.height === 0) {
                    rect.width = 90;
                    rect.height = minHeight;
                }
                this.selectedObject = this.createNode(rect.x + (rect.width / 2), (rect.y + (rect.height / 2)), rect.width, rect.height);
                this.diagram._startEdit(this.selectedObject);
            }
            else {
                var node = this._findNodeUnderMouse(evt);
                if (ej.datavisualization.Diagram.Util.isPageEditable(this.diagram)) {
                    if (node != null && !node.isSwimlane && !node.isLane) {
                        this.selectedObject = node;
                        this.diagram._startEdit(this.selectedObject);
                    }
                    else {
                        var rect = ej.datavisualization.Diagram.Rectangle(this.currentPoint.x - (90 / 2), this.currentPoint.y - (minHeight / 2), 90, minHeight);
                        this._endAction();
                        this.selectedObject = this.createNode(rect.x + (rect.width / 2), rect.y + (rect.height / 2), rect.width, minHeight);
                        this.diagram._startEdit(this.selectedObject);
                    }
                }
            }
            this._overNode = "";
        };
        TextToolBase.prototype.getBoundingRect = function (startPoint, currentPoint) {
            var startPoint = this.snap(this.startPoint);
            var currentPoint = this.snap(this.currentPoint);
            var width = Math.abs(startPoint.x - currentPoint.x);
            var height = Math.abs(startPoint.y - currentPoint.y);
            var x = (startPoint.x > currentPoint.x) ? currentPoint.x : startPoint.x;
            var y = (startPoint.y > currentPoint.y) ? currentPoint.y : startPoint.y;
            return { x: x, y: y, width: width, height: height };
        };
        TextToolBase.prototype._initHelper = function () {
            if (!this._svgHelper) {
                var g = this.diagram._adornerSvg.g();
                this.diagram._adornerLayer.appendChild(g);
                var scale = this.diagram._currZoom;
                var selectionRect = this.diagram._svg.rect({ "id": "helper", "x": this.startPoint.x * scale, "y": this.startPoint.y * scale, "fill": "transparent", "stroke": "gray", "stroke-dasharray": "2 2", "shape-rendering": "crispEdges" });
                g.appendChild(selectionRect);
                g.setAttribute("pointer-events", "none");
                this._svgHelper = g;
            }
        };
        TextToolBase.prototype._updateHelper = function () {
            var startPoint = this.snap(this.startPoint);
            var currentPoint = this.snap(this.currentPoint);
            var helper = this.diagram._adornerSvg.getElementById("helper");
            var width = Math.abs(startPoint.x - currentPoint.x);
            var height = Math.abs(startPoint.y - currentPoint.y);
            var scale = this.diagram._currZoom;
            var x = ((startPoint.x > currentPoint.x) ? currentPoint.x : startPoint.x) * scale;
            var y = ((startPoint.y > currentPoint.y) ? currentPoint.y : startPoint.y) * scale;
            if (helper) {
                this.diagram._adornerSvg.rect({ "id": helper.id, "x": x, "y": y, "width": width * scale, "height": height * scale });
            }
        };
        TextToolBase.prototype._endAction = function () {
            if (this._svgHelper) {
                this.diagram._adornerLayer.removeChild(this._svgHelper);
                this._svgHelper = null;
            }
            base.prototype._endAction.apply(this);
        };
        TextToolBase.prototype._findNodeUnderMouse = function (evt, skip) {
            var obj;
            var foreignObject = this.diagram._isForeignObject(evt.target);
            if (foreignObject)
                evt.target = foreignObject;
            var textElement = evt.target;
            if (textElement.getAttribute("class") == "ej-d-label") {
                var parentNode = $(textElement).parents(".ej-d-node,.ej-d-connector,.ej-d-group")[0];
                obj = this._findObj(parentNode);
                this.activeLabel = this.diagram._findLabelAtPoint(this.currentPoint, obj);
            }
            else {
                var parents = $(evt.target).parents("g");
                if (parents.length > 3) {
                    var element = parents[parents.length - 4];
                    var id = element.getAttribute("id");
                    var type = element.getAttribute("class");
                    if (type) {
                        if (type === "ej-d-node" || type === "ej-d-group") {
                            obj = this.diagram._findNode(id);
                            var curlabel = this.diagram._findLabelAtPoint(this.currentPoint, obj);
                            this.activeLabel = curlabel;
                        }
                        else if (type === "ej-d-connector") {
                            obj = this.diagram._findConnector(id);
                            var curlabel = this.diagram._findLabelAtPoint(this.currentPoint, obj);
                            this.activeLabel = curlabel;
                        }
                    }
                }
            }
            return obj;
        };
        return TextToolBase;
    })(ej.datavisualization.Diagram.ToolBase);
    ej.datavisualization.Diagram.TextToolBase = TextToolBase;
    //#endregion

    //#region TextTool
    var TextTool = (function (base) {
        ej.datavisualization.Diagram.extend(TextTool, base);
        function TextTool(diagram) {
            base.call(this, "textTool", diagram);
        }
        TextTool.prototype.createNode = function (x, y, width, height) {
            var textnode = { "offsetX": x, "offsetY": y, "width": width, "height": height, "parent": this._overNode, "labels": [], "ports": [], "type": "text" };
            var node = this.diagram._getNewNode($.extend(true, {}, textnode, this.diagram.model.drawType));
            if (this.diagram.model.drawType.name) {
                node.name = this.diagram.model.drawType.name + ej.datavisualization.Diagram.Util.randomId();
            }
            else {
                node.name = "text" + ej.datavisualization.Diagram.Util.randomId();
            }
            if (node._type = "text") node._type = "node";
            var parent = this.diagram.nameTable[node.parent];
            if (parent && parent.container)
                this._updateMargin(node, parent);
            return node;
        };
        return TextTool;
    })(ej.datavisualization.Diagram.TextToolBase);
    ej.datavisualization.Diagram.TextTool = function (diagram) {
        return new TextTool(diagram);
    };
    //#endregion

    //#region PhaseTool
    var PhaseTool = (function (base) {
        ej.datavisualization.Diagram.extend(PhaseTool, base);
        function PhaseTool(diagram) {
            base.call(this, "phase", diagram);
            this.selectedSeperator = null;
            this._svgHelper = null;
        }
        PhaseTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this.inAction = true;
            this.diagram._selectedGNode = null;
        };
        PhaseTool.prototype._getSeperator = function (evt) {
            if ($(evt.target).parents("g").first()[0]) {
                var id = $(evt.target).parents("g").first()[0].id;
                if (id) {
                    return this._getphase(id.split('_phase_g')[0]);
                }
            }
        };
        PhaseTool.prototype._removePhasehelper = function () {
            ej.datavisualization.Diagram.SvgContext._removePhasehelper(this.diagram);
        };
        PhaseTool.prototype._outOfBoundsDrag = function (node) {
            var diffX = this.currentPoint.x - this.startPoint.x;
            var diffY = this.currentPoint.y - this.startPoint.y;
            if (node && ej.datavisualization.Diagram.Util.canMoveOutofBoundary(this.diagram)) {
                var size = this._getPageBounds();
                var parent = this.diagram.nameTable[node.parent];
                if (parent) {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(parent)
                    if (!this.diagram._selectedSymbol && (bounds.right + diffX >= size.width || node.offset + diffX < size.x)) {
                        this.updateCursor("not-allowed")
                        return false
                    }
                    if (!this.diagram._selectedSymbol && (bounds.bottom + diffY >= size.height || node.offset + diffY < size.y)) {
                        this.updateCursor("not-allowed")
                        return false
                    }
                }
                node.orientation == "horizontal" ? this.updateCursor("e-resize") : this.updateCursor("n-resize");
            }


            return true
        };
        PhaseTool.prototype._updatePhasehelper = function (phase) {
            var bounds = this._bounds ? jQuery.extend(true, {}, this._bounds) : this.diagram._getPhaseBounds(phase), dx, dy;
            var ptSrt = this.startPoint;
            var ptCur = this.currentPoint;
            var horizontalsnap = { snapped: false, offset: 0, left: false, right: false };
            var verticalsnap = { snapped: false, offset: 0, top: false, bottom: false };
            this.selectedObject = this.diagram.nameTable[this.selectedSeperator.parent];
            this.initialBounds = { width: this.selectedObject.width, height: this.selectedObject.height, y: this.selectedObject.offsetY, x: this.selectedObject.offsetX };

            if (phase.orientation === "horizontal") {
                dx = ptCur.x - ptSrt.x;
                dx = this._snapRight(horizontalsnap, verticalsnap, dx, 0, this.selectedObject, false);
                dy = 0;
                this.diagram._comparePropertyValues(phase, "offset", { offset: phase.offset + dx }, true);
            }
            else {
                dx = 0;
                dy = ptCur.y - ptSrt.y;
                dy = this._snapBottom(horizontalsnap, verticalsnap, 0, dy, this.selectedObject, false);
                this.diagram._comparePropertyValues(phase, "offset", { offset: phase.offset + dy }, true);
            }
            if (bounds) {
                bounds.width += dx;
                bounds.height += dy;
                this._helperBounds = $.extend(true, {}, bounds);
                ej.datavisualization.Diagram.SvgContext._updatePhaseHelper(this.diagram, phase, bounds);
            }
        };
        PhaseTool.prototype._drawPhasehelper = function (phase) {
            var bounds = this.diagram._getPhaseBounds(phase);
            if (phase && bounds)
                ej.datavisualization.Diagram.SvgContext._phasehelper(this.diagram, phase, bounds);
        };
        PhaseTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            if (this._outOfBoundsDrag(this.selectedSeperator)) {
                if (!this.selectedSeperator) {
                    if (this.inAction) {
                        var phase = this._getSeperator(evt);
                        if (phase && !this.selectedSeperator) {
                            this.selectedSeperator = phase;
                        }
                    }
                    this._drawPhasehelper(this.selectedSeperator);
                    if (this.diagram.selectionList[0] && this.diagram.selectionList[0].type != "phase") {
                        this.diagram._clearSelection(true);
                        this.diagram.addSelection(this.selectedSeperator, true);
                    }
                    else
                        this.diagram.addSelection(this.selectedSeperator, true);
                }
                else if (this.selectedSeperator) {
                    if (!this._bounds)
                        this._bounds = this.diagram._getPhaseBounds(this.selectedSeperator);
                    this._updatePhasehelper(this.selectedSeperator);
                }
                this.previousPoint = this.currentPoint;
            }
        };
        PhaseTool.prototype._getPadding = function (swimlane) {
            var xpad = 20, ypad = 20;
            var laneStack = this.diagram.nameTable[this.diagram._getChild(swimlane.children[swimlane.children.length - 1])];
            if (laneStack) {
                var lanes = laneStack.children;
                if (lanes.length > 0) {
                    var lane = this.diagram.nameTable[this.diagram._getChild(lanes[0])];
                    if (lane && lane.isLane) {
                        xpad = lane.paddingRight;
                        ypad = lane.paddingBottom;
                    }
                }
            }
            return { x: xpad, y: ypad };
        };
        PhaseTool.prototype.mouseup = function (evt) {
            var phase = this._getSeperator(evt);

            if (this.diagram.selectionList.length > 0 && phase && this.diagram.selectionList[0].name != phase.name)
                this.diagram._clearSelection(true);
            if (phase && !this.selectedSeperator) {
                this.selectedSeperator = phase;
                this.diagram.addSelection(this.selectedSeperator, true);
            }
            else {
                if (this.selectedSeperator) {
                    var swimlaneName = this.selectedSeperator.parent.split('phaseStack')[0];
                    if (swimlaneName) {
                        var swimlane = this.diagram.nameTable[swimlaneName];
                        if (swimlane && this._helperBounds) {
                            if (swimlane.isSwimlane) {
                                var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(this.diagram, swimlane);
                                var prevOffset = 0;
                                var index = phases.indexOf(this.selectedSeperator.name);
                                if (index > 0) {
                                    prevOffset = this.diagram.nameTable[this.diagram._getChild(phases[index - 1])].offset;
                                }
                                else {
                                    if (swimlane.orientation === "horizontal")
                                        prevOffset = 50;
                                }

                                var undoObject = jQuery.extend(true, {}, this.selectedSeperator);
                                if (swimlane.orientation === "horizontal")
                                    this.diagram._updatePhase({ name: this.selectedSeperator.name, offset: prevOffset + this._helperBounds.width })
                                else
                                    this.diagram._updatePhase({ name: this.selectedSeperator.name, offset: prevOffset + this._helperBounds.height })
                                var entry = { type: "phasepositionchanged", undoObject: jQuery.extend(true, {}, undoObject), redoObject: jQuery.extend(true, {}, jQuery.extend(true, {}, this.selectedSeperator)), category: "internal" };
                                if (!this._multipleUndo)
                                    this.diagram.addHistoryEntry(entry);
                                this.diagram.addSelection(this.selectedSeperator, true);
                            }
                        }
                    }
                }
            }

            this._removePhasehelper();
            this._bounds = null;
            this.inAction = false;
            this.selectedSeperator = null;
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            base.prototype.mouseup.call(this, evt);
        };
        PhaseTool.prototype._getOuterPhaseNodes = function (group, isVertical) {
            if (group) {
                var stack = this.diagram.nameTable[this.diagram._getChild(group.children[2])];
                var tchildren = [];
                var tchild = null;
                var bounds = null;
                var laneChild = null
                for (var i = 0; stack && i < stack.children.length; i++) {
                    var lane = this.diagram.nameTable[this.diagram._getChild(stack.children[i])];
                    if (lane && lane.children && lane.children.length > 1) {
                        for (var j = 0; j < lane.children.length; j++) {
                            laneChild = this.diagram.nameTable[this.diagram._getChild(lane.children[j])];
                            if (laneChild) {
                                bounds = ej.datavisualization.Diagram.Util.bounds(laneChild);
                                if (isVertical) {
                                    if (bounds.y > ((group.offsetY - group.height / 2) + this.selectedSeperator.offset))
                                        tchildren.push(laneChild);
                                }
                                else {
                                    if (bounds.x > ((group.offsetX - group.width / 2) + this.selectedSeperator.offset))
                                        tchildren.push(laneChild);
                                }
                            }
                        }
                    }
                }
            }
            return tchildren;
        };
        return PhaseTool;
    })(ToolBase);
    ej.datavisualization.Diagram.PhaseTool = PhaseTool;
    //#endregion

    //#region LabelMoveTool
    var LabelMoveTool = (function (base) {
        ej.datavisualization.Diagram.extend(LabelMoveTool, base);
        function LabelMoveTool(diagram) {
            base.call(this, "labelMove", diagram);
            this._isMouseDown = false;
            this.undoObject = [];
            this.inAction = false;
        }
        LabelMoveTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this._isMouseDown = true;
            if (evt && (evt.target.className == "ej-d-label" || evt.target.parentNode.getAttribute("class") === "ej-d-label")) {
                var node = this.diagram._nodeUnderMouse;
                var id = evt.target.id;
                if (!id) id = evt.target.parentNode.id;
                var labels = id.split("_");

                var labelName = "";
                for (var i = 1; i < labels.length; i++) {
                    labelName += labels[i];
                    if (i != labels.length - 1)
                        labelName += "_";
                }

                var currentlabel = this.diagram._findLabel(node, labelName);
                if (!currentlabel) currentlabel = node.labels[0];

                this.selectedObject = currentlabel;

                if (!node.segments) {
                    this.selectedObject.width = this.selectedObject.width > node.width ? this.selectedObject.width : node.width;
                    this.selectedObject.height = this.selectedObject.height > node.height ? this.selectedObject.height : node.height;
                }
                if (node.segments) {
                    var lblBounds = ej.datavisualization.Diagram.Util.getLabelbounds(this.diagram, node, this.selectedObject);
                    this.selectedObject.width = this.selectedObject.width ? this.selectedObject.width : lblBounds.width;
                    this.selectedObject.height = this.selectedObject.height ? this.selectedObject.height : lblBounds.height;
                }
            }
        };
        LabelMoveTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this.selectedObject && this.selectedObject._parent) {
                var node = this.diagram.findNode(this.selectedObject._parent);
                if (this._isMouseDown && !this.inAction) {
                    if (!this.inAction && this.selectedObject) {
                        this.inAction = true;
                        var childTable = {};
                        var data = $.extend(true, {}, { "childTable": childTable, "node": node, "activeLabel": this.selectedObject });
                        this.undoObject = jQuery.extend(true, {}, data);
                    }
                }
                if (this._isMouseDown && this.selectedObject && ej.datavisualization.Diagram.Util.enableLayerOption(this.selectedObject, "lock", this.diagram)
                    && (ej.datavisualization.Diagram.Util.canMove(this.selectedObject)
                        || ej.datavisualization.Diagram.Util.canMoveLabel(node)) && !this.diagram._isEditing) {
                    if (!this.inAction)
                        this.inAction = true;
                    this.updateCursor("move");
                    if (this.selectedObject._type === "label")
                        this._updateSelection();
                    this._updateLabelXY(this.selectedObject, this.previousPoint, this.currentPoint);
                    if (this.selectedObject._type === "label")
                        this.diagram._updateSelectionHandle(true);
                }
            }
            this.previousPoint = this.currentPoint;
        };
        LabelMoveTool.prototype.mouseup = function (evt, doc) {
            var clickedObject;
            if (this.selectedObject && this.selectedObject._parent) {
                var node = this.diagram.findNode(this.selectedObject._parent);
                if ((ej.datavisualization.Diagram.Util.canSelect(this.selectedObject) && ej.datavisualization.Diagram.Util.enableLayerOption(this.selectedObject, "lock", this.diagram) && ej.datavisualization.Diagram.Util.canMove(this.selectedObject)) || ej.datavisualization.Diagram.Util.canMoveLabel(node)) {
                    if (ej.datavisualization.Diagram.Util.canMoveLabel(node) && !ej.datavisualization.Diagram.Util.canSelect(this.selectedObject)) {
                        if (!this.diagram._selectionContains(this.node)) {
                            this.diagram._clearSelection(true);
                            this.diagram._addSelection(node, false);
                        }
                    }
                    else {
                        if (!this.diagram._selectionContains(this.selectedObject)) {
                            this.diagram._clearSelection(true);
                            this.diagram._addSelection(this.selectedObject, false);
                        }
                    }
                    if (this.selectedObject._type === "label")
                        this.diagram._updateSelectionHandle(false);
                    clickedObject = node;
                    if (this.inAction) {
                        this.inAction = false;
                        var childTable = {};
                        var data = $.extend(true, {}, { "childTable": childTable, "node": node, "label": this.selectedObject });
                        var entry = { type: "labelpositionchanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, data), category: "internal", activeLabel: this.selectedObject };
                        this.diagram.addHistoryEntry(entry);
                    }
                }
            }
            if (clickedObject) {
                var mousePosition = this.diagram._mousePosition(evt.originalEvent);
                this._raiseEvent("click", { element: clickedObject, actualObject: null, count: this.diagram._getEventDetail(evt), offsetX: mousePosition.x, offsetY: mousePosition.y, event: evt });
            }
            delete this._isMouseDown;
            base.prototype.mouseup.call(this, evt);
        };
        LabelMoveTool.prototype._updateLabelXY = function (label, startPoint, endPoint) {
            var difx = endPoint.x - startPoint.x;
            var dify = endPoint.y - startPoint.y;
            var node = this.diagram.findNode(label._parent);
            if (!node.segments) {
                var matrix = ej.Matrix.identity();
                ej.Matrix.rotate(matrix, -node.rotateAngle);
                var diff = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(difx, dify)); difx = diff.x; dify = diff.y;
            }

            if (node.segments && label.relativeMode == "segmentpath" && ej.datavisualization.Diagram.Util.isAllowDragLimit(node))
                this._updateLabelOffset(node, label, difx, dify);
            else
                this.diagram.translateLabel(node, label, difx, dify);
        };

        LabelMoveTool.prototype._updateSelection = function () {
            if (this.selectedObject._type === "label") {
                this.diagram._clearSelection(true);
                this.diagram._addSelection(this.selectedObject, true);
            }
        };
        LabelMoveTool.prototype._updateLabelOffset = function (node, label, dx, dy, newOffset, width, height) {
            var minDistance = { minDistance: null };
            var prev = null;
            var pointLength = 0;
            if (node.segments && label.relativeMode === "segmentpath") {
                var clnLabel = $.extend(true, {}, label);
                var textBounds, labelBounds = { x: 0, y: 0, width: 0, height: 0, centerX: 0, centerY: 0 }, curLoc, _intialDelta, currentPoint, conPoints, intersetingPts, newOffset, totalLength, intersectingOffset, distance;
                if (!newOffset) {
                    labelBounds = ej.datavisualization.Diagram.Util.getLabelbounds(this.diagram, node, label);
                    var curZoomfactor = this.diagram._currZoom;
                    labelBounds.x = (labelBounds.x) + dx;
                    labelBounds.y = (labelBounds.y) + dy;
                    if (this.diagram.model.labelRenderingMode === "svg") {
                        curLoc = { x: labelBounds.centerX + dx, y: labelBounds.centerY + dy }
                    }
                    else {
                        curLoc = { x: (labelBounds.x + (labelBounds.width / 2)), y: labelBounds.y + (labelBounds.height / 2) };
                    }
                    _intialDelta = { x: this.currentPoint.x - curLoc.x, y: this.currentPoint.y - curLoc.y };
                    currentPoint = { x: this.currentPoint.x - _intialDelta.x, y: this.currentPoint.y - _intialDelta.y };
                }
                else
                    currentPoint = newOffset;
                conPoints = ej.datavisualization.Diagram.Util.getPoints(node);
                intersetingPts = this._getInterceptWithSegment(currentPoint, conPoints);
                newOffset = this._getRelativeOffset(currentPoint, conPoints, minDistance);
                totalLength = this._getLengthFromListOfPoints(conPoints);
                var nodebounds = ej.datavisualization.Diagram.Util.bounds(node)
                if (intersetingPts.length > 0) {
                    distance = { minDistance: null };
                    intersectingOffset = this._getRelativeOffset(currentPoint, intersetingPts, distance);
                    if (minDistance.minDistance != null && distance.minDistance < minDistance.minDistance)
                        newOffset = intersectingOffset;
                    if (newOffset) {
                        var p, bounds, offset;
                        for (p = 0; p < conPoints.length; p++) {
                            if (prev != null) {
                                bounds = ej.datavisualization.Diagram.Geometry.rect([prev, conPoints[p]]);
                                if (ej.datavisualization.Diagram.Geometry.containsPoint(bounds, newOffset)) {
                                    pointLength += ej.datavisualization.Diagram.Util.findLength(prev, newOffset);
                                    break;
                                }
                                else
                                    pointLength += ej.datavisualization.Diagram.Util.findLength(prev, conPoints[p]);
                            }
                            prev = conPoints[p];
                        }
                        offset = ej.datavisualization.Diagram.Point(pointLength / totalLength, 0);
                    }
                    this._updateLabelMargin(node, label, offset, currentPoint, dx, dy, width, height);
                }
                else {
                    this._updateLabelMargin(node, label, null, currentPoint, dx, dy);
                }
                this.diagram._comparePropertyValues(node, "labels", clnLabel, true);
            }
        };
        LabelMoveTool.prototype._updateLabelMargin = function (node, label, offset, tempPt, dx, dy, width, height) {
            offset = offset ? offset : { x: label.segmentOffset, y: 0 };
            if (label && offset) {
                var draggableBounds, contentDimension, angle, point, length, line;
                var dragLimit = label.dragLimit;
                line = ej.datavisualization.Diagram.Util.getPoints(node);
                length = this._getLengthFromListOfPoints(line)
                if (offset.x > 0 && offset.x < 1) {
                    angle = { angle: null };
                    point = this._getPointAtLength(length * offset.x, line, angle);
                    var curZoomfactor = this.diagram._currZoom
                    var labelBounds = ej.datavisualization.Diagram.Util.getLabelbounds(this.diagram, node, label);
                    var contentDimension = { x: 0, y: 0, width: 0, height: 0 };
                    contentDimension = ej.datavisualization.Diagram.Util.getLabelbounds(this.diagram, node, label, true);
                    contentDimension.x = (contentDimension.x / curZoomfactor) + dx;
                    contentDimension.y = (contentDimension.y / curZoomfactor) + dy;
                    contentDimension.width = contentDimension.width / curZoomfactor;
                    contentDimension.height = contentDimension.height / curZoomfactor;
                    draggableBounds = {
                        x: point.x - dragLimit.left - contentDimension.width / 2,
                        y: point.y - dragLimit.top - contentDimension.height / 2,
                        width: dragLimit.left + dragLimit.right + contentDimension.width,
                        height: dragLimit.top + dragLimit.bottom + contentDimension.height
                    };
                    if (ej.datavisualization.Diagram.Geometry.containsPoint(draggableBounds, tempPt)) {
                        tempPt = tempPt;
                    }
                    else {
                        var line1, lineIntersects, i;
                        line1 = [point, tempPt];
                        lineIntersects = this._boundsInterSects(line1, draggableBounds, false);
                        for (i = 0; i < lineIntersects.length; i++) {
                            var ptt = lineIntersects[i]
                            tempPt = ptt;
                        }
                    }
                    var cursorLimit = this._checkCursorLimit(label, point, tempPt, contentDimension);
                    label.margin = { left: cursorLimit.x ? tempPt.x - point.x : label.margin.left, top: cursorLimit.y ? tempPt.y - point.y : label.margin.top, right: 0, bottom: 0 };
                    label.segmentOffset = offset.x;
                    if (width && height) {
                        label.width = width;
                        label.height = height;
                    }
                    ej.datavisualization.Diagram.DiagramContext.updateLabel(node, label, this.diagram);
                }
                else {
                }
            }
        };
        LabelMoveTool.prototype._getInterceptWithSegment = function (currenPosition, conPoints) {
            var intercepts = [], tarAngle, srcAngle, imgLine, segemnt, i, maxLength;
            maxLength = ej.datavisualization.Diagram.Util.findLength(ej.datavisualization.Diagram.Point(0, 0), ej.datavisualization.Diagram.Point(this.diagram._viewPort.width, this.diagram._viewPort.height));
            for (i = 1; i < conPoints.length; i++) {
                segemnt = [conPoints[i - 1], conPoints[i]];
                imgLine = [];
                srcAngle = Math.round(ej.datavisualization.Diagram.Util.findAngle(segemnt[0], segemnt[1]) % 360, 2);
                tarAngle = Math.round(ej.datavisualization.Diagram.Util.findAngle(segemnt[1], segemnt[0]) % 360, 2);
                var angleAdd = (srcAngle > 0 && srcAngle <= 90) || (srcAngle > 180 && srcAngle <= 270) ? 90 : -90;

                imgLine.push(ej.datavisualization.Diagram.Geometry.transform(currenPosition, srcAngle + angleAdd, maxLength));
                imgLine.push(ej.datavisualization.Diagram.Geometry.transform(currenPosition, tarAngle + angleAdd, maxLength));

                var intercept = this._intersect(segemnt, imgLine, false);
                for (var m = 0; m < intercept.length; m++) {
                    intercepts.push(intercept[m]);
                }
            }
            return intercepts;
        };
        LabelMoveTool.prototype._getRelativeOffset = function (currentPosition, points, minDistance) {
            var newOffset, distance, pt, i;
            for (i = 0; i < points.length; i++) {
                pt = points[i];
                distance = Math.round(Math.sqrt(Math.pow((currentPosition.x - pt.x), 2) + Math.pow((currentPosition.y - pt.y), 2)));
                if (minDistance.minDistance == null || Math.min(Math.abs(minDistance.minDistance), Math.abs(distance)) == Math.abs(distance)) {
                    newOffset = pt;
                    minDistance.minDistance = distance;
                }
            }
            return newOffset;
        };
        LabelMoveTool.prototype._getLengthFromListOfPoints = function (list) {
            var length = 0, start, i;
            start = list[0];
            for (i = 0; i < list.length; i++) {
                length += ej.datavisualization.Diagram.Util.findLength(start, list[i]);
                start = list[i];
            }
            return length;
        };
        LabelMoveTool.prototype._getPointAtLength = function (length, pts, angle) {
            angle.angle = 0;
            var run = 0, pre = null, found = ej.datavisualization.Diagram.Point(0, 0), i, pt;
            for (i = 0 ; i < pts.length; i++) {
                pt = pts[i]
                if (!pre) {
                    pre = pt;
                    continue;
                }
                else {
                    var l = ej.datavisualization.Diagram.Util.findLength(pre, pt), r, deg, x, y;
                    if (run + l >= length) {
                        r = length - run;
                        deg = ej.datavisualization.Diagram.Util.findAngle(pre, pt);
                        x = r * Math.cos(deg * Math.PI / 180);
                        y = r * Math.sin(deg * Math.PI / 180);
                        found = ej.datavisualization.Diagram.Point(pre.x + x, pre.y + y);
                        angle.angle = deg;
                        break;
                    }
                    else {
                        run += l;
                    }
                }
                pre = pt;
            }
            return found;
        };
        LabelMoveTool.prototype._checkCursorLimit = function (label, point, tempPt, contentDimension) {
            var x = false, y = false;
            if ((tempPt.x >= (point.x - label.dragLimit.left - (contentDimension.width / 2))) && (tempPt.x <= point.x + label.dragLimit.right + (contentDimension.width / 2)))
                x = true
            if ((tempPt.y >= (point.y - label.dragLimit.top - (contentDimension.height / 2))) && (tempPt.y <= point.y + label.dragLimit.bottom + (contentDimension.height / 2)))
                y = true;
            return { x: x, y: y };
        };
        LabelMoveTool.prototype._boundsInterSects = function (polyLine, bounds, self) {
            var intersect = []
            if (bounds) {
                var polyLine2 = [
                    { x: bounds.x, y: bounds.y },
                    { x: bounds.x + bounds.width, y: bounds.y },
                    { x: bounds.x + bounds.width, y: bounds.y + bounds.height },
                    { x: bounds.x, y: bounds.y + bounds.height },
                    { x: bounds.x, y: bounds.y }
                ];
                intersect = this._intersect(polyLine, polyLine2, intersect);
            }
            return intersect;
        };
        LabelMoveTool.prototype._intersect = function (polyLine1, polyLine2, self) {
            var intersect = [];
            for (var i = 0; i < polyLine1.length - 1; i++) {
                for (var j = 0; j < polyLine2.length - 1; j++) {
                    var p = ej.datavisualization.Diagram.Util.interSect2(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);
                    if (!ej.datavisualization.Diagram.Geometry.isEqualPoint(ej.datavisualization.Diagram.Point(0, 0), p)) {
                        intersect.push(p);
                    }
                }

                if (self && polyLine2.length >= 1) { }
            }
            return intersect;
        };
        LabelMoveTool.prototype.getCenterOfLabel = function (label, offset, bounds) {
            var center = ej.datavisualization.Diagram.Point(0, 0);
            if (this.selectedObject && this.selectedObject._parent) {
                var points = ej.datavisualization.Diagram.Util.getPoints(this.diagram.findNode(this.selectedObject._parent));
                var length = this._getLengthFromListOfPoints(points);
                var center = this._getPointAtLength(length * offset, points, {});
                center.x += (label.margin.left - label.margin.right);
                center.y += (label.margin.top - label.margin.bottom);
            }
            return center;
        };
        return LabelMoveTool;
    })(ToolBase);
    ej.datavisualization.Diagram.LabelMoveTool = LabelMoveTool;

    var LabelResizeTool = (function (base) {
        ej.datavisualization.Diagram.extend(LabelResizeTool, base);
        function LabelResizeTool(diagram) {
            base.call(this, "labelResize", diagram);
            this._resizeDirection = null;
            this.undoObject = null;
            this._mouseDown = false;
        };
        LabelResizeTool.prototype.mousedown = function (evt) {
            ej.datavisualization.Diagram.SnapUtil._removeGuidelines(this.diagram);
            base.prototype.mousedown.call(this, evt);
            this._mouseDown = true;
            this.selectedObject = this.diagram.selectionList[0];
        };
        LabelResizeTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (!this.inAction && this.diagram.selectionList[0] && this._mouseDown) {
                this.selectedObject = this.diagram.selectionList[0];
                var childTable = {};
                var node = this.diagram.findNode(this.selectedObject._parent);
                var data = $.extend(true, {}, { "childTable": childTable, "node": node, "activeLabel": this.selectedObject });
                this.undoObject = jQuery.extend(true, {}, data);
                this._resizeDirection = evt.target.getAttribute("class");
                var labelPosition = this._getLabelCenter(this.selectedObject);
                this.initialBounds = { width: this.selectedObject.width, height: this.selectedObject.height, y: labelPosition.y, x: labelPosition.x };
                this.inAction = true;
            }
            if (this.selectedObject && this.inAction) {
                if (ej.datavisualization.Diagram.Util.canResize(this.selectedObject)) {
                    this._updateSize(this.selectedObject, this.previousPoint, this.currentPoint);
                    ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                    this.diagram._updateSelectionHandle(true);
                }
            }
            this.previousPoint = this.currentPoint;
        };
        LabelResizeTool.prototype.mouseup = function (evt) {
            this._mouseDown = false;
            if (this.inAction && this.selectedObject) {
                this.inAction = false;
                var childTable = {};
                var data = $.extend(true, {}, { "childTable": childTable, "node": this.diagram.findNode(this.selectedObject._parent), "label": this.selectedObject });
                var entry = { type: "labelsizechanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, data), isMultipleNode: (this.selectedObject._type === "group") ? true : false, category: "internal", activeLabel: this.selectedObject };
                this.diagram.addHistoryEntry(entry);
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                this.diagram._updateSelectionHandle(false);
            }
            base.prototype.mouseup.call(this, evt);
        };
        LabelResizeTool.prototype._updateSize = function (shape, startPoint, endPoint) {
            var node = this.diagram.findNode(shape._parent);
            var deltaWidth, deltaHeight;
            var matrix = ej.Matrix.identity();
            var difx = this.currentPoint.x - this.startPoint.x;
            var dify = this.currentPoint.y - this.startPoint.y;
            var rotateAngle = this.diagram._findLabelRotateAngle(shape);
            var center = this._getLabelCenter(shape);
            var pivot = this._resizeObject(shape, difx, dify);
            deltaWidth = pivot.width;
            deltaHeight = pivot.height;
            if (deltaWidth < 0) deltaWidth = 1;
            if (deltaHeight < 0) deltaHeight = 1;
            if ((deltaWidth && deltaWidth != 1) || (deltaHeight && deltaHeight != 1)) {
                var newMat = ej.Matrix.identity();
                ej.Matrix.rotate(newMat, -node.rotateAngle, node.offsetX, node.offsetY);
                var bounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                ej.Matrix.rotate(matrix, -rotateAngle, pivot.x, pivot.y);
                ej.Matrix.scale(matrix, deltaWidth, deltaHeight, pivot.x, pivot.y);
                ej.Matrix.rotate(matrix, rotateAngle, pivot.x, pivot.y);
                var newPosition = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(center.x, center.y));
                var height = shape.height * deltaHeight;
                var width = shape.width * deltaWidth;
                if (node.segments && shape.relativeMode == "segmentpath") {
                    this.diagram.tools['labelMove']._updateLabelOffset(node, shape, 0, 0, newPosition, width, height);
                }
                else {
                    if (!node.segments)
                        newPosition = ej.Matrix.transform(newMat, newPosition);
                    newPosition.x = newPosition.x - shape.margin.left + shape.margin.right;
                    newPosition.y = newPosition.y - shape.margin.top + shape.margin.bottom;
                    var size = this._findLabelAtNode(node, shape);

                    if (shape.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Top) newPosition.y -= size.height / 2;
                    else if (shape.verticalAlignment == ej.datavisualization.Diagram.VerticalAlignment.Bottom) newPosition.y += size.height / 2;
                    if (shape.horizontalAlignment == ej.datavisualization.Diagram.HorizontalAlignment.Left) newPosition.x -= size.width / 2;
                    else if (shape.horizontalAlignment == ej.datavisualization.Diagram.HorizontalAlignment.Right) newPosition.x += size.width / 2;

                    var offsetx = bounds.width / (newPosition.x - bounds.x);
                    var offsety = bounds.height / (newPosition.y - bounds.y);
                    if (width > 1) {
                        shape.width = width;
                        shape.offset.x = 1 / offsetx;
                    }
                    if (height > 1) {
                        shape.height = height;
                        shape.offset.y = 1 / offsety;
                    }
                }
            }
        };
        return LabelResizeTool;
    })(ToolBase);
    ej.datavisualization.Diagram.LabelResizeTool = LabelResizeTool;

    var LabelRotateTool = (function (base) {
        ej.datavisualization.Diagram.extend(LabelRotateTool, base);
        function LabelRotateTool(diagram) {
            base.call(this, "labelRotate", diagram);
            this.inAction = false;
            this.undoObject = null;
        }
        LabelRotateTool.prototype.mousedown = function (evt) {
            base.prototype.mousedown.call(this, evt);
            this.selectedObject = this.diagram.selectionList[0];
            var childTable = {};
            var node = this.diagram.findNode(this.selectedObject._parent);
            var data = $.extend(true, {}, { "childTable": childTable, "node": node, "activeLabel": this.selectedObject });
            this.undoObject = jQuery.extend(true, {}, data);
        };
        LabelRotateTool.prototype.mousemove = function (evt) {
            base.prototype.mousemove.call(this, evt);
            if (this.selectedObject && ej.datavisualization.Diagram.Util.canRotate(this.selectedObject)) {
                if (!this.inAction)
                    this.inAction = true;
                this._rotate(this.selectedObject);
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                this.diagram._updateSelectionHandle(true);
            }
            this.previousPoint = this.currentPoint;
        };
        LabelRotateTool.prototype._rotate = function (label) {
            var matrix = ej.Matrix.identity();
            var rotateAngle, pivot;
            rotateAngle = this.diagram._findLabelRotateAngle(label);
            var pivot = this._getLabelCenter(label);
            var angle = ej.datavisualization.Diagram.Geometry.findAngle(ej.datavisualization.Diagram.Point(pivot.x, pivot.y), this.currentPoint) + 90;
            angle = ej.datavisualization.Diagram.SnapUtil._snapAngle(this.diagram, angle) - (rotateAngle);
            label.rotateAngle += angle;
            label.rotateAngle %= 360;
            if (label.rotateAngle < 0) label.rotateAngle += 360;
        };
        LabelRotateTool.prototype.mouseup = function (evt) {
            if (this.inAction) {
                this.inAction = false;
                this._rotate(this.selectedObject);
                ej.datavisualization.Diagram.DiagramContext.update(this.selectedObject, this.diagram);
                var childTable = {};
                var data = $.extend(true, {}, { "childTable": childTable, "node": this.diagram.findNode(this.selectedObject._parent), "activeLabel": this.selectedObject });
                var entry = { type: "labelrotationchanged", undoObject: this.undoObject, redoObject: jQuery.extend(true, {}, data), category: "internal", activeLabel: this.selectedObject };
                this.diagram.addHistoryEntry(entry);
                if (this.selectedObject)
                    ej.datavisualization.Diagram.SvgContext._removePivotPoint(this.selectedObject, this.diagram._adornerSvg, this.diagram._currZoom);
                this.diagram._updateSelectionHandle();
            }
            base.prototype.mouseup.call(this, evt);
        };
        return LabelRotateTool;
    })(ToolBase);
    ej.datavisualization.Diagram.LabelRotateTool = LabelRotateTool;

})(jQuery, Syncfusion);;
(function ($, ej) {
    "use strict";
    ej.datavisualization.Diagram.LayoutTypes = {
        None: "none",
        HierarchicalTree: "hierarchicaltree",
        OrganizationalChart: "organizationalchart",
        RadialTree: "radialtree",
        SymmetricLayout: "symmetriclayout"
    };
    ej.datavisualization.Diagram.ChartOrientations = {
        Horizontal: "horizontal",
        Vertical: "vertical"
    };
    ej.datavisualization.Diagram.ChartTypes = {
        Left: "left",
        Right: "right",
        Alternate: "alternate",
        Center: "center"
    };
    ej.datavisualization.Diagram.Layout = {
        doLayout: function (diagram, updateView) {
            var model = diagram.model;
            var layout = {
                diagram: diagram, _anchorX: 0, _anchorY: 0, _graphNodes: {},
                _firstLevelNodes: [], _centerNode: null, levels: [], maxLevel: 0, layoutNodes: [],
            };
            for (var prop in model.layout) {
                if (prop == "type") layout.type = diagram._layoutType();
                else if (prop == "orientation") layout.orientation = diagram._layoutOrientation();
                else if (prop == "fixedNode") layout.fixedNode = diagram._fixedNode();
                else if (prop == "horizontalSpacing") layout.horizontalSpacing = Number(diagram._horizontalSpacing());
                else if (prop == "verticalSpacing") layout.verticalSpacing = Number(diagram._verticalSpacing());
                else if (prop == "marginX") layout.marginX = Number(diagram._layoutMarginX());
                else if (prop == "marginY") layout.marginY = Number(diagram._layoutMarginY());
                else if (prop == "getLayoutInfo") {
                    if (typeof model.layout.getLayoutInfo === "string") {
                        layout.getLayoutInfo = ej.util.getObject(model.layout.getLayoutInfo, window);
                    }
                    else
                        if ($.isFunction(model.layout.getLayoutInfo)) {
                            layout.getLayoutInfo = model.layout.getLayoutInfo;
                        }
                }
                else if (prop == "getConnectorSegments") {
                    if (typeof model.layout.getConnectorSegments === "string") {
                        layout.getConnectorSegments = ej.util.getObject(model.layout.getConnectorSegments, window);
                    }
                    else
                        if ($.isFunction(model.layout.getConnectorSegments)) {
                            layout.getConnectorSegments = model.layout.getConnectorSegments;
                        }
                }
                else layout[prop] = model.layout[prop];
            }
            layout.updateView = updateView === undefined ? true : layout.updateView;
            layout.objects = [];
            if (layout.type === "symmetriclayout") {
                var smtLayout = new SymmetricLayoutManager(layout.diagram, 50);
                smtLayout.MaxIteration = layout.maxIteration;
                smtLayout.SpringLength = layout.springLength;
                smtLayout.SpringFactor = layout.springFactor;
                var graphLayoutManager = new GraphLayoutManager();
                graphLayoutManager.updateLayout(layout.diagram, smtLayout);
            }
            else if (layout.type != "radialtree")
                ej.datavisualization.Diagram.HierarchicalLayout.doLayout(layout);
            else
                ej.datavisualization.Diagram.RadialTreeLayout.doLayout(layout);
            if (!layout.updateView) return layout.objects;
        }
    };
    //region Hierarchical layout
    ej.datavisualization.Diagram.HierarchicalLayout = {
        doLayout: function (layout) {
            var diagram, model, nodes, node, layoutInfo, i;
            diagram = layout.diagram
            model = diagram.model;
            nodes = diagram.nodes();
            var distributeLine;
            if (this._checkMultiparent(nodes, layout)) {
                distributeLine = new ej.datavisualization.Diagram.LineDistribution(this);
                if (layout.avoidSegmentOverlapping) {
                    distributeLine._initLineDistribution(layout);
                }
                ej.datavisualization.Diagram.MultipleParentHierarchicalLayout.doLayout(layout);
            }
            else {
                if (nodes.length > 0) {
                    for (var i = 0; i < nodes.length; i++) {
                        node = nodes[i];
                        if (!node.excludeFromLayout) {
                            layoutInfo = layout._graphNodes[node.name] = this._setUpLayoutInfo(layout, node);
                            layoutInfo.tree.hasSubTree = false;
                            if (!node.inEdges || !node.inEdges.length || this._isAnnotationShape(node, false)) { layout._firstLevelNodes.push(node); }
                        }
                    }
                    //Update relationship(parent and children)
                    if (layout.root || diagram.model.dataSourceSettings.root) {
                        var root;
                        if (layout.root)
                            layout.rootNode = root = diagram.nameTable[diagram._getChild(layout.root)];
                        else {
                            var rootId = diagram.model.dataSourceSettings.root;
                            var dataSourceId = diagram.model.dataSourceSettings.id;
                            for (var i = 0; i < nodes.length; i++) {
                                if (nodes[i][dataSourceId] === rootId)
                                    layout.rootNode = root = diagram.nameTable[diagram._getChild(nodes[i].name)];
                            }
                        }
                        if (root && layout._firstLevelNodes.length === 0) {
                            ej.datavisualization.Diagram.MultipleParentHierarchicalLayout.doLayout(layout);
                            return;
                        }
                    }
                    for (i = 0; i < layout._firstLevelNodes.length; i++) {
                        node = layout._firstLevelNodes[i];
                        this._updateEdges(layout, node, 1);
                    }
                    if (layout._firstLevelNodes.length > 0) {
                        layout._rootNode = layout._firstLevelNodes[0];
                        var bounds, x = 0, y = 0, minX, maxX, minY, maxY;
                        for (i = 0; i < layout._firstLevelNodes.length; i++) {
                            bounds = this._updateTree(layout, x, y, layout._firstLevelNodes[i], 0, layout._firstLevelNodes[i - 1]);
                            var rootInfo = layout._graphNodes[layout._firstLevelNodes[i].name];
                            if (rootInfo.y < bounds.y) bounds.y = rootInfo.y;
                            if (rootInfo.x < bounds.x) bounds.x = rootInfo.x;
                            if (layout.orientation == "lefttoright" || layout.orientation == "righttoleft") y = bounds.right + layout.horizontalSpacing;
                            else x = bounds.right + layout.horizontalSpacing;
                            if (i == 0) { minX = bounds.x; minY = bounds.y; maxX = bounds.right; maxY = bounds.bottom; }
                            else {
                                minX = Math.min(minX, bounds.x); minY = Math.min(minY, bounds.y); maxX = Math.max(maxX, bounds.right); maxY = Math.max(maxY, bounds.bottom);
                            }
                        }
                        this._updateAnchor(layout, { x: minX, y: minY, right: maxX, bottom: maxY });
                        diagram._layoutInAction = true;
                        for (i = 0; i < layout._firstLevelNodes.length; i++) {
                            this._updateNodes(layout, layout._firstLevelNodes[i], 0);
                        }
                        diagram._layoutInAction = false;
                        if (!layout.updateView) diagram._internalLayout = layout;
                        if (layout.updateView) {
                            for (i = 0; i < layout._firstLevelNodes.length; i++) {
                                this._updateConnectors(layout, layout._firstLevelNodes[i], 1);
                            }
                        }
                            for (var j = 0; j < layout.diagram.model.connectors.length; j++) {
                                delete layout.diagram.model.connectors[j]._visited;
                            }
                            for (var j = 0; j < layout.diagram.model.nodes.length; j++) {
                                delete layout.diagram.model.nodes[j]._visited1;
                                delete layout.diagram.model.nodes[j]._isRightAdded;
                            }
                        }
                    }
                }
            if (layout.avoidSegmentOverlapping) {
                distributeLine._distributeLines(layout);
            }
            delete layout.diagram.minSpaceBetweenNode;
        },
        _checkMultiparent: function (nodes, layout) {
            if (nodes && nodes.length > 0) {
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    layout._processedNodes = [];
                    if (node && (((node.inEdges && node.inEdges.length > 1) && !this._isAnnotationShape(node, true)) ||
                        this._checkCyclicNodes(node, layout, node.name))) {
                        delete layout._processedNodes;
                        return true;
                }
            }
            }
            delete layout._processedNodes;
            return false;
        },

        _checkCyclicNodes: function (node, layout, nodeName) {
            if (node.outEdges && node.outEdges.length > 0 && !this._isLoopProcessed(layout, node.name)) {
                layout._processedNodes.push(node.name);
                for (var i = 0; i < node.outEdges.length; i++) {
                    var connector = layout.diagram.nameTable[node.outEdges[i]];
                    if (connector) {
                        if (connector.targetNode === nodeName) {
                            return true;
                        }
                        else {
                        var targetNode = layout.diagram.nameTable[connector.targetNode];
                            if (targetNode) {
                                if (targetNode.outEdges && targetNode.outEdges.length > 0) {
                                    var isCycle = this._checkCyclicNodes(targetNode, layout, nodeName);
                                    if (isCycle)
                            return true;
                        }
                    }
                }
            }
                }
            }
            return false;
        },

        _isLoopProcessed: function (layout, name) {
            var processedNodes = layout._processedNodes;
            for (var i = 0; i < processedNodes.length; i++) {
                if (processedNodes[i] === name)
                    return true;
                }
            return false;
        },

        _isAnnotationShape: function (node, isMultiParentCheck) {
            if (node && node.type === "bpmn" && node._type === "group" && node.annotation && node.annotation.text) {
                if (isMultiParentCheck) {
                    if (node.inEdges.length <= 2)
                        return true;
                }
                else if (node.inEdges.length <= 1) {
                    return true;
                }
            }
            return false;
        },

        _updateTree: function (layout, x, y, shape, level, prev, dontupdate) {
            if (!shape._visited1) {
                shape._visited1 = true;
                var dimensions, info, lev, obj, hasChild;
                dimensions = this._getDimensions(layout, shape, x, y, level);
                info = layout._graphNodes[shape.name];
                //Set maximum level of layout
                layout.maxLevel = Math.max(layout.maxLevel, level);
                lev = level;
                hasChild = this._hasChild(layout, shape);
                if (!hasChild && !info.tree.assistants.length) {
                    //update leaf nodes
                    shape._treeBounds = this._updateLeafNode(layout, shape, prev, dimensions, level, dontupdate);
                    return shape._treeBounds;
                }
                else {
                    var treeBounds, shapeBounds, levelBounds, d, asstBounds, space;
                    var bottom = dimensions.y + dimensions.height + layout.verticalSpacing;
                    if (info.tree.assistants.length) {
                        //Vertically place assistants
                        obj = this._setDepthSpaceForAssistants(layout, shape, bottom, dimensions.height, level, layout.verticalSpacing);
                        lev = obj.level;
                        bottom = obj.bottom;
                    }
                    if (!info.tree.assistants.length && info.tree.orientation != "horizontal") bottom = dimensions.y + dimensions.height + layout.verticalSpacing / 2;
                    if (info.tree.children.length) {
                        if (info.tree.orientation == "horizontal" && (info.tree.type != "balanced" || info.tree.children.length == 1))
                            treeBounds = this._updateHorizontalTree(layout, shape, prev, dimensions.x, bottom, lev);
                        else if (info.tree.type == "balanced")
                            treeBounds = this._updateHorizontalTreeWithMultipleRows(layout, shape, prev, dimensions.x, bottom, lev);
                        else
                            treeBounds = this._updateVerticalTree(layout, shape, dimensions.x, bottom, lev, dontupdate);
                    }
                    if (!(info.y && info.y > dimensions.y))
                        info.y = dimensions.y;
                    if (info.mid)
                        x = info.mid;
                    if (info.tree.assistants.length) {
                        //Set breadth space for assistants
                        space = x !== undefined ? x : dimensions.x;
                        asstBounds = this._setBreadthSpaceForAssistants(layout, shape, dimensions, space, bottom, level);
                        if (!hasChild) {
                            levelBounds = treeBounds = asstBounds;
                            x = (levelBounds.x + levelBounds.right) / 2 - dimensions.width / 2;
                            treeBounds = levelBounds;
                        }
                        d = asstBounds ? asstBounds.canMoveBy : undefined;
                    }
                    info.x = x;
                    if (!info.translate) info._treeWidth = treeBounds.right - treeBounds.x;
                    shapeBounds = { x: x, y: dimensions.y, right: x + dimensions.width, bottom: dimensions.y + dimensions.height };
                    this._translateSubTree(layout, shape, shapeBounds, treeBounds, dimensions, level, d, prev != undefined, dontupdate);
                    if (typeof info.firstChild != "string")
                        info.firstChild.x += info.subTreeTranslation;
                    shape._treeBounds = treeBounds;
                    return treeBounds;
                }
            }
            else {
                return shape._treeBounds;
            }
        },
        _updateLeafNode: function (layout, shape, prev, dimensions, level, dontupdate) {
            var info, bounds;
            info = layout._graphNodes[shape.name];
            if (!(info.x && info.x > dimensions.x))
                info.x = dimensions.x;
            if (!(info.y && info.y > dimensions.y))
                info.y = dimensions.y;
            info.maxLevel = Math.max(level, info.maxLevel || 0);
            bounds = { x: dimensions.x, y: dimensions.y, right: dimensions.x + dimensions.width, bottom: dimensions.y + dimensions.height };
            info.maxLevel = Math.max(info.maxLevel || 0, level);
            this._translateSubTree(layout, shape, bounds, bounds, dimensions, level, undefined, prev != undefined, dontupdate);
            return { x: info.x, y: info.y, right: info.x + dimensions.width, bottom: info.y + dimensions.height };
        },
        _translateSubTree: function (layout, shape, shapeBounds, treeBounds, dimensions, level, assistDiff, translate, dontupdate) {
            var info = layout._graphNodes[shape.name];
            var firstChild = layout.diagram.nameTable[info.firstChild ? info.firstChild.child : info.tree.children[0]];
            var firstChildInfo = firstChild ? layout._graphNodes[firstChild.name] : null;
            var hasChild = this._hasChild(layout, shape);
            var intersect = this._findIntersectingLevels(layout, shapeBounds, level, info.actualLevel);
            var treeIntersect = this._findIntersectingLevels(layout, treeBounds, level, info.actualLevel);
            var levelBounds = [], diff;
            if (intersect.length && info.translate) {
                info.intersect = intersect;
                this._spaceLeftFromPrevSubTree(layout, shape, shapeBounds);
                info.canMoveBy = info.diff;
                if (assistDiff !== undefined)
                    info.canMoveBy = Math.min(assistDiff, info.canMoveBy);
                if (firstChild && firstChildInfo.canMoveBy !== undefined) {
                    if (firstChildInfo.canMoveBy >= info.canMoveBy) info.translated = true;
                    info.canMoveBy = Math.min(info.canMoveBy, firstChildInfo.canMoveBy);
                }
                if (translate) {
                    info.x -= info.canMoveBy;
                    info.subTreeTranslation -= info.canMoveBy;
                    if (hasChild) {
                        this._shiftSubordinates(layout, treeIntersect, info.canMoveBy);
                        treeBounds.x = Math.min(treeBounds.x, info.x);
                        treeBounds.right = Math.max(treeBounds.right, info.x + dimensions.width);
                        treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dimensions.height);
                        treeBounds.x -= info.canMoveBy;
                        treeBounds.right -= info.canMoveBy;
                    }
                    if (firstChild && firstChildInfo.canMoveBy > info.canMoveBy) {
                        info.canMoveBy = firstChildInfo.canMoveBy - info.canMoveBy;
                    }
                    else if (firstChild && info.canMoveBy !== undefined) {
                        info.canMoveBy = 0;
                    }
                }
            }
            else {
                if (hasChild) {
                    treeBounds.x = Math.min(treeBounds.x, shapeBounds.x);
                    treeBounds.right = Math.max(treeBounds.right, shapeBounds.x + dimensions.width);
                    treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dimensions.height);
                }
                if (!info.translate) {
                    info.canMoveBy = 0;
                    info.subTreeTranslation = 0;
                }
            }
            if (!dontupdate) {
                shapeBounds = { x: info.x, y: dimensions.y, right: info.x + dimensions.width, bottom: dimensions.y + dimensions.height };
                levelBounds.push({ rBounds: shapeBounds });
                this._updateRearBounds(layout, shape, levelBounds, level);
            }
        },
        _updateRearBounds: function (layout, shape, levelBounds, level, intersect) {
            var bnds, index, intersect, firstLevel, lastLevel, isLastLeaf = true;
            if (shape) {
                var info = layout._graphNodes[shape.name];
                intersect = info.intersect;
                isLastLeaf = !info.tree.children.length && !info.tree.assistants.length;
            }
            firstLevel = levelBounds[0].rBounds;
            lastLevel = levelBounds[levelBounds.length - 1].rBounds;
            if (intersect && intersect.length) {
                bnds = layout.levels[intersect[0]].rBounds;
                var bottom = bnds.bottom;
                if (bnds.y < firstLevel.y) {
                    bnds.bottom = firstLevel.y;
                    levelBounds.splice(0, 0, { rBounds: bnds });
                }
                if (bottom > lastLevel.bottom) {
                    levelBounds.push({ rBounds: { x: bnds.x, right: bnds.right, y: firstLevel.bottom, bottom: bottom } });
                }
                else {
                    bnds = layout.levels[intersect[intersect.length - 1]].rBounds;
                    if (isLastLeaf && bnds.bottom > lastLevel.bottom) {
                        bnds.y = lastLevel.bottom;
                        levelBounds.push({ rBounds: bnds });
                    }
                }
                index = intersect[0];
                for (var i = levelBounds.length - 1; i >= 0; i--)
                    layout.levels.splice(index, 0, levelBounds[i]);
                index += levelBounds.length;
                layout.levels.splice(index, intersect.length);
            }
            else {
                index = this._findLevel(layout, levelBounds[levelBounds.length - 1].rBounds, level);
                for (var i = levelBounds.length - 1; i >= 0; i--)
                    layout.levels.splice(index, 0, levelBounds[i]);
            }
        },
        _shiftSubordinates: function (layout, intersect, diff) {
            var i;
            //Shift the sublevels by the distance diff
            if (diff != 0) {
                for (i = 0; i < intersect.length; i++) {
                    if (layout.levels[intersect[i]].rBounds) {
                        layout.levels[intersect[i]].rBounds.x -= diff;
                        layout.levels[intersect[i]].rBounds.right -= diff;
                    }
                }
            }
        },
        _setDepthSpaceForAssistants: function (layout, shape, bottom, height, lev, verticalSpacing) {
            var info = layout._graphNodes[shape.name];
            var asst, asstHeight, i, asstElement;
            var max = bottom;
            //Vertically place the assistants as alternate layout(alternatively at both right and left sides of parent)
            for (i = 0; i < info.tree.assistants.length; i++) {
                asst = layout._graphNodes[info.tree.assistants[i]];
                if (asst) {
                    asst.tree.children = asst.tree.assistants = [];
                    asst.y = bottom;
                    asstElement = layout.diagram.nameTable[info.tree.assistants[i]];
                    asstHeight = asstElement.height ? asstElement.height : asstElement._height;
                    if (layout.orientation == "lefttoright" || layout.orientation == "righttoleft")
                        asstHeight = asstElement.width ? asstElement.width : asstElement._width;
                    max = bottom + asstHeight + verticalSpacing / 2;
                    layout.maxLevel = lev + 1;
                    if (i % 2 == 1 && i != info.tree.assistants.length - 1) {
                        bottom = max;
                        lev++;
                    }
                }
            }
            return { level: layout.maxLevel, bottom: bottom + asstHeight + verticalSpacing };
        },
        _setBreadthSpaceForAssistants: function (layout, shape, dimensions, space, bottom, level) {
            var asst, asstWidth, prevBounds, bounds, asstElement;
            var info = layout._graphNodes[shape.name];
            var max = bottom;
            var lev = level;
            var left, diff, levelBounds, intersect, i;
            for (i = 0; i < info.tree.assistants.length; i++) {
                asst = layout._graphNodes[info.tree.assistants[i]];
                //Arrange assistants at both left and right sides of parent(like alternate layout)
                //Check - By default, distance to be left between parent and child nodes is assumed as 20. It can be modified/customized later.
                if (asst) {
                    asstElement = layout.diagram.nameTable[info.tree.assistants[i]];
                    asstWidth = asstElement.width ? asstElement.width : asstElement._width;
                    if (layout.orientation == "lefttoright" || layout.orientation == "righttoleft")
                        asstWidth = asstElement.height ? asstElement.height : asstElement._height;
                    if (i % 2 == 0) left = space + dimensions.width / 2 - 20 - asstWidth;
                    else left = space + dimensions.width / 2 + 20;
                    //Check - What will happen if update leaf node is called? Since assistants don't have children
                    bounds = this._updateTree(layout, left, asst.y, layout.diagram.nameTable[info.tree.assistants[i]], lev + 1);
                    if (!this._hasChild(layout, shape))
                        if (i == 0) levelBounds = bounds;
                        else this._uniteRects(levelBounds, bounds);
                    if (i % 2 == 0 && asst.prevBounds) {
                        if (diff === undefined) diff = asst.canMoveBy;
                        else diff = Math.min(diff, asst.canMoveBy);
                    }
                    if (i % 2 == 1 || i == info.tree.assistants.length - 1) {
                        intersect = this._findIntersectingLevels(layout, bounds, lev + 1);
                        //Update rightmost positions of known layout levels
                        this._updateRearBounds(layout, null, [{ rBounds: bounds }], lev + 1, intersect);
                        lev++;
                    }
                }
            }
            if (levelBounds)
                levelBounds.canMoveBy = diff;
            return levelBounds;
        },
        _updateHorizontalTree: function (layout, shape, prev, x, y, level) {
            var child, childInfo, childBounds, childWidth, childHeight, firstChildInfo;
            var prevBounds, bounds, actBounds, maxLevel, translateSibilingsBy;
            //Get dimensions with respect to layout orientations
            var dimensions = this._getDimensions(layout, shape, x, y, level);
            var info = layout._graphNodes[shape.name];
            var side = info.tree.type;
            var lev = level;
            var right = x;
            var bottom = y;
            var width, height;
            var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);
            if (this._hasChild(layout, shape)) {
                var h = layout.orientation == "lefttoright" || layout.orientation == "righttoleft" ? true : false;
                for (var i = 0; i < info.tree.children.length; i++) {
                    var oldActBounds;
                    child = layout.diagram.nameTable[info.tree.children[i]];
                    width = child.width ? child.width : child._width;
                    height = child.height ? child.height : child._height;
                    childWidth = h ? height : width;
                    childHeight = h ? width : height;
                    prevBounds = layout.levels[lev + 1] ? layout.levels[lev + 1].rBounds : null;
                    //Update sub tree
                    childBounds = this._updateTree(layout, right, bottom, child, lev + 1, layout.diagram.nameTable[info.tree.children[i - 1]]);
                    childInfo = layout._graphNodes[child.name];
                    info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);
                    actBounds = { x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth, bottom: childInfo.y + childHeight };
                    if (i == 0) {
                        //Compare with previous(right most) subtree
                        bounds = { x: Math.min(childInfo.x, childBounds.x), y: Math.min(childInfo.y, childBounds.y), right: childBounds.right, bottom: childBounds.bottom };
                        firstChildInfo = childInfo;
                    }
                    if (!oldActBounds)
                        oldActBounds = actBounds;
                    else {
                        oldActBounds.x = actBounds.x;
                        oldActBounds.y = actBounds.y;
                        if (actBounds.right > oldActBounds.right)
                            oldActBounds.right = actBounds.right;
                        oldActBounds.bottom = actBounds.bottom;
                        //oldActBounds = actBounds;
                    }
                    //Compare with previous subtree if level of the child is greater than the level of previous sub tree
                    //Check - what will happen if level of second child is greater than current child
                    if (i == 0) info.firstChild = { x: childInfo.x, canMoveBy: childInfo.canMoveBy, child: child.name };
                    if (this._hasChild(layout, child)) {
                        if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {
                            if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {
                                var canMoveBy = info.firstChild.canMoveBy;
                                childInfo.canMoveBy = canMoveBy;
                                layout._graphNodes[info.firstChild.child].canMoveBy = canMoveBy;
                                info.firstChild.canMoveBy = canMoveBy;
                            }
                            info.firstChild = { x: childInfo.firstChild.x, canMoveBy: canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy, child: child.name }
                        }
                        else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {
                            info.firstChild.canMoveBy = layout._graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;
                        }
                    }
                    maxLevel = maxLevel ? Math.max(childInfo.maxLevel, maxLevel) : childInfo.maxLevel;
                    if (!child._isRightAdded) {
                        this._uniteRects(bounds, childBounds);
                        if (i != 0 && !this._hasChild(layout, child) && childInfo.subTreeTranslation < 0)
                            right = childBounds.right - childInfo.subTreeTranslation + layout.horizontalSpacing;
                        else
                            right = childBounds.right + layout.horizontalSpacing;
                    }
                    child._isRightAdded = true;
                }
                if (!isNaN(translateSibilingsBy)) firstChildInfo.canMoveBy = translateSibilingsBy;
                info.mid = (firstChildInfo.x + oldActBounds.right) / 2 - dimensions.width / 2;
                //Set parent based on the chart type
                if (side == "left") info.mid = actBounds.right - dimensions.width; else if (side == "right") info.mid = x;
            }
            return bounds;
        },
        _updateHorizontalTreeWithMultipleRows: function (layout, shape, prev, x, y, level, centered) {
            var child, childInfo, childBounds, childWidth, childHeight, firstChildInfo;
            var prevBounds, bounds, actBounds, maxLevel, translateSibilingsBy, rowBounds;
            //Get dimensions with respect to layout orientations
            var dimensions = this._getDimensions(layout, shape, x, y, level);
            var info = layout._graphNodes[shape.name];
            var side = info.tree.type;
            var lev = level;
            var right = x;
            var bottom = y;
            var width, height;
            var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);
            var fchild;
            var centered = [];
            var maxRowWidth;
            var minTranslation = 0;
            if (this._hasChild(layout, shape)) {
                var h = layout.orientation == "lefttoright" || layout.orientation == "righttoleft" ? true : false;
                var rows = this._splitChildrenInRows(layout, shape);
                var unique = info.tree.children.length == 5 && rows[0].length == 3;
                var left = [];
                var centerTree = [];
                var rightTree = [];
                if (!unique)
                    for (var i = 0; i < rows.length; i++) {
                        left[i] = []; rightTree[i] = [];
                        var half = rows[i].length;
                        if (rows[i].length % 2 != 1) {
                            half = Math.ceil(rows[i].length / 2);
                            for (var k = 0; k < half ; k++) {
                                left[i].push(rows[i][k]);
                            }
                        }
                        for (var j = left[i].length; j < rows[i].length; j++)
                            rightTree[i].push(rows[i][j]);
                    }
                else rightTree = rows;
                var leftBounds = [];
                var rightMost, minTranslation = 0;
                //Arrange left side
                for (var i = 0; i < left.length && left[i].length; i++) {
                    right = x;
                    if (leftBounds[i - 1]) bottom = leftBounds[i - 1].bottom + layout.verticalSpacing;
                    for (var j = 0; j < left[i].length; j++) {
                        child = layout.diagram.nameTable[left[i][j]];
                        width = child.width ? child.width : child._width;
                        height = child.height ? child.height : child._height;
                        childWidth = h ? height : width;
                        childHeight = h ? width : height;
                        prevBounds = layout.levels[lev + 1] ? layout.levels[lev + 1].rBounds : null;
                        //Update sub tree
                        childInfo = layout._graphNodes[child.name];
                        childInfo.actualLevel = lev + 1 + i;
                        childBounds = this._updateTree(layout, right, bottom, child, lev + 1, layout.diagram.nameTable[left[i][j - 1]]);
                        if (j == 0) {
                            leftBounds[i] = { x: childBounds.x, y: childBounds.y, right: childBounds.right, bottom: childBounds.bottom };
                        }
                        else {
                            this._uniteRects(leftBounds[i], childBounds);
                        }
                        if (i == 0 && j == 0) {
                            minTranslation = childInfo.canMoveBy;
                            info.firstChild = { x: childInfo.x, child: child.name, canMoveBy: childInfo.canMoveBy };
                        }
                        else if (j == 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {
                            minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);
                            info.firstChild = { x: childInfo.x, child: child.name, canMoveBy: childInfo.canMoveBy };
                        }
                        right = childBounds.right + layout.horizontalSpacing;
                    }
                    if (i == 0)
                        rightMost = leftBounds[i].right;
                    else rightMost = Math.max(rightMost, leftBounds[i].right);
                    prevBounds = actBounds;
                }
                //Translate to same positions
                for (var i = 0; i < left.length && left[i].length; i++) {
                    if (rightMost != leftBounds[i].right) {
                        var diff = rightMost - leftBounds[i].right;
                        for (var j = 0; j < left[i].length; j++) {
                            var element = layout.diagram.nameTable[left[i][j]];
                            var elementInfo = layout._graphNodes[left[i][j]];
                            elementInfo.x += diff;
                        }
                        //leftBounds[i].x += diff;
                        //leftBounds[i].right += diff;
                    }
                    if (i == 0) {
                        bounds = { x: leftBounds[0].x, y: leftBounds[0].y, right: leftBounds[0].right, bottom: leftBounds[0].bottom };
                    }
                    else this._uniteRects(bounds, leftBounds[i]);
                    prevBounds = childBounds;
                }
                var center = (rightMost || 0) + (rightMost !== undefined ? (layout.horizontalSpacing / 2) : 0);
                if (rightMost !== undefined) {
                    info.mid = center - dimensions.width / 2;
                    var rightX = rightMost + layout.horizontalSpacing;
                }
                var maxRowWidth;
                bottom = y;
                var rightBounds = [];
                for (var i = 0; i < rightTree.length; i++) {
                    if (rows[i].length % 2 == 1 && i == rightTree.length - 1 || unique) right = x;
                    else right = rightX || x;
                    if (i != 0) bottom = rightBounds[i - 1].bottom + layout.verticalSpacing;
                    for (var j = 0; j < rightTree[i].length; j++) {
                        child = layout.diagram.nameTable[rightTree[i][j]];
                        width = child.width ? child.width : child._width;
                        height = child.height ? child.height : child._height;
                        childWidth = h ? height : width;
                        childHeight = h ? width : height;
                        prevBounds = layout.levels[lev + 1] ? layout.levels[lev + 1].rBounds : null;
                        //Update sub tree
                        childInfo = layout._graphNodes[child.name];
                        childInfo.actualLevel = lev + 1 + i;
                        if (j == 0 && left[i] && left[i].length) childInfo.translate = false;
                        if (unique && i == 1) {
                            if (j == 0 && leftCenter + childWidth + layout.horizontalSpacing <= rightCenter) {
                                var align = true;
                                right = leftCenter - childWidth / 2;
                            }
                            if (align && j == 1) { right = rightCenter - childWidth / 2; }
                        }
                        childBounds = this._updateTree(layout, right, bottom, child, lev + 1, layout.diagram.nameTable[rightTree[i][j - 1]]);
                        if (unique && j <= 2 && i == 0) {
                            if (j == 1) {
                                var leftCenter = childBounds.x - layout.horizontalSpacing / 2;
                                var rightCenter = childBounds.x + childWidth + layout.horizontalSpacing / 2;
                            }
                        }
                        if (j == 0) {
                            rightBounds[i] = { x: childBounds.x, y: childBounds.y, right: childBounds.right, bottom: childBounds.bottom };
                        }
                        else {
                            this._uniteRects(rightBounds[i], childBounds);
                        }
                        if (!bounds) bounds = { x: rightBounds[i].x, y: rightBounds[i].y, right: rightBounds[i].right, bottom: rightBounds[i].bottom };
                        this._uniteRects(bounds, rightBounds[i]);
                        right = childBounds.right + layout.horizontalSpacing;
                        prevBounds = childBounds;
                        if (!info.firstChild || ((i == rightTree.length - 1 && rows[i].length % 2 == 1) || unique) && j == 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {
                            minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);
                            info.firstChild = { x: childInfo.x, child: child.name, canMoveBy: childInfo.canMoveBy };
                        }
                    }
                    if (unique && i == 1) {
                        var max = (rightBounds[0].right - rightBounds[0].x) >= (rightBounds[1].right - rightBounds[1].x) ? 0 : 1;
                    }
                    if (i == rows.length - 1) {
                        if (rows[i].length % 2 == 1 || unique && i == 1) {
                            var centered = rightTree[i][Math.floor(rightTree[i].length / 2)];
                            var centerObjct = layout.diagram.nameTable[centered];
                            var childDimension = this._getDimensions(layout, centerObjct, layout._graphNodes[centered].x, layout._graphNodes[centered].y, lev + 1);
                            diff = undefined;
                            if (!align && unique) {
                                if (max == 1) i = 0;
                                diff = (rightBounds[max].x + rightBounds[max].right) / 2 - (rightBounds[i].x + rightBounds[i].right) / 2;
                                if (i == 0) info.mid += diff;
                            }
                            else if (!unique && rightX !== undefined) diff = rightX - layout.horizontalSpacing / 2 - (layout._graphNodes[centered].x + childDimension.width / 2);
                            if (diff !== undefined) {
                                for (var j = 0; j < rightTree[i].length; j++) {
                                    layout._graphNodes[rightTree[i][j]].x += diff;
                                    layout._graphNodes[rightTree[i][j]].canMoveBy += diff;
                                    if (j == rightTree[i].length - 1) {
                                        var chldDimensions = this._getDimensions(layout, layout.diagram.nameTable[rightTree[i][j]], layout._graphNodes[rightTree[i][j]].x, layout._graphNodes[rightTree[i][j]].y, layout._graphNodes[rightTree[i][j]].actualLevel);
                                        var child = layout._graphNodes[rightTree[i][j]];
                                        var intersect = this._findIntersectingLevels(layout, { x: child.x, y: child.y, right: child.x + dimensions.width, bottom: child.y + dimensions.height }, layout._graphNodes[rightTree[i][j]].actualLevel);
                                        this._updateRearBounds(layout, null, [{ rBounds: { x: child.x, y: child.y, right: child.x + dimensions.width, bottom: child.y + dimensions.height } }], layout._graphNodes[rightTree[i][j]].actualLevel, intersect);
                                    }
                                }
                            }
                            if (unique)
                                info.mid = (rightCenter + leftCenter) / 2 + (i == 0 ? diff : 0) - dimensions.width / 2;
                            if (info.mid == undefined && layout._graphNodes[centered]) { info.mid = layout._graphNodes[centered].x; }
                            align = false;
                            i++;
                        }
                    }
                }
            }
            return bounds;
        },
        _updateVerticalTree: function (layout, shape, x, y, level, dontupdate) {
            //declare local variables
            var child, childInfo, childBounds, childWidth, childHeight, prevBounds, bounds, actBounds, oddBounds, evenBounds;
            var dimensions, info, firstChild, h, factor, right, bottom, lev, i;
            var diff, type, canMoveBy, levels = [], oddLevels = [], intersect;
            var width, height;
            //Get dimensions with respect to layout orientations
            dimensions = this._getDimensions(layout, shape, x, y, level);
            info = layout._graphNodes[shape.name];
            firstChild = layout.diagram.nameTable[info.tree.children[0]];
            h = layout.orientation == "lefttoright" || layout.orientation == "righttoleft" ? true : false;
            factor = info.tree.type == "left" || info.tree.type == "leftoffset" ? -1 : 0;
            right = x;
            bottom = y;
            lev = level;
            for (i = 0; i < info.tree.children.length; i++) {
                if (info.tree.type == "alternate") {
                    //arrange at both left and right
                    type = (i % 2 == 0 && info.tree.children.length > 2) ? "left" : "right";
                    factor = (i % 2 == 0 && info.tree.children.length > 2) ? -1 : 0;
                }
                right = x + this._findOffset(layout, shape, info, type);
                child = layout.diagram.nameTable[info.tree.children[i]];
                width = child.width ? child.width : child._width;
                height = child.height ? child.height : child._height;
                childWidth = h ? height : width;
                childHeight = h ? width : height;
                //Update sub tree
                childBounds = this._updateTree(layout, right + factor * childWidth, bottom, child, level + 1, undefined, true);
                childInfo = layout._graphNodes[child.name];
                actBounds = { x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth, bottom: childInfo.y + childHeight };
                if (i == 0) {
                    this._uniteRects(childBounds, actBounds);
                    bounds = childBounds;
                }
                else
                    this._uniteRects(bounds, childBounds);
                //Check and adjust the space left from previous subtree/sibling
                if (childInfo.prevBounds && !(info.tree.type == "alternate" && i % 2 == 1 && info.tree.children.length > 2)) {
                    canMoveBy = canMoveBy !== undefined ? Math.min(childInfo.canMoveBy, canMoveBy) : childInfo.canMoveBy;
                }
                //Max level of the subtree node
                info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);
                if (!(info.tree.type == "alternate" && info.tree.children.length > 2 && i % 2 == 0)) {
                    if (info.tree.type == "alternate" && info.tree.children.length > 2)
                        //alternate - arrange children with even index(0,2,4,6,..) at the next level
                        bottom = Math.max(childBounds.bottom, prevBounds.bottom) + layout.verticalSpacing / 2;
                    else
                        // left/right - arrange next child at the nect level(bottom)
                        bottom = childBounds.bottom + layout.verticalSpacing / 2;
                    level = info.maxLevel;
                    levels.push({ rBounds: actBounds });
                    if (!evenBounds) evenBounds = { x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth, bottom: childInfo.y + childHeight };
                    else this._uniteRects(evenBounds, actBounds);
                    if (childInfo.levelBounds) levels = levels.concat(childInfo.levelBounds);
                }
                else {
                    if (i != 0) bottom = prevBounds.bottom + layout.verticalSpacing / 2;
                    oddLevels.push({ rBounds: actBounds });
                    if (childInfo.levelBounds) oddLevels = oddLevels.concat(childInfo.levelBounds);
                }
                if (i == 0) info.firstChild = { x: childInfo.x, canMoveBy: childInfo.canMoveBy, child: child.name };
                if (this._hasChild(layout, child)) {
                    if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {
                        if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {
                            var canMoveBy = info.firstChild.canMoveBy;
                            childInfo.canMoveBy = canMoveBy;
                            layout._graphNodes[info.firstChild.child].canMoveBy = canMoveBy;
                            info.firstChild.canMoveBy = canMoveBy;
                        }
                        info.firstChild = { x: childInfo.firstChild.x, canMoveBy: canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy, child: child.name }
                    }
                    else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {
                        info.firstChild.canMoveBy = layout._graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;
                    }
                }
                prevBounds = actBounds;
            }
            //To set level bounds(right most position of levels)
            if (!dontupdate) {
                if (info.tree.type == "alternate" && info.tree.children.length > 2) {
                    oddBounds = { x: oddLevels[0].rBounds.x, y: oddLevels[0].rBounds.y, right: oddLevels[oddLevels.length - 1].rBounds.right, bottom: oddLevels[oddLevels.length - 1].rBounds.bottom };
                    intersect = this._findIntersectingLevels(layout, oddBounds, lev + 1);
                    this._updateRearBounds(layout, null, oddLevels, lev + 1, intersect);
                }
                intersect = this._findIntersectingLevels(layout, evenBounds || bounds, lev + 1);
                this._updateRearBounds(layout, null, evenBounds ? levels : [{ rBounds: bounds }], lev + 1, intersect);
            }
            else info.levelBounds = levels;
            if (!isNaN(canMoveBy))
                layout._graphNodes[firstChild.name].canMoveBy = canMoveBy;
            info.childBounds = bounds;
            info.mid = x;
            return bounds;
        },
        _splitChildrenInRows: function (layout, shape) {
            var info = layout._graphNodes[shape.name];
            var column = 4;
            var rows = [];
            var childNodes = info.tree.children.length;
            var children = $.extend([], true, info.tree.children);
            if (info.tree.rows) {
                var count = info.tree.children.length;
                var columns = Math.ceil(count / info.tree.rows);
                if (columns % 2 == 0)
                    column = columns;
                else {
                    column = columns + 1;
                }
            }
            else if (info.tree.children.length == 3 || info.tree.children.length == 4)
                column = 2;
            else if (info.tree.children.length == 5) {
                column = 3;
            }
            while (childNodes > 0) {
                rows[rows.length] = children.splice(0, column);
                childNodes -= column;
                if (childNodes < column) {
                    column = childNodes;
                }
            }
            return rows;
        },
        _findOffset: function (layout, shape, info, type) {
            var offset = 0;
            var space = (layout.orientation == "lefttoright" || layout.orientation == "righttoleft") ? shape.height ? shape.height : shape._height : shape.width ? shape.width : shape._width;
            var ch = type ? type : info.tree.type;
            offset = info.tree.offset || (info.tree.offset === 0 ? 0 : 20);
            if (info.tree.type == "alternate")
                if (offset >= layout.horizontalSpacing) offset = layout.horizontalSpacing / 2;
            switch (ch) {
                case "left":
                    offset = space / 2 - offset;
                    break;
                case "right":
                    offset = offset + space / 2;
                    break;
            }
            return offset;
        },
        _translateSiblings: function (layout, shape, child) {
            var i, childInfo, info, diff;
            info = layout._graphNodes[shape.name];
            diff = layout._graphNodes[child.name].diff - layout._graphNodes[child.name].canMoveBy;
            for (i = 0; i < info.tree.children.length; i++) {
                if (child.name == info.tree.children[i])
                    break;
                childInfo = layout._graphNodes[info.tree.children[i]];
                childInfo.x += diff;
            }
        },
        _uniteRects: function (rect1, rect2) {
            //Unite two rects
            rect1.x = Math.min(rect1.x, rect2.x);
            rect1.right = Math.max(rect1.right, rect2.right);
            rect1.bottom = Math.max(rect1.bottom, rect2.bottom);
        },
        _spaceLeftFromPrevSubTree: function (layout, shape, bounds) {
            var info = layout._graphNodes[shape.name];
            var dif, prevBounds, intersect, k;
            var space = layout.horizontalSpacing;
            //Find the minimum distance to move towards previous sub tree
            for (k = 0; k < info.intersect.length; k++) {
                prevBounds = layout.levels[info.intersect[k]].rBounds;
                dif = bounds.x - (prevBounds.right + space);
                if (info.diff == undefined || dif < info.diff) {
                    info.diff = dif;
                    info.prevBounds = layout.levels[info.intersect[k]];
                }
            }
        },
        _findIntersectingLevels: function (layout, bounds, level, actualLevel) {
            //intersecting with exact Level
            var bnds = { x: bounds.x, y: bounds.y, right: bounds.right, bottom: bounds.bottom };
            bnds.y -= layout.verticalSpacing / 2;
            bnds.bottom += layout.verticalSpacing / 2;
            var intersectingLevels = [];
            var rBounds;
            var l = actualLevel !== undefined ? actualLevel : level;
            rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;
            //Performance - We can consider only the intersecting levels
            do {
                if (rBounds && ((bnds.y < rBounds.y && bnds.bottom > rBounds.y) || (bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom) ||
                    bnds.y >= rBounds.y && bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {
                    intersectingLevels.splice(0, 0, l);
                }
                else if (rBounds && rBounds.bottom < bnds.y) break;
                l--;
                rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;
            } while (l >= 0);
            l = (actualLevel !== undefined ? actualLevel : level) + 1;
            rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;
            do {
                if (rBounds && ((bnds.y < rBounds.y && bnds.bottom > rBounds.y) || (bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom) ||
                    bnds.y >= rBounds.y && bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {
                    intersectingLevels.push(l);
                }
                else if (rBounds && rBounds.y > bnds.bottom) break;
                l++;
                rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;
            } while (l <= layout.levels.length);
            return intersectingLevels;
        },
        _findLevel: function (layout, bounds, level) {
            var bnds = bounds;
            var l = 0;
            var rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;
            while (l < layout.levels.length) {
                if (rBounds && bnds.bottom < rBounds.y) {
                    return l;
                }
                else l++;
                rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;
            }
            return l;
        },
        _updateEdges: function (layout, node, depth) {
            var layoutInfo = layout._graphNodes[node.name];
            if (node.outEdges && node.outEdges.length && node.isExpanded) {
                for (var j = 0; j < node.outEdges.length; j++) {
                    var edge = layout.diagram.nameTable[layout.diagram.nameTable[node.outEdges[j]].targetNode];
                    if (!edge.excludeFromLayout) {
                        if (!ej.datavisualization.Diagram.Util._collectionContains(edge.name, layoutInfo.tree.children)) {
                            layoutInfo.tree.children.push(edge.name);
                        }
                        if (edge.outEdges && edge.outEdges.length && edge.isExpanded) {
                            layoutInfo.tree.hasSubTree = true;
                        }
                        this._updateEdges(layout, edge, depth + 1);
                    }
                }
            }
            //set level info
            layoutInfo.tree.level = depth;
            //By default, orientation is horizontal for nested trees
            if (layoutInfo.tree.hasSubTree) layoutInfo.tree.orientation = "horizontal";
            //Customizing assistants and children collection
            //Performance-Instead of reading the method everytime, we can set once and can reuse that
            if (layout.getLayoutInfo && layout.type == "organizationalchart") {
                layout.getLayoutInfo(layout.diagram, node, layoutInfo.tree);
                if (layoutInfo.tree.type == "balanced" && layoutInfo.tree.hasSubTree) { layoutInfo.tree.type = "center"; layoutInfo.tree.orientation = "horizontal" }
            }
            if (layout.level && layoutInfo.tree.type != "alternate" && depth >= layout.level)
                layoutInfo.tree.hasSubTree = false;
        },
        _updateAnchor: function (layout, bounds) {
            var node, viewPort, fixedNode, width, height, mod;
            //Update anchor based on viewport
            layout.diagram.viewPort = viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(layout.diagram, true);
            viewPort.x = 0; viewPort.y = 0;
            var layoutbounds = layout.bounds ? layout.bounds : viewPort;
            var orientation = layout.diagram._layoutOrientation();
            if (orientation == "toptobottom" || orientation == "bottomtotop") {
                switch (layout.horizontalAlignment) {
                    case "left":
                        layout._anchorX = (layoutbounds.x - bounds.x) + layout.margin.left;
                        break;
                    case "right":
                        layout._anchorX = layoutbounds.x + layoutbounds.width - layout.margin.right - bounds.right;
                        break;
                    case "center":
                        layout._anchorX = layoutbounds.x + layoutbounds.width / 2 - (bounds.x + bounds.right) / 2;
                        break;
                }
                switch (layout.verticalAlignment) {
                    case "top":
                        var top = layoutbounds.y + layout.margin.top;
                        layout._anchorY = orientation == "toptobottom" ? top : bounds.bottom + top;
                        break;
                    case "bottom":
                        var bottom = layoutbounds.y + layoutbounds.height - layout.margin.bottom;
                        layout._anchorY = orientation == "toptobottom" ? bottom - bounds.bottom : bottom;
                        break;
                    case "center":
                        var center = layoutbounds.y + layoutbounds.height / 2;
                        layout._anchorY = layout.orientation == "toptobottom" ? center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;
                        break;
                }
            }
            else if (orientation == "lefttoright" || orientation == "righttoleft") {
                switch (layout.horizontalAlignment) {
                    case "left":
                        var left = layoutbounds.x + layout.margin.left;
                        layout._anchorX = orientation == "lefttoright" ? left : bounds.bottom + left;
                        break;
                    case "right":
                        var right = layoutbounds.x + layoutbounds.width - layout.margin.right;
                        layout._anchorX = orientation == "lefttoright" ? right - bounds.bottom : right;
                        break;
                    case "center":
                        var center = layoutbounds.width / 2 + layoutbounds.x;
                        layout._anchorX = layout.orientation == "lefttoright" ? center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;
                        break;
                }
                switch (layout.verticalAlignment) {
                    case "top":
                        layout._anchorY = layoutbounds.y + layout.margin.top - bounds.x;
                        break;
                    case "center":
                        layout._anchorY = layoutbounds.y + layoutbounds.height / 2 - (bounds.right + bounds.x) / 2;
                        break;
                    case "bottom":
                        layout._anchorY = layoutbounds.y + layoutbounds.height - layout.margin.bottom - bounds.right;
                        break;
                }
            }
            //Anchor based on fixed nodes
            if (layout.fixedNode) {
                fixedNode = layout.diagram.nameTable[layout.fixedNode];
                width = fixedNode.width ? fixedNode.width : fixedNode._width;
                height = fixedNode.height ? fixedNode.height : fixedNode._height;
                layout._anchorX = fixedNode.offsetX;
                layout._anchorY = fixedNode.offsetY;
                layout._anchorX += layout.orientation == "righttoleft" ? width * fixedNode.pivot.x : -width * fixedNode.pivot.x;
                layout._anchorY += layout.orientation == "bottomtotop" ? height * fixedNode.pivot.y : -height * fixedNode.pivot.y;
                node = fixedNode, mod = 0;
                while (node.inEdges.length) {
                    node = this._getParentNode(layout, node);
                    mod += layout._graphNodes[node.name].subTreeTranslation || 0;
                }
                if (layout.orientation == "lefttoright" || layout.orientation == "righttoleft") {
                    layout._anchorX -= layout._graphNodes[fixedNode.name].y;
                    layout._anchorY -= layout._graphNodes[fixedNode.name].x + mod;
                } else {
                    layout._anchorX -= layout._graphNodes[fixedNode.name].x + mod;
                    layout._anchorY -= layout._graphNodes[fixedNode.name].y;
                }
            }
        },
        _updateConnectors: function (layout, node, level) {
            var i, conn, target, info, direction, offsetDir, segments;
            var nodeWidth = 0, nodeHeight = 0, targetWidth = 0, targetHeight = 0, length = 0, offsetLen = 0;
            //Route out edges
            info = layout._graphNodes[node.name];
            if (node.outEdges.length) {
                for (i = 0; i < node.outEdges.length; i++) {
                    conn = layout.diagram.nameTable[node.outEdges[i]];
                    target = layout.diagram.nameTable[conn.targetNode];
                    if (conn.visible && !conn._visited) {
                        conn._visited = true;
                        if (layout.getConnectorSegments) {
                            segments = layout.getConnectorSegments(layout.diagram, conn);
                        }
                        else {
                            if (info && info.tree.children.indexOf(conn.targetNode) != -1) {
                                var nwidth = node.width ? node.width : node._width;
                                var nheight = node.height ? node.height : node._height;
                                var twidth = target.width ? target.width : target._width;
                                var theight = target.height ? target.height : target._height;
                                if (layout.type == "organizationalchart") {
                                    if (layout.orientation == "toptobottom" || layout.orientation == "bottomtotop") {
                                        //Connector routing - vertical layouts
                                        nodeHeight = layout.orientation == "toptobottom" ? nheight : -nheight;
                                        targetHeight = layout.orientation == "toptobottom" ? -theight : theight;
                                        direction = layout.orientation == "toptobottom" ? "bottom" : "top";
                                        if (info.tree.assistants.length) {
                                            //Route inedge of child node, if the parent has assistants
                                            length = Math.abs((target.offsetY + targetHeight / 2) - (node.offsetY + nodeHeight / 2)) - layout.verticalSpacing / 2;
                                            segments = [{ type: "orthogonal", length: length, direction: direction }];
                                        }
                                        else {
                                            //Route inedge of child node
                                            if (info.tree.orientation == "horizontal" && (conn.segments.length == 1 || info.tree.type == "balanced")) {
                                                if (info.tree.type == "balanced") {
                                                    if (info.tree.children.length == 5 && i > 2) {
                                                        var relative = info.tree.children[1];
                                                        if (isNaN(layout._graphNodes[relative]._treeWidth)) layout._graphNodes[relative]._treeWidth = layout.diagram.nameTable[relative].width;
                                                        if (i == 3)
                                                            var center = layout.diagram.nameTable[relative].offsetX - layout._graphNodes[relative]._treeWidth / 2 - layout.horizontalSpacing / 2;
                                                        else
                                                            var center = layout.diagram.nameTable[relative].offsetX + layout._graphNodes[relative]._treeWidth / 2 + layout.horizontalSpacing / 2;
                                                        segments = [
                                                        { type: "orthogonal", length: layout.verticalSpacing / 2, direction: "bottom" },
                                                        {
                                                            type: "orthogonal", length: node.offsetX - center, direction: "left"
                                                        }, {
                                                            type: "orthogonal", length: target.offsetY + targetHeight / 2 - (node.offsetY + nodeHeight / 2) - layout.verticalSpacing, direction: "bottom"
                                                        }
                                                        ];
                                                    }
                                                    else {
                                                        var spacing = Math.min(30, layout.verticalSpacing / 2) * (direction == "bottom" ? 1 : -1);
                                                        length = Math.abs(target.offsetY + (targetHeight * target.pivot.y) - spacing - (node.offsetY + nodeHeight * (1 - target.pivot.y)));
                                                        segments = [{ type: "orthogonal", length: length, direction: direction }];
                                                    }
                                                }
                                                else
                                                    layout.diagram._dock(conn, layout.diagram.nameTable);
                                            }
                                            else {
                                                if (info.tree.orientation == "horizontal") {
                                                    segments = [{ type: "orthogonal" }];
                                                }
                                                else {
                                                    if (info.tree.enableRouting) {
                                                        length = Math.abs(target.offsetY - (node.offsetY + nodeHeight / 2));
                                                        segments = [{ type: "orthogonal", length: length, direction: direction }];
                                                        if (info.tree.offset < 5) {
                                                            offsetDir = info.tree.type == "left" ? "right" : "left";
                                                            length = layout.verticalSpacing / 4;
                                                            offsetLen = Math.abs(info.tree.offset) + layout.horizontalSpacing / 2;
                                                            segments = [{ type: "orthogonal", length: length, direction: direction },
                                                             { type: "orthogonal", length: offsetLen, direction: offsetDir }];
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        //Connector routing - Horizontal layout orientation
                                        nodeWidth = layout.orientation == "lefttoright" ? nwidth : -nwidth;
                                        targetWidth = layout.orientation == "lefttoright" ? -twidth : twidth;
                                        direction = layout.orientation == "lefttoright" ? "right" : "left";
                                        if (info.tree.assistants.length) {
                                            //Route inedge of child node, if the parent has assistants
                                            length = Math.abs((target.offsetX + targetWidth / 2) - (node.offsetX + nodeWidth / 2)) - layout.verticalSpacing / 2;
                                            segments = [{ type: "orthogonal", length: length, direction: direction }];
                                        }
                                        else {
                                            //Route inedge of child node
                                            if (info.tree.orientation == "horizontal" && (conn.segments.length == 1 || info.tree.type == "balanced")) {
                                                if (info.tree.type == "balanced") {
                                                    if (info.tree.children.length == 5 && i > 2) {
                                                        var relative = info.tree.children[1];
                                                        if (isNaN(layout._graphNodes[relative]._treeWidth)) layout._graphNodes[relative]._treeWidth = layout.diagram.nameTable[relative].width;
                                                        if (i == 3)
                                                            var center = layout.diagram.nameTable[relative].offsetY - layout._graphNodes[relative]._treeWidth / 2 - layout.verticalSpacing / 2;
                                                        else
                                                            var center = layout.diagram.nameTable[relative].offsetY + layout._graphNodes[relative]._treeWidth / 2 + layout.verticalSpacing / 2;
                                                        segments = [
                                                        { type: "orthogonal", length: layout.horizontalSpacing / 2, direction: "right" },
                                                        {
                                                            type: "orthogonal", length: node.offsetY - center, direction: "top"
                                                        }, {
                                                            type: "orthogonal", length: target.offsetX + targetWidth / 2 - (node.offsetX + nodeWidth / 2) - layout.horizontalSpacing, direction: "right"
                                                        }
                                                        ];
                                                    }
                                                    else {
                                                        var spacing = Math.min(30, layout.horizontalSpacing / 2) * (direction == "right" ? 1 : -1);
                                                        length = Math.abs(target.offsetX + (targetWidth * target.pivot.x) - spacing - (node.offsetX + nodeWidth * (1 - target.pivot.x)));
                                                        segments = [{ type: "orthogonal", length: length, direction: direction }];
                                                    }
                                                }
                                                else {
                                                    layout.diagram._dock(conn, layout.diagram.nameTable);
                                                }
                                            }
                                            else {
                                                if (info.tree.orientation == "horizontal") {
                                                    segments = [{ type: "orthogonal" }];
                                                }
                                                else {
                                                    length = Math.abs(target.offsetX - (node.offsetX + nodeWidth / 2));
                                                    segments = [{ type: "orthogonal", length: length, direction: direction }];
                                                    if (info.tree.offset < 5) {
                                                        offsetDir = info.tree.type == "left" ? "bottom" : "top";
                                                        length = layout.verticalSpacing / 4;
                                                        offsetLen = Math.abs(info.tree.offset) + 10;
                                                        segments = [{ type: "orthogonal", length: length, direction: direction },
                                                         { type: "orthogonal", length: offsetLen, direction: offsetDir }];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (segments)
                            layout.diagram.updateConnector(conn.name, { segments: segments });
                        else layout.diagram._dock(conn, layout.diagram.nameTable);
                        if (layout.diagram._svg)
                            ej.datavisualization.Diagram.DiagramContext.update(conn, layout.diagram);
                        if (target && !target.excludeFromLayout && (target.isExpanded || this._hasChild(layout, target)))
                            this._updateConnectors(layout, target, level + 1);
                    }
                }
            }
            if (info && info.tree.assistants.length) {
                //In-Edge routing of assistant nodes
                for (i = 0; i < info.tree.assistants.length; i++) {
                    target = layout.diagram.nameTable[info.tree.assistants[i]];
                    conn = layout.diagram.nameTable[target.inEdges[0]];
                    length = Math.abs(target.offsetY - (node.offsetY + nodeHeight / 2));
                    segments = [{ type: "orthogonal", length: length, direction: direction }];
                    if (segments) { layout.diagram.updateConnector(conn.name, { segments: segments }); }
                    if (layout.diagram._svg)
                        ej.datavisualization.Diagram.DiagramContext.update(conn, layout.diagram);
                    if (target.isExpanded || this._hasChild(layout, target))
                        this._updateConnectors(layout, target, level + 1);
                }
            }
        },
        _updateNodes: function (layout, node, mod, update, dx, dy) {
            var child, i;
            node._visited = true;
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var offsetX = node.offsetX;
            var offsetY = node.offsetY;
            if (!node.excludeFromLayout) {
                offsetX = layout._anchorX;
                offsetY = layout._anchorY;
                //Performance - instead of checking conditions for every node, we can make the layout related conditions once and we can reuse them
                if (layout.orientation == "lefttoright") {
                    offsetX += layout._graphNodes[node.name].y + width / 2;
                    offsetY += layout._graphNodes[node.name].x + mod + height / 2;
                }
                else if (layout.orientation == "righttoleft") {
                    offsetX -= layout._graphNodes[node.name].y + width / 2;
                    offsetY += layout._graphNodes[node.name].x + mod + height / 2;
                }
                else if (layout.orientation == "toptobottom") {
                    offsetX += layout._graphNodes[node.name].x + mod + width / 2;
                    offsetY += layout._graphNodes[node.name].y + height / 2;
                }
                else {
                    offsetX += layout._graphNodes[node.name].x + mod + width / 2;
                    offsetY -= layout._graphNodes[node.name].y + height / 2;
                }
                if (layout._graphNodes) {
                    var updNode = layout._graphNodes[node.name]
                    if (updNode) {
                        var upnodeTree = updNode.tree;
                        if (!upnodeTree.enableRouting) {
                            if (!layout.diagram.minSpaceBetweenNode)
                                layout.diagram.minSpaceBetweenNode = []
                            layout.diagram.minSpaceBetweenNode.push(node.name);
                        }
                    }
                }
                dx = dx ? dx : 0;
                dy = dy ? dy : 0;
                offsetX += dx;
                offsetY += dy;
                if (!layout.updateView) {
                    update = (node.name == layout.fixedNode) || update;
                    if (!update && this._withinView(offsetX, offsetY, width, height, node, layout)) {
                        if (offsetX != node.offsetX || offsetY != node.offsetY)
                            layout.objects.push({
                                object: node.name, diff: offsetX - node.offsetX, diffy: offsetY - node.offsetY
                            });
                    } else
                        layout.diagram._translate(node, offsetX - (node.offsetX || 0), offsetY - (node.offsetY || 0), layout.diagram.nameTable);
                }
                else
                    layout.diagram._translate(node, offsetX - (node.offsetX || 0), offsetY - (node.offsetY || 0), layout.diagram.nameTable);
            }
            var list = [];
            if (this._hasChild(layout, node)) {
                for (i = 0; i < layout._graphNodes[node.name].tree.children.length; i++) {
                    child = layout.diagram.nameTable[layout._graphNodes[node.name].tree.children[i]];
                    this._updateNodes(layout, child, mod + (layout._graphNodes[node.name].subTreeTranslation || 0), update, dx, dy);
                    list.push(child);
                }
            }
            //this._updateChildTreePosition(layout, list);
            if (layout._graphNodes[node.name].tree.assistants.length) {
                for (i = 0; i < layout._graphNodes[node.name].tree.assistants.length; i++) {
                    child = layout.diagram.nameTable[layout._graphNodes[node.name].tree.assistants[i]];
                    this._updateNodes(layout, child, mod + (layout._graphNodes[node.name].subTreeTranslation || 0), null, dx, dy);
                }
            }
            layout.diagram._updateQuad(layout.diagram.nameTable[node.name]);
            layout.diagram._setBounds(node);
            if (layout.diagram._svg)
                ej.datavisualization.Diagram.DiagramContext.update(node, layout.diagram);
        },
        _withinView: function (newoffsetX, newoffsetY, width, height, node, layout) {
            var left = layout.diagram.model.scrollSettings.horizontalOffset / layout.diagram.model.scrollSettings.currentZoom;
            var top = layout.diagram.model.scrollSettings.verticalOffset / layout.diagram.model.scrollSettings.currentZoom;
            var right = layout.diagram.model.scrollSettings.viewPortWidth / layout.diagram.model.scrollSettings.currentZoom + left;
            var bottom = layout.diagram.model.scrollSettings.viewPortHeight / layout.diagram.model.scrollSettings.currentZoom + top;
            if ((newoffsetX + width / 2 > left || node.offsetX + width / 2 > left) && (newoffsetX - width / 2 < right || node.offsetX - width / 2 < right) &&
            (newoffsetY + height / 2 > top || node.offsetY + height / 2 > top) && (newoffsetY - height / 2 < bottom || node.offsetY - height / 2 < bottom)) {
                return true;
            }
            return false;
        },
        _getDimensions: function (layout, shape, x, y, level) {
            var width = shape.width ? shape.width : shape._width;
            var height = shape.height ? shape.height : shape._height;
            if (layout.orientation == "lefttoright" || layout.orientation == "righttoleft") {
                if (!level) {
                    var temp = x;
                    x = y;
                    y = temp;
                }
                height = shape.width ? shape.width : shape._width;
                width = shape.height ? shape.height : shape._height;
            }
            return { x: x, y: y, width: width, height: height };
        },
        _getParentNode: function (layout, node) {
            //Return the first parent node
            if (node.inEdges && node.inEdges.length) {
                return layout.diagram.nameTable[layout.diagram.nameTable[node.inEdges[0]].sourceNode];
            }
        },
        _hasChild: function (layout, shape) {
            //Check whether the node has children
            var shape = layout._graphNodes[shape.name];
            return shape.tree.children && shape.tree.children.length;
        },
        _setUpLayoutInfo: function (layout, item) {
            //Initialize graph node info
            var info = {};
            info.subTreeTranslation = 0;
            if (layout.type == "organizationalchart")
                info.tree = { orientation: "vertical", type: "alternate", offset: 20, enableRouting: true };
            else if (layout.type == "hierarchicaltree")
                info.tree = { orientation: "horizontal", type: "center", enableRouting: true };
            info.tree.children = [];
            info.tree.assistants = [];
            info.tree.level = 0;
            info.translate = true;
            return info;
        }
    };
    //end region
    //region Radialtree layout
    ej.datavisualization.Diagram.RadialTreeLayout = {
        doLayout: function (layout) {
            var diagram, nodes, node;
            diagram = layout.diagram;
            nodes = diagram.nodes();
            for (var i = 0; i < nodes.length; i++) {
                if (!nodes[i].excludeFromLayout) {
                    layout._graphNodes[nodes[i].name] = this._setUpLayoutInfo(layout, nodes[i]);
                    if (!nodes[i].inEdges || !nodes[i].inEdges.length) { layout._firstLevelNodes.push(nodes[i]); }
                }
            }
            if (layout.rootNode && diagram.nameTable[layout.rootNode])
                layout._centerNode = diagram.nameTable[layout.rootNode];
            else if (layout._firstLevelNodes.length) {
                layout._centerNode = layout._firstLevelNodes[0];
                diagram.model.layout.rootNode = layout._centerNode.name;
            }
            if (layout._centerNode) {
                this._updateEdges(layout, layout._centerNode, 0);
                this._depthFirstAllignment(layout, layout._centerNode, 0, 0);
                this._populateLevels(layout);
                this._transformToCircleLayout(layout);
                this._updateAnchor(layout);
                this._updateNodes(layout, layout._centerNode)
            }
        },
        _updateEdges: function (layout, node, depth) {
            var nodeInfo = layout._graphNodes[node.name];
            layout.layoutNodes.push(nodeInfo);
            nodeInfo.level = depth;
            nodeInfo.visited = true;
            layout.maxLevel = Math.max(layout.maxLevel, depth);
            for (var j = 0; j < node.outEdges.length; j++) {
                var edge = layout.diagram.nameTable[layout.diagram.nameTable[node.outEdges[j]].targetNode];
                if (!edge.excludeFromLayout && !edge.visited) {
                    nodeInfo.children.push(edge);
                    this._updateEdges(layout, edge, depth + 1);
                }
            }
        },
        _depthFirstAllignment: function (layout, node, x, y) {
            if (node) {
                var newValue;
                var nodeInfo = layout._graphNodes[node.name];
                if (nodeInfo.children.length) {
                    y += 300;
                    for (var i = 0; i < nodeInfo.children.length; i++) {
                        newValue = this._depthFirstAllignment(layout, nodeInfo.children[i], x, y);
                        x = newValue.x; y = newValue.y;
                    }
                    nodeInfo.children = nodeInfo.children.sort(function (obj1, obj2) { return layout._graphNodes[obj1.name].x - layout._graphNodes[obj2.name].x; });
                    var min = layout._graphNodes[nodeInfo.children[0].name].min;
                    var max = layout._graphNodes[nodeInfo.children[nodeInfo.children.length - 1].name].max;
                    nodeInfo.x = min + (max - min) / 2;
                    x = max + layout.horizontalSpacing;
                    nodeInfo.segmentOffset = max + layout.horizontalSpacing;
                    nodeInfo.x -= nodeInfo.width / 2;
                    nodeInfo.y -= nodeInfo.height / 2;
                    nodeInfo.min = min;
                    nodeInfo.max = max;
                    if (nodeInfo.x < min && nodeInfo.visited) {
                        nodeInfo.x = min;
                        x = nodeInfo.x + nodeInfo.width / 2 - (max - min) / 2;
                        nodeInfo.visited = false;
                        for (var i = 0; i < nodeInfo.children.length; i++) {
                            newValue = this._depthFirstAllignment(layout, nodeInfo.children[i], x, y);
                        }
                        nodeInfo.visited = true;
                        x = nodeInfo.x + nodeInfo.width + layout.horizontalSpacing;
                    }
                    max = layout._graphNodes[nodeInfo.children[nodeInfo.children.length - 1].name].segmentOffset;
                    x = x < max ? max : x;
                    y -= 300;
                    nodeInfo.y = y;
                }
                else {
                    nodeInfo.x = x;
                    nodeInfo.y = y;
                    nodeInfo.min = x;
                    nodeInfo.max = x + nodeInfo.width;
                    x += nodeInfo.width + layout.horizontalSpacing;
                }
                return { x: x, y: y };
            }
        },
        _populateLevels: function (layout) {
            var stages = [];
            var min = Math.min.apply(Math, layout.layoutNodes.map(function (nodeInfo) { return nodeInfo.x; }));
            var max = Math.max.apply(Math, layout.layoutNodes.map(function (nodeInfo) { return nodeInfo.x + nodeInfo.width + layout.horizontalSpacing; }));
            var full = max - min;
            layout.levels = [];
            for (var i = 0; i <= layout.maxLevel; i++) {
                stages = layout.layoutNodes.filter(function (nodeInfo) { if (nodeInfo.level == i) return nodeInfo; });
                var newlevel = {};
                stages = stages.sort(function (nodeInfo1, nodeInfo2) { return nodeInfo1.x - nodeInfo2.x; });
                newlevel.min = stages[0].x;
                newlevel.max = stages[stages.length - 1].x + stages[stages.length - 1].width + layout.horizontalSpacing;
                newlevel._actualCircumference = 0;
                newlevel.height = 0;
                for (var k = 0; k < stages.length; k++) {
                    if (stages[k].height > newlevel.height) newlevel.height = stages[k].height;
                    newlevel._actualCircumference += Math.max(stages[k].width, stages[k].height);
                    if (k != stages.length - 1) newlevel._actualCircumference += layout.horizontalSpacing;
                }
                newlevel.circumference = newlevel.max - newlevel.min;
                if (newlevel._actualCircumference < newlevel.circumference) newlevel.circumference = (newlevel.circumference + newlevel._actualCircumference) / 2;
                newlevel.radius = newlevel.circumference / (2 * Math.PI) + newlevel.height;
                newlevel.nodes = [];
                if (i > 1) {
                    if (layout.levels[i - 1].radius + layout.levels[i - 1].height >= newlevel.radius)
                        newlevel.radius = layout.levels[i - 1].radius + layout.levels[i - 1].height;
                }
                for (var j = 0; j < stages.length; j++) {
                    stages[j].ratio = Math.abs(stages[j].x + stages[j].width / 2 - min) / full;
                    newlevel.nodes.push(stages[j]);
                }
                layout.levels.push(newlevel);
            }
        },
        _transformToCircleLayout: function (layout) {
            var root = layout._graphNodes[layout._centerNode.name];
            root.x = 0;
            root.y = 0;
            //root.x = -root.width;
            //root.y = -root.height;
            for (var i = 1; i < layout.levels.length; i++) {
                for (var j = 0; j < layout.levels[i].nodes.length; j++) {
                    var nodeInfo = layout.levels[i].nodes[j];
                    nodeInfo.x = Math.cos(nodeInfo.ratio * 360 * Math.PI / 180) * (layout.levels[i].radius + layout.verticalSpacing * i);
                    nodeInfo.y = Math.sin(nodeInfo.ratio * 360 * Math.PI / 180) * (layout.levels[i].radius + layout.verticalSpacing * i);
                    //nodeInfo.x -= nodeInfo.width / 2;
                    //nodeInfo.y -= nodeInfo.height / 2;
                    layout._anchorX = Math.min(layout._anchorX, nodeInfo.x);
                    layout._anchorY = Math.min(layout._anchorY, nodeInfo.y);
                }
            }
        },
        _updateAnchor: function (layout) {
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(layout.diagram);
            if (layout._centerNode) {
                layout._anchorX = layout._centerNode.offsetX || viewPort.width / 2;
                layout._anchorY = layout._centerNode.offsetY || viewPort.height / 2;
            }
            else {
                layout._anchorX = viewPort.width / 2;
                layout._anchorY = viewPort.height / 2;
            }
        },
        _updateNodes: function (layout, node) {
            var nodeInfo = layout._graphNodes[node.name];
            var offsetX = nodeInfo.x + layout._anchorX;
            var offsetY = nodeInfo.y + layout._anchorY;
            layout.diagram._translate(node, offsetX - node.offsetX || 0, offsetY - node.offsetY || 0, layout.diagram.nameTable);
            for (var i = 0; i < nodeInfo.children.length; i++) {
                var childInfo = nodeInfo.children[i];
                this._updateNodes(layout, layout.diagram.nameTable[childInfo.name]);
            }
            if (layout.diagram._svg)
                ej.datavisualization.Diagram.DiagramContext.update(node, layout.diagram);
        },
        _isValidLayout: function (layout) {
            if (layout._centerNode) {
                var maxParents = Math.max.apply(Math, layout.diagram.nodes().map(function (obj) { return obj.inEdges.length; }));
                if (maxParents < 2) return true;
            }
            return false;
        },
        _setUpLayoutInfo: function (layout, item) {
            var info = {};
            info.name = item.name;
            info.x = 0;
            info.y = 0;
            info.min = 0;
            info.max = 0;
            info.width = item.width ? item.width : item._width;
            info.height = item.height ? item.height : item._height;
            info.children = [];
            info.level = 0;
            info.ratio = 0;
            info.visited = false;
            return info;
        },
    };
    //region Multi Parent Hierarchical Layout
    ej.datavisualization.Diagram.MultipleParentHierarchicalLayout = {
        doLayout: function (layout) {
            var segments;
            this.diagram = layout.diagram;
            var dnodes = this.diagram.nodes();
            this.nodes = [];
            var filledVertexSet = {};
            var distributeLine = new ej.datavisualization.Diagram.LineDistribution(this);
            distributeLine.edgeMapper = [];
            for (var i = 0; i < dnodes.length; i++) {
                var node = this._createVertex(dnodes[i], dnodes[i].name, 0, 0, dnodes[i].width, dnodes[i].height);

                var outEdges = dnodes[i].outEdges.slice();
                for (var j = 0; j < outEdges.length; j++) {
                    var outEdge = layout.diagram.nameTable[outEdges[j]];
                    distributeLine._setEdgeMapper({ key: outEdge, value: [] });
                }

                this.nodes.push(node);
                filledVertexSet[node.name] = node;
            }
            var hierarchyVertices = [];
            if (this.roots == null && parent != null) {
                var candidateRoots = this._findRoots(filledVertexSet, layout);
                for (var i = 0; i < candidateRoots.length; i++) {
                    var vertexSet = Object();
                    hierarchyVertices.push(vertexSet);
                    this._traverse(candidateRoots[i], true, null, vertexSet, hierarchyVertices, filledVertexSet);
                }
            }
            var limit = { marginX: 0, marginY: 0 };
            var matrixModel;
            for (var i = 0; i < hierarchyVertices.length; i++) {
                var vertexSet = hierarchyVertices[i];
                var tmp = [];
                for (var key in vertexSet) {
                    tmp.push(vertexSet[key]);
                }
                var model = new ej.datavisualization.Diagram.MultiParentModel(this, tmp, candidateRoots, layout);
                this._cycleStage(model);
                this._layeringStage(model, candidateRoots);
                this._crossingStage(model);

                // New implementation for placing elements
                var matrixModel = new ej.datavisualization.Diagram.MatrixModel({ model: model, matrix: [], rowOffset: [] });
                distributeLine._arrangeElements(matrixModel);

                //limit = this._placementStage(model, limit.marginX, limit.marginY, parent);
            }
            var modelBounds = this._getModelBounds(this.nodes);
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(layout.diagram, true);
            var trnsX = ((viewPort.width - modelBounds.width) / 2) - modelBounds.x;
            var trnsY = ((viewPort.height - modelBounds.height) / 2) - modelBounds.y;

            trnsX = Math.round(trnsX);
            trnsY = Math.round(trnsY);
            var margin = layout.margin || {};
            margin.left = margin.left || 0;
            margin.right = margin.right || 0;
            margin.top = margin.top || 0;
            margin.bottom = margin.bottom || 0;

            var isHorizontal = layout.orientation == "lefttoright"
                     || layout.orientation == "righttoleft";
            var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;
            var nodeWithMultiEdges = [];

            for (var i = 0; i < this.nodes.length; i++) {
                var clnode = this.nodes[i];
                if (clnode && !clnode.source && !clnode.target) {
                    var dnode = this.diagram.nameTable[clnode.name];
                    var dx = (clnode.geometry.x + (clnode.geometry.width / 2));
                    var dy = (clnode.geometry.y + (clnode.geometry.height / 2));
                    var x = dx, y = dy;
                    if (layout.orientation === "bottomtotop") {
                        y = modelBounds.height - dy;
                    }
                    else if (layout.orientation === "righttoleft") {
                        x = modelBounds.width - dx;
                    }
                    x += margin.left;
                    y += margin.top;
                    x += trnsX;
                    y += trnsY;
                    if (dnode != null)
                    {
                        this.diagram._translate(dnode, x - dnode.offsetX, y - dnode.offsetY, layout.diagram.nameTable);
                        if (!this.diagram._isInit)
                            ej.datavisualization.Diagram.DiagramContext.update(dnode, this.diagram);
                        if (clnode.inEdges.length > 0 || clnode.outEdges.length > 0)
                        {
                            nodeWithMultiEdges.push(dnode);
                        }
                    }
                }
            }
            if (layout.updateView && !layout.avoidSegmentOverlapping) {
                var connectors = layout.diagram.connectors();
                for (var i = 0; i < connectors.length; i++) {
                    var conn = connectors[i];
                    if (layout.getConnectorSegments) {
                        segments = layout.getConnectorSegments(layout.diagram, conn);
                    }
                    if (segments)
                        layout.diagram.updateConnector(conn.name, { segments: segments });
                }
            }
            if (layout.avoidSegmentOverlapping) {
                var modifiedConnectors = [];
                var transModelBounds = new ej.datavisualization.Diagram.Rectangle(
                    modelBounds.x + trnsX,
                    modelBounds.y + trnsY,
                    modelBounds.width,
                    modelBounds.height);
                for (var i = 0; i < nodeWithMultiEdges.length; i++) {
                    var node = nodeWithMultiEdges[i];
                    if (node.outEdges != null && node.outEdges.length > 0) {
                        var count = node.outEdges.length;
                        for (var j = 0; j < count; j++) {
                            var internalConnector = layout.diagram.nameTable[node.outEdges[j]];
                            internalConnector._pointCollection = [];
                            if (count > 1) {
                                var segmentsize = inversespacing / 2.0;
                                var intermediatePoint = null;
                                var key;
                                var edgeMapper = distributeLine._getEdgeMapper();
                                for (var k = 0; k < edgeMapper.length; k++) {
                                    if (edgeMapper[k].key == internalConnector) {
                                        key = k;
                                        break;
                                    }
                                }
                                if (edgeMapper[key].value.length > 0) {
                                    var edgePt = edgeMapper[key].value[0];
                                    var dx1 = edgePt.x + margin.left;
                                    var dy1 = edgePt.y + margin.top;
                                    var x1 = dx1, y1 = dy1;
                                    if (layout.orientation == "bottomtotop") {
                                        y1 = modelBounds.height - dy1;
                                    }
                                    else if (layout.orientation == "righttoleft") {
                                        x1 = modelBounds.width - dx1;
                                    }

                                    x1 += trnsX;
                                    y1 += trnsY;

                                    intermediatePoint = new ej.datavisualization.Diagram.Point(x1, y1);
                                }

                                var pts = [];
                                for (var p = 0; p < internalConnector.segments.length; p++) {
                                    var pt = internalConnector.segments[p].points;
                                    for (var temp in pt) {
                                        pts.push(pt[temp]);
                                    }
                                }

                                pts = distributeLine._updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds);

                                for (p = 0; p < pts.length; p++) {
                                    var pt = pts[p];

                                    internalConnector._pointCollection.push(new ej.datavisualization.Diagram.Point(pt.x, pt.y));
                                }
                                distributeLine._resetConnectorPoints(internalConnector, layout.diagram);
                            }
                            modifiedConnectors.push(internalConnector);
                        }
                    }

                    if (node.inEdges != null && node.inEdges.length > 1) {
                        var count = node.inEdges.length;
                        var edgeMapper = distributeLine._getEdgeMapper();
                        for (var j = 0; j < count; j++) {
                            var internalConnector = layout.diagram.nameTable[node.inEdges[j]];
                            if (!distributeLine._containsValue(modifiedConnectors, internalConnector))  //!modifiedConnectors.Contains(internalConnector))
                            {
                                internalConnector._pointCollection = [];// new List<Syncfusion.Base.Diagram.Primitives.Point>();
                                //internalConnector.ResetPoints();
                            }

                            if (count > 1) {
                                var segmentsize = inversespacing / 2.0;
                                var intermediatePoint = null;
                                var key;
                                for (var k = 0; k < edgeMapper.length; k++) {
                                    if (edgeMapper[k].key == internalConnector) {
                                        key = k;
                                        break;
                                    }
                                }
                                if (edgeMapper[key].value.length > 0
                                    && !distributeLine._containsValue(modifiedConnectors, internalConnector))  //!modifiedConnectors.Contains(internalConnector))
                                {
                                    var edgePt = edgeMapper[k].value[0];
                                    var dx1 = edgePt.x + margin.left;
                                    var dy1 = edgePt.y + margin.top;
                                    var x1 = dx1, y1 = dy1;
                                    if (layout.orientation == "bottomtotop") {
                                        y1 = modelBounds.height - dy1;
                                    }
                                    else if (layout.orientation == "righttoleft") {
                                        x1 = modelBounds.width - dx1;
                                    }

                                    x1 += trnsX;
                                    y1 += trnsY;
                                    intermediatePoint = new ej.datavisualization.Diagram.Point(x1, y1);
                                }

                                var pts = [];// internalConnector.ToPoints(true).Reverse().ToList();
                                for (var p = 0; p < internalConnector.segments.length; p++) {
                                    var pt = internalConnector.segments[p].points;
                                    for (var temp in pt) {
                                        //if (temp == 0 || (temp > 0 && !(pt[temp - 1].x == pt[temp].x && pt[temp - 1].y == pt[temp].y)))
                                        pts.push(pt[temp]);
                                    }
                                }
                                pts.reverse();
                                pts = distributeLine._updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds);
                                pts.reverse();
                                internalConnector._pointCollection = [];
                                for (p = 0; p < pts.length; p++) {
                                    var pt = pts[p];
                                    internalConnector._pointCollection.push(new ej.datavisualization.Diagram.Point(pt.x, pt.y));
                                }
                                //internalConnector.segments[0].points = internalConnector._points;
                                //layout.diagram.updateConnector(internalConnector.name, { segments: internalConnector.segments });
                                distributeLine._resetConnectorPoints(internalConnector, layout.diagram);
                            }
                        }
                    }
                }
            }
           
        },

        //get the bounds of the layout model
        _getModelBounds: function (lnodes) {
            lnodes = lnodes.slice();
            var rect = null, rect1 = null;
            for (var i = 0; i < lnodes.length; i++) {
                rect = lnodes[i].geometry;
                if (rect1) {
                    rect1 = ej.datavisualization.Diagram.Geometry.union(rect1, rect)
                }
                else
                    rect1 = rect;
            };
            return rect1;
        },
        _placementStage: function (model, marginX, marginY, parent) {
            var placementStage = this._coordinateAssignment(marginX, marginY, parent, model);
            placementStage.model = model;
            placementStage.widestRankValue = null;
            this._placementStageExecute(placementStage, parent);
            return { marginX: placementStage.marginX + model.layout.horizontalSpacing, marginY: placementStage.marginY + model.layout.verticalSpacing }///####
        },
        //calculate the largest size of the node either height or width depends upon the layoutorientation
        _calculateWidestRank: function (plalementChange, graph, model) {
            var isHorizontal = false;
            if (plalementChange.model.layout.orientation === "lefttoright" || plalementChange.model.layout.orientation === "righttoleft") {
                isHorizontal = true;
            }
            var offset = -plalementChange.verticalSpacing;
            var lastRankMaxCellSize = 0.0;
            plalementChange.rankSizes = [];
            plalementChange.rankOffset = [];
            for (var rankValue = model.maxRank; rankValue >= 0; rankValue--) {
                var maxCellSize = 0.0;
                var rank = model.ranks[rankValue];
                var localOffset = isHorizontal ? plalementChange.marginY : plalementChange.marginX;
                for (var i = 0; i < rank.length; i++) {
                    var node = rank[i];
                    if (node.cell && (node.cell.inEdges || node.cell.outEdges)) {
                        var bounds = ej.datavisualization.Diagram.Util.bounds(this.diagram.nameTable[node.cell.name]);
                        if (bounds != null) {
                            node.width = bounds.width;
                            node.height = bounds.height;
                        }
                        maxCellSize = Math.max(maxCellSize, (isHorizontal ? node.width : node.height));
                    }
                    else if (!ej.datavisualization.Diagram.CrossReduction.prototype._isVertex(node)) {
                        var numEdges = 1;
                        if (node.edges != null) {
                            numEdges = node.edges.length;
                        }
                        node.width = (numEdges - 1) * 10;
                    }
                    if (isHorizontal) {
                        if (!node.height)
                            node.height = 0;
                    }
                    // Set the initial x-value as being the best result so far
                    localOffset += (isHorizontal ? node.height : node.width) / 2.0;
                    this._setXY(node, rankValue, localOffset, isHorizontal ? true : false);
                    this._setTempVariable(node, rankValue, localOffset);
                    localOffset += ((isHorizontal ? node.height : node.width) / 2.0) + plalementChange.horizontalSpacing;
                    if (localOffset > plalementChange.widestRankValue) {
                        plalementChange.widestRankValue = localOffset;
                        plalementChange.widestRank = rankValue;
                    }
                    plalementChange.rankSizes[rankValue] = localOffset;
                }
                plalementChange.rankOffset[rankValue] = offset;
                var distanceToNextRank = maxCellSize / 2.0 + lastRankMaxCellSize / 2.0 + plalementChange.verticalSpacing;
                lastRankMaxCellSize = maxCellSize;
                if (plalementChange.orientation == "north" || plalementChange.orientation == "west") {
                    offset += distanceToNextRank;
                }
                else {
                    offset -= distanceToNextRank;
                }
                for (var i = 0; i < rank.length; i++) {
                    var cell = rank[i];
                    var realOffset = this._getOffset(cell, offset, maxCellSize, isHorizontal ? false : true)
                    this._setXY(cell, rankValue, realOffset, isHorizontal ? false : true);
                }
            }
        },

        _getOffset: function (cell, offset, maxCellSize, isHorizontal) {
            if (isHorizontal) {
                offset -= (maxCellSize - cell.height) / 2;
            } else {
                offset -= (maxCellSize - cell.width) / 2;
            }
            return offset;
        },

        //set the temp position of the node on the layer
        _setTempVariable: function (node, layer, value) {
            if (ej.datavisualization.Diagram.CrossReduction.prototype._isVertex(node)) {
                node.temp[0] = value;
            }
            else {
                node.temp[layer - node.minRank - 1] = value;
            }
        },
        //initialize the layout properties for positioning 
        _coordinateAssignment: function (marginX, marginY, parent, model) {
            var plalementChange = {};
            plalementChange.horizontalSpacing = model.layout.horizontalSpacing;
            plalementChange.verticalSpacing = model.layout.verticalSpacing;
            plalementChange.orientation = "north";
            plalementChange.marginX = plalementChange.marginX = marginX ? marginX : 0;
            plalementChange.marginY = plalementChange.marginY = marginY ? marginY : 0;
            return plalementChange;
        },
        //get the X value of the cell
        _getXY: function (node, layer, isY) {
            if (ej.datavisualization.Diagram.CrossReduction.prototype._isVertex(node)) {
                if (isY)
                    return node.y[0];
                return node.x[0];
            }
            else {
                if (isY)
                    return node.y[layer - this.minRank - 1];
                return node.x[layer - this.minRank - 1];
            }
        },
        //set the geometry position of the cell         
        _setXY: function (node, layer, value, isY) {
            if (node && node.cell) {
                if (node.cell.inEdges || node.cell.outEdges) {
                    if (isY)
                        node.y[0] = value;
                    else
                        node.x[0] = value;
                }
                else {
                    if (isY)
                        node.y[layer - node.minRank - 1] = value;
                    else
                        node.x[layer - node.minRank - 1] = value;
                }
            }
        },
        //set geometry position of the layout node on the layout model
        _rankCoordinates: function (plalementChange, rankValue, graph, model) {
            var isHorizontal = false;
            if (plalementChange.model.layout.orientation === "lefttoright" || plalementChange.model.layout.orientation === "righttoleft") {
                isHorizontal = true;
            }
            var rank = model.ranks[rankValue];
            var maxOffset = 0.0;
            var localOffset = (isHorizontal ? plalementChange.marginY : plalementChange.marginX) + (plalementChange.widestRankValue - plalementChange.rankSizes[rankValue]) / 2;
            for (var i = 0; i < rank.length; i++) {
                var node = rank[i];
                if (ej.datavisualization.Diagram.CrossReduction.prototype._isVertex(node)) {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(this.diagram.nameTable[node.cell.name]);
                    if (bounds != null) {
                        node.width = bounds.width;
                        node.height = bounds.height;
                    }
                    maxOffset = Math.max(maxOffset, node.height);
                }
                else if (!ej.datavisualization.Diagram.CrossReduction.prototype._isVertex(node)) {
                    var numEdges = 1;
                    if (node.edges != null) {
                        numEdges = node.edges.length;
                    }
                    if (isHorizontal)
                        node.height = (numEdges - 1) * 10;
                    else
                        node.width = (numEdges - 1) * 10;
                }
                var size = (isHorizontal ? node.height : node.width) / 2.0;
                localOffset += size;
                this._setXY(node, rankValue, localOffset, isHorizontal ? true : false);
                this._setTempVariable(node, rankValue, localOffset);
                localOffset += (size + plalementChange.horizontalSpacing);
            }
        },
        //sets the layout in an initial positioning.it will arange all the ranks as much as possible
        _initialCoords: function (plalementChange, facade, model) {
            this._calculateWidestRank(plalementChange, facade, model);
            // Reverse sweep direction each time from widest rank 
            for (var i = plalementChange.widestRank; i >= 0; i--) {
                if (i < model.maxRank) {
                    this._rankCoordinates(plalementChange, i, facade, model);
                }
            }
            for (var i = plalementChange.widestRank + 1; i <= model.maxRank; i++) {
                if (i > 0) {
                    this._rankCoordinates(plalementChange, i, facade, model);
                }
            }
        },
        _isAncestor: function (node, otherNode) {
            // Firstly, the hash code of this node needs to be shorter than the other node
            if (otherNode != null && node.hashCode != null && otherNode.hashCode != null
                    && node.hashCode.length < otherNode.hashCode.length) {
                if (node.hashCode == otherNode.hashCode) {
                    return true;
                }
                if (node.hashCode == null || node.hashCode == null) {
                    return false;
                }
                for (var i = 0; i < node.hashCode.length; i++) {
                    if (node.hashCode[i] != otherNode.hashCode[i]) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        },
        //initialize the sorter object
        _weightedCellSorter: function (cell, weightedValue) {
            var weightedCellSorter = {};
            weightedCellSorter.cell = cell ? cell : null;
            weightedCellSorter.weightedValue = weightedValue ? weightedValue : 0;
            weightedCellSorter.visited = false;
            weightedCellSorter.rankIndex = null;
            return weightedCellSorter;
        },
        //Performs one node positioning in both directions
        _minNode: function (plalementChange, model) {
            var nodeList = [];
            var map = { map: {} };
            var rank = [];
            for (var i = 0; i <= model.maxRank; i++) {
                rank[i] = model.ranks[i];
                for (var j = 0; j < rank[i].length; j++) {
                    var node = rank[i][j];
                    var nodeWrapper = this._weightedCellSorter(node, i);
                    nodeWrapper.rankIndex = j;
                    nodeWrapper.visited = true;
                    nodeList.push(nodeWrapper);
                    ej.datavisualization.Diagram.MultiParentModel.prototype._setDictionary(map, node, nodeWrapper, true);
                }
            }
            var maxTries = nodeList.length * 10;
            var count = 0;
            var tolerance = 1;
            while (nodeList.length > 0 && count <= maxTries) {
                var cellWrapper = nodeList.shift();
                var cell = cellWrapper.cell;
                var rankValue = cellWrapper.weightedValue;
                var rankIndex = parseInt(cellWrapper.rankIndex);
                var nextLayerConnectedCells = ej.datavisualization.Diagram.CrossReduction.prototype._getConnectedCellsOnLayer(cell, rankValue);
                var previousLayerConnectedCells = ej.datavisualization.Diagram.CrossReduction.prototype._getConnectedCellsOnLayer(cell, rankValue, true);
                var numNextLayerConnected = nextLayerConnectedCells.length;
                var numPreviousLayerConnected = previousLayerConnectedCells.length;
                var medianNextLevel = this._medianXValue(plalementChange, nextLayerConnectedCells, rankValue + 1);
                var medianPreviousLevel = this._medianXValue(plalementChange, previousLayerConnectedCells, rankValue - 1);
                var numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;
                var currentPosition = ej.datavisualization.Diagram.CrossReduction.prototype._getTempVariable(cell, rankValue);
                var cellMedian = currentPosition;
                if (numConnectedNeighbours > 0) {
                    cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel * numPreviousLayerConnected) / numConnectedNeighbours;
                }
                var positionChanged = false;
                var tempValue = null;
                if (cellMedian < currentPosition - tolerance) {
                    if (rankIndex == 0) {
                        tempValue = cellMedian;
                        positionChanged = true;
                    }
                    else {
                        var leftCell = rank[rankValue][rankIndex - 1];
                        var leftLimit = ej.datavisualization.Diagram.CrossReduction.prototype._getTempVariable(leftCell, rankValue);
                        leftLimit = leftLimit + leftCell.width / 2 + plalementChange.intraCellSpacing + cell.width / 2;
                        if (leftLimit < cellMedian) {
                            tempValue = cellMedian;
                            positionChanged = true;
                        }
                        else if (leftLimit < ej.datavisualization.Diagram.CrossReduction.prototype._getTempVariable(cell, rankValue) - tolerance) {
                            tempValue = leftLimit;
                            positionChanged = true;
                        }
                    }
                }
                else if (cellMedian > currentPosition + tolerance) {
                    var rankSize = rank[rankValue].length;
                    if (rankIndex == rankSize - 1) {
                        tempValue = cellMedian;
                        positionChanged = true;
                    }
                    else {
                        var rightCell = rank[rankValue][rankIndex + 1];
                        var rightLimit = ej.datavisualization.Diagram.CrossReduction.prototype._getTempVariable(rightCell, rankValue);
                        rightLimit = rightLimit - rightCell.width / 2 - plalementChange.intraCellSpacing - cell.width / 2;
                        if (rightLimit > cellMedian) {
                            tempValue = cellMedian;
                            positionChanged = true;
                        }
                        else if (rightLimit > ej.datavisualization.Diagram.CrossReduction.prototype._getTempVariable(cell, rankValue) + tolerance) {
                            tempValue = rightLimit;
                            positionChanged = true;
                        }
                    }
                }
                if (positionChanged) {
                    this._setTempVariable(cell, rankValue, tempValue);
                    // Add connected nodes to map and list
                    this._updateNodeList(nodeList, map, nextLayerConnectedCells);
                    this._updateNodeList(nodeList, map, previousLayerConnectedCells);
                }
                if (ej.datavisualization.Diagram.CrossReduction.prototype._isVertex(cellWrapper.cell)) {
                    cellWrapper.visited = false;
                }
                count++;
            }
        },
        _updateNodeList: function (nodeList, map, collection) {
            for (var i = 0; i < collection.length; i++) {
                var connectedCell = collection[i];
                var connectedCellWrapper = ej.datavisualization.Diagram.MultiParentModel.prototype._getDictionary(map, connectedCell);
                if (connectedCellWrapper != null) {
                    if (connectedCellWrapper.visited == false) {
                        connectedCellWrapper.visited = true;
                        nodeList.push(connectedCellWrapper);
                    }
                }
            }
        },
        //calculates the node position of the connected cell on the specified rank
        _medianXValue: function (plalementChange, connectedCells, rankValue) {
            if (connectedCells.length == 0) {
                return 0;
            }
            var medianValues = [];
            for (var i = 0; i < connectedCells.length; i++) {
                medianValues[i] = ej.datavisualization.Diagram.CrossReduction.prototype._getTempVariable(connectedCells[i], rankValue);
            }
            medianValues.sort(function (a, b) {
                return a - b;
            });
            if (connectedCells.length % 2 == 1) {
                return medianValues[Math.floor(connectedCells.length / 2)];
            }
            else {
                var medianPoint = connectedCells.length / 2;
                var leftMedian = medianValues[medianPoint - 1];
                var rightMedian = medianValues[medianPoint];
                return ((leftMedian + rightMedian) / 2);
            }
        },
        _placementStageExecute: function (plalementChange, parent) {
            var isHorizontal = false;
            if (plalementChange.model.layout.orientation === "lefttoright" || plalementChange.model.layout.orientation === "righttoleft") {
                isHorizontal = true
            }
            plalementChange.jettyPositions = Object();
            var model = plalementChange.model;
            isHorizontal ? plalementChange.currentYDelta = 0.0 : plalementChange.currentXDelta = 0.0;
            this._initialCoords(plalementChange, { model: model }, model);
            this._minNode(plalementChange, model);
            var bestOffsetDelta = 100000000.0;
            if (!plalementChange.maxIterations)
                plalementChange.maxIterations = 8;
            for (var i = 0; i < plalementChange.maxIterations; i++) {
                // if the total offset is less for the current positioning, there are less heavily angled edges and so the current positioning is used
                if ((isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta) < bestOffsetDelta) {
                    for (var j = 0; j < model.ranks.length; j++) {
                        var rank = model.ranks[j];
                        for (var k = 0; k < rank.length; k++) {
                            var cell = rank[k];
                            this._setXY(cell, j, ej.datavisualization.Diagram.CrossReduction.prototype._getTempVariable(cell, j), isHorizontal ? true : false);
                        }
                    }
                    bestOffsetDelta = isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta;
                }
                isHorizontal ? plalementChange.currentYDelta = 0 : plalementChange.currentXDelta = 0;
            }
            this._setCellLocations(plalementChange, model);
        },
        //sets the cell position in the after the layout operation
        _setCellLocations: function (plalementChange, model) {
            var vertices = this._getValues(model.vertexMapper);
            for (var i = 0; i < vertices.length; i++) {
                this._setVertexLocation(plalementChange, vertices[i]);
            }
        },
        //used to specify the geometrical position of the layout model cell
        _garphModelsetVertexLocation: function (plalementChange, cell, x, y) {
            var model = plalementChange.model;
            var geometry = cell.geometry;
            var result = null;
            if (geometry != null) {
                result = new ej.datavisualization.Diagram.Rectangle(x, y, geometry.width, geometry.height);
                if (geometry.x != x || geometry.y != y) {
                    geometry = $.extend(true, {}, geometry);
                    geometry.x = x;
                    geometry.y = y;
                    cell.geometry = geometry;
                }
            }
            return result;
        },
        //set the position of the specified node
        _setVertexLocation: function (plalementChange, cell) {
            var isHorizontal = false;
            if (plalementChange.model.layout.orientation === "lefttoright" || plalementChange.model.layout.orientation === "righttoleft")
                isHorizontal = true;
            var realCell = cell.cell;
            var positionX = cell.x[0] - cell.width / 2;
            var positionY = cell.y[0] - cell.height / 2;
            this._garphModelsetVertexLocation(plalementChange, realCell, positionX, positionY);
            if (isHorizontal) {
                if (!plalementChange.marginY)
                    plalementChange.marginY = null;
                plalementChange.marginY = Math.max(plalementChange.marginY, positionY + cell.height);
            }
            else {
                if (!plalementChange.marginX)
                    plalementChange.marginX = null;
                plalementChange.marginX = Math.max(plalementChange.marginX, positionX + cell.width);
            }
        },
        //get the specific value from the key value pair
        _getValues: function (mapper) {
            var list = [];
            if (mapper.map) {
                for (var key in mapper.map)
                    list.push(mapper.map[key]);
            }
            return list;
        },
        //used to create a duplicate of the node as vertex for layout
        _createVertex: function (dnode, value, x, y, width, height) {            
            var geometry = new ej.datavisualization.Diagram.Rectangle(x, y, width, height);
            geometry.relative = true;
            var vertex = {
                value: value, geometry: geometry, name: value, vertex: true, inEdges: (dnode.inEdges).slice(), outEdges: (dnode.outEdges).slice()
            }
            return vertex;
        },
        //used to remove the any duplicate nodes persist on the multiple number of ranks
        _crossingStage: function (model) {
            var _crossingStage = new ej.datavisualization.Diagram.CrossReduction(this);
            _crossingStage._execute(model);
        },
        _layeringStage: function (model) {
            this._initialRank(model);
            this._fixRanks(model);
        },
        //determine the initial rank for the each vertex on the relevent direction
        _initialRank: function (model) {
            var startNodes = model._startNodes;
            var internalNodes = ej.datavisualization.Diagram.MultiParentModel.prototype._getDictionaryValues(model.vertexMapper);
            var startNodesCopy = startNodes.slice();
            while (startNodes.length > 0) {
                var internalNode = startNodes[0];
                var layerDeterminingEdges = internalNode.connectsAsTarget;
                var edgesToBeMarked = internalNode.connectsAsSource;
                var allEdgesScanned = true;
                var minimumLayer = 100000000;
                for (var i = 0; i < layerDeterminingEdges.length; i++) {
                    var internalEdge = layerDeterminingEdges[i];
                    if (internalEdge.temp[0] == 5270620) {
                        // This edge has been scanned, get the layer of the node on the other end
                        var otherNode = internalEdge.source;
                        minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
                    }
                    else {
                        allEdgesScanned = false;
                        break;
                    }
                }
                // If all edge have been scanned, assign the layer, mark all edges in the other direction and remove from the nodes list
                if (allEdgesScanned) {
                    internalNode.temp[0] = minimumLayer;
                    if (!model.maxRank)
                        model.maxRank = 100000000
                    model.maxRank = Math.min(model.maxRank, minimumLayer);
                    if (edgesToBeMarked != null) {
                        for (var i = 0; i < edgesToBeMarked.length; i++) {
                            var internalEdge = edgesToBeMarked[i];
                            internalEdge.temp[0] = 5270620;
                            // Add node on other end of edge to LinkedList of nodes to be analysed
                            var otherNode = internalEdge.target;
                            // Only add node if it hasn't been assigned a layer
                            if (otherNode.temp[0] == -1) {
                                startNodes.push(otherNode);
                                // Mark this other node as neither being unassigned nor assigned so it isn't added to this list again, but it's layer isn't used in any calculation.
                                otherNode.temp[0] = -2;
                            }
                        }
                    }
                    startNodes.shift();
                }
                else {
                    // Not all the edges have been scanned, get to the back of the class and put the dunces cap on
                    var removedCell = startNodes.shift();
                    startNodes.push(internalNode);
                    if (removedCell == internalNode && startNodes.length == 1) {
                        // This is an error condition, we can't get out of this loop. It could happen for more than one node but that's a lot harder to detect. Log the error
                        break;
                    }
                }
            }
            for (var i = 0; i < internalNodes.length; i++) {
                internalNodes[i].temp[0] -= model.maxRank;
            }
            for (var i = 0; i < startNodesCopy.length; i++) {
                var internalNode = startNodesCopy[i];
                var currentMaxLayer = 0;
                var layerDeterminingEdges = internalNode.connectsAsSource;
                for (var j = 0; j < layerDeterminingEdges.length; j++) {
                    var internalEdge = layerDeterminingEdges[j];
                    var otherNode = internalEdge.target;
                    internalNode.temp[0] = Math.max(currentMaxLayer,
                            otherNode.temp[0] + 1);
                    currentMaxLayer = internalNode.temp[0];
                }
            }
            model.maxRank = 100000000 - model.maxRank;
        },
        //used to set the optimum value of each vertex on the layout
        _fixRanks: function (model) {
            model._fixRanks();
        },
        //used to determine any cyclic stage have been created on the layout model
        _cycleStage: function (model) {
            var seenNodes = new Object();
            model._startNodes = [];
            var unseenNodesArray = ej.datavisualization.Diagram.MultiParentModel.prototype._getDictionaryValues(model.vertexMapper);
            var unseenNodes = new Object();
            for (var i = 0; i < unseenNodesArray.length; i++) {
                unseenNodesArray[i].temp[0] = -1;
                unseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];
            }
            window.model = model;
            window.objLayout = this;
            var rootsArray = null;
            if (model.roots != null) {
                var modelRoots = model.roots;
                rootsArray = [];
                for (var i = 0; i < modelRoots.length; i++) {
                    rootsArray[i] = ej.datavisualization.Diagram.MultiParentModel.prototype._getDictionary(model.vertexMapper, modelRoots[i]);
                    if (rootsArray[i] != null) {
                        model._startNodes.push(rootsArray[i]);
                    }
                }
            }
            model._visit("removeParentConnection", rootsArray, true, null, seenNodes, unseenNodes);
            var seenNodesCopy = ej.datavisualization.Diagram.MultiParentModel.prototype._clone(seenNodes, null, true);
            model._visit("removeNodeConnection", unseenNodes, true, seenNodesCopy, seenNodes, unseenNodes);
        },
        _remove: function (obj, array) {
            var result = null;
            if (typeof (array) == 'object') {
                var index = ej.datavisualization.Diagram.Util.indexOf(array, obj);
                while (index >= 0) {
                    array.splice(index, 1);
                    result = obj;
                    index = ej.datavisualization.Diagram.Util.indexOf(array, obj);
                }
            }
            for (var key = 0; key < array.length; key++) {
                if (array[key] == obj) {
                    delete array[key];
                    result = obj;
                }
            }
            return result;
        },
        _invert: function (connectingEdge, layer) {
            var temp = connectingEdge.source;
            connectingEdge.source = connectingEdge.target;
            connectingEdge.target = temp;
            connectingEdge.isReversed = !connectingEdge.isReversed;
        },
        //used to confirm each vertex is visited once to avoid more no of cycle
        _traverse: function (vertex, directed, edge, currentComp, hierarchyVertices, filledVertexSet) {
            if (vertex != null) {
                var vertexID = vertex.name;
                if ((filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {
                    if (currentComp[vertexID] == null) {
                        currentComp[vertexID] = vertex;
                    }
                    if (filledVertexSet !== null) {
                        delete filledVertexSet[vertexID];
                    }
                    var edges = this._getEdges(vertex);
                    var edgeIsSource = [];
                    for (var i = 0; i < edges.length; i++) {
                        edgeIsSource[i] = (this._getVisibleTerminal(edges[i], true) == vertex);
                    }
                    for (var i = 0; i < edges.length; i++) {
                        if (!directed || edgeIsSource[i]) {
                            var next = this._getVisibleTerminal(edges[i], !edgeIsSource[i]);
                            var netCount = 1;
                            for (var j = 0; j < edges.length; j++) {
                                if (j == i) {
                                    continue;
                                }
                                else {
                                    var isSource2 = edgeIsSource[j];
                                    var otherTerm = this._getVisibleTerminal(edges[j], !isSource2);
                                    if (otherTerm == next) {
                                        if (isSource2) {
                                            netCount++;
                                        }
                                        else {
                                            netCount--;
                                        }
                                    }
                                }
                            }
                            if (netCount >= 0) {
                                currentComp = this._traverse(next, directed, edges[i],
                                    currentComp, hierarchyVertices,
                                    filledVertexSet);
                            }
                        }
                    }
                }
                else {
                    if (currentComp[vertexID] == null) {
                        // We've seen this vertex before, but not in the current component This component and the one it's in need to be merged
                        for (var i = 0; i < hierarchyVertices.length; i++) {
                            var comp = hierarchyVertices[i];
                            if (comp[vertexID] != null) {
                                for (var key in comp) {
                                    currentComp[key] = comp[key];
                                }
                                // Remove the current component from the hierarchy set
                                hierarchyVertices.splice(i, 1);
                                return currentComp;
                            }
                        }
                    }
                }
            }
            return currentComp;
        },
        //used to get the root nodes on the given layout
        _findRoots: function (vertices, layout) {
            var roots = [], root;
            var best = null;
            var maxDiff = -100000;
            for (var i in vertices) {
                var cell = vertices[i];
                var conns = this._getEdges(cell);
                var outEdges = 0;
                var inEdges = 0;
                for (var k = 0; k < conns.length; k++) {
                    var src = this._getVisibleTerminal(conns[k], true);
                    if (src.name == cell.name) {
                        outEdges++;
                    }
                    else {
                        inEdges++;
                    }
                }
                if (inEdges == 0 && outEdges > 0) {
                    roots.push(cell);
                }
                var diff = outEdges - inEdges;
                if (diff > maxDiff) {
                    maxDiff = diff;
                    best = cell;
                }
                if (layout.rootNode && vertices[i].name === layout.rootNode.name) {
                    root = cell;
                }
            }
            if (roots.length == 0 && best != null) {
                if (layout && layout.rootNode) {
                    roots.push(root);
                }
                else
                    roots.push(best);
            }
            return roots;
        },
        //used to get the no of edges connected to the specific node
        _getEdges: function (node) {
            var edges = [];
            if (node) {
                for (var i = 0; node.inEdges.length > 0 && i < node.inEdges.length; i++) {
                    edges.push(this.diagram.nameTable[node.inEdges[i]]);
                }
                for (var i = 0; node.outEdges.length > 0 && i < node.outEdges.length; i++) {
                    if (this.diagram.nameTable[node.outEdges[i]].visible)
                        edges.push(this.diagram.nameTable[node.outEdges[i]]);
                }
            }
            return edges;
        },
        //used to get the source or target node of the conenctor(edge)
        _getVisibleTerminal: function (edge, source) {
            var terminalCache = this.diagram.nameTable[edge.targetNode];
            if (source) {
                terminalCache = this.diagram.nameTable[edge.sourceNode];
            }
            for (var i = 0; i < this.nodes.length; i++) {
                if (this.nodes[i].name === terminalCache.name)
                    return this.nodes[i];
            }
        },
        // used to get the edges between the given source and target 
        _getEdgesBetween: function (source, target, directed) {
            directed = (directed != null) ? directed : false;
            var edges = this._getEdges(source);
            var result = [];
            for (var i = 0; i < edges.length; i++) {
                var src = this._getVisibleTerminal(edges[i], true);
                var trg = this._getVisibleTerminal(edges[i], false);
                if ((src == source && trg == target) || (!directed && src == target && trg == source)) {
                    result.push(edges[i]);
                }
            }
            return result;
        },
    };
    var MultiParentModel = (function () {
        function MultiParentModel(layout, vertices, roots, dlayout) {
            this.roots = roots;
            this.vertexMapper = { map: {} };
            var internalVertices = [];
            this.layout = dlayout;
            this.maxRank = 100000000;
            this._createInternalCells(layout, vertices, internalVertices);
            for (var i = 0; i < vertices.length; i++) {
                var edges = internalVertices[i].connectsAsSource;
                for (var j = 0; j < edges.length; j++) {
                    var internalEdge = edges[j];
                    var realEdges = internalEdge.edges;
                    if (realEdges != null && realEdges.length > 0) {
                        var realEdge = realEdges[0];
                        var targetCell = layout._getVisibleTerminal(realEdge, false);
                        var internalTargetCell = this._getDictionary(this.vertexMapper, targetCell);
                        if (internalVertices[i] == internalTargetCell) {
                            targetCell = layout._getVisibleTerminal(realEdge, true);
                            internalTargetCell = this._getDictionary(this.vertexMapper, targetCell);
                        }
                        if (internalTargetCell != null && internalVertices[i] != internalTargetCell) {
                            internalEdge.target = internalTargetCell;
                            if (internalTargetCell.connectsAsTarget.length == 0) {
                                internalTargetCell.connectsAsTarget = [];
                            }
                            if (ej.datavisualization.Diagram.Util.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0) {
                                internalTargetCell.connectsAsTarget.push(internalEdge);
                            }
                        }
                    }
                }
                internalVertices[i].temp[0] = 1;
            }
        };
        //used to count the no of times the parent have been used
        MultiParentModel.prototype.dfsCount = 0;
        //used to create the duplicate of the edges on the layout model
        MultiParentModel.prototype._createInternalCells = function (layout, vertices, internalVertices) {
            for (var i = 0; i < vertices.length; i++) {
                internalVertices[i] = { x: [], y: [], temp: [], cell: vertices[i], id: vertices[i].name, connectsAsTarget: [], connectsAsSource: [],identicalSibilings:null, type:"internalVertex" };
                this._setDictionary(this.vertexMapper, vertices[i], internalVertices[i]);
                var conns = ej.datavisualization.Diagram.MultipleParentHierarchicalLayout._getEdges(vertices[i]);
                internalVertices[i].connectsAsSource = [];
                for (var j = 0; j < conns.length; j++) {
                    var cell = layout._getVisibleTerminal(conns[j], false);
                    if (cell != vertices[i]) {
                        var undirectedEdges = layout._getEdgesBetween(vertices[i], cell, false);
                        var directedEdges = layout._getEdgesBetween(vertices[i], cell, true);
                        if (undirectedEdges != null && undirectedEdges.length > 0 && directedEdges.length * 2 >= undirectedEdges.length) {
                            var internalEdge = { x: [], y: [], temp: [], edges: undirectedEdges, ids: [], identicalSibilings:null, type:"internalEdge" };
                            for (var m = 0; m < undirectedEdges.length; m++) {
                                internalEdge.ids.push(undirectedEdges[m].name);
                            }
                            internalEdge.source = internalVertices[i];
                            if (!internalVertices[i].connectsAsSource)
                                internalVertices[i].connectsAsSource = [];
                            if (ej.datavisualization.Diagram.Util.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0) {
                                internalVertices[i].connectsAsSource.push(internalEdge);
                            }
                        }
                    }
                }
                internalVertices[i].temp[0] = 0;
            }
        };
        MultiParentModel.prototype._getType = function (type) {
            if (type === "internalVertex")
                return "internalVertex";
            else
                return "internalEdge";
        };
        //used to set the optimum value of each vertex on the layout
        MultiParentModel.prototype._fixRanks = function () {
            var rankList = [];
            this.ranks = [];
            for (var i = 0; i < this.maxRank + 1; i++) {
                rankList[i] = [];
                this.ranks[i] = rankList[i];
            }
            var rootsArray = null;
            if (this.roots != null) {
                var oldRootsArray = this.roots;
                rootsArray = [];
                for (var i = 0; i < oldRootsArray.length; i++) {
                    var cell = oldRootsArray[i];
                    var internalNode = this._getDictionary(this.vertexMapper, cell);
                    rootsArray[i] = internalNode;
                }
            }
            this._visit("updateMinMaxRank", rootsArray, false, null, null, null, rankList);
        };
        MultiParentModel.prototype._updateMinMaxRank = function (parent, node, edge, layer, seen, seenNodes1, unseenNodes1, rankList) {
            if (!node.maxRank && node.maxRank != 0)
                node.maxRank = -1;
            if (!node.minRank && node.minRank != 0)
                node.minRank = -1;
            if (seen == 0 && node.maxRank < 0 && node.minRank < 0) {
                rankList[node.temp[0]].push(node);
                node.maxRank = node.temp[0];
                node.minRank = node.temp[0];
                node.temp[0] = rankList[node.maxRank].length - 1;
            }
            if (parent != null && edge != null) {
                var parentToCellRankDifference = parent.maxRank - node.maxRank;
                if (parentToCellRankDifference > 1) {
                    edge.maxRank = parent.maxRank;
                    edge.minRank = node.maxRank;
                    edge.temp = [];
                    edge.x = [];
                    edge.y = [];
                    for (var i = edge.minRank + 1; i < edge.maxRank; i++) {
                        rankList[i].push(edge);
                        ej.datavisualization.Diagram.MultipleParentHierarchicalLayout._setTempVariable(edge, i, rankList[i].length - 1);
                    }
                }
            }
        };
        //used to store the value of th given key on the object
        MultiParentModel.prototype._setDictionary = function (dic, key, value) {
            var id = key.name;
            if (!id) {
                id = this._getDictionary(dic, key);
            }
            var previous = dic.map[id];
            dic.map[id] = value;
            return previous;
        };
        //used to get the value of the given key
        MultiParentModel.prototype._getDictionary = function (dic, key) {
            if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter != 0)
                this.multiObjectIdentityCounter = 0;
            var id = key.name;
            if (!id) {
                if (!key["layoutObjectId"]) {///####
                    key["layoutObjectId"] = "graphHierarchyNode#" + this.multiObjectIdentityCounter++;
                    return key["layoutObjectId"];
                }
                else return dic.map[key["layoutObjectId"]];
            }
            return dic.map[id];
        };
        //used to get all the values of the dictionary object
        MultiParentModel.prototype._getDictionaryValues = function (dic, key) {
            var result = [];
            for (var key in dic.map) {
                result.push(dic.map[key]);
            }
            return result;
        };
        //used to visit all the entries on the given dictionary with given function
        MultiParentModel.prototype._visit = function (visitor, dfsRoots, trackAncestors, seenNodes, seenNodes1, unseenNodes1, rankList) {
            // Run depth first search through on all roots
            if (dfsRoots != null) {
                for (var i = 0; i < dfsRoots.length; i++) {
                    var internalNode = dfsRoots[i];
                    if (internalNode != null) {
                        if (seenNodes == null) {
                            seenNodes = new Object();
                        }
                        if (trackAncestors) {
                            // Set up hash code for root
                            internalNode.hashCode = [];
                            internalNode.hashCode[0] = this.dfsCount;
                            internalNode.hashCode[1] = i;
                            this._extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i, 0, seenNodes1, unseenNodes1, rankList);
                        }
                        else {
                            this._depthFirstSearch(null, internalNode, null, visitor, seenNodes, 0, seenNodes1, unseenNodes1, rankList);
                        }
                    }
                }
                this.dfsCount++;
            }
        };
        //used to perform the depth fisrt search on the layout model
        MultiParentModel.prototype._depthFirstSearch = function (parent, root, connectingEdge, visitor, seen, layer, seenNodes1, unseenNodes1, rankList) {
            if (root != null) {
                var rootId = root.id;
                if (seen[rootId] == null) {
                    seen[rootId] = root;
                    this._updateConnectionRank(visitor, parent, root, connectingEdge, layer, 0, seenNodes1, unseenNodes1, rankList);
                    // Copy the connects as source list so that visitors can change the original for edge direction inversions
                    var outgoingEdges = root.connectsAsSource.slice();
                    for (var i = 0; i < outgoingEdges.length; i++) {
                        var internalEdge = outgoingEdges[i];
                        var targetNode = internalEdge.target;
                        // Root check is O(|roots|)
                        this._depthFirstSearch(root, targetNode, internalEdge, visitor, seen, layer + 1, seenNodes1, unseenNodes1, rankList);
                    }
                }
                else {
                    this._updateConnectionRank(visitor, parent, root, connectingEdge, layer, 1, seenNodes1, unseenNodes1, rankList);
                }
            }
        };
        MultiParentModel.prototype._updateConnectionRank = function (visitor, parent, root, connectingEdge, layer, seen, seenNodes1, unseenNodes1, rankList) {
            if (visitor === "removeParentConnection" || visitor === "removeNodeConnection")
                this._removeConnectionEdge(parent, root, connectingEdge, layer, seen, seenNodes1, unseenNodes1, rankList, visitor === "removeNodeConnection" ? true : false);
            if (visitor === "updateMinMaxRank")
                this._updateMinMaxRank(parent, root, connectingEdge, layer, seen, seenNodes1, unseenNodes1, rankList);
        };
        MultiParentModel.prototype._removeConnectionEdge = function (parent, node, connectingEdge, layer, seen, seenNodes, unseenNodes, removeNodeConnection) {
            if (window.objLayout._isAncestor(node, parent)) {
                window.objLayout._invert(connectingEdge);
                window.objLayout._remove(connectingEdge, parent.connectsAsSource);
                if (removeNodeConnection) {
                    node.connectsAsSource.push(connectingEdge);
                    parent.connectsAsTarget.push(connectingEdge);
                    window.objLayout._remove(connectingEdge, node.connectsAsTarget);
                }
                else {
                    parent.connectsAsTarget.push(connectingEdge);
                    window.objLayout._remove(connectingEdge, node.connectsAsTarget);
                    node.connectsAsSource.push(connectingEdge);
                }
            }
            seenNodes[node.id] = node;
            delete unseenNodes[node.id];
        };

        //the dfs extends the default version by keeping track of cells ancestors, but it should be only used when necessary
        MultiParentModel.prototype._extendedDfs = function (parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer, seenNodes1, unseenNodes1, rankList) {
            if (root != null) {
                if (parent != null) {
                    if (root.hashCode == null ||
                        root.hashCode[0] != parent.hashCode[0]) {
                        var hashCodeLength = parent.hashCode.length + 1;
                        root.hashCode = parent.hashCode.slice();
                        root.hashCode[hashCodeLength - 1] = childHash;
                    }
                }
                var rootId = root.id;
                if (seen[rootId] == null) {
                    seen[rootId] = root;
                    this._updateConnectionRank(visitor, parent, root, connectingEdge, layer, 0, seenNodes1, unseenNodes1, rankList)
                    var outgoingEdges = root.connectsAsSource.slice();
                    for (var i = 0; i < outgoingEdges.length; i++) {
                        var internalEdge = outgoingEdges[i];
                        var targetNode = internalEdge.target;
                        this._extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1, seenNodes1, unseenNodes1, rankList);
                    }
                }
                else {
                    this._updateConnectionRank(visitor, parent, root, connectingEdge, layer, 1, seenNodes1, unseenNodes1, rankList);
                }
            }
        };
        //used to clone the specified object ignoring all fieldnames in the given array of transient fields
        MultiParentModel.prototype._clone = function (obj, transients, shallow) {
            shallow = (shallow != null) ? shallow : false;
            if (obj != null && typeof (obj.constructor) == 'function') {
                var _clone = new obj.constructor();
                for (var i in obj) {
                    if (i != "layoutObjectId" && (transients == null || ej.datavisualization.Diagram.Util.indexOf(transients, i) < 0)) {
                        if (!shallow && typeof (obj[i]) == 'object') {
                            _clone[i] = $.extend(true, {}, obj[i]);
                        }
                        else {
                            _clone[i] = obj[i];
                        }
                    }
                }
            }
            return _clone;
        };
        return MultiParentModel;
    })();
    ej.datavisualization.Diagram.MultiParentModel = MultiParentModel;
    var CrossReduction = (function () {
        function CrossReduction() {
        };
        //used to calculate the number of edges crossing the layout model
        CrossReduction.prototype._calculateCrossings = function (model) {
            var numRanks = model.ranks.length;
            var totalCrossings = 0;
            for (var i = 1; i < numRanks; i++) {
                totalCrossings += this._calculateRankCrossing(i, model);
            }
            return totalCrossings;
        };
        //used to get the temp value specified for the node or connector
        CrossReduction.prototype._getTempVariable = function (node, layer) {
            if (node) {
                if (this._isVertex(node)) {
                    return node.temp[0];
                }
                else {
                    return node.temp[layer - node.minRank - 1];
                }
            }
        },
        //used to specify the number of conenctors crossing between the specified rank and its below rank 
        CrossReduction.prototype._calculateRankCrossing = function (i, model) {
            var totalCrossings = 0;
            var rank = model.ranks[i];
            var previousRank = model.ranks[i - 1];
            var tmpIndices = [];
            // Iterate over the top rank and fill in the connection information
            for (var j = 0; j < rank.length; j++) {
                var node = rank[j];
                var rankPosition = this._getTempVariable(node, i);
                var connectedCells = this._getConnectedCellsOnLayer(node, i, true);
                ///#### 
                var nodeIndices = [];
                for (var k = 0; k < connectedCells.length; k++) {
                    var connectedNode = connectedCells[k];
                    var otherCellRankPosition = this._getTempVariable(connectedNode, i - 1);
                    nodeIndices.push(otherCellRankPosition);
                }
                nodeIndices.sort(function (x, y) { return x - y; });
                tmpIndices[rankPosition] = nodeIndices;
            }
            var indices = [];
            for (var j = 0; j < tmpIndices.length; j++) {
                indices = indices.concat(tmpIndices[j]);
            }
            var firstIndex = 1;
            while (firstIndex < previousRank.length) {
                firstIndex <<= 1;
            }
            var treeSize = 2 * firstIndex - 1;
            firstIndex -= 1;
            var tree = [];
            for (var j = 0; j < treeSize; ++j) {
                tree[j] = 0;
            }
            for (var j = 0; j < indices.length; j++) {
                var index = indices[j];
                var treeIndex = index + firstIndex;
                ++tree[treeIndex];
                while (treeIndex > 0) {
                    if (treeIndex % 2) {
                        totalCrossings += tree[treeIndex + 1];
                    }
                    treeIndex = (treeIndex - 1) >> 1;
                    ++tree[treeIndex];
                }
            }
            return totalCrossings;
        };
        CrossReduction.prototype._execute = function (model) {
            // Stores initial ordering 
            this.nestedBestRanks = [];
            for (var i = 0; i < model.ranks.length; i++) {
                this.nestedBestRanks[i] = model.ranks[i].slice();
            }
            var iterationsWithoutImprovement = 0;
            var currentBestCrossings = this._calculateCrossings(model);
            for (var i = 0; i < 24 && iterationsWithoutImprovement < 2; i++) {
                this._weightedMedian(i, model);
                var candidateCrossings = this._calculateCrossings(model);
                if (candidateCrossings < currentBestCrossings) {
                    currentBestCrossings = candidateCrossings;
                    iterationsWithoutImprovement = 0;
                }
                else {
                    // Increase count of iterations  
                    iterationsWithoutImprovement++;
                    // Restore the best values to the cells
                    for (var j = 0; j < this.nestedBestRanks.length; j++) {
                        var rank = model.ranks[j];
                        for (var k = 0; k < rank.length; k++) {
                            var cell = rank[k];
                            this._setTempVariable(cell, j, k);
                        }
                    }
                }
                if (currentBestCrossings == 0) {
                    break;
                }
            }
            // Store the best rankings but in the model
            var ranks = [];
            var rankList = [];
            for (var i = 0; i < model.maxRank + 1; i++) {
                rankList[i] = [];
                ranks[i] = rankList[i];
            }
            for (var i = 0; i < this.nestedBestRanks.length; i++) {
                for (var j = 0; j < this.nestedBestRanks[i].length; j++) {
                    rankList[i].push(this.nestedBestRanks[i][j]);
                }
            }
            model.ranks = ranks;
        };
        //check whether the object is vertext or edge on the layout model.
        CrossReduction.prototype._isVertex = function (node) {
            if (node && node.cell && (node.cell.inEdges || node.cell.outEdges)) {
                return true
            }
            return false;
        };
        //used to move up or move down the node position on the adjacent ranks 
        CrossReduction.prototype._weightedMedian = function (iteration, model) {
            // Reverse sweep direction each time through this method
            var downwardSweep = (iteration % 2 == 0);
            if (downwardSweep) {
                for (var j = model.maxRank - 1; j >= 0; j--) {
                    this._medianRank(j, downwardSweep);
                }
            }
            else {
                for (var j = 1; j < model.maxRank; j++) {
                    this._medianRank(j, downwardSweep);
                }
            }
        };
        //used to get the node next(up) connected to the specified node or connector
        CrossReduction.prototype._getConnectedCellsOnLayer = function (cell, layer, isPrevious) {
            var connectedlayer = "nextLayerConnectedCells";
            var connectedAs = "connectsAsTarget"
            if (isPrevious) {
                connectedlayer = "previousLayerConnectedCells";
                connectedAs = "connectsAsSource"
            }
            if (cell) {
                if (this._isVertex(cell)) {
                    if (cell[connectedlayer] == null) {
                        cell[connectedlayer] = [];
                        cell[connectedlayer][0] = [];
                        for (var i = 0; i < cell[connectedAs].length; i++) {
                            var edge = cell[connectedAs][i];
                            if (edge.maxRank == undefined)
                                edge.maxRank = -1;
                            if (edge.maxRank == -1 || (isPrevious ? (edge.minRank == layer - 1) : (edge.maxRank == layer + 1))) {
                                // Either edge is not in any rank or no dummy nodes in edge, add node of other side of edge
                                cell[connectedlayer][0].push(isPrevious ? edge.target : edge.source);
                            }
                            else {
                                // Edge spans at least two layers, add edge
                                cell[connectedlayer][0].push(edge);
                            }
                        }
                    }
                    return cell[connectedlayer][0];
                }
                else {
                    if (cell[connectedlayer] == null) {
                        cell[connectedlayer] = [];
                        for (var i = 0; i < cell.temp.length; i++) {
                            cell[connectedlayer][i] = [];
                            if (i == (isPrevious ? 0 : (cell.temp.length - 1))) {
                                cell[connectedlayer][i].push(isPrevious ? cell.target : cell.source);
                            }
                            else {
                                cell[connectedlayer][i].push(cell);
                            }
                        }
                    }
                    return cell[connectedlayer][layer - cell.minRank - 1];
                }
            }
        };
        //calculates the rank elements on the specified rank
        CrossReduction.prototype._medianValue = function (connectedCells, rankValue) {
            var medianValues = [];
            var arrayCount = 0;
            for (var i = 0; i < connectedCells.length; i++) {
                var cell = connectedCells[i];
                medianValues[arrayCount++] = this._getTempVariable(cell, rankValue);
            }
            // sorts numerical order sort
            medianValues.sort(function (a, b) { return a - b; });
            if (arrayCount % 2 == 1) {
                // For odd numbers of adjacent vertices return the median
                return medianValues[Math.floor(arrayCount / 2)];
            }
            else if (arrayCount == 2) {
                return ((medianValues[0] + medianValues[1]) / 2.0);
            }
            else {
                var medianPoint = arrayCount / 2;
                var leftMedian = medianValues[medianPoint - 1] - medianValues[0];
                var rightMedian = medianValues[arrayCount - 1]
                        - medianValues[medianPoint];
                return (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint] * leftMedian) / (leftMedian + rightMedian);
            }
        };
        //get the temp value of the specified layer
        CrossReduction.prototype._setTempVariable = function (cell, layer, value) {
            if (cell)
                cell.temp[0] = value;
        };
        //used to minimize the node position on this rank and one of its adjacent ranks
        CrossReduction.prototype._medianRank = function (rankValue, downwardSweep) {
            var numCellsForRank = this.nestedBestRanks[rankValue].length;
            var medianValues = [];
            var reservedPositions = [];
            for (var i = 0; i < numCellsForRank; i++) {
                var cell = this.nestedBestRanks[rankValue][i];
                var sorterEntry = { _medianValue: 0, cell: false };
                sorterEntry.cell = cell;
                // Flip whether or not equal medians are flipped on up and down sweeps TODO re-implement some kind of nudge medianValues[i].nudge = !downwardSweep;
                var nextLevelConnectedCells;
                if (downwardSweep) nextLevelConnectedCells = this._getConnectedCellsOnLayer(cell, rankValue);
                else nextLevelConnectedCells = this._getConnectedCellsOnLayer(cell, rankValue, true);
                var nextRankValue;
                downwardSweep ? nextRankValue = rankValue + 1 : nextRankValue = rankValue - 1;
                if (nextLevelConnectedCells != null && nextLevelConnectedCells.length != 0) {
                    sorterEntry._medianValue = this._medianValue(nextLevelConnectedCells, nextRankValue);
                    medianValues.push(sorterEntry);
                }
                else {
                    // Nodes with no adjacent vertices are flagged in the reserved array to indicate they should be left in their current position.
                    reservedPositions[this._getTempVariable(cell, rankValue)] = true;
                }
            }
            medianValues.sort(this._compare);
            // Set the new position of each node within the rank using its temp variable
            for (var i = 0; i < numCellsForRank; i++) {
                if (reservedPositions[i] == null) {
                    var cell = medianValues.shift().cell;
                    this._setTempVariable(cell, rankValue, i);
                }
            }
        };
        //compares two values, it sends the values to the compare function, and sorts the values according to the returned (negative, zero, positive) value
        CrossReduction.prototype._compare = function (a, b) {
            if (a != null && b != null) {
                if (b._medianValue > a._medianValue)
                    return -1;
                else if (b._medianValue < a._medianValue)
                    return 1;
            }
            return 0;
        };
        return CrossReduction;
    })();
    ej.datavisualization.Diagram.CrossReduction = CrossReduction;
    //end region

    var LineDistribution = (function () {
        var edgeMapper = [];
        function LineDistribution() {
            this.edgeMapper = [];
        };
        LineDistribution.prototype._setEdgeMapper = function (value){
            this.edgeMapper.push(value);
        };
        LineDistribution.prototype._getEdgeMapper = function(){
            return this.edgeMapper;
        };
        LineDistribution.prototype._initLineDistribution = function (graph) {            
            var srcDirection = "bottom";
            var tarDirection = "top";

            if (graph.orientation == ej.datavisualization.Diagram.LayoutOrientations.BottomToTop) {
                srcDirection = "top";
                tarDirection = "bottom";
            }
            else if (graph.orientation == ej.datavisualization.Diagram.LayoutOrientations.RightToLeft) {
                srcDirection = "left";
                tarDirection = "right";
            }
            else if (graph.orientation == ej.datavisualization.Diagram.LayoutOrientations.LeftToRight) {
                srcDirection = "right";
                tarDirection = "left";
            }
            var graphnodes = graph.diagram._spatialSearch.parentQuad.objects;
            if (graphnodes.length > 0) {
                for (var i = 0 ; i < graphnodes.length; i++) {
                    var node = graphnodes[i];
                    this._addDynamicPortandDistrrbuteLine(graph, node, srcDirection, tarDirection);
                }
            }
        };
        LineDistribution.prototype._addDynamicPortandDistrrbuteLine = function (layout, node, sourceDirection, targetDirection) {
            if (!(node._ports && node._ports == null)) {
                node._ports = [];
            }
            var existingPorts = node._ports;

            var portColls = [];
            var outConnectors = node.outEdges;
            var inConnectors = node.inEdges;

            for (var name in outConnectors) {
                var internalConnector = layout.diagram.nameTable[outConnectors[name]];
                var sourceNodePort = ej.datavisualization.Diagram.Util.findPortByName(node, internalConnector.sourcePort);
                var direction = sourceDirection;
                if (sourceNodePort == null) {
                    sourceNodePort = ej.datavisualization.Diagram.Port({});
                    sourceNodePort.type = "internal";
                    node._ports.push(sourceNodePort);
                    //delete internalConnector._sourcePortLocation;
                    layout.diagram.updateConnector(internalConnector.name, { sourcePort: sourceNodePort.name });

                    //internalConnector.sourcePort = sourceNodePort;
                }

                if (direction == null) {
                    var pts = internalConnector.segments[0].points;
                    direction = ej.datavisualization.Diagram.Util._getBezierDirection(pts[0], pts[1]);// ej.datavisualization.Diagram.Geometry._findDirection(pts[0], pts[1]);
                }

                portColls.push({ port: sourceNodePort, direction: direction });
            }

            for (var name in inConnectors) {
                var internalConnector = layout.diagram.nameTable[inConnectors[name]];
                var targetNodePort = ej.datavisualization.Diagram.Util.findPortByName(node, internalConnector.targetPort);
                var direction = targetDirection;
                if (targetNodePort == null) {
                    targetNodePort = ej.datavisualization.Diagram.Port({});
                    targetNodePort.type = "internal";
                    node._ports.push(targetNodePort);
                    //delete internalConnector._targetPortLocation;
                    layout.diagram.updateConnector(internalConnector.name, { targetPort: targetNodePort.name });
                }
                if (direction == null) {
                    var pts = internalConnector.segments[0].points;
                    direction = ej.datavisualization.Diagram.Util._getBezierDirection(pts[pts.length - 2], (pts[pts.length - 1]));
                }
                portColls.push({ port: targetNodePort, direction: direction });
            }

            var topPorts = [];
            var leftPorts = [];
            var bottomPorts = [];
            var rightPorts = [];

            for (var key in portColls) {
                var temp = portColls[key];

                if (temp.direction == "top")
                    topPorts.push(temp);
                else if (temp.direction == "left")
                    leftPorts.push(temp);
                else if (temp.direction == "bottom")
                    bottomPorts.push(temp);
                else
                    rightPorts.push(temp);
            }

            if (topPorts.length > 0) {
                for (var i = 0; i < topPorts.length; i++) {
                    var port = topPorts[i].port;
                    port.offset = { x: (i + 1) * (1.0 / (topPorts.length + 1)), y: 0 };
                }
            }

            if (bottomPorts.length > 0) {
                for (var i = 0; i < bottomPorts.length; i++) {
                    var port = bottomPorts[i].port;
                    port.offset = { x: (i + 1) * (1.0 / (bottomPorts.length + 1)), y: 1 };
                }
            }

            if (leftPorts.length > 0) {
                for (var i = 0; i < leftPorts.length; i++) {
                    var port = leftPorts[i].port;
                    port.offset = { x: 0, y: (i + 1) * (1.0 / (leftPorts.length + 1)) };
                }
            }

            if (rightPorts.length > 0) {
                for (var i = 0; i < rightPorts.length; i++) {
                    var port = rightPorts[i].port;
                    port.offset = { x: 1, y: (i + 1) * (1.0 / (rightPorts.length + 1)) };
                }
            }
        };
        LineDistribution.prototype._containsValue = function (list, keyValue) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].key == keyValue || list[i] == keyValue) {
                    return true;
                }
            }
            return false;
        };
        LineDistribution.prototype._distributeLines = function (layout) {
            var isHorizontal = layout.orientation == "lefttoright"
                               || layout.orientation == "righttoleft";
            var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;
            var srcdecoratorSize = 8.0, tardecoratorSize = 10.0;
            var avaibaleSpace = inversespacing - srcdecoratorSize - tardecoratorSize;
            var graph = [];// new SortedList<double, List<ObstacleSegment>>();
            var connectorObstacles = [];//new List<ConnectorObstacle>();
            var globalConnectors = layout.diagram.connectors();
            for (var i = 0; i < globalConnectors.length; i++)  //foreach (var connector in this.Graph.SharedData.GlobalConnectors.Values)
            {
                var connector = globalConnectors[i];
                var pts = [];
                for (var key in connector.segments) {
                    var seg = connector.segments[key];
                    for (var k in seg.points) {
                        var pt = seg.points[k];
                        if (pts.length == 0 || !(ej.datavisualization.Diagram.Geometry.isEqualPoint(pt, pts[pts.length - 1])))
                            pts.push(pt);
                    }
                }
                var obssegments = [];
                for (var j = 1; j < pts.length; j++) {
                    var obstacle = ej.datavisualization.Diagram.ObstacleSegment({ startpt: pts[j - 1], endpt: pts[j], id: connector.id });
                    obssegments.push(obstacle);
                }

                var connectorObstacle = { wrapper: connector, segments: obssegments };
                var segments = [];
                if (!isHorizontal) {
                    for (var key in connectorObstacle.segments) {
                        var obstacle = connectorObstacle.segments[key];
                        if (obstacle.orientation == "horizontal")
                            segments.push(obstacle);
                    }
                }
                else {
                    for (var key in connectorObstacle.segments) {
                        var obstacle = connectorObstacle.segments[key];
                        if (obstacle.orientation == "vertical")
                            segments.push(obstacle);
                    }
                }

                for (var j = 0; j < segments.length; j++) {
                    var obstacleSegment = segments[j];
                    if (!this._containsValue(graph, obstacleSegment.coord)) {//  !graph.ContainsKey(obstacleSegment.Coord)) {
                        graph.push({ key: obstacleSegment.coord, value: [] });
                    }

                    var index;
                    for (var k in graph) {
                        var key = graph[k].key;
                        if (key == obstacleSegment.coord) {
                            index = k;
                            break;
                        }
                    }
                    graph[index].value.push(obstacleSegment);
                }

                connectorObstacles.push(connectorObstacle);
            }

            var modifiedgrap = [];// new SortedList<double, List<ObstacleSegment>>();
            for (var m = 0; m < graph.length; m++) {
                var row = graph[m];
                var sortedrow = row.value;//.OrderBy(e => e.Start);
                sortedrow.sort(function (a, b) { return a.start - b.start });

                var groupby = [];

                var index = 0;

                var maxEnd = Number.MIN_VALUE;
                groupby.push([]);
                for (var n = 0 ; n < sortedrow.length; n++) {
                    var obstacleSegment = sortedrow[n];
                    if (!(groupby[index].length > 0) || maxEnd >= obstacleSegment.start) {
                        groupby[index].push(obstacleSegment);
                        maxEnd = Math.max(maxEnd, groupby[index][groupby[index].length - 1].end);
                    }
                    else {
                        index++;
                        groupby.push([]);
                        groupby[index].push(obstacleSegment);
                        maxEnd = groupby[index][groupby[index].length - 1].end;
                    }
                }

                for (var n = 0 ; n < groupby.length; n++) {
                    var group = groupby[n];
                    var sortedGroup = [];//group.Value.OrderBy(e => e.Start).ToList();
                    for (var j = 0; j < group.length; j++) {
                        var e = group[j];
                        if (e.start)
                            sortedGroup.push(e);
                    }
                    var comparingDir = isHorizontal ? "bottom" : "right";

                    var directed = [];//sortedGroup.Where(e => e.Direction == comparingDir).ToList();
                    for (var j = 0; j < sortedGroup.length; j++) {
                        var e = sortedGroup[j];
                        if (e.direction == comparingDir)
                            directed.push(e);
                    }

                    var reversedirected = [];//sortedGroup.Where(e => e.Direction != comparingDir).ToList();
                    for (var j = 0; j < sortedGroup.length; j++) {
                        var e = sortedGroup[j];
                        if (e.direction != comparingDir)
                            reversedirected.push(e);
                    }

                    var mutual = [];//new List<ObstacleSegment>();
                    if (directed.length > 0) {
                        var temp = directed[0].start;

                        var j = 0;
                        while (j < reversedirected.length) {
                            if (reversedirected[j].end > temp) {
                                mutual.push(reversedirected[j]);
                                reversedirected.splice(j, 1);
                            }
                            else {
                                j++;
                            }
                            for (var i = 0; i < layout.diagram.model.connectors.length; i++) {
                                delete layout.diagram.model.connectors[i]._visited;
                                for (var j = 0; j < layout.diagram.model.connectors.length; j++) {
                                    delete layout.diagram.model.connectors[j]._visited;
                                }
                                for (var j = 0; j < layout.diagram.model.nodes.length; j++) {
                                    delete layout.diagram.model.nodes[j]._visited1;
                                    delete layout.diagram.model.nodes[j]._isRightAdded;
                                }
                            }
                        }
                    }
                    var mutualRow = [];// new Dictionary<int, List<ObstacleSegment>>();
                    mutualRow = this._updateSegmentRow(mutual, mutualRow);

                    var directedRow = [];//new Dictionary<int, List<ObstacleSegment>>();
                    directedRow = this._updateSegmentRow(reversedirected, directedRow);
                    directed.reverse();
                    directedRow = this._updateSegmentRow(directed, directedRow);


                    if (!mutualRow[mutualRow.length - 1].length > 0) {
                        mutualRow.splice(mutualRow.length - 1, 1);
                    }

                    if (!directedRow[directedRow.length - 1].length > 0) {
                        directedRow.splice(directedRow.length - 1, 1);
                    }

                    var subrow = [];// new Dictionary<int, List<ObstacleSegment>>();
                    var descAdding = mutual.length > 0 && (sortedGroup[0].direction == mutual[0].direction
                                                      || sortedGroup[sortedGroup.length - 1].direction == mutual[mutual.length - 1].direction);
                    if (descAdding) {
                        subrow = directedRow;
                        for (var p = 0; p < mutualRow.length; p++) {
                            var obj = mutualRow[p];
                            subrow[subrow.length] = obj;
                        }
                        for (var j = 0; j < layout.diagram.model.nodes.length; j++) {
                            delete layout.diagram.model.nodes[j]._visited1;
                            delete layout.diagram.model.nodes[j]._isRightAdded;
                        }
                    }
                    else {
                        subrow = mutualRow;
                        for (var p = 0; p < directedRow.length; p++) {
                            var obj = directedRow[p];
                            subrow[subrow.length] = obj;
                        }
                    }

                    if (subrow.length > 1) {
                        var directionModifier = 1;
                        if (layout.orientation == "bottomtotop"
                            || layout.orientation == "righttoleft") {
                            directionModifier = -1;
                        }

                        var startCoord = row.key - (directionModifier * avaibaleSpace / 2.0);
                        var diff = avaibaleSpace / subrow.length;

                        for (var i = 0; i < subrow.length; i++) {
                            var newcoord = startCoord + (i * diff * directionModifier);
                            for (var p = 0; p < subrow[i].length; p++) {
                                var obstacleSegment = subrow[i][p];
                                obstacleSegment.coord = newcoord;
                                if (!this._containsValue(modifiedgrap, obstacleSegment.coord)) {  //!modifiedgrap.ContainsKey(obstacleSegment.Coord)) {
                                    modifiedgrap.push({ key: obstacleSegment.coord, value: [] });
                                }
                                var index;
                                for (var k in modifiedgrap) {
                                    var key = modifiedgrap[k].key;
                                    if (key == obstacleSegment.coord) {
                                        index = k;
                                        break;
                                    }
                                }
                                modifiedgrap[index].value.push(obstacleSegment);
                            }
                        }
                    }
                }
            }

            for (var m = 0; m < connectorObstacles.length; m++) {
                var connectorObstacle = connectorObstacles[m];
                var pts = [];//new List<Point>();
                for (var i = 0; i < connectorObstacle.segments.length; i++) {
                    if (i == 0) {
                        pts.push(this._getObstacleStartPoint(connectorObstacle.segments[i]));
                    }
                    else if (isHorizontal) {
                        if (connectorObstacle.segments[i].orientation == "vertical") {
                            pts[pts.length - 1] = this._getObstacleStartPoint(connectorObstacle.segments[i]);
                        }
                    }
                    else if (!isHorizontal) {
                        if (connectorObstacle.segments[i].orientation == "horizontal") {
                            pts[pts.length - 1] = this._getObstacleStartPoint(connectorObstacle.segments[i]);
                        }
                    }

                    pts.push(this._getObstacleEndPoint(connectorObstacle.segments[i]));
                }

                //connectorObstacle.Wrapper.Points =
                //    pts.Select(p => new Syncfusion.Base.Diagram.Primitives.Point(p.X, p.Y)).ToList();
                connectorObstacle.wrapper._pointCollection = [];
                for (j = 0; j < pts.length; j++) {
                    var p = pts[j];
                    if (j == 0 || (j > 0 && !(ej.datavisualization.Diagram.Geometry.isEqualPoint(p, pts[j - 1]))))
                        connectorObstacle.wrapper._pointCollection.push(new ej.datavisualization.Diagram.Point(p.x, p.y));
                }
                this._resetConnectorPoints(connectorObstacle.wrapper, layout.diagram);
                delete connectorObstacle.wrapper._pointCollection;
            }
        };        
        LineDistribution.prototype._getObstacleStartPoint = function (segment) {
            if (segment.orientation == "horizontal") {
                if (segment.direction == "left") {
                    return new ej.datavisualization.Diagram.Point(segment.end, segment.coord);
                }

                return new ej.datavisualization.Diagram.Point(segment.start, segment.coord);
            }

            if (segment.direction == "top") {
                return new ej.datavisualization.Diagram.Point(segment.coord, segment.end);
            }

            return new ej.datavisualization.Diagram.Point(segment.coord, segment.start);
        };
        LineDistribution.prototype._getObstacleEndPoint = function (segment) {
            if (segment.orientation == "horizontal") {
                if (segment.direction == "left") {
                    return new ej.datavisualization.Diagram.Point(segment.start, segment.coord);
                }

                return new ej.datavisualization.Diagram.Point(segment.end, segment.coord);
            }

            if (segment.direction == "top") {
                return new ej.datavisualization.Diagram.Point(segment.coord, segment.start);
            }

            return new ej.datavisualization.Diagram.Point(segment.coord, segment.end);
        };
        LineDistribution.prototype._updateSegmentRow = function (obstacleSegments, segmentRow) {
            var k = 0;
            if (!(segmentRow.length > 0)) {
                segmentRow[0] = [];
            }

            for (var i = 0; i < obstacleSegments.length; i++) {
                var obstacleSegment = obstacleSegments[i];
                while (k < segmentRow.length) {
                    if (k == segmentRow.length - 1) {
                        segmentRow[k + 1] = [];
                    }

                    if (!(segmentRow[k].length > 0) || segmentRow[k][segmentRow[k].length - 1].end < obstacleSegment.start) {
                        segmentRow[k].push(obstacleSegment);
                        break;
                    }

                    k++;
                }
            }
            return segmentRow;
        };
        LineDistribution.prototype._resetConnectorPoints = function (edge, diagram) {
            if (edge._pointCollection && edge._pointCollection.length > 0) {
                var connector = edge;
                connector.segments = [];
                connector.sourcePoint = edge._pointCollection[0];
                connector.targetPoint = edge._pointCollection[edge._pointCollection.length - 1];
                var points = [];
                var segments = [];
                for (var i = 0; i < edge._pointCollection.length - 1; i++) {
                    var point1 = edge._pointCollection[i];
                    var point2 = edge._pointCollection[i + 1];
                    var length = ej.datavisualization.Diagram.Geometry.distance(point1, point2);
                    var direction = ej.datavisualization.Diagram.Util._getBezierDirection(point1, point2);
                    segments.push({ length: length, direction: direction, type: "orthogonal" });
                }
                diagram.updateConnector(connector.name, { segments: segments });
            }
        };
        LineDistribution.prototype._updateConnectorPoints = function (connectorPoints, startSegmentSize, intermediatePoint, layoutBounds) {
            var isHorizontal = this.orientation == "lefttoright"
                             || this.orientation == "righttoleft";
            var pts = connectorPoints;
            if (pts.length > 2) {
                var newPt = ej.datavisualization.Diagram.Geometry.transform(pts[0], ej.datavisualization.Diagram.Util.findAngle(pts[0], pts[1]), startSegmentSize);   //pts[0].Transform(startSegmentSize, pts[0].FindAngle(pts[1]));
                var nextPt = ej.datavisualization.Diagram.Geometry.transform(newPt, ej.datavisualization.Diagram.Util.findAngle(pts[1], pts[2]), ej.datavisualization.Diagram.Util.findLength(pts[1], pts[2]));// newPt.Transform(pts[1].FindLength(pts[2]), pts[1].FindAngle(pts[2]));
                pts.splice(1, 2, newPt, nextPt);
                if (intermediatePoint != null) {
                    var index = 2;
                    var ptsCount = pts.length;
                    var newPt1 = ej.datavisualization.Diagram.Geometry.transform(
                        pts[ptsCount - 1],
                        ej.datavisualization.Diagram.Util.findAngle(pts[ptsCount - 1], pts[ptsCount - 2]),
                        startSegmentSize);
                    pts.splice(ptsCount - 1, 0, newPt1);
                    while (index < (pts.length - 2)) {
                        pts.splice(index, 1);
                    }

                    var edgePt = intermediatePoint;
                    ej.datavisualization.Diagram.Geometry.inflate(layoutBounds, layoutBounds.width, layoutBounds.height);

                    var line1 = [];
                    line1[0] = new ej.datavisualization.Diagram.Point(edgePt.x, layoutBounds.y);
                    line1[1] = new ej.datavisualization.Diagram.Point(edgePt.x, layoutBounds.y + layoutBounds.height);

                    var line2 = [];
                    line2[0] = new ej.datavisualization.Diagram.Point(layoutBounds.x, pts[1].y);
                    line2[1] = new ej.datavisualization.Diagram.Point(layoutBounds.x + layoutBounds.width, pts[1].y);

                    var line3 = [];
                    line3[0] = new ej.datavisualization.Diagram.Point(layoutBounds.x, newPt1.y);
                    line3[1] = new ej.datavisualization.Diagram.Point(layoutBounds.x + layoutBounds.width, newPt1.y);


                    if (isHorizontal) {
                        line1[0] = new ej.datavisualization.Diagram.Point(layoutBounds.x, edgePt.y);
                        line1[1] = new ej.datavisualization.Diagram.Point(layoutBounds.x + layoutBounds.width, edgePt.y);

                        line2[0] = new ej.datavisualization.Diagram.Point(pts[1].x, layoutBounds.y);
                        line2[1] = new ej.datavisualization.Diagram.Point(pts[1].x, layoutBounds.y + layoutBounds.height);

                        line3[0] = new ej.datavisualization.Diagram.Point(newPt1.x, layoutBounds.y);
                        line2[1] = new ej.datavisualization.Diagram.Point(newPt1.x, layoutBounds.y + layoutBounds.height);
                    }

                    var intercepts1 = [ej.datavisualization.Diagram.Util.interSect2(line1[0], line1[1], line2[0], line2[1])];
                    var intercepts2 = [ej.datavisualization.Diagram.Util.interSect2(line1[0], line1[1], line3[0], line3[1])];

                    if (intercepts2.length > 0) {
                        pts.splice(2, 0, intercepts2[0]);
                    }

                    if (intercepts1.length > 0) {
                        pts.splice(2, 0, intercepts1[0]);
                    }
                }
            }

            var i = 1;
            while (i < pts.length - 1) {
                if (ej.datavisualization.Diagram.Geometry.isEqualPoint(pts[i - 1], pts[i])) {
                    pts.splice(i, 1);
                }
                else if (ej.datavisualization.Diagram.Util.findAngle(pts[i - 1], pts[i]) == ej.datavisualization.Diagram.Util.findAngle(pts[i], pts[i + 1])) {
                    pts.splice(i, 1);
                }
                else {
                    i++;
                }
            }

            return pts;
        };
        LineDistribution.prototype._updateMutualSharing = function (cell, id)
        {
            if (cell.identicalSibilings != null)
            {
                cell.identicalSibilings.push(id);
            }
            else
            {
                cell.identicalSibilings = [];
                cell.identicalSibilings.push(id);
            }
        };
        LineDistribution.prototype._groupLayoutCells = function (matrixModel) {
            var ranks = matrixModel.model.ranks;
            for (var j = ranks.length - 1; j >= 0; j--) {
                var vertices = [];
                for (var v = 0 ; v < ranks[j].length; v++) {
                    var rank = ranks[j][v];
                    var type = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(rank.type);
                    if (type === "internalVertex")
                        vertices.push(ranks[j][v]);
                }

                var edges = [];
                for (var e = 0 ; e < ranks[j].length; e++) {
                    var rank = ranks[j][e];
                    var type = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(rank.type);
                    if (type === "internalEdge")
                        edges.push(rank);
                }

                while (vertices.length > 1) {
                    var vertex1 = vertices[0];
                    var parentset1 = this._selectIds(vertex1.connectsAsTarget, true); //  internalVertex.connectsAsTarget.Select(e => e.Source.ID);
                    var childset1 = this._selectIds(vertex1.connectsAsSource, false); //internalVertex.connectsAsSource.Select(e => e.Target.ID);
                    while (vertices.length > 1) {
                        var vertex2 = vertices[1];
                        var parentset2 = this._selectIds(vertex2.connectsAsTarget, true); // internalVertex1.connectsAsTarget.Select(e => e.Source.ID);
                        var childset2 = this._selectIds(vertex2.connectsAsSource, false);  // internalVertex1.connectsAsSource.Select(e => e.Target.ID);
                        var parentequals = this._compareLists(parentset1, parentset2);
                        var childequals = this._compareLists(childset1, childset2);
                        if (parentequals && childequals) {
                            this._updateMutualSharing(vertices[0], vertex2.id);
                            this._updateMutualSharing(vertices[1], vertex1.id);
                            vertices.splice(1, 1);
                            continue;
                        }
                        break;
                    }
                    vertices.splice(0, 1);
                }


                while (edges.length > 1) {
                    var internalEdge = edges[0];
                    var parentset = internalEdge.source;
                    var childset = internalEdge.target;
                    if (parentset.identicalSibilings != null) {

                        var groupedges = [];

                        for (var i = 0; i < edges.length; i++) {
                            var edge = edges[i];
                            if (edge.target == childset) {
                                groupedges.push(edge);
                            }
                        }

                        for (var i = 0 ; i < groupedges.length; i++) {
                            var internalEdgese = groupedges[i];
                            if (this._containsValue(parentset.identicalSibilings, internalEdgese.source.id)) {
                                internalEdgese.source.identicalSibilings = null;
                            }
                        }
                        internalEdge.source.identicalSibilings = null;
                    }
                    edges.splice(0, 1);
                }
            }
        };
        LineDistribution.prototype._selectIds = function (node, source) {
            var returnIds = [];
            for (var i = 0; i < node.length; i++) {
                var connector = node[i];
                if (source) {
                    returnIds.push(connector.source.id);
                }
                else {
                    returnIds.push(connector.target.id);
                }
            }
            return returnIds;
        };
        LineDistribution.prototype._createMatrixCells = function (matrixModel) {
            var layoutSettings = matrixModel.model.layout;
            var isHorizontal = layoutSettings.orientation == "lefttoright"
                               || layoutSettings.orientation == "righttoleft";
            var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
            var spacingInverse = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
            
            var ranks = matrixModel.model.ranks;
            var matrixCellMapper = [];// new Dictionary<int, Dictionary<object, MatrixCellGroup>>();
            var rowoffset = -spacingInverse;
            for (var j = ranks.length - 1; j >= 0; j--) {
                var maxDimension = 0.0;
                var index = (ranks.length - 1) - j;
                var rank = ranks[j].slice();//.ToList();

                // Creating new row and adding it to matrix
                var matrixRow = [];//new List<MatrixCellGroup>();                
                matrixModel.matrix.push({ key: index, value: matrixRow });

                // Creating new row mapper
                var tempMatrixRow = [];//new Dictionary<object, MatrixCellGroup>();
                matrixCellMapper.push({ index: index, value: tempMatrixRow });

                while (rank.length > 0) //.Any())
                {
                    var layoutCell = rank[0];
                    var matrixCell = ej.datavisualization.Diagram.MatrixCellGroup({ level: index, parents: [], children: [], visitedParents: [], visitedChildren: [], ignoredChildren: [], cells: [], size: 0, offset: 0, initialOffset: 0 });
                    matrixRow.push(matrixCell);
                    var type = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(layoutCell.type);
                    if (type === "internalVertex")//is InternalVertex)
                    {
                        matrixCell.cells.push(layoutCell);
                        if (layoutCell.identicalSibilings != null) {
                            for (var i = 0 ; i < rank.length; i++) //foreach (var internalVertex in rank.OfType<InternalVertex>())
                            {
                                var internalVertex = rank[i];
                                var type = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(internalVertex.type);

                                if (type === "internalVertex" && this._containsValue(layoutCell.identicalSibilings, internalVertex.id)) {
                                    matrixCell.cells.push(internalVertex);
                                    if (matrixCell.cells.length > layoutCell.identicalSibilings.length) {
                                        break;
                                    }
                                }
                            }
                        }

                        for (var i = 0; i < matrixCell.cells.length; i++)// foreach (var internalVertex in matrixCell.Cells.OfType<InternalVertex>())
                        {
                            var internalVertex = matrixCell.cells[i];
                            var type = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(internalVertex.type);
                            if (type === "internalVertex") {
                                var geometry = internalVertex.cell.geometry;
                                matrixCell.size += isHorizontal ? geometry.height : geometry.width;
                                maxDimension = Math.max(maxDimension, !isHorizontal ? geometry.height : geometry.width);
                                tempMatrixRow.push({ key: internalVertex.id, value: matrixCell });
                                if (internalVertex.connectsAsTarget.length > 0) {
                                    for (var k = 0; k < internalVertex.connectsAsTarget.length; k++) //foreach (var internalEdgese in internalVertex.ConnectsAsTarget)
                                    {
                                        var internalEdgese = internalVertex.connectsAsTarget[k];
                                        var key = null;
                                        if (this._containsValue(matrixCellMapper[index - 1].value, internalEdgese.ids)) { //matrixCellMapper[index - 1].ContainsKey(internalEdgese.ids)) {
                                            key = internalEdgese.ids;
                                        }
                                        else if (this._containsValue(matrixCellMapper[index - 1].value, internalEdgese.source.id)) { //matrixCellMapper[index - 1].ContainsKey(internalEdgese.Source.ID)) {
                                            key = internalEdgese.source.id;
                                        }

                                        if (key != null) {
                                            var parentcell = matrixCellMapper[index - 1].value;
                                            var parentMartixCell;
                                            for (var v = 0 ; v < parentcell.length; v++) {
                                                if (parentcell[v].key == key) {
                                                    parentMartixCell = parentcell[v].value;
                                                    break;
                                                }
                                            }
                                            if (!this._containsValue(matrixCell.parents, parentMartixCell)) { //   !matrixCell.Parents.Contains(parentMartixCell)) {
                                                matrixCell.parents.push(parentMartixCell);
                                            }

                                            if (!this._containsValue(parentMartixCell.children, matrixCell)) { //!parentMartixCell.Children.Contains(matrixCell)) {
                                                parentMartixCell.children.push(matrixCell);
                                            }
                                        }
                                    }
                                }
                                rank.reverse();
                                rank.pop();
                                rank.reverse();
                            }
                        }
                        matrixCell.size += (matrixCell.cells.length - 1) * spacing;
                    }
                    else if (type === "internalEdge")
                    {
                        matrixCell.cells.push(layoutCell);

                        for (var i = 0; i < matrixCell.cells.length; i++) //  foreach (var internalEdge in matrixCell.Cells.OfType<InternalEdges>())
                        {
                            var internalEdge = matrixCell.cells[i];
                            var type1 = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(internalEdge.type);

                            if (type1 === "internalEdge" && internalEdge.edges != null) {
                                // need to spacing based on its source and target Node
                                var edgeSpacing = 5;
                                var cellSize = -edgeSpacing;
                                for (var k = 0; k < internalEdge.edges.length; k++)  //foreach (var internalConnector in internalEdge.Edges)
                                {
                                    var internalConnector = internalEdge.edges[k];
                                    // need to summ up the line width
                                    cellSize += 1 + edgeSpacing;
                                }

                                matrixCell.size += cellSize;
                            }

                            tempMatrixRow.push({ key: internalEdge.ids, value: matrixCell });

                            var key = null;
                            if (this._containsValue(matrixCellMapper[index - 1].value, internalEdge.ids)) {     //matrixCellMapper[index - 1].ContainsKey(internalEdge.ids)) {
                                key = internalEdge.ids;
                            }
                            else if (this._containsValue(matrixCellMapper[index - 1].value, internalEdge.source.id)) {  //matrixCellMapper[index - 1].ContainsKey(internalEdge.Source.ID)) {
                                key = internalEdge.source.id;
                            }

                            if (key != null) {
                                var parentcell = matrixCellMapper[index - 1].value;
                                var parentMartixCell;
                                for (var v = 0 ; v < parentcell.length; v++) {
                                    if (parentcell[v].key == key) {
                                        parentMartixCell = parentcell[v].value;
                                        break;
                                    }
                                }
                                if (!this._containsValue(matrixCell.parents, parentMartixCell)) {//   !matrixCell.Parents.Contains(parentMartixCell)) {
                                    matrixCell.parents.push(parentMartixCell);
                                }

                                if (!this._containsValue(parentMartixCell.children, matrixCell)) {//!parentMartixCell.Children.Contains(matrixCell)) {
                                    parentMartixCell.children.push(matrixCell);
                                }
                            }

                            rank.reverse();
                            rank.pop();
                            rank.reverse();
                        }

                        matrixCell.size += (matrixCell.cells.length - 1) * spacing;
                    }
                }

                matrixModel.rowOffset.push(rowoffset + (maxDimension / 2) + spacingInverse);
                rowoffset += maxDimension + spacingInverse;
            }
        };
        LineDistribution.prototype._setXYforMatrixCell = function (matrixModel) {
            var layoutSettings = matrixModel.model.layout;
            var isHorizontal = layoutSettings.orientation == "lefttoright"
                               || layoutSettings.orientation == "righttoleft";
            var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;

            for (var i = 0; i < matrixModel.matrix.length; i++) //foreach (var matrixrow1 in matrixModel.Matrix.Values)  //i
            {
                var matrixrow1 = matrixModel.matrix[i].value;
                for (var j = 0; j < matrixrow1.length; j++) //  foreach (var matrixCell in matrixrow1) //j
                {
                    var matrixCell = matrixrow1[j];
                    var start = matrixCell.offset - (matrixCell.size / 2);
                    for (var k = 0; k < matrixCell.cells.length; k++) // foreach (var cell in matrixCell.Cells) //k
                    {
                        var cell = matrixCell.cells[k];
                        var type = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(cell.type);
                        if (type === "internalVertex") {
                            var internalVertex = cell;
                            var width = internalVertex.cell.geometry.width;
                            var height = internalVertex.cell.geometry.height;
                            if (isHorizontal) {
                                internalVertex.cell.geometry = new ej.datavisualization.Diagram.Rectangle(
                                    matrixModel.rowOffset[matrixCell.level] - (width / 2),
                                    start,
                                    width,
                                    height);
                            }
                            else {
                                internalVertex.cell.geometry = new ej.datavisualization.Diagram.Rectangle(
                                    start,
                                    matrixModel.rowOffset[matrixCell.level] - (height / 2),
                                    width,
                                    height);
                            }

                            start += (isHorizontal ? height : width) + spacing;
                        }
                        else if (type === "internalEdge") {
                            var internalEdges = cell;
                            var parent = matrixCell.visitedParents[0];
                            var isContainSibilingVertex = false;
                            for (var l = 0; l < parent.visitedChildren.length; l++) {
                                var children = parent.visitedChildren[l];
                                var cells = [];
                                for (var m = 0; m < children.cells.length; m++) {
                                    var cell = children.cells[m];
                                    var type = ej.datavisualization.Diagram.MultiParentModel.prototype._getType(cell.type);
                                    if (type === "internalVertex") {
                                        cells.push(cell);
                                    }
                                }
                                if (cells.length > 0) {
                                    isContainSibilingVertex = true;
                                    break;
                                }
                            }

                            // Need to updated line width
                            var lineWidth = 1, edgeSpacing = 5;
                            for (var m = 0; m < internalEdges.edges.length; m++) {
                                var internalConnector = internalEdges.edges[m];
                                var pt = new ej.datavisualization.Diagram.Point(start + (lineWidth / 2.0), matrixModel.rowOffset[matrixCell.Level]);
                                if (isHorizontal) {
                                    pt = new ej.datavisualization.Diagram.Point(matrixModel.rowOffset[matrixCell.level], start + (lineWidth / 2.0));
                                }
                                
                                if (this._containsValue(this._getEdgeMapper(), internalConnector)) {  //matrixModel.Model.Layout.EdgesMapper.ContainsKey(internalConnector)) {
                                    var key;
                                    for (var l = 0; l < this._getEdgeMapper().length; l++)
                                    {
                                        if (this._getEdgeMapper()[l].key == internalConnector) {
                                            key = l;
                                            break;
                                        }
                                    }
                                    this._getEdgeMapper()[key].value.push(pt);
                                }

                                start += lineWidth + edgeSpacing;
                            }

                            start += spacing;
                        }
                    }
                }
            }
        };
        LineDistribution.prototype._arrangeElements = function (matrixModel) {
            var layoutSettings = matrixModel.model.layout;
            var isHorizontal = layoutSettings.orientation == ej.datavisualization.Diagram.LayoutOrientations.LeftToRight
            || layoutSettings.orientation == ej.datavisualization.Diagram.LayoutOrientations.RightToLeft;

            var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
            var spacingInverse = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
            // Need to group element before
            this._groupLayoutCells(matrixModel);
            this._createMatrixCells(matrixModel);
           
            for (var j = 0; j < matrixModel.matrix.length; j++) { // foreach (var matrixKey in this.matrix.Keys)
                var matrixKey = matrixModel.matrix[j].key;
                var matrixrow = matrixModel.matrix[matrixKey].value;
                for (var i = 1; i < matrixrow.length; i++) {
                    var cell = matrixrow[i];
                    var prevCell = matrixrow[i - 1];
                    cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
                }
            }


            for (var j = 0; j < matrixModel.matrix[0].value.length; j++) {
                var root = matrixModel.matrix[0].value[j];
                this._arrangeMatrix(root, null, matrixModel);
            }

            for (var k = 0; k < matrixModel.matrix.length; k++) {
                var row = matrixModel.matrix[k].value;
                for (var i = 0; i < row.length; i++) {
                    var cell = row[i];
                    if (cell.visitedParents.length > 1) {
                        var firstParent = cell.visitedParents[0];
                        var lastParent = cell.visitedParents[cell.visitedParents.length - 1];
                        var firstVertexParent = this._findParentVertexCellGroup(firstParent);
                        var lastVertexParent = this._findParentVertexCellGroup(lastParent);

                        if (firstParent != firstVertexParent && firstVertexParent.offset < firstParent.offset)
                        {
                            firstParent = firstVertexParent;
                        }

                        if (lastParent != lastVertexParent && lastVertexParent.offset > lastParent.offset)
                        {
                            lastParent = firstVertexParent;
                        }

                        var newoffset = (firstParent.offset + lastParent.offset) / 2;
                        var availOffsetMin = cell.initialOffset, availOffsetMax = cell.offset;
                        if (!(availOffsetMax == availOffsetMin))
                        {
                            if (newoffset >= availOffsetMin && newoffset <= availOffsetMax)
                            {
                                this._translateMatrixCells(newoffset - cell.offset, cell);
                            }
                            else if (newoffset < availOffsetMin)
                            {
                                this._translateMatrixCells(availOffsetMin - cell.offset, cell);
                            }
                        }
                    }
                }
            }

            this._setXYforMatrixCell(matrixModel);
        };
        LineDistribution.prototype._findParentVertexCellGroup = function (cell) {
            if (cell.cells[0]) {
                return cell;
            }

            if (cell.parents.length > 0) {
                return this._findParentVertexCellGroup(cell.parents[0]);
            }

            return cell;
        };
        LineDistribution.prototype._translateMatrixCells = function (value, cell)
        {
            if (!(value == 0)) {
                cell.offset += value;
                if (cell.visitedChildren.length > 0) {
                    for (var i = 0 ; i < cell.visitedChildren.length; i++) //foreach (var cellVisitedChild in cell.visitedChildren)
                    {
                        var cellVisitedChild = cell.visitedChildren[i];
                        this._translateMatrixCells(value, cellVisitedChild);
                    }
                }
            }
        };
        LineDistribution.prototype._arrangeMatrix = function (cell, parent, matrixModel) {
            var layoutSettings = matrixModel.model.layout;
            var isHorizontal = layoutSettings.orientation == "lefttoright"
                               || layoutSettings.orientation == "righttoleft";
            var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;

            var matrix = matrixModel.matrix;
            var matrixRow = matrix[cell.level].value;
            var matrixIndex = matrixRow.indexOf(cell);

            if (cell.visitedParents.length > 0) {
                if (cell.visitedParents.length == 1) {
                    cell.initialOffset = cell.offset;
                }

                if (matrixIndex + 1 < matrixRow.length) {
                    var nextCell = matrixRow[matrixIndex + 1];
                    if (nextCell.visitedParents.length > 0) {
                        if (!this._containsValue(cell.visitedParents, parent)) {   //   !cell.VisitedParents.Contains(parent)) {
                            cell.visitedParents.push(parent);
                            parent.ignoredChildren.push(cell);
                            return;
                        }
                    }
                }
            }

            if (!(cell.children.length > 0))//!cell.Children.Any())
            {
                var validOffset = cell.offset;
                if (matrixIndex > 0) {
                    var prevCell = matrixRow[matrixIndex - 1];
                    validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
                }

                this._shiftMatrixCells(validOffset - cell.offset, cell, false, null, matrixModel);
            }
            else {
                for (var i = 0 ; i < cell.children.length; i++)// foreach (var matrixCellChild in cell.Children)
                {
                    var matrixCellChild = cell.children[i];
                    if (!this._containsValue(cell.visitedChildren, matrixCellChild)) {  //!cell.visitedChildren.Contains(matrixCellChild)) {
                        this._arrangeMatrix(matrixCellChild, cell, matrixModel);
                        cell.visitedChildren.push(matrixCellChild);
                    }
                }

                if (cell.visitedChildren.length > 0)//.Any())
                {
                    var children = cell.visitedChildren.slice();
                    for (var i = 0 ; i < cell.ignoredChildren.length; i++)  //foreach (var cellIgnoredChild in cell.IgnoredChildren)
                    {
                        var cellIgnoredChild = cell.ignoredChildren[i];
                        children.splice(i, 1, cellIgnoredChild);//.Remove(cellIgnoredChild);
                    }

                    if (children.length > 0) {
                        var firstChild = cell.visitedChildren[0];
                        var lastChild = cell.visitedChildren[cell.visitedChildren.length -1];
                        var x1 = firstChild.offset - (firstChild.size / 2);
                        var x2 = lastChild.offset + (lastChild.size / 2);
                        var newoffset = (x1 + x2) / 2;
                        if (newoffset < cell.offset) {
                            this._shiftMatrixCells(cell.offset - newoffset, firstChild, true, cell, matrixModel);
                        }
                        else if (newoffset > cell.offset) {
                            this._shiftMatrixCells(newoffset - cell.offset, cell, false, null, matrixModel);
                        }
                    }
                }
            }

            if (!this._containsValue(cell.visitedParents, parent)) {   //  !cell.VisitedParents.Contains(parent))
                cell.visitedParents.push(parent);
            }
        };
        LineDistribution.prototype._shiftMatrixCells = function (value, startingCell, shiftChildren, parentCell, matrixModel) {
            if (!(value == 0)) {
                var matrix = matrixModel.matrix;
                var matrixRow = matrix[startingCell.level].value;
                var index = matrixRow.indexOf(startingCell);

                for (var i = index; i < matrixRow.length; i++) {
                    matrixRow[i].offset += value;
                }

                if (shiftChildren) {
                    if (startingCell.visitedChildren.length > 0) {
                        this._shiftMatrixCells(
                            value,
                            startingCell.visitedChildren[0],
                            true,
                            startingCell,
                            matrixModel);
                    }
                    else {
                        var i = 1;
                        var nextSibilingwithChild = null;
                        while (index + i < matrixRow.length) {
                            var nextCell = matrixRow[index + i];
                            if (parentCell != null && this._containsValue(nextCell.visitedParents, parentCell)) {   // nextCell.VisitedParents.Contains(parentCell)) {
                                if (nextCell.visitedChildren.length > 0) {
                                    nextSibilingwithChild = nextCell;
                                }
                                else {
                                    i++;
                                    continue;
                                }
                            }

                            break;
                        }

                        if (nextSibilingwithChild != null) {
                            this._shiftMatrixCells(
                                value,
                                nextSibilingwithChild.visitedChildren[0],                                
                                true,
                                nextSibilingwithChild,
                                matrixModel);
                        }
                    }
                }
            }
        };
        LineDistribution.prototype._compareLists = function (list1, list2) {
            var newList1 = list1.slice();
            var newList2 = list2.slice();
            if (newList1.length == newList2.length) {
                if (newList1.length == 0) {
                    return true;
                }
                else {
                    var isSame = true;
                    for (var i = 0; i < newList2.length; i++)// foreach (var o in newList2)
                    {
                        var o = newList2[i];
                        for (var j = i ; j < newList1.length; j++) {
                            if (!(newList1[j] == o)) {
                                isSame = false;
                                break;
                            }
                        }
                    }

                    return isSame;
                }
            }

            return false;
        };
        return LineDistribution;
    })();
    ej.datavisualization.Diagram.LineDistribution = LineDistribution;

    ej.datavisualization.Diagram.ConnectorObstacleDefaults = {
        wrapper: null,
        segments: []
    };
    ej.datavisualization.Diagram.ConnectorObstacle = function (options) {
        options.wrapper = options.wrapper;
        options.segments = options.segments;        
        return $.extend(false, {}, ej.datavisualization.Diagram.ConnectorObstacleDefaults, options);
    };
    ej.datavisualization.Diagram.ObstacleSegmentDefaults = {
        start: Number,
        end: Number,
        coord: Number,
        direction: null,
        distance: Number,
        orientation: null,
        id: Number,
        startpoint: ej.datavisualization.Diagram.Point,
        endpoint: ej.datavisualization.Diagram.Point
    };
    ej.datavisualization.Diagram.ObstacleSegment = function (options) {
        options.direction = ej.datavisualization.Diagram.Util._getBezierDirection(options.startpt, options.endpt); // ej.datavisualization.Diagram.Geometry._findDirection(options.startpt, options.endpt);
        options.distance = ej.datavisualization.Diagram.Util.findLength(options.startpt, options.endpt);
        options.orientation = options.direction == "left" || options.direction == "right" ? "horizontal" : "vertical";
        options.id = options.id;
        if (options.orientation == "horizontal") {
            options.coord = options.startpt.y;
            if (options.direction == "left") {
                options.start = options.endpt.x;
                options.end = options.startpt.x;
            }
            else {
                options.start = options.startpt.x;
                options.end = options.endpt.x;
            }
        }
        else {
            options.coord = options.startpt.x;
            if (options.direction == "top") {
                options.start = options.endpt.y;
                options.end = options.startpt.y;
            }
            else {
                options.start = options.startpt.y;
                options.end = options.endpt.y;
            }
        }

        return $.extend(false, {}, ej.datavisualization.Diagram.ObstacleSegmentDefaults, options);
    };
    ej.datavisualization.Diagram.MatrixModelDefaults = {
        model: null,
        matrix: [],
        rowOffset: []
    };
    ej.datavisualization.Diagram.MatrixModel = function (options) {
        options.model = options.model;
        options.matrix = options.matrix || [];
        options.rowOffset = options.rowOffset || [];
        return $.extend(false, {}, ej.datavisualization.Diagram.MatrixModelDefaults, options);
    };
    ej.datavisualization.Diagram.MatrixCellGroupDefaults = {
        parents: [],
        children: [],
        visitedParents: [],
        visitedChildren: [],
        ignoredChildren: [],
        cells: [],
        size: Number,
        offset: Number,
        level: Number,
        initialOffset: Number
    };
    ej.datavisualization.Diagram.MatrixCellGroup = function (options) {
        options.level = options.level;
        options.parents = options.parents;
        options.children = options.children;
        options.visitedChildren = options.visitedChildren;
        options.visitedParents = options.visitedParents;
        options.ignoredChildren = options.ignoredChildren;
        options.cells = options.cells;
        options.offset = options.offset;
        options.initialOffset = options.initialOffset
        return $.extend(false, {}, ej.datavisualization.Diagram.MatrixCellGroupDefaults, options);
    };



})(jQuery, Syncfusion);
;
var SizeF = (function () {
    function SizeF(width, height) {
        this.width = width;
        this.height = height;
    }
    return SizeF;
}());
var GraphForceNode = (function () {
    function GraphForceNode(gnNode) {
        this.m_fVelocityX = 0;
        this.m_fVelocityY = 0;
        this.nodes = [];
        this.velocityX = this.m_fVelocityX;
        this.velocityY = this.m_fVelocityY;
        this.graphNode = gnNode;
        var bounds = ej.datavisualization.Diagram.Util.bounds(gnNode);
        this.location = bounds._center;
        this.nodes = [];
        if (!gnNode._parents) {
            gnNode._parents = [];
        }
        if (!gnNode._children) {
            gnNode._children = [];
        }
        this.nodes = (gnNode._parents).concat(gnNode._children);
    }
    GraphForceNode.prototype.ApplyChanges = function () {
        this.graphNode._center = this.location;
    };
    return GraphForceNode;
}());
var SymmetricLayoutManager = (function () {
    function SymmetricLayoutManager(diagram) {
        this.m_szMaxForceVelocity = new SizeF(SymmetricLayoutManager.c_fMAX_VELOCITY, SymmetricLayoutManager.c_fMAX_VELOCITY);
        this.m_fVertexDistance = 0;
        this.m_dSpringFactor = SymmetricLayoutManager.c_dCOEF;
        this.m_nMaxIteraction = SymmetricLayoutManager.c_nMAX_ITERACTION;
        this.SpringLength = this.m_fVertexDistance;
        this.SpringFactor = this.m_dSpringFactor;
        this.MaxIteraction = this.m_nMaxIteraction;
        this.selectedNode = this.m_objSelectedNode;
        this.m_fVertexDistance = diagram.model.layout.springLength;
        this.m_dSpringFactor = diagram.model.layout.springFactor;
        this.m_nMaxIteraction = diagram.model.layout.maxIteration;
    }
    SymmetricLayoutManager.prototype.doGraphLayout = function (graphLayoutManager) {
        var graph = this.selectedNode;
        this.diagram = graphLayoutManager.diagram;
        graph.Bounds = graphLayoutManager._getModelBounds(this.diagram.nodes());
        var lstGraphNodes = graph.GraphNodes;
        var lstNodes = this._convertGraphNodes(lstGraphNodes);
        var count = lstNodes.length;
        count = Math.min(this.m_nMaxIteraction, count * count * count);
        this._preLayoutNodes(lstNodes, graph.Bounds);
        for (var i = 0, nLenght = count; i < nLenght; i++) {
            this._makeSymmetricLayout(lstNodes);
            this._appendForces(lstNodes);
        }
        this._resetGraphPosition(lstNodes, graph);
    };
    SymmetricLayoutManager.prototype._preLayoutNodes = function (lstNodes, rcBounds) {
        var fMaxSize = Math.max(rcBounds ? rcBounds.width : 25, rcBounds ? rcBounds.height : 25);
        var ptCenter = { x: fMaxSize / 2, y: fMaxSize / 2 };
        var dRotateAngle = 2 * Math.PI / lstNodes.length;
        var dAngle = dRotateAngle;
        for (var i = 0; i < lstNodes.length; i++) {
            var gnNode = lstNodes[i];
            var forceNode = this._getForceNode(gnNode);
            forceNode.location = {
                x: ptCenter.x + fMaxSize * Number((Math.cos(dAngle)).toFixed(2)),
                y: ptCenter.y + fMaxSize * Number(Math.sin(dAngle).toFixed(2))
            };
            dAngle -= dRotateAngle;
        }
    };
    SymmetricLayoutManager.prototype.DoLayout = function (GraphLayoutManager) {
        this.selectedNode = GraphLayoutManager.selectedNode;
        this.doGraphLayout(GraphLayoutManager);
    };
    SymmetricLayoutManager.prototype._collectionContains = function (name, coll) {
        for (var i = 0; i < coll.length; i++) {
            if (coll[i].name === name) {
                return true;
            }
        }
    };
    SymmetricLayoutManager.prototype._makeSymmetricLayout = function (lstNodes) {
        var forceNode;
        var force;
        for (var k = 0; k < lstNodes.length; k++) {
            var gnNode = lstNodes[k];
            forceNode = this._getForceNode(gnNode);
            var nodes = forceNode.nodes;
            for (var l = 0; l < nodes.length; l++) {
                var gnChild = nodes[l];
                if (this._collectionContains(gnChild.name, lstNodes)) {
                    this._calcNodesForce(forceNode, this._getForceNode(gnChild));
                }
            }
            for (var i = 0, length = nodes.length; i < length; i++) {
                if (length < 2) {
                    break;
                }
                var vtx1 = this._getForceNode(nodes[i]);
                var vtx2 = (i + 1 >= length) ? this._getForceNode(nodes[0]) : this._getForceNode((nodes[i + 1]));
                var angle = (360 / nodes.length / 2) * Math.PI / 180;
                var normalDistance = 2 * this.m_fVertexDistance * Math.sin(angle);
                this._calcRelatesForce(vtx1, vtx2, normalDistance);
            }
            for (var s = 0; s < lstNodes.length; s++) {
                var gnChild = lstNodes[s];
                if (!this._collectionContains(gnChild.name, nodes) && gnChild.name !== gnNode.name) {
                    force = this._getForceNode(gnChild);
                    this._updateNeigbour(forceNode, force);
                }
            }
        }
    };
    SymmetricLayoutManager.prototype._appendForces = function (lstNodes) {
        var gfnNode = null;
        for (var k = 0; k < lstNodes.length; k++) {
            var gnNode = lstNodes[k];
            gfnNode = this._getForceNode(gnNode);
            var ptPoint = gfnNode.location;
            ptPoint.x += Math.min(gfnNode.velocityX, this.m_szMaxForceVelocity.width);
            ptPoint.y += Math.min(gfnNode.velocityY, this.m_szMaxForceVelocity.height);
            gfnNode.velocityX = 0;
            gfnNode.velocityY = 0;
            gfnNode.location = ptPoint;
        }
    };
    SymmetricLayoutManager.prototype._resetGraphPosition = function (lstNodes, graph) {
        var szMin = new SizeF(Number.MAX_VALUE, Number.MAX_VALUE);
        var gfnNode = null;
        for (var k = 0; k < lstNodes.length; k++) {
            var gnNode = lstNodes[k];
            gfnNode = this._getForceNode(gnNode);
            var ptLocation = { x: gfnNode.location.x - gnNode.width / 2, y: gfnNode.location.y - gnNode.height / 2 };
            szMin.width = Math.min(szMin.width, ptLocation.x);
            szMin.height = Math.min(szMin.height, ptLocation.y);
        }
        for (var k = 0; k < lstNodes.length; k++) {
            gnNode = lstNodes[k];
            gfnNode = this._getForceNode(gnNode);
            var ptLocation = gfnNode.location;
            ptLocation.x -= szMin.width - graph.location ? graph.location.x : 0;
            ptLocation.y -= szMin.height - graph.location ? graph.location.y : 0;
            gfnNode.location = ptLocation;
            gfnNode.ApplyChanges();
        }
    };
    SymmetricLayoutManager.prototype._convertGraphNodes = function (lstNodes) {
        var lstToReturn = [];
        for (var k in lstNodes) {
            if (lstNodes[k]) {
                var gnNode = lstNodes[k];
                var forceNode = new GraphForceNode(gnNode);
                gnNode._tag = forceNode;
                lstToReturn.push(gnNode);
            }
        }
        return lstToReturn;
    };
    SymmetricLayoutManager.prototype._getForceNode = function (gnNode) {
        return gnNode._tag;
    };
    SymmetricLayoutManager.prototype._updateNeigbour = function (vtSource, vtTarget) {
        if (vtTarget == null || vtSource == null) {
            return;
        }
        var distance = this._pointDistance(vtSource.location, vtTarget.location);
        var angle = this._lineAngle(vtSource.location, vtTarget.location);
        var normalDistance = (this.m_fVertexDistance * 0.9);
        if (distance < normalDistance) {
            this._calcForce(distance, normalDistance, angle, vtTarget);
        }
    };
    SymmetricLayoutManager.prototype._lineAngle = function (pt1, pt2) {
        var radians = 0;
        var vx = pt2.x - pt1.x;
        var vy = pt2.y - pt1.y;
        if (vx === 0) {
            if (vy <= 0) {
                radians = (3.0 * Math.PI) / 2.0;
            }
            else {
                radians = Math.PI / 2.0;
            }
        }
        else if (vy === 0) {
            if (vx < 0) {
                radians = Math.PI;
            }
            else {
                radians = 0;
            }
        }
        else {
            radians = Math.atan(vy / vx);
            if (vx < 0 && vy > 0) {
                radians = Math.PI + radians;
            }
            else if (vx < 0 && vy < 0) {
                radians = Math.PI + radians;
            }
            else if (vx > 0 && vy < 0) {
                radians = 2.0 * Math.PI + radians;
            }
        }
        return radians;
    };
    SymmetricLayoutManager.prototype._pointDistance = function (pt1, pt2) {
        var d = 0;
        var dx = pt2.x - pt1.x;
        var dy = pt2.y - pt1.y;
        var t = (dx * dx) + (dy * dy);
        if (t > 0) {
            d = Math.sqrt(t);
        }
        return d;
    };
    SymmetricLayoutManager.prototype._calcRelatesForce = function (vtSource, vtTarget, normalDistance) {
        var distance = this._pointDistance(vtSource.location, vtTarget.location);
        var angle = this._lineAngle(vtSource.location, vtTarget.location);
        if (distance < normalDistance) {
            this._calcForce(distance, normalDistance, angle, vtTarget);
        }
    };
    SymmetricLayoutManager.prototype._calcNodesForce = function (vtSource, vtTarget) {
        var distance = this._pointDistance(vtSource.location, vtTarget.location);
        var angle = this._lineAngle(vtSource.location, vtTarget.location);
        if (distance > this.m_fVertexDistance || distance < this.m_fVertexDistance) {
            this._calcForce(distance, this.m_fVertexDistance, angle, vtTarget);
        }
    };
    SymmetricLayoutManager.prototype._calcForce = function (distance, minDist, angle, vtTarget) {
        var count = vtTarget.nodes.length;
        var length = distance - minDist;
        var factor = this.m_dSpringFactor / (count * count) * Math.sqrt(count);
        if (length !== 0) {
            var fVelocity = length * factor;
            var fOffset = fVelocity;
            var offsetX = Math.cos(angle) * fOffset;
            var offsetY = Math.sin(angle) * fOffset;
            vtTarget.velocityX -= offsetX;
            vtTarget.velocityY -= offsetY;
        }
    };
    SymmetricLayoutManager.c_dCOEF = 0.442;
    SymmetricLayoutManager.c_fMAX_VELOCITY = 50;
    SymmetricLayoutManager.c_nMAX_ITERACTION = 1000;
    SymmetricLayoutManager.c_nSPRING_LENGTH = 100;
    return SymmetricLayoutManager;
}());
var GraphLayoutManager = (function () {
    function GraphLayoutManager() {
        this.visitedStack = [];
        this.cycleEdgesCollection = [];
        this.passedNodes = {};
    }
    GraphLayoutManager.prototype.updateLayout = function (diagram, smtLayout) {
        this.diagram = diagram;
        var selectionList = diagram.nodes();
        if (selectionList.length > 0) {
            this.m_helperSelectedNode = $.extend(true, {}, selectionList[0]);
        }
        var nodes = [];
        for (var i = 0; i < diagram.nodes().length; i++) {
            nodes.push(diagram.nodes()[i]);
        }
        for (i = 0; i < diagram.connectors().length; i++) {
            nodes.push(diagram.connectors()[i]);
        }
        this._updateLayout1(nodes, smtLayout);
        var modelBounds = this._getModelBounds(diagram.nodes());
        var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(diagram, true);
        for (i = 0; i < diagram.nodes().length; i++) {
            var node = diagram.nodes()[i];
            var trnsX = (viewPort.width - modelBounds.width) / 2;
            var margin = diagram.model.layout.margin || {}, marginX, marginY;
            margin.left = margin.left || 0;
            margin.right = margin.right || 0;
            margin.top = margin.top || 0;
            margin.bottom = margin.bottom || 0;
            if (diagram.model.layout.marginX) {
                margin.left = diagram.model.layout.marginX;
            }
            if (diagram.model.layout.marginY) {
                margin.top = diagram.model.layout.marginY;
            }
            var dx = (node._tag.location.x - (node.offsetX - (node.width / 2)) - modelBounds.x + trnsX + margin.left);
            var dy = (node._tag.location.y - (node.offsetY - (node.height / 2)) - modelBounds.y + margin.top);
            this.diagram._translate(node, dx, dy, diagram.nameTable);
            delete node._tag;
            delete node._center;
            delete node._children;
            delete node._isCycleEdge;
            delete node._parents;
            if (!this.diagram._isInit) {
                ej.datavisualization.Diagram.DiagramContext.update(node, this.diagram);
            }
        }
        return;
    };
    GraphLayoutManager.prototype._getModelBounds = function (lnodes) {
        lnodes = lnodes.slice();
        var rect = null, rect1 = null, node;
        for (var i = 0; i < lnodes.length; i++) {
            node = lnodes[i];
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            rect = {
                x: node._tag ? node._tag.location.x : bounds.x,
                y: node._tag ? node._tag.location.y : bounds.y,
                width: node.width, height: node.height
            };
            if (rect1) {
                rect1 = ej.datavisualization.Diagram.Geometry.union(rect1, rect);
            }
            else {
                rect1 = rect;
            }
        }
        ;
        return rect1;
    };
    GraphLayoutManager.prototype._updateLayout1 = function (nodesToLayout, smtLayout) {
        this._detectCyclesInGraph(nodesToLayout);
        var nodesCount = nodesToLayout.length;
        if (nodesCount > 0) {
            var cycleConnColln = [];
            var nodes = [];
            var nodeSymbols = [];
            for (var s = 0; s < nodesToLayout.length; s++) {
                var nd = nodesToLayout[s];
                if (nd._isCycleEdge === undefined) {
                    nd._isCycleEdge = false;
                }
                if (nd.segments && !nd._isCycleEdge) {
                    nodes.push(nd);
                }
                else if (nd.segments) {
                    cycleConnColln.push(nd);
                }
                else {
                    nodeSymbols.push(nd);
                }
            }
            nodes = nodes.concat(nodeSymbols);
            nodes = cycleConnColln.concat(nodes);
            while (nodesCount > this._dictionaryLength(this.passedNodes)) {
                this._getNodesToPosition(nodes);
                if (this.selectedNode == null) {
                    continue;
                }
                smtLayout.DoLayout(this);
                this.selectedNode = null;
                this.visitedStack = [];
                this.cycleEdgesCollection.forEach(function (connector) {
                    connector._isCycleEdge = false;
                });
            }
            this.passedNodes = null;
            this.selectedNode = null;
        }
        return false;
    };
    GraphLayoutManager.prototype._getNodesToPosition = function (nodes) {
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (!this._collectionContains(node.name, this.passedNodes)) {
                if (node) {
                    this._selectNodes(node);
                }
                break;
            }
        }
    };
    GraphLayoutManager.prototype._selectNodes = function (node) {
        var nodeGraph = node;
        if (node.segments) {
            this._exploreGraphEdge(node);
        }
        else if (nodeGraph != null) {
            if (this._addNode(node, "passed")) {
                this._addNode(node, "selected");
                if (this._isConnectedToAnotherNode(nodeGraph)) {
                    this.selectedNode = {};
                    this.selectedNode.LeftMargin = 10;
                    this.selectedNode.TopMargin = 10;
                    this._selectConnectedNodes(nodeGraph);
                }
                else {
                    this.selectedNode = node;
                }
            }
        }
    };
    GraphLayoutManager.prototype._selectConnectedNodes = function (nodeGraph) {
        var graph = this.selectedNode;
        if (!graph.GraphNodes) {
            graph.GraphNodes = {};
        }
        var node = nodeGraph;
        if (node != null && this._addNode(node, "passed")) {
            var nodeName = node.name;
            if (!this._dictionaryContains(graph.GraphNodes, node)) {
                var gnNode = this._addGraphNode(node);
                this._getConnectedRelatives(gnNode);
                this._exploreRelatives(nodeGraph);
            }
            else {
                var graphNode = graph.GraphNodes[nodeName];
                if (graphNode.Added) {
                    graphNode.Added = false;
                    this._getConnectedRelatives(graphNode);
                    this._exploreRelatives(nodeGraph);
                }
            }
        }
    };
    GraphLayoutManager.prototype._exploreRelatives = function (nodeGraph) {
        this._exploreRelatives1(nodeGraph, "Parents");
        this._exploreRelatives1(nodeGraph, "Children");
    };
    GraphLayoutManager.prototype._exploreRelatives1 = function (nodeGraph, relativesToExplore) {
        var edges = [];
        if (relativesToExplore === "Parents") {
            edges = nodeGraph.inEdges;
        }
        else if (relativesToExplore === "Children") {
            edges = nodeGraph.outEdges;
        }
        for (var i = 0; i < edges.length; i++) {
            var edge = this.diagram.nameTable[edges[i]];
            if (this._addNode(edge, "passed")) {
                var fromNode = this.diagram.nameTable[edge.sourceNode];
                var toNode = this.diagram.nameTable[edge.targetNode];
                if (relativesToExplore === "Parents" && fromNode != null &&
                    this._collectionContains(fromNode.name, this.diagram.nodes())) {
                    this._selectConnectedNodes(this.diagram.nameTable[edge.sourceNode]);
                }
                else if (relativesToExplore === "Children" && toNode != null &&
                    this._collectionContains(toNode.name, this.diagram.nodes())) {
                    this._selectConnectedNodes(this.diagram.nameTable[edge.targetNode]);
                }
            }
        }
    };
    GraphLayoutManager.prototype._getConnectedRelatives = function (graphNode) {
        this._getConnectedParents(graphNode);
        this._getConnectedChildren(graphNode);
    };
    GraphLayoutManager.prototype._dictionaryContains = function (obj, keyObj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
            if (obj[keys[i]].name === keyObj.name) {
                return true;
            }
        }
        return false;
    };
    GraphLayoutManager.prototype._dictionaryLength = function (obj) {
        var keys = Object.keys(obj);
        return keys.length;
    };
    GraphLayoutManager.prototype._getConnectedChildren = function (graphNode) {
        var graph = this.selectedNode;
        var nodeGraph = graphNode;
        for (var s = 0; s < nodeGraph.outEdges.length; s++) {
            var edge = this.diagram.nameTable[nodeGraph.outEdges[s]];
            if (!edge._isCycleEdge) {
                var node = this.diagram.nameTable[edge.targetNode];
                if (this._collectionContains(node.name, this.diagram.nodes()) && node != null && node.visible) {
                    var gnNode;
                    if (!this._dictionaryContains(graph.GraphNodes, node)) {
                        gnNode = this._addGraphNode(node);
                        gnNode.Added = true;
                    }
                    else {
                        gnNode = graph.GraphNodes[node.name];
                    }
                    if (!graphNode._children) {
                        graphNode._children = [];
                    }
                    if (!gnNode._parents) {
                        gnNode._parents = [];
                    }
                    this._setNode(gnNode._parents, graphNode);
                    if (this._findNode(graphNode._children, gnNode.name) < 0) {
                        graphNode._children.push(gnNode);
                    }
                }
            }
        }
    };
    GraphLayoutManager.prototype._getConnectedParents = function (graphNode) {
        var graph = this.selectedNode;
        var nodeGraph = graphNode;
        for (var s = 0; s < nodeGraph.inEdges.length; s++) {
            var edge = this.diagram.nameTable[nodeGraph.inEdges[s]];
            if (!edge._isCycleEdge) {
                var node = this.diagram.nameTable[edge.sourceNode];
                if (this._collectionContains(node.name, this.diagram.nodes()) && node != null && node.visible) {
                    var gnNode;
                    if (!this._dictionaryContains(graph.GraphNodes, node)) {
                        gnNode = this._addGraphNode(node);
                        gnNode.Added = true;
                    }
                    else {
                        gnNode = graph.GraphNodes[node.name];
                    }
                    if (!graphNode._parents) {
                        graphNode._parents = [];
                    }
                    if (!gnNode._children) {
                        gnNode._children = [];
                    }
                    this._setNode(gnNode._children, graphNode);
                    if (this._findNode(graphNode._parents, gnNode.name) < 0) {
                        graphNode._parents.push(gnNode);
                    }
                }
            }
        }
    };
    GraphLayoutManager.prototype._setNode = function (list, node) {
        var nIndex = this._findNode(list, node.name);
        if (nIndex >= 0 && nIndex < list.length) {
            list[nIndex] = node;
        }
        else {
            list.push(node);
        }
    };
    GraphLayoutManager.prototype._findNode = function (list, fullName) {
        var nIndex = -1;
        if (list != null && fullName !== "") {
            for (var i = 0, nLength = list.length; i < nLength; i++) {
                var gnNode = list[i];
                if (typeof (gnNode) === "string" && gnNode === fullName) {
                    nIndex = i;
                    break;
                }
                else if (gnNode != null && gnNode.name === fullName) {
                    nIndex = i;
                    break;
                }
            }
        }
        return nIndex;
    };
    GraphLayoutManager.prototype._addGraphNode = function (node) {
        var graph = this.selectedNode;
        if (!graph.GraphNodes) {
            graph.GraphNodes = {};
        }
        var gnNode = node;
        if (graph != null) {
            graph.GraphNodes[gnNode.name] = gnNode;
            var nodeHelper = this.m_helperSelectedNode;
            if (nodeHelper != null && node.name === nodeHelper.name) {
                this.m_helperSelectedNode = gnNode;
            }
        }
        return gnNode;
    };
    GraphLayoutManager.prototype._isConnectedToAnotherNode = function (gnNode) {
        var bFoundConnectedNode = false;
        var edges = (gnNode.inEdges).concat(gnNode.outEdges);
        if (edges.length > 0) {
            if ((gnNode.inEdges != null) && (gnNode.inEdges.length > 0)) {
                bFoundConnectedNode = this._searchEdgeCollection(gnNode.inEdges, "FromNode");
            }
            if ((!bFoundConnectedNode) && (gnNode.outEdges != null) && (gnNode.outEdges.length > 0)) {
                bFoundConnectedNode = this._searchEdgeCollection(gnNode.outEdges, "ToNode");
            }
        }
        return bFoundConnectedNode;
    };
    GraphLayoutManager.prototype._searchEdgeCollection = function (edgesToSearchThrough, connectionDirection) {
        var bFoundConnectedNode = false;
        for (var i = 0; i < edgesToSearchThrough.length - 1; i++) {
            var edge = this.diagram.nameTable[edgesToSearchThrough[i]];
            if (!this._addNode(edge, "passed")) {
                continue;
            }
            if (!edge._isCycleEdge && ((connectionDirection === "FromNode" && this.diagram.nameTable[edge.sourceNode] != null)
                || (connectionDirection === "ToNode" && this.diagram.nameTable[edge.targetNode] != null))) {
                bFoundConnectedNode = true;
                break;
            }
        }
        return bFoundConnectedNode;
    };
    GraphLayoutManager.prototype._exploreGraphEdge = function (node) {
        var nodeLink = node;
        if (nodeLink != null && !nodeLink._isCycleEdge && this._addNode(node, "passed")) {
            this._addNode(node, "selected");
            var fromNode = this.diagram.nameTable[nodeLink.sourceNode];
            var toNode = this.diagram.nameTable[nodeLink.targetNode];
            if (fromNode != null) {
                this._selectNodes(fromNode);
            }
            else if (toNode != null) {
                this._selectNodes(toNode);
            }
            else {
                this.selectedNode = node;
            }
        }
    };
    GraphLayoutManager.prototype._addNode = function (nodeToAdd, collectionToAdd) {
        var bResult = true;
        var node = nodeToAdd;
        if (collectionToAdd === "passed" || !node.visible) {
            if (!this._dictionaryContains(this.passedNodes, node)) {
                this.passedNodes[node.name] = node;
            }
        }
        if (!node.visible) {
            return false;
        }
        return bResult;
    };
    GraphLayoutManager.prototype._detectCyclesInGraph = function (nodes) {
        var vertex = [];
        var currentStack = [];
        for (var k = 0; k < nodes.length; k++) {
            if (!nodes[k].segments) {
                vertex.push(nodes[k]);
            }
        }
        if (vertex.length > 0) {
            currentStack.push(vertex[0]);
            this.visitedStack.push(vertex[0]);
            while (currentStack.length > 0) {
                var top = currentStack[currentStack.length - 1];
                var childNodes = this._getUnVisitedChildNodes(top);
                if (childNodes.length > 0) {
                    var child = childNodes[0];
                    var currentEdge = childNodes[childNodes.length - 1];
                    if (this._collectionContains(child.name, this.visitedStack)) {
                        currentEdge._isCycleEdge = true;
                        this.cycleEdgesCollection.push(currentEdge);
                    }
                    else {
                        currentStack.push(child);
                        this.visitedStack.splice(0, 0, child);
                    }
                }
                else {
                    currentStack.pop();
                }
            }
        }
    };
    GraphLayoutManager.prototype._getUnVisitedChildNodes = function (top) {
        var childNodes = [];
        if (top.outEdges.length > 0) {
            for (var i = 0; i < top.outEdges.length; i++) {
                var con = this.diagram.nameTable[top.outEdges[i]];
                if (!this._collectionContains(con.name, this.visitedStack)) {
                    var toNode = this.diagram.nameTable[con.targetNode];
                    if (toNode != null) {
                        childNodes.push(toNode);
                    }
                    childNodes.push(con);
                    this.visitedStack.splice(0, 0, con);
                    return childNodes;
                }
            }
            return childNodes;
        }
        return childNodes;
    };
    GraphLayoutManager.prototype._collectionContains = function (name, coll) {
        for (var i = 0; i < coll.length; i++) {
            if (coll[i].name === name) {
                return true;
            }
        }
    };
    return GraphLayoutManager;
}());
;
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ConnectionEnd;
(function (ConnectionEnd) {
    ConnectionEnd[ConnectionEnd["Source"] = 0] = "Source";
    ConnectionEnd[ConnectionEnd["Target"] = 1] = "Target";
})(ConnectionEnd || (ConnectionEnd = {}));
var LoadingPriority;
(function (LoadingPriority) {
    LoadingPriority[LoadingPriority["ImmediateLoading"] = 0] = "ImmediateLoading";
    LoadingPriority[LoadingPriority["DelayedDiagramLoading"] = 1] = "DelayedDiagramLoading";
    LoadingPriority[LoadingPriority["DelayedConnectorLoading"] = 2] = "DelayedConnectorLoading";
})(LoadingPriority || (LoadingPriority = {}));
var RoutingPriority;
(function (RoutingPriority) {
    RoutingPriority[RoutingPriority["Routing"] = 0] = "Routing";
    RoutingPriority[RoutingPriority["Performance"] = 1] = "Performance";
    RoutingPriority[RoutingPriority["Default"] = 2] = "Default";
})(RoutingPriority || (RoutingPriority = {}));
var SegmentOrientation;
(function (SegmentOrientation) {
    SegmentOrientation[SegmentOrientation["Horizontal"] = 0] = "Horizontal";
    SegmentOrientation[SegmentOrientation["Vertical"] = 1] = "Vertical";
})(SegmentOrientation || (SegmentOrientation = {}));
var ObstacleSideType;
(function (ObstacleSideType) {
    ObstacleSideType[ObstacleSideType["Low"] = 0] = "Low";
    ObstacleSideType[ObstacleSideType["High"] = 1] = "High";
})(ObstacleSideType || (ObstacleSideType = {}));
var PortDirection;
(function (PortDirection) {
    PortDirection[PortDirection["None"] = 0] = "None";
    PortDirection[PortDirection["Left"] = 1] = "Left";
    PortDirection[PortDirection["Right"] = 2] = "Right";
    PortDirection[PortDirection["Top"] = 3] = "Top";
    PortDirection[PortDirection["Bottom"] = 4] = "Bottom";
})(PortDirection || (PortDirection = {}));
var Orientation;
(function (Orientation) {
    Orientation[Orientation["None"] = 0] = "None";
    Orientation[Orientation["Horizontal"] = 1] = "Horizontal";
    Orientation[Orientation["Vertical"] = 2] = "Vertical";
})(Orientation || (Orientation = {}));
var ScanDirection;
(function (ScanDirection) {
    ScanDirection[ScanDirection["Right"] = 0] = "Right";
    ScanDirection[ScanDirection["Top"] = 1] = "Top";
})(ScanDirection || (ScanDirection = {}));
var RoutingSolution;
(function (RoutingSolution) {
    RoutingSolution[RoutingSolution["Quick"] = 0] = "Quick";
    RoutingSolution[RoutingSolution["Best"] = 1] = "Best";
})(RoutingSolution || (RoutingSolution = {}));
var Directions;
(function (Directions) {
    Directions[Directions["None"] = 0] = "None";
    Directions[Directions["North"] = 1] = "North";
    Directions[Directions["East"] = 2] = "East";
    Directions[Directions["South"] = 4] = "South";
    Directions[Directions["West"] = 8] = "West";
})(Directions || (Directions = {}));
var Utility = (function () {
    function Utility() {
    }
    Utility.ToRoundedInt = function (value) {
        return Math.round(value);
    };
    Utility.IntersectionWithRectangleBorder = function (rect, point, dir) {
        switch (dir) {
            case Directions.North:
            case Directions.South:
                return new Point(Utility.ToRoundedInt(point.x), this.GetRectangleEdge(rect, dir));
            case Directions.East:
            case Directions.West:
                return new Point(this.GetRectangleEdge(rect, dir), Utility.ToRoundedInt(point.y));
        }
        return new Point();
    };
    Utility.GetRectangleEdge = function (rect, direction) {
        switch (direction) {
            case Directions.East:
                return rect.right();
            case Directions.West:
                return rect.left();
            case Directions.North:
                return rect.bottom();
            case Directions.South:
                return rect.top();
        }
        return 0;
    };
    Utility.GetLengthFromListOfPoints = function (list) {
        var length = 0.0;
        var start = list.get(0);
        for (var k = 0; k < list.size(); k++) {
            var i = list.get(k);
            length += Extensions.FindDistance(start, i, Extensions.GetOrientation(start.FindDirection(i)));
            start = i;
        }
        return Number(length.toFixed(4));
    };
    Utility.GetIntersections = function (line, point) {
        var ret = new PointList();
        var offset = 0.0;
        var par0, par1;
        var x = new Point();
        var polyPoint = point;
        var close = false;
        for (; polyPoint != null && close == false; polyPoint = polyPoint.getNext()) {
            var obj = this.CrossTwoLineSegs(line.StartPoint, line.EndPoint, polyPoint.Point, polyPoint.getNext().Point, 0, 1, 0, 1, par0, par1, x);
            par0 = obj.aSolution;
            par1 = obj.bSolution;
            x = obj.x;
            if (obj.crossToLines) {
                if (!this.OldIntersection(x, ret))
                    ret.add(x);
            }
            offset++;
            if (polyPoint.getNext() == point)
                close = true;
        }
        return ret;
    };
    Utility.OldIntersection = function (point, intersectingPoints) {
        for (var i = 0; i < intersectingPoints.size(); i++) {
            if (point.equals(intersectingPoints.get(i)))
                return true;
        }
        return false;
    };
    Utility.CrossTwoLineSegs = function (aStart, aEnd, bStart, bEnd, amin, amax, bmin, bmax, aSolution, bSolution, x) {
        var u = aEnd.subtract(aStart);
        var v = bStart.subtract(bEnd);
        var w = bStart.subtract(aStart);
        var args = this.Solve(u.x, v.x, w.x, u.y, v.y, w.y, aSolution, bSolution);
        var r = args.solve;
        aSolution = args.x;
        bSolution = args.y;
        var crossToLines = false;
        x = aStart.add(u.multiplyFactor(aSolution));
        if (r) {
            if (aSolution < amin)
                crossToLines = false;
            aSolution = Math.max(aSolution, amin);
            if (aSolution > amax)
                crossToLines = false;
            aSolution = Math.min(aSolution, amax);
            if (bSolution < bmin)
                crossToLines = false;
            bSolution = Math.max(bSolution, bmin);
            if (bSolution > bmax)
                crossToLines = false;
            bSolution = Math.min(bSolution, bmax);
            crossToLines = true;
        }
        return { crossToLines: crossToLines, aSolution: aSolution, bSolution: bSolution, x: x };
    };
    Utility.Solve = function (a00, a01, b0, a10, a11, b1, x, y) {
        var d = a00 * a11 - a10 * a01;
        var solve = true;
        if (Math.abs(d) < 0.00001) {
            x = y = 0;
            return { solve: false, x: x, y: y };
        }
        x = (b0 * a11 - b1 * a01) / d;
        y = (a00 * b1 - a10 * b0) / d;
        return { solve: true, x: x, y: y };
    };
    Utility.CheckWithScanDirection = function (direction, start, end) {
        if (direction == ScanDirection.Right) {
            return start.FindDirection(end) == Directions.East;
        }
        else {
            return start.FindDirection(end) == Directions.North;
        }
    };
    Utility.SegmentIntersects = function (segment1, segment2, intersect) {
        var args = this.IntervalsIntersects(segment1, segment2, intersect);
        return { isInterSect: args.isInterSect, intersect: args.intersect };
    };
    Utility.IntervalsIntersects = function (segment1, segment2, intersect) {
        intersect = this.FindIntersection(segment1.StartPoint, segment1.EndPoint, segment2.StartPoint);
        return { isInterSect: segment1.Contains(intersect) && segment2.Contains(intersect), intersect: intersect };
    };
    Utility.FindIntersection = function (start, end, newPt) {
        var direction = start.FindDirection(end);
        if (Extensions.IsVertical(direction)) {
            return new Point(start.x, newPt.y);
        }
        return new Point(newPt.x, start.y);
    };
    Utility.AreEquivalentLines = function (segment1, segment2) {
        if (segment1.StartPoint.equals(segment2.StartPoint) && segment1.EndPoint.equals(segment2.EndPoint) || segment1.StartPoint.equals(segment2.EndPoint) && segment1.EndPoint.equals(segment2.StartPoint))
            return true;
        return false;
    };
    Utility.ListOrderBy = function (arr, key) {
        return arr.sort(function (a, b) {
            if (a.key > b.key || a[key] < b[key]) {
                return 1;
            }
            if (a[key] < b[key] || a[key] > b[key]) {
                return -1;
            }
            return 0;
        });
    };
    Utility.OrderBy = function (arr, key) {
        return arr.items.sort(function (a, b) {
            if (a._outerBounds[key]() < b._outerBounds[key]()) {
                return -1;
            }
            if (a._outerBounds[key]() > b._outerBounds[key]()) {
                return 1;
            }
            return 0;
        });
    };
    Utility.OrderByDescending = function (arr, key) {
        return arr.items.sort(function (a, b) {
            if (a._outerBounds[key]() > b._outerBounds[key]()) {
                return -1;
            }
            if (a._outerBounds[key]() < b._outerBounds[key]()) {
                return 1;
            }
            return 0;
        });
    };
    Utility.ToList = function (collection) {
        var list = new List();
        var keys = Object.keys(collection);
        keys.sort(function (a, b) { return a - b; });
        for (var i = 0; i < keys.length; i++) {
            list.add(collection[keys[i]]);
        }
        return list;
    };
    return Utility;
}());
var Extensions = (function () {
    function Extensions() {
    }
    Extensions.Left = function (direction) {
        switch (direction) {
            case Directions.None:
                return Directions.None;
            case Directions.North:
                return Directions.West;
            case Directions.East:
                return Directions.North;
            case Directions.South:
                return Directions.East;
            case Directions.West:
                return Directions.South;
            default:
                break;
        }
    };
    Extensions.Right = function (direction) {
        switch (direction) {
            case Directions.None:
                return Directions.None;
            case Directions.North:
                return Directions.East;
            case Directions.East:
                return Directions.South;
            case Directions.South:
                return Directions.West;
            case Directions.West:
                return Directions.North;
            default:
                return Directions.None;
        }
    };
    Extensions.Contains = function (dirs, direction) {
        return (direction & dirs) != 0;
    };
    Extensions.ToIndex = function (direction) {
        switch (direction) {
            case Directions.North:
                return 0;
            case Directions.East:
                return 1;
            case Directions.South:
                return 2;
            case Directions.West:
                return 3;
            default:
                break;
        }
    };
    Extensions.IsAscending = function (direction) {
        if (direction == Directions.South || direction == Directions.West) {
            return false;
        }
        return true;
    };
    Extensions.IsAscending_Direction = function (direction) {
        if (direction == PortDirection.Left || direction == PortDirection.Top) {
            return false;
        }
        return true;
    };
    Extensions.IsVertical = function (direction) {
        if (direction == Directions.East || direction == Directions.West) {
            return false;
        }
        return true;
    };
    Extensions.GetOrientation_PortDirection = function (direction) {
        switch (direction) {
            case PortDirection.Right:
            case PortDirection.Left:
                return Orientation.Horizontal;
            case PortDirection.Top:
            case PortDirection.Bottom:
                return Orientation.Vertical;
        }
        return Orientation.None;
    };
    Extensions.GetOrientation = function (direction) {
        switch (direction) {
            case Directions.East:
            case Directions.West:
                return Orientation.Horizontal;
            case Directions.North:
            case Directions.South:
                return Orientation.Vertical;
        }
        return Orientation.None;
    };
    Extensions.OppositeDirection_Port = function (direction) {
        switch (direction) {
            case PortDirection.Right:
                return PortDirection.Left;
            case PortDirection.Left:
                return PortDirection.Right;
            case PortDirection.Top:
                return PortDirection.Bottom;
            case PortDirection.Bottom:
                return PortDirection.Top;
        }
        return PortDirection.None;
    };
    Extensions.OppositeDirection = function (direction) {
        switch (direction) {
            case Directions.North:
                return Directions.South;
            case Directions.West:
                return Directions.East;
            case Directions.South:
                return Directions.North;
            case Directions.East:
                return Directions.West;
            default:
                return Directions.None;
        }
    };
    Extensions.IsPureDirection = function (direction) {
        switch (direction) {
            case Directions.North:
                return true;
            case Directions.East:
                return true;
            case Directions.South:
                return true;
            case Directions.West:
                return true;
            default:
                return false;
        }
    };
    Extensions.OppositeDirection_Direction = function (direction) {
        switch (direction) {
            case Directions.North:
                return Directions.South;
            case Directions.West:
                return Directions.East;
            case Directions.South:
                return Directions.North;
            case Directions.East:
                return Directions.West;
            default:
                return Directions.None;
        }
    };
    Extensions.OppositeOrientation = function (orientation) {
        if (orientation == Orientation.Horizontal)
            return Orientation.Vertical;
        return Orientation.Horizontal;
    };
    Extensions.ToAngle = function (direction) {
        switch (direction) {
            case Directions.East:
                return 0;
            case Directions.North:
                return 90;
            case Directions.West:
                return 180;
            case Directions.South:
                return 270;
        }
        return 0;
    };
    Extensions.GetEquivalentDirection = function (direction) {
        switch (direction) {
            case PortDirection.Right:
                return Directions.East;
            case PortDirection.Left:
                return Directions.West;
            case PortDirection.Bottom:
                return Directions.North;
            case PortDirection.Top:
                return Directions.South;
        }
        return Directions.None;
    };
    Extensions.FindDirection = function (start, end) {
        var direction = Directions.None;
        var startX = start.x, startY = start.y;
        var endX = end.x, endY = end.y;
        if (startX != endX)
            direction = endX > startX ? Directions.East : Directions.West;
        if (startY != endY)
            direction = endY > startY ? direction | Directions.North : direction | Directions.South;
        return direction;
    };
    Extensions.FindDirection_orientation = function (start, end, orientation) {
        var direction = Directions.None;
        if (orientation == Orientation.Horizontal) {
            var horizontalDiff = end.x - start.x;
            if (horizontalDiff > 0) {
                direction = Directions.East;
            }
            else if (horizontalDiff < 0) {
                direction = Directions.West;
            }
        }
        else {
            var verticalDiff = end.y - start.y;
            if (verticalDiff > 0) {
                direction = direction | Directions.North;
            }
            else if (verticalDiff < 0) {
                direction = direction | Directions.South;
            }
        }
        return direction;
    };
    Extensions.ManhattanDistance = function (source, target) {
        return Math.abs(source.x - target.x) + Math.abs(source.y - target.y);
    };
    Extensions.FindDistance = function (source, target, orientation) {
        if (orientation == Orientation.Horizontal) {
            return Math.abs(source.x - target.x);
        }
        else
            return Math.abs(source.y - target.y);
    };
    Extensions.Transform = function (s, length, direction) {
        var angle = this.ToAngle(direction);
        return new Point(Number(Math.round(s.x + length * Math.cos(angle * Math.PI / 180)).toFixed(4)), Number(Math.round(s.y + length * Math.sin(angle * Math.PI / 180)).toFixed(4)));
    };
    Extensions.VectorDirection = function (d) {
        var epsilon = 0.0001;
        var r = Directions.None;
        if (d.x > epsilon)
            r = Directions.East;
        else if (d.x < -epsilon)
            r = Directions.West;
        if (d.y > epsilon)
            r = r | Directions.North;
        else if (d.y < -epsilon)
            r = r | Directions.South;
        return r;
    };
    Extensions.GetLengthFromListOfPoints = function (list) {
        var length = 0.0;
        var start = list.get(0);
        for (var k = 0; k < list.size(); k++) {
            var i = list.get(Number(k));
            length += Extensions.FindDistance(start, i, Extensions.GetOrientation(Extensions.FindDirection(start, i)));
            start = i;
        }
        return Number(length.toFixed(4));
    };
    Extensions.CompareTo = function (value1, value) {
        if (value1 < value) {
            return -1;
        }
        if (value1 > value) {
            return 1;
        }
        if (value1 != value) {
            if (!isNaN(value1)) {
                return 1;
            }
            if (!isNaN(value)) {
                return -1;
            }
        }
        return 0;
    };
    Extensions.FindDirectionOrientation = function (start, end, orientation) {
        var direction = Directions.None;
        if (orientation == Orientation.Horizontal) {
            var horizontalDiff = end.x - start.x;
            if (horizontalDiff > 0) {
                direction = Directions.East;
            }
            else if (horizontalDiff < 0) {
                direction = Directions.West;
            }
        }
        else {
            var verticalDiff = end.y - start.y;
            if (verticalDiff > 0) {
                direction = direction || Directions.North;
            }
            else if (verticalDiff < 0) {
                direction = direction || Directions.South;
            }
        }
        return direction;
    };
    Extensions.add = function (dictionary, key, object, canSort) {
        var count = Object.keys(dictionary);
        var addObject = { key: key, value: object };
        dictionary[count.length] = addObject;
        if (!canSort && (typeof dictionary[0].key !== "object"))
            this.sortOnKeys(dictionary);
        return dictionary;
    };
    Extensions.sortOnKeys = function (dict) {
        var sorted = [];
        for (var key in dict) {
            sorted[sorted.length] = dict[key].key;
        }
        sorted.sort(function (a, b) {
            return a - b;
        });
        var cloneDic = $.extend(false, {}, dict);
        var keys = Object.keys(dict);
        for (var h = 0; h < keys.length; h++) {
            var key = keys[h];
            if (dict[key])
                delete dict[key];
        }
        ;
        for (var i = 0; i < sorted.length; i++) {
            var list = Object.keys(cloneDic);
            for (var s = 0; s < list.length; s++) {
                var object = cloneDic[list[s]];
                if (object.key == sorted[i]) {
                    Extensions.add(dict, sorted[i], object.value, true);
                }
            }
        }
        return dict;
    };
    Extensions.getFromDictionary123 = function (dictionary, key) {
        var keys = Object.keys(dictionary);
        var index = -1;
        for (var i = 0; i < keys.length; i++) {
            var object = dictionary[keys[i]];
            var keyType1 = typeof object.key;
            if (keyType1 === "object") {
                if (object.key && object.key.x && object.key.y) {
                    if (object.key.x === key.x && object.key.y === key.y)
                        return object.value;
                }
                else if (object.key.name && key.name) {
                    if (object.key.name === key.name)
                        return object.value;
                }
                else {
                }
            }
            else {
            }
        }
        return null;
    };
    Extensions.getFromDictionary = function (dictionary, key, type) {
        var keyType = type ? type : typeof key;
        if (keyType === "number") {
            var list = Object.keys(dictionary);
            for (var i = 0; i < list.length; i++) {
                var object = dictionary[list[i]];
                if (object.key == key)
                    return object.value;
            }
        }
        else {
            return this.getFromDictionary123(dictionary, key);
        }
        return null;
    };
    Extensions.ElementAt = function (object, index) {
        var keys = Object.keys(object);
        var retObject = object[keys[index]];
        if (retObject) {
            if (retObject.value) {
                return object[keys[index]].value;
            }
            else {
                return object[keys[index]];
            }
        }
        return null;
    };
    Extensions.KeytAt = function (object, index) {
        var keys = Object.keys(object);
        var retObject = object[keys[index]];
        if (retObject)
            return object[keys[index]].key;
        return null;
    };
    Extensions.Clear = function (object) {
        object = {};
        return object;
    };
    Extensions.IndexOfKey = function (dictionary, keyObject) {
        var keys = Object.keys(dictionary);
        var index = -1;
        for (var i = 0; i < keys.length; i++) {
            index++;
            var keyType = typeof keyObject;
            if (keyType == "string" || keyType == "number") {
                if (dictionary[keys[i]].key === keyObject) {
                    return index;
                }
            }
            else {
                var object = dictionary[keys[i]];
                var keyType1 = typeof (object.key);
                if (keyType1 === "object") {
                    if (object.key && object.key.x && object.key.y) {
                        if (object.key.x === keyObject.x && object.key.y === keyObject.y)
                            return index;
                    }
                }
            }
        }
        return -1;
    };
    Extensions.Count = function (object) {
        var keys = Object.keys(object);
        return keys.length;
    };
    Extensions.ContainsKey = function (dictionary, key) {
        var keyType = typeof key;
        if (keyType == "string" || keyType == "number") {
            var list = Object.keys(dictionary);
            for (var i = 0; i < list.length; i++) {
                var object = dictionary[list[i]];
                if (object.key == key)
                    return true;
            }
        }
        else if (keyType == "object") {
            if (key && key.x && key.y) {
                var list = Object.keys(dictionary);
                for (var i = 0; i < list.length; i++) {
                    var object = dictionary[list[i]];
                    var keyType1 = typeof (object.key);
                    if (keyType1 == "object") {
                        if (object.key && object.key.x && object.key.y) {
                            if (object.key.x === key.x && object.key.y === key.y)
                                return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    Extensions.ReAlignDictionary = function (dictionary) {
        var keys = Object.keys(dictionary);
        if (keys.length > 0) {
            var keyType = typeof dictionary[keys[0]].key;
            if (keyType == "string" || keyType == "number") {
                var cloneDic = $.extend(false, {}, dictionary);
                for (var h = 0; h < keys.length; h++) {
                    var key = keys[h];
                    if (dictionary[key])
                        delete dictionary[key];
                }
                ;
                var clKeys = Object.keys(cloneDic);
                for (var j = 0; j < clKeys.length; j++) {
                    Extensions.add(dictionary, cloneDic[clKeys[j]].key, cloneDic[clKeys[j]].value, true);
                }
            }
        }
        return dictionary;
    };
    Extensions.Remove = function (dictionary, key, index) {
        if (index != undefined) {
            if (dictionary[index]) {
                delete dictionary[index];
                this.ReAlignDictionary(dictionary);
                return true;
            }
        }
        else {
            var list = Object.keys(dictionary);
            for (var i = 0; i < list.length; i++) {
                var object = dictionary[list[i]];
                var keyType = typeof key;
                if (keyType == "string" || keyType == "number") {
                    if (object.key == key) {
                        delete dictionary[list[i]];
                        this.ReAlignDictionary(dictionary);
                        return true;
                    }
                }
                else {
                    if (key && key.x && key.y) {
                        var list = Object.keys(dictionary);
                        for (var i = 0; i < list.length; i++) {
                            var object = dictionary[list[i]];
                            var keyType1 = typeof object.key;
                            if (keyType1 == "object") {
                                if (object.key && object.key.x && object.key.y) {
                                    if (object.key.x === key.x && object.key.y === key.y) {
                                        delete dictionary[list[i]];
                                        dictionary[list[i]];
                                        this.ReAlignDictionary(dictionary);
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    };
    return Extensions;
}());
var Point = (function () {
    function Point(x, y) {
        this.x = 0;
        this.y = 0;
        this.x = x ? x : 0;
        this.y = y ? y : 0;
    }
    Point.equals = function (point1, point2) {
        if (point1 === point2) {
            return true;
        }
        if (!point1 || !point2) {
            return false;
        }
        return !point1 || !point2 || point1.x === point2.x && point1.y === point2.y;
    };
    Point.prototype.equals = function (point1) {
        if (point1 === this) {
            return true;
        }
        if (!point1 || !this) {
            return false;
        }
        return !point1 || !this || point1.x === this.x && point1.y === this.y;
    };
    Point.prototype.OperatorNotEqual = function (point2) {
        var point1 = this;
        return point1.CompareTo(point2) != 0;
    };
    Point.prototype.subtract = function (point1) {
        return new Point(this.x - point1.x, this.y - point1.y);
    };
    Point.prototype.add = function (point1) {
        return new Point(this.x + point1.x, this.y + point1.y);
    };
    Point.prototype.multiplyFactor = function (factor) {
        return new Point(this.x * factor, this.y * factor);
    };
    Point.prototype.distance = function (point2) {
        return Math.sqrt(Math.pow(this.x - point2.x, 2) + Math.pow(this.y - point2.y, 2));
    };
    Point.transform = function (point, angle, length) {
        var pt = { x: 0, y: 0 };
        pt.x = Number((((point.x + length * Math.cos(angle * Math.PI / 180)) * 100) / 100).toFixed(4));
        pt.y = Number((((point.y + length * Math.sin(angle * Math.PI / 180)) * 100) / 100).toFixed(4));
        return pt;
    };
    Point.findLength = function (s, e) {
        var length = Math.sqrt(Math.pow((s.x - e.x), 2) + Math.pow((s.y - e.y), 2));
        return Number(length.toFixed(4));
    };
    Point.findAngle = function (point1, point2) {
        var angle = Math.atan2(point2.y - point1.y, point2.x - point1.x);
        angle = (180 * angle / Math.PI);
        angle %= 360;
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    };
    Point.distancePoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    };
    Point.prototype.OperatorLessThan = function (point2) {
        var point1 = this;
        return point1.CompareTo(point2) < 0;
    };
    Point.prototype.OperatorGreaterThan = function (point2) {
        var point1 = this;
        return point1.CompareTo(point2) > 0;
    };
    Point.prototype.CompareTo = function (point) {
        var result = this.CompareTo_Number(this.x, point.x);
        return result != 0 ? result : this.CompareTo_Number(this.y, point.y);
    };
    Point.prototype.CompareTo_Number = function (number1, value) {
        if (number1 < value) {
            return -1;
        }
        if (number1 > value) {
            return 1;
        }
        if (number1 != value) {
            if (!isNaN(number1)) {
                return 1;
            }
            if (!isNaN(value)) {
                return -1;
            }
        }
        return 0;
    };
    Point.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    };
    Point.prototype.FindDirection = function (end) {
        var direction = Directions.None;
        var startX = this.x, startY = this.y;
        var endX = end.x, endY = end.y;
        if (startX != endX)
            direction = endX > startX ? Directions.East : Directions.West;
        if (startY != endY)
            direction = endY > startY ? direction | Directions.North : direction | Directions.South;
        return direction;
    };
    Point.prototype.ManhattanDistance = function (target) {
        return Math.abs(this.x - target.x) + Math.abs(this.y - target.y);
    };
    return Point;
}());
var List = (function () {
    function List() {
        this._size = 0;
        this.items = [];
    }
    List.prototype.List = function (collection) {
        for (var i = 0; i < collection.size(); i++) {
            this.items.push(collection.get(i));
        }
    };
    List.prototype.size = function () {
        return this.items.length;
    };
    List.prototype.sortByKey = function (key) {
        return this.items.sort(function (a, b) {
            var x = a[key];
            var y = b[key];
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        });
    };
    List.prototype.Concat = function (collection) {
        var list = new List();
        for (var i = 0; i < this.items.length; i++) {
            list.add(this.items[i]);
        }
        for (var i = 0; i < collection.size(); i++) {
            list.add(collection.get(i));
        }
        return list;
    };
    List.prototype.GetRange = function (index, count) {
        var list = new List();
        for (var i = index; i < index + count; i++) {
            list.add(this.items[i]);
        }
        return list;
    };
    List.prototype.AddRange = function (collection) {
        for (var i = 0; i < collection.size(); i++) {
            this.items.push(collection.get(i));
        }
    };
    List.prototype.Insert = function (index, value) {
        if (index === void 0) { index = this.size() + 1; }
        this.items.splice(index, 0, value);
        this._size++;
    };
    List.prototype.add = function (value) {
        this.items.push(value);
        this._size++;
    };
    List.prototype.get = function (index) {
        return this.items[Number(index)];
    };
    List.prototype.Remove = function (item) {
        var index = this.IndexOf(item);
        if (index >= 0) {
            this.RemoveAt(index);
            return true;
        }
        return false;
    };
    List.prototype.RemoveAt = function (index) {
        if (index >= this._size) {
        }
        this._size--;
        this.items.splice(index, 1);
    };
    List.prototype.Last = function () {
        return this.items[this.size() - 1];
    };
    List.prototype.IndexOf = function (value) {
        return this.items.indexOf(value);
    };
    List.prototype.Clear = function () {
        while (this.items.length > 0) {
            this.items.pop();
            this._size = 0;
        }
    };
    List.prototype.ElementAt = function (index) {
        return this.items[index];
    };
    List.prototype.UpdateListValue = function (index, newValue) {
        if (newValue && newValue) {
            this.items[index] = newValue;
            return true;
        }
        return false;
    };
    List.prototype.contains = function (item) {
        if (item == null) {
            for (var j = 0; j < this._size; j++) {
                if (this.items[j] == null) {
                    return true;
                }
            }
            return false;
        }
        for (var j = 0; j < this._size; j++) {
            if (this.items[j] == item) {
                return true;
            }
        }
    };
    return List;
}());
var PointList = (function () {
    function PointList() {
        this._size = 0;
        this.items = [];
    }
    PointList.prototype.PointList = function (collection) {
        for (var i = 0; i < collection.length; i++) {
            this.items.push(collection[i]);
        }
        return this;
    };
    PointList.prototype.size = function () {
        return this.items.length;
    };
    PointList.prototype.Insert = function (index, value) {
        if (index === void 0) { index = this.size() + 1; }
        this.items.splice(index, 0, value);
        this._size++;
    };
    PointList.prototype.AddRange = function (collection) {
        for (var i = 0; i < collection.size(); i++) {
            this.items.push(collection.get(i));
        }
    };
    PointList.prototype.Concat = function (collection) {
        var list = new PointList();
        for (var i = 0; i < this.items.length; i++) {
            list.add(this.items[i]);
        }
        for (var i = 0; i < collection.size(); i++) {
            list.add(collection.get(i));
        }
        return list;
    };
    PointList.prototype.add = function (value) {
        this.items.push(value);
        this._size++;
    };
    PointList.prototype.get = function (index) {
        return this.items[index];
    };
    PointList.prototype.RemoveAt = function (index) {
        if (index >= this._size) {
        }
        this._size--;
        this.items.splice(index, 1);
    };
    PointList.prototype.Last = function () {
        return this.items[this.size() - 1];
    };
    PointList.prototype.IndexOf = function (value) {
        return this.items.indexOf(value);
    };
    PointList.prototype.Clear = function () {
        while (this.items.length > 0) {
            this.items.pop();
        }
    };
    PointList.prototype.ElementAt = function (index) {
        return this.items[index];
    };
    PointList.prototype.contains = function (item) {
        if (item == null) {
            for (var j = 0; j < this._size; j++) {
                if (this.items[j] == null) {
                    return true;
                }
            }
            return false;
        }
        for (var j = 0; j < this._size; j++) {
            if (this.items[j] == item) {
                return true;
            }
        }
    };
    return PointList;
}());
var Rect = (function () {
    function Rect(x, y, width, height) {
        this.x = Number.MAX_VALUE;
        this.y = Number.MAX_VALUE;
        this.width = 0;
        this.height = 0;
        if (x === undefined || y === undefined) {
            x = y = Number.MAX_VALUE;
            width = height = 0;
        }
        else {
            if (width === undefined) {
                width = 0;
            }
            if (height === undefined) {
                height = 0;
            }
        }
        this.x = x !== undefined ? x : Number.MAX_VALUE;
        this.y = y !== undefined ? y : Number.MAX_VALUE;
        this.width = width !== undefined ? width : 0;
        this.height = height !== undefined ? height : 0;
    }
    Rect.prototype.Rect = function (start, end) {
        this.x = Math.min(start.x, end.x);
        this.y = Math.min(start.y, end.y);
        this.width = Number(Math.max(start.x, end.x)) - Number(this.x);
        this.height = Number(Math.max(start.y, end.y)) - Number(this.y);
        return this;
    };
    Rect.Rect = function (start, end) {
        return this.Rect(start, end);
    };
    Rect.prototype.left = function () {
        return this.x;
    };
    Rect.prototype.right = function () {
        return this.x + this.width;
    };
    Rect.prototype.top = function () {
        return this.y;
    };
    Rect.prototype.bottom = function () {
        return Number((this.y + this.height).toFixed(4));
    };
    Rect.prototype.topLeft = function () {
        return new Point(this.left(), this.top());
    };
    Rect.prototype.topRight = function () {
        return new Point(this.right(), this.top());
    };
    Rect.prototype.bottomLeft = function () {
        return new Point(this.left(), this.bottom());
    };
    Rect.prototype.bottomRight = function () {
        return new Point(this.right(), this.bottom());
    };
    Rect.prototype.middleLeft = function () {
        return new Point(this.left(), this.y + this.height / 2);
    };
    Rect.prototype.middleRight = function () {
        return new Point(this.right(), this.y + this.height / 2);
    };
    Rect.prototype.topCenter = function () {
        return new Point(this.x + this.width / 2, this.top());
    };
    Rect.prototype.bottomCenter = function () {
        return new Point(this.x + this.width / 2, this.bottom());
    };
    Rect.prototype.center = function () {
        return new Point(this.x + this.width / 2, this.y + this.height / 2);
    };
    Rect.prototype.equals = function (rect1, rect2) {
        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
    };
    Rect.prototype.uniteRect = function (rect) {
        var right = Math.max(Number.NaN === this.right() || this.x === Number.MAX_VALUE ? rect.right() : this.right(), rect.right());
        var bottom = Math.max(Number.NaN === this.bottom() || this.y === Number.MAX_VALUE ? rect.bottom() : this.bottom(), rect.bottom());
        this.x = Math.min(this.left(), rect.left());
        this.y = Math.min(this.top(), rect.top());
        this.width = right - this.x;
        this.height = bottom - this.y;
        return this;
    };
    Rect.prototype.unitePoint = function (point) {
        if (this.x === Number.MAX_VALUE) {
            this.x = point.x;
            this.y = point.y;
            return;
        }
        var x = Math.min(this.left(), point.x);
        var y = Math.min(this.top(), point.y);
        var right = Math.max(this.right(), point.x);
        var bottom = Math.max(this.bottom(), point.y);
        this.x = x;
        this.y = y;
        this.width = right - this.x;
        this.height = bottom - this.y;
    };
    Rect.prototype.Inflate = function (padding) {
        this.x -= padding;
        this.y -= padding;
        this.width += padding * 2;
        this.height += padding * 2;
        return this;
    };
    Rect.prototype.intersects = function (rect) {
        if (this.right() < rect.left() || this.left() > rect.right() || this.top() > rect.bottom() || this.bottom() < rect.top()) {
            return false;
        }
        return true;
    };
    Rect.prototype.containsRect = function (rect) {
        return this.left() <= rect.left() && this.right >= rect.right && this.top() <= rect.top() && this.bottom >= rect.bottom;
    };
    Rect.prototype.containsPoint = function (point) {
        return this.left() <= point.x && this.right() >= point.x && this.top() <= point.y && this.bottom() >= point.y;
    };
    Rect.toBounds = function (pts) {
        var rect = new Rect();
        for (var _i = 0, pts_1 = pts; _i < pts_1.length; _i++) {
            var pt = pts_1[_i];
            rect.unitePoint(pt);
        }
        return rect;
    };
    Rect.prototype.round = function () {
        this.x = Math.round(this.x);
        this.width = Math.round(this.width);
        this.y = Math.round(this.y);
        this.height = Math.round(this.height);
        return this;
    };
    Rect.empty = new Rect(Number.MAX_VALUE, Number.MIN_VALUE, 0, 0);
    return Rect;
}());
var Stack = (function () {
    function Stack() {
        this.items = [];
    }
    Stack.prototype.Push = function (item) {
        this.items.push(item);
    };
    Stack.prototype.Pop = function () {
        return this.items.pop();
    };
    Stack.prototype.Peek = function () {
        return this.items[this.items.length - 1];
    };
    Stack.prototype.Clear = function () {
        this.items = [];
    };
    Stack.prototype.Count = function () {
        return this.items.length;
    };
    Stack.prototype.get = function (index) {
        return this.items[Number(index)];
    };
    return Stack;
}());
var Dictionary = (function () {
    function Dictionary() {
        this.keys = [];
        this.items = {};
        this.count = 0;
    }
    Dictionary.prototype.Items = function () {
        return this.items;
    };
    Dictionary.prototype.Dictionary = function (items, count, keys) {
        var ss = new Dictionary();
        ss.items = $.extend(false, {}, items);
        ss.count = count;
        ss.keys = keys;
        return ss;
    };
    Dictionary.prototype.Add = function (item, key) {
        if (key != undefined && item != undefined) {
            var obj = { key: key, value: item };
            this.items[this.count] = obj;
            this.keys.push(key);
            this.count++;
        }
    };
    Dictionary.prototype.Remove = function (key) {
        if (this.ContainsKey(key)) {
            var index = this.IndexOfKey(key);
            delete this.items[index];
            this.keys.splice(index, 1);
            this.count--;
            this.updateDic();
        }
    };
    Dictionary.prototype.updateDic = function () {
        var tempDict = {};
        var tempKeys = Object.keys(this.items);
        for (var i = 0; i < this.count; i++) {
            tempDict[i] = this.items[tempKeys[i]];
        }
        this.items = tempDict;
    };
    Dictionary.prototype.Update = function (key, value) {
        if (this.ContainsKey(key)) {
            var index = this.IndexOfKey(key);
            this.items[index].value = value;
        }
    };
    Dictionary.prototype.Clear = function () {
        this.items = {};
        this.count = 0;
        this.keys = [];
    };
    Dictionary.prototype.ContainsKey = function (key) {
        var index = this.keys.indexOf(key);
        if (index == -1)
            return false;
        else
            return true;
    };
    Dictionary.prototype.GetValue = function (key) {
        if (key != undefined && this.ContainsKey(key)) {
            var index = this.IndexOfKey(key);
            if (index != -1)
                return this.items[index].value;
        }
        return null;
    };
    Dictionary.prototype.IndexOfKey = function (key) {
        return this.keys.indexOf(key);
    };
    Dictionary.prototype.ElementAt = function (index) {
        if (index < this.keys.length)
            this.items[index].value;
        return null;
    };
    Dictionary.prototype.KeyAt = function (index) {
        return this.keys[index];
    };
    Dictionary.prototype.GetLength = function () {
        return this.keys.length;
    };
    Dictionary.prototype.Count = function () {
        return this.keys.length;
    };
    Dictionary.prototype.Clone = function () {
        return this.Dictionary(this.items, this.count, this.keys);
    };
    return Dictionary;
}());
var SortedList = (function () {
    function SortedList() {
        this.keys = [];
        this.items = {};
        this.count = 0;
    }
    SortedList.prototype.Items = function () {
        return this.items;
    };
    SortedList.prototype.SortedList = function (items, count, keys) {
        var ss = new SortedList();
        ss.items = $.extend(false, {}, items);
        ss.count = count;
        ss.keys = keys;
        return ss;
    };
    SortedList.prototype.Add = function (item, key) {
        if (key != undefined && item != undefined) {
            var obj = { key: key, value: item };
            this.items[key] = obj;
            this.keys = Object.keys(this.items);
            this.keys.sort(function (a, b) { return a - b; });
            this.count++;
        }
    };
    SortedList.prototype.Remove = function (key) {
        if (this.ContainsKey(key)) {
            delete this.items[key];
            this.keys = Object.keys(this.items);
            this.keys.sort(function (a, b) { return a - b; });
            this.count--;
        }
    };
    SortedList.prototype.Update = function (key, value) {
        if (this.ContainsKey(key)) {
            this.items[key].value = value;
        }
    };
    SortedList.prototype.Clear = function () {
        this.items = {};
        this.count = 0;
        this.keys = [];
    };
    SortedList.prototype.sortOnKeys = function () {
        var sorted = [];
        for (var key in this.items) {
            sorted[sorted.length] = key;
        }
        sorted.sort(function (a, b) { return a - b; });
        var tempDict = {};
        for (var i = 0; i < sorted.length; i++) {
            tempDict[sorted[i]] = this.items[sorted[i]];
        }
        this.items = tempDict;
    };
    SortedList.prototype.ContainsKey = function (key) {
        if (this.items.hasOwnProperty(key)) {
            return true;
        }
    };
    SortedList.prototype.GetValue = function (key) {
        if (key != undefined && this.items.hasOwnProperty(key)) {
            return this.items[key].value;
        }
    };
    SortedList.prototype.IndexOfKey = function (key) {
        var i = 0;
        this.keys.indexOf(key);
        for (var tempkey in this.keys) {
            if (this.keys[tempkey] == key) {
                return i;
            }
            i++;
        }
        return -1;
    };
    SortedList.prototype.ElementAt = function (index) {
        var i = 0;
        for (var tempkey in this.items) {
            if (i === index || index === tempkey) {
                return this.items[tempkey].value;
            }
            i++;
        }
        return null;
    };
    SortedList.prototype.KeyAt = function (index) {
        return Number(this.keys[index]);
    };
    SortedList.prototype.GetLength = function () {
        return this.keys.length;
    };
    SortedList.prototype.Count = function () {
        return this.keys.length;
    };
    SortedList.prototype.Clone = function () {
        return this.SortedList(this.items, this.count, this.keys);
    };
    return SortedList;
}());
var Tuple = (function () {
    function Tuple(item1, item2) {
        this._mT1 = item1;
        this._mT2 = item2;
    }
    Tuple.prototype.Item11 = function () {
        return this._mT1;
    };
    Tuple.prototype.Item2 = function () {
        return this._mT2;
    };
    return Tuple;
}());
var PolylinePoint = (function () {
    function PolylinePoint(point) {
        this.Point = point;
    }
    PolylinePoint.prototype.getPrev = function () {
        return this._mPrev;
    };
    PolylinePoint.prototype.setPrev = function (value) {
        this._mPrev = value;
    };
    PolylinePoint.prototype.getNext = function () {
        return this._mNext;
    };
    PolylinePoint.prototype.setNext = function (value) {
        this._mNext = value;
    };
    return PolylinePoint;
}());
var Segment = (function () {
    function Segment(start, end) {
        this.StartPoint = start;
        this.EndPoint = end;
    }
    Segment.prototype.Bounds = function () {
        return new Rect().Rect(this.StartPoint, this.EndPoint);
    };
    Segment.prototype.Contains = function (point) {
        var direction = this.StartPoint.FindDirection(this.EndPoint);
        switch (direction) {
            case Directions.East:
                return this.StartPoint.x <= point.x && point.x <= this.EndPoint.x;
            case Directions.West:
                return this.StartPoint.x >= point.x && point.x >= this.EndPoint.x;
            case Directions.North:
                return this.StartPoint.y <= point.y && point.y <= this.EndPoint.y;
            case Directions.South:
                return this.StartPoint.y >= point.y && point.y >= this.EndPoint.y;
        }
        return false;
    };
    return Segment;
}());
var SharedData = (function () {
    function SharedData() {
    }
    return SharedData;
}());
var ICoreGroupableInfo = (function () {
    function ICoreGroupableInfo() {
    }
    return ICoreGroupableInfo;
}());
var IObstacle = (function (_super) {
    __extends(IObstacle, _super);
    function IObstacle() {
        _super.apply(this, arguments);
    }
    return IObstacle;
}(ICoreGroupableInfo));
var SpatialSearching = (function () {
    function SpatialSearching() {
        this._pageLeft = 0;
        this._pageRight = 0;
        this._pageTop = 0;
        this._pageBottom = 0;
        this.childLeft = 0;
        this.childTop = 0;
        this.childRight = 0;
        this.childBottom = 0;
    }
    SpatialSearching.quadSize = 500;
    return SpatialSearching;
}());
var ObstacleTree = (function () {
    function ObstacleTree() {
        this.Rectangle = new Rect();
        this.ObstaclePadding = 0;
        this.startNode = null;
        this.endNode = null;
        this.lookupSegment = null;
        this.canRoute = true;
        this.hit = null;
    }
    ObstacleTree.prototype.InitObstacles = function (obstacles, padding, spatialSearch) {
        this.spatialSearch = spatialSearch;
        this.ObstaclePadding = padding;
        var i = 0;
        var obj;
        for (var m = 0; m < obstacles.size(); m++) {
            obj = obstacles.get(i);
            obj._obstacle = new Obstacle()._obstacle(obj._outerBounds, padding);
            if (m == 0) {
                this.Rectangle = obj._obstacle.getPaddedBounds();
            }
            else {
                this.Rectangle = this.Rectangle.uniteRect(obj._obstacle.getPaddedBounds());
            }
            obj._obstacle.CenterPort = new CenterPort(obj._obstacle.getPaddedBounds().center());
            i++;
        }
    };
    ObstacleTree.prototype.DisposeObstacles = function (obstacles) {
        for (var i in obstacles) {
            var obj = obstacles.get(i);
            if (obj._obstacle != null) {
                obj._obstacle = null;
            }
        }
        this.spatialSearch = null;
    };
    ObstacleTree.prototype.RestrictSegmentWithinFreeSpace = function (edge, segment, node, end) {
        if (end === void 0) { end = null; }
        return this.FindMaximumVisibility(segment, node, end);
    };
    ObstacleTree.prototype.FindNodesWhere = function (nodes, bounds) {
        var node;
        var newList = new List();
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[i];
            if (node && node._obstacle != null) {
                var paddedBounds = node._obstacle.getPaddedBounds ? node._obstacle.getPaddedBounds() : null;
                if (paddedBounds != null && paddedBounds.intersects(bounds)) {
                    newList.add(node);
                }
            }
        }
        return newList;
    };
    ObstacleTree.prototype.FindNodes = function (bounds) {
        var nodes = new List();
        var quadObjects = new List();
        var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(this.spatialSearch, bounds);
        for (var i = 0; i < quads.length; i++) {
            var quad = quads[i];
            if (quad.objects.length > 0) {
                quadObjects = this.FindNodesWhere(quad.objects, bounds);
            }
            nodes = nodes.Concat(quadObjects);
        }
        return nodes;
    };
    ObstacleTree.prototype.FindMaximumVisibility = function (segment, start, end) {
        if (end === void 0) { end = null; }
        var hit;
        this.canRoute = true;
        var args = this.FindMaximumVisibility_hitNode(segment, start, end, hit);
        hit = args.hitNode;
        return args.canRoute;
    };
    ObstacleTree.prototype.FindMaximumVisibility_hitNode = function (segment, node, end, hitNode, ignoreLookup) {
        if (ignoreLookup === void 0) { ignoreLookup = false; }
        hitNode = null;
        if (!ignoreLookup) {
            this.lookupSegment = segment;
        }
        this.startNode = node;
        this.endNode = end;
        var direction = Extensions.FindDirection(segment.StartPoint, segment.EndPoint);
        if (direction != Directions.None) {
            var hit = this.FindFirstHit(this.spatialSearch.parentQuad, direction, segment.Bounds());
            if (hit != null && hit) {
                hitNode = hit;
                this.GetSegmentEnd(segment, direction, hit._obstacle);
            }
        }
        this.startNode = null;
        this.lookupSegment = null;
        return { canRoute: this.canRoute, hitNode: hitNode };
    };
    ObstacleTree.prototype.GetSegmentEnd = function (segment, direction, obstacle) {
        var endPoint = segment.EndPoint;
        if (obstacle != null) {
            switch (direction) {
                case Directions.East:
                    endPoint = new Point(obstacle.getPaddedBounds().left(), endPoint.y);
                    break;
                case Directions.West:
                    endPoint = new Point(obstacle.getPaddedBounds().right(), endPoint.y);
                    break;
                case Directions.North:
                    endPoint = new Point(endPoint.x, obstacle.getPaddedBounds().top());
                    break;
                case Directions.South:
                    endPoint = new Point(endPoint.x, obstacle.getPaddedBounds().bottom());
                    break;
            }
        }
        segment.EndPoint = endPoint.round();
    };
    ObstacleTree.prototype.FindFirstHit = function (quad, direction, rect) {
        var nodes = null;
        var quadToSearch = quad;
        switch (direction) {
            case Directions.East:
                nodes = this.FindIntersectingObjectsAtRight(quadToSearch, rect);
                break;
            case Directions.West:
                nodes = this.FindIntersectingObjectsAtLeft(quadToSearch, rect);
                break;
            case Directions.North:
                nodes = this.FindIntersectingObjectsAtBottom(quadToSearch, rect);
                break;
            case Directions.South:
                nodes = this.FindIntersectingObjectsAtTop(quadToSearch, rect);
                break;
        }
        if (nodes != null && nodes.size() > 0) {
            return this.FirstHitNode(nodes, direction);
        }
        return null;
    };
    ObstacleTree.prototype.FirstHitNode = function (nodes, direction) {
        var sortedCollection = null;
        switch (direction) {
            case Directions.East:
                sortedCollection = Utility.OrderBy(nodes, "left");
                break;
            case Directions.West:
                sortedCollection = Utility.OrderByDescending(nodes, "right");
                break;
            case Directions.South:
                sortedCollection = Utility.OrderByDescending(nodes, "bottom");
                break;
            case Directions.North:
                sortedCollection = Utility.OrderBy(nodes, "top");
                break;
        }
        return Extensions.ElementAt(sortedCollection, 0);
    };
    ObstacleTree.prototype.FindIntersectingObjectsAtRight = function (quad, rect, objects) {
        if (objects === void 0) { objects = null; }
        var count = objects != null ? objects.size() : 0;
        var foundAtFirstHalf = false;
        if (quad.first != null) {
            if (this.IsIntersects(quad.first, rect)) {
                objects = this.FindIntersectingObjectsAtRight(quad.first, rect, objects);
            }
        }
        if (quad.third != null) {
            if (this.IsIntersects(quad.third, rect)) {
                objects = this.FindIntersectingObjectsAtRight(quad.third, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0 && count != objects.size()) {
            foundAtFirstHalf = true;
        }
        objects = this.GetIntersectingNodesInaQuad(quad, rect, objects);
        if (objects != null && objects.size() > 0) {
            if (foundAtFirstHalf) {
                return objects;
            }
            else {
                if (this.CheckForObjectsOnCenterline(quad, objects, Directions.East))
                    return objects;
            }
        }
        if (quad.second != null) {
            if (this.IsIntersects(quad.second, rect)) {
                objects = this.FindIntersectingObjectsAtRight(quad.second, rect, objects);
            }
        }
        if (quad.fourth != null) {
            if (this.IsIntersects(quad.fourth, rect)) {
                objects = this.FindIntersectingObjectsAtRight(quad.fourth, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0) {
            return objects;
        }
        return null;
    };
    ObstacleTree.prototype.FindIntersectingObjectsAtLeft = function (quad, rect, objects) {
        if (objects === void 0) { objects = null; }
        var foundAtFirstHalf = false;
        var count = objects != null ? objects.size() : 0;
        if (quad.second != null) {
            if (this.IsIntersects(quad.second, rect)) {
                objects = this.FindIntersectingObjectsAtLeft(quad.second, rect, objects);
            }
        }
        if (quad.fourth != null) {
            if (this.IsIntersects(quad.fourth, rect)) {
                objects = this.FindIntersectingObjectsAtLeft(quad.fourth, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0 && count != objects.size()) {
            foundAtFirstHalf = true;
        }
        objects = this.GetIntersectingNodesInaQuad(quad, rect, objects);
        if (objects != null && objects.size() > 0) {
            if (foundAtFirstHalf) {
                return objects;
            }
            else {
                if (this.CheckForObjectsOnCenterline(quad, objects, Directions.West))
                    return objects;
            }
        }
        if (quad.first != null) {
            if (this.IsIntersects(quad.first, rect)) {
                objects = this.FindIntersectingObjectsAtLeft(quad.first, rect, objects);
            }
        }
        if (quad.third != null) {
            if (this.IsIntersects(quad.third, rect)) {
                objects = this.FindIntersectingObjectsAtLeft(quad.third, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0) {
            return objects;
        }
        return null;
    };
    ObstacleTree.prototype.FindIntersectingObjectsAtBottom = function (quad, rect, objects) {
        if (objects === void 0) { objects = null; }
        var foundAtFirstHalf = false;
        var count = objects != null ? objects.size() : 0;
        if (quad.first != null) {
            if (this.IsIntersects(quad.first, rect)) {
                objects = this.FindIntersectingObjectsAtBottom(quad.first, rect, objects);
            }
        }
        if (quad.second != null) {
            if (this.IsIntersects(quad.second, rect)) {
                objects = this.FindIntersectingObjectsAtBottom(quad.second, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0 && count != objects.size()) {
            foundAtFirstHalf = true;
        }
        objects = this.GetIntersectingNodesInaQuad(quad, rect, objects);
        if (objects != null && objects.size() > 0) {
            if (foundAtFirstHalf) {
                return objects;
            }
            else {
                if (this.CheckForObjectsOnCenterline(quad, objects, Directions.North)) {
                    return objects;
                }
            }
        }
        if (quad.third != null) {
            if (this.IsIntersects(quad.third, rect)) {
                objects = this.FindIntersectingObjectsAtBottom(quad.third, rect, objects);
            }
        }
        if (quad.fourth != null) {
            if (this.IsIntersects(quad.fourth, rect)) {
                objects = this.FindIntersectingObjectsAtBottom(quad.fourth, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0) {
            return objects;
        }
        return null;
    };
    ObstacleTree.prototype.FindIntersectingObjectsAtTop = function (quad, rect, objects) {
        if (objects === void 0) { objects = null; }
        var count = objects != null ? objects.size() : 0;
        var foundAtFirstHalf = false;
        if (quad.third != null) {
            if (this.IsIntersects(quad.third, rect)) {
                objects = this.FindIntersectingObjectsAtTop(quad.third, rect, objects);
            }
        }
        if (quad.fourth != null) {
            if (this.IsIntersects(quad.fourth, rect)) {
                objects = this.FindIntersectingObjectsAtTop(quad.fourth, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0) {
            foundAtFirstHalf = true;
        }
        objects = this.GetIntersectingNodesInaQuad(quad, rect, objects);
        if (objects != null && objects.size() > 0 && count != objects.size()) {
            if (foundAtFirstHalf) {
                return objects;
            }
            else {
                if (this.CheckForObjectsOnCenterline(quad, objects, Directions.South)) {
                    return objects;
                }
            }
        }
        if (quad.first != null) {
            if (this.IsIntersects(quad.first, rect)) {
                objects = this.FindIntersectingObjectsAtTop(quad.first, rect, objects);
            }
        }
        if (quad.second != null) {
            if (this.IsIntersects(quad.second, rect)) {
                objects = this.FindIntersectingObjectsAtTop(quad.second, rect, objects);
            }
        }
        if (objects != null && objects.size() > 0) {
            return objects;
        }
        return null;
    };
    ObstacleTree.prototype.CheckForObjectsOnCenterline = function (quad, objects, direction) {
        if (direction == Directions.North) {
            var centerY = quad.top + quad.height / 2;
            for (var i = 0; i < objects.size(); i++) {
                var obj = objects.get(i);
                if (obj) {
                    var jsBounds = ej.datavisualization.Diagram.Util.bounds(obj);
                    var nBounds = new Rect(jsBounds.left, jsBounds.top, jsBounds.right - jsBounds.left, jsBounds.bottom - jsBounds.top);
                    if (obj._obstacle) {
                        obj._obstacle._outerBounds = nBounds;
                    }
                    else {
                        obj._obstacle = { OuterBounds: nBounds };
                    }
                }
                if (objects.get(i)._obstacle._outerBounds.top() <= centerY) {
                    return true;
                }
            }
        }
        else if (direction == Directions.South) {
            var centerY = quad.top + quad.height / 2;
            for (var i = 0; i < objects.size(); i++) {
                obj = objects.get(i);
                if (obj) {
                    var jsBounds = ej.datavisualization.Diagram.Util.bounds(obj);
                    var nBounds = new Rect(jsBounds.left, jsBounds.top, jsBounds.right - jsBounds.left, jsBounds.bottom - jsBounds.top);
                    if (obj._obstacle) {
                        obj._obstacle._outerBounds = nBounds;
                    }
                    else {
                        obj._obstacle = { OuterBounds: nBounds };
                    }
                }
                if (objects.get(i)._obstacle._outerBounds.bottom >= centerY) {
                    return true;
                }
            }
        }
        else if (direction == Directions.East) {
            var centerX = quad.left + quad.width / 2;
            for (var i = 0; i < objects.size(); i++) {
                obj = objects.get(i);
                if (obj) {
                    var jsBounds = ej.datavisualization.Diagram.Util.bounds(obj);
                    var nBounds = new Rect(jsBounds.left, jsBounds.top, jsBounds.right - jsBounds.left, jsBounds.bottom - jsBounds.top);
                    if (obj._obstacle) {
                        obj._obstacle._outerBounds = nBounds;
                    }
                    else {
                        obj._obstacle = { OuterBounds: nBounds };
                    }
                }
                if (objects.get(i)._obstacle._outerBounds.left <= centerX) {
                    return true;
                }
            }
        }
        else {
            var centerX = quad.left + quad.width / 2;
            for (var i = 0; i < objects.size(); i++) {
                obj = objects.get(i);
                if (obj) {
                    var jsBounds = ej.datavisualization.Diagram.Util.bounds(obj);
                    var nBounds = new Rect(jsBounds.left, jsBounds.top, jsBounds.right - jsBounds.left, jsBounds.bottom - jsBounds.top);
                    if (obj._obstacle) {
                        obj._obstacle._outerBounds = nBounds;
                    }
                    else {
                        obj._obstacle = { OuterBounds: nBounds };
                    }
                }
                if (objects.get(i)._obstacle._outerBounds.right >= centerX) {
                    return true;
                }
            }
        }
        return false;
    };
    ObstacleTree.prototype.GetIntersectingNodesInaQuad = function (quad, rect, nodes) {
        if (nodes === void 0) { nodes = null; }
        if (nodes == null)
            nodes = new List();
        for (var i in quad.objects) {
            var obj = quad.objects[i];
            if (obj && obj._obstacle != null) {
                var paddedBounds = obj._obstacle.getPaddedBounds ? obj._obstacle.getPaddedBounds() : null;
                if (paddedBounds != null && obj != this.startNode && obj != this.endNode && obj._obstacle.getPaddedBounds().intersects(rect)) {
                    if (this.lookupSegment != null && paddedBounds.containsPoint(this.lookupSegment.StartPoint)) {
                        this.canRoute = false;
                        nodes = null;
                        break;
                    }
                    nodes.add(obj);
                }
            }
        }
        return nodes;
    };
    ObstacleTree.prototype.IsIntersects = function (quad, rect) {
        if (quad.left > rect.right || quad.left + quad.width < rect.left || quad.top > rect.bottom || quad.top + quad.height < rect.top()) {
            return false;
        }
        return true;
    };
    return ObstacleTree;
}());
var LineRouting = (function () {
    function LineRouting() {
        this.KnownObstacles = null;
        this.VisibleConnectors = null;
        this.consideredRegion = Rect.empty;
        this.IsDirt = false;
        this.firstLoad = false;
        this.ObstaclePadding = 0;
        this.BendEquivalence = 0;
        this.Priority = RoutingPriority.Routing;
        this.loadingPriority = LoadingPriority.ImmediateLoading;
        this.visibleVertices = new List();
        this.visibleEdges = new List();
        this.selectorBounds = Rect.empty;
    }
    LineRouting.prototype.SetLineRoutingSettings = function () {
        var lineRoutingSettings = this._mSharedData.lineRoutingSettings != null ? this._mSharedData.lineRoutingSettings : new LineRoutingSettings();
        if (this.ObstaclePadding != lineRoutingSettings.obstaclePadding || this.Priority != lineRoutingSettings.priority || this.BendEquivalence != lineRoutingSettings.bendEquivalence || this.loadingPriority != lineRoutingSettings.loadingPriority) {
            this.IsDirt = true;
        }
        this.ObstaclePadding = lineRoutingSettings.obstaclePadding;
        this.BendEquivalence = lineRoutingSettings.bendEquivalence;
        this.Priority = lineRoutingSettings.priority;
        this.loadingPriority = lineRoutingSettings.loadingPriority;
    };
    LineRouting.prototype.RerouteConnectors = function (diagram, node) {
        if (diagram.nodes().length > 0 && diagram.connectors().length > 0) {
            var dgm = diagram;
            var selectedObject = node != null ? node : dgm.activeTool.selectedObject;
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(selectedObject);
            var nBounds = new Rect(nodeBounds.left, nodeBounds.top, nodeBounds.right - nodeBounds.left, nodeBounds.bottom - nodeBounds.top);
            var points, connector;
            var connName = "";
            for (var n = 0; n < diagram.connectors().length; n++) {
                connector = diagram.connectors()[n];
                if (connector && connName != connector.name) {
                    points = ej.datavisualization.Diagram.Util.getPoints(connector);
                    var pts = [];
                    for (var i = 0; i < points.length; i++) {
                        if ((i > 0 && !(pts[pts.length - 1].x == points[i].x && pts[pts.length - 1].y == points[i].y)) || i == 0) {
                            pts.push(new Point(Math.round(points[i].x), Math.round(points[i].y)));
                        }
                    }
                    connector = diagram.connectors()[n];
                    if (pts.length > 1) {
                        var first = pts[0];
                        for (var i = 1; i < pts.length; i++) {
                            var rect = new Rect().Rect(first, pts[i]);
                            if (rect.intersects(nBounds)) {
                                if (this.router.CanRoute(connector)) {
                                    this.routeEdge(connector, diagram);
                                    connName = connector.name;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (this.router != null) {
                    this.router.ForceInvalidateRouter();
                }
            }
        }
    };
    LineRouting.prototype.Init = function (shared) {
        this._mSharedData = shared;
        this.SetLineRoutingSettings();
    };
    LineRouting.prototype.cloneConnector = function (line, diagram) {
        this._mSharedData = diagram;
        if (line.sourceNode && !line._sourceNodeInfo)
            line._sourceNodeInfo = diagram.nameTable[line.sourceNode];
        if (line.targetNode && !line._targetNodeInfo)
            line._targetNodeInfo = diagram.nameTable[line.targetNode];
        return line;
    };
    LineRouting.prototype.updateAllQuadObjects = function (parentQuad) {
        for (var i = 0; i < parentQuad.objects.length; i++) {
            var obj = parentQuad.objects[i];
            if (obj) {
                var jsBounds = ej.datavisualization.Diagram.Util.bounds(obj);
                var nBounds = new Rect(jsBounds.left, jsBounds.top, jsBounds.right - jsBounds.left, jsBounds.bottom - jsBounds.top);
                var pBounds = new Rect(jsBounds.x - this.ObstaclePadding, jsBounds.y - this.ObstaclePadding, (jsBounds.width + (2 * this.ObstaclePadding)), (jsBounds.height + (2 * this.ObstaclePadding)));
                if (!obj.segments) {
                    if (obj._obstacle) {
                        obj._obstacle._outerBounds = nBounds;
                    }
                    else {
                        obj._obstacle = { OuterBounds: nBounds };
                    }
                    obj._outerBounds = nBounds;
                    if (!obj._obstacle.CenterPort) {
                        obj._obstacle.CenterPort = new CenterPort(pBounds.center());
                    }
                }
            }
        }
    };
    LineRouting.prototype.routeEdge = function (connector, diagram) {
        connector = this.cloneConnector(connector, diagram);
        this.updateParentQuad(diagram, true, connector);
        this.router.RouteEdge(connector, diagram);
        diagram._resetConnectorPoints(connector, diagram);
    };
    LineRouting.prototype._checkFromSwimlane = function (node, diagram) {
        return diagram._checkFromSwimlane(node);
    };
    LineRouting.prototype._removeGroupChild = function (nodes, diagram) {
        var rNodes = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = diagram.nameTable[diagram._getChild(nodes[i])];
            if (node && !this._checkFromSwimlane(node, diagram)) {
                rNodes.push(node);
            }
        }
        return rNodes;
    };
    LineRouting.prototype.GenerateVisibilityGraph = function (diagram, nodesLength) {
        this.router = new Router().Router(this.Priority, this.BendEquivalence, this.ObstaclePadding, diagram);
        var nodes = nodesLength ? diagram.nodes() : diagram._spatialSearch.parentQuad.objects;
        this.updateParentQuad(diagram);
        if (nodes.length > 0) {
            var rNodes = this._removeGroupChild(nodes, diagram);
            this.router.GenerateVisibilityGraph(rNodes, diagram._spatialSearch);
        }
        VisibilityGraphGeneration.setRouter(this.router);
    };
    LineRouting.prototype.updateParentQuad = function (diagram, isConnector, connector) {
        var spatialSearch = this._mSharedData;
        var parentQuad = $.extend(false, [], diagram._spatialSearch.parentQuad);
        if (parentQuad.objects.length == 0) {
            parentQuad.objects = diagram.nodes();
        }
        if (isConnector) {
            if (connector) {
                if (connector.targetNode) {
                    var targetNode = diagram.nameTable[connector.targetNode];
                    var targetBounds = ej.datavisualization.Diagram.Util.bounds(targetNode, true);
                }
                if (connector.sourceNode) {
                    var sourceNode = diagram.nameTable[connector.sourceNode];
                    var sourceBounds = ej.datavisualization.Diagram.Util.bounds(sourceNode, true);
                }
                var sourcePort = ej.datavisualization.Diagram.Util.findPortByName(sourceNode, connector.sourcePort);
                var targetPort = ej.datavisualization.Diagram.Util.findPortByName(targetNode, connector.targetPort);
                var targetPortLocation = ej.datavisualization.Diagram.Util._getPortPosition(targetPort, targetBounds);
                var sourcePortLocation = ej.datavisualization.Diagram.Util._getPortPosition(sourcePort, sourceBounds);
            }
            if (sourcePort) {
                var sourceDirection = ej.datavisualization.Diagram.Util._swapDirection(sourceNode.rotateAngle, ej.datavisualization.Diagram.Util._getDirection(sourceBounds, sourcePortLocation ? sourcePortLocation : sourceBounds.center));
                connector._sourcePortInfo = new IObstaclePort();
                if (sourceDirection === "left") {
                    connector._sourcePortInfo.Direction = PortDirection.Left;
                }
                else if (sourceDirection === "right") {
                    connector._sourcePortInfo.Direction = PortDirection.Right;
                }
                else if (sourceDirection === "bottom") {
                    connector._sourcePortInfo.Direction = PortDirection.Bottom;
                }
                else if (sourceDirection === "top") {
                    connector._sourcePortInfo.Direction = PortDirection.Top;
                }
                connector._sourcePortInfo.Location = new Point(Number((sourcePortLocation.x).toFixed(4)), Number((sourcePortLocation.y).toFixed(4)));
            }
            if (targetPort) {
                var targetDirection = ej.datavisualization.Diagram.Util._swapDirection(targetNode.rotateAngle, ej.datavisualization.Diagram.Util._getDirection(targetBounds, targetPortLocation ? targetPortLocation : targetBounds.center));
                connector._targetPortInfo = new IObstaclePort();
                if (targetDirection === "left") {
                    connector._targetPortInfo.Direction = PortDirection.Left;
                }
                else if (targetDirection === "right") {
                    connector._targetPortInfo.Direction = PortDirection.Right;
                }
                else if (targetDirection === "bottom") {
                    connector._targetPortInfo.Direction = PortDirection.Bottom;
                }
                else if (targetDirection === "top") {
                    connector._targetPortInfo.Direction = PortDirection.Top;
                }
                connector._targetPortInfo.Location = new Point(Number((targetPortLocation.x).toFixed(4)), Number((targetPortLocation.y).toFixed(4)));
            }
        }
        else {
            for (var i = 0; i < parentQuad.objects.length; i++) {
                var obj = parentQuad.objects[i];
                if (obj) {
                    var jsBounds = ej.datavisualization.Diagram.Util.bounds(obj);
                    var nBounds = new Rect(jsBounds.left, jsBounds.top, jsBounds.right - jsBounds.left, jsBounds.bottom - jsBounds.top);
                    var pBounds = new Rect(jsBounds.left - this.ObstaclePadding, jsBounds.top - this.ObstaclePadding, ((jsBounds.right - jsBounds.left) + (2 * this.ObstaclePadding)), ((jsBounds.bottom - jsBounds.top) + (2 * this.ObstaclePadding)));
                    if (obj._obstacle) {
                        obj._obstacle._outerBounds = nBounds;
                    }
                    else {
                        obj._obstacle = { OuterBounds: nBounds };
                    }
                    obj._outerBounds = nBounds;
                    obj._obstacle.CenterPort = new CenterPort(pBounds.center());
                }
            }
        }
    };
    LineRouting.prototype.AddNode = function (node) {
        if (this.router != null) {
            this.router.AddNode(node);
        }
    };
    LineRouting.prototype.RemoveNode = function (node) {
        if (this.router != null) {
            this.router.RemoveNode(node);
        }
    };
    LineRouting.prototype.SetObstacles = function (nodes, connectors) {
        this.KnownObstacles = nodes;
        this.VisibleConnectors = connectors;
    };
    return LineRouting;
}());
var LineRoutingSettings = (function () {
    function LineRoutingSettings() {
        this.bendEquivalence = 0;
        this.obstaclePadding = 0;
        this.bendEquivalence = 5;
        this.priority = RoutingPriority.Routing;
        this.obstaclePadding = 12;
        this.loadingPriority = LoadingPriority.DelayedDiagramLoading;
    }
    return LineRoutingSettings;
}());
var VertexQueue = (function () {
    function VertexQueue() {
        this.vertexQueue = new List();
        this.timeStamp = 0;
    }
    VertexQueue.prototype.getnextTimeStamp = function () {
        return ++this.timeStamp;
    };
    VertexQueue.prototype.Enqueue = function (vertex) {
        vertex.TimeStamp = this.getnextTimeStamp();
        this.Sort(vertex);
    };
    VertexQueue.prototype.Sort = function (entry) {
        var index = this.vertexQueue.size();
        this.vertexQueue.add(entry);
        if (index > 0) {
            while (index > 0 && this.vertexQueue.get(index >> 1).CompareTo(this.vertexQueue.get(index)) > 0) {
                var i = index >> 1;
                var temp = this.vertexQueue.get(i);
                this.vertexQueue.UpdateListValue(i, this.vertexQueue.get(index));
                this.vertexQueue.UpdateListValue(index, temp);
                index >>= 1;
            }
        }
    };
    VertexQueue.prototype.Dequeue = function () {
        var vertex = this.vertexQueue.get(0);
        this.MoveQueueOneStepForward(vertex);
        return vertex;
    };
    VertexQueue.prototype.MoveQueueOneStepForward = function (entry) {
        var count = this.vertexQueue.size() - 2;
        if (this.vertexQueue.size() > 1) {
            var last = this.vertexQueue.Last();
            this.vertexQueue.RemoveAt(this.vertexQueue.size() - 1);
            this.vertexQueue.UpdateListValue(0, last);
            var i = 0;
            while (true) {
                var smallest = i;
                var l = i << 1;
                if (l <= count && this.vertexQueue.get(l).CompareTo(this.vertexQueue.get(i)) < 0)
                    smallest = l;
                var r = l + 1;
                if (r <= count && this.vertexQueue.get(r).CompareTo(this.vertexQueue.get(smallest)) < 0)
                    smallest = r;
                if (smallest != i) {
                    this.SwapWithParent(smallest);
                }
                else {
                    break;
                }
                i = smallest;
            }
        }
        else {
            this.vertexQueue.RemoveAt(0);
        }
    };
    VertexQueue.prototype.DecreasePriority = function (entry, newPriority) {
        newPriority = Math.round(newPriority);
        var index = this.vertexQueue.IndexOf(entry);
        if (index == -1)
            return;
        var h = this.vertexQueue.get(index);
        h.Cost = newPriority;
        var i = index;
        while (i > 0) {
            if (this.vertexQueue.get(i).CompareTo(this.vertexQueue.get(i >> 1)) < 0) {
                this.SwapWithParent(i);
            }
            else {
                break;
            }
            ;
            i >>= 1;
        }
    };
    VertexQueue.prototype.SwapWithParent = function (i) {
        var parent = this.vertexQueue.get(i >> 1);
        this.vertexQueue.UpdateListValue(i >> 1, this.vertexQueue.get(i));
        this.vertexQueue.UpdateListValue(i, parent);
    };
    VertexQueue.prototype.Count = function () {
        return this.vertexQueue.size();
    };
    VertexQueue.prototype.ToString = function () {
        var build = "";
        for (var i = 0; i < this.vertexQueue.size(); i++) {
            var vertex = this.vertexQueue[i];
            build += ("{0}, ", vertex);
        }
        return build;
    };
    return VertexQueue;
}());
var Neighbor = (function () {
    function Neighbor() {
        this.Weight = 0;
        this.Clear();
    }
    Neighbor.prototype.Set = function (vertex, weight) {
        this.Vertex = vertex;
        this.Weight = weight;
    };
    Neighbor.prototype.Clear = function () {
        this.Vertex = null;
        this.Weight = Number.NaN;
    };
    return Neighbor;
}());
var NeighborSides = (function () {
    function NeighborSides() {
    }
    return NeighborSides;
}());
var ShortestPath = (function () {
    function ShortestPath(graph, bendEquivalence, target) {
        this.cancel = false;
        this.upperBoundCost = Number.MAX_VALUE;
        this.targetConnector = null;
        this.bendEquivalence = 0;
        this.bendsImportance = 1;
        this.lengthImportance = 1;
        this.visitedVertices = new List();
        this.queue = new VertexQueue();
        this.mode = RoutingSolution.Quick;
        this.neighbors = [new Neighbor(), new Neighbor(), new Neighbor()];
        this.visibilityGraph = graph;
        this.targetConnector = target;
        this.bendEquivalence = bendEquivalence;
    }
    ShortestPath.prototype.GetSingleStagePath = function (possibleEntries) {
        var bestEntry = this.FindPath(possibleEntries);
        var entries = this.GetEntries(bestEntry);
        var pts = this.GetPoints(entries);
        return pts;
    };
    ShortestPath.prototype.GetEntries = function (bestEntry) {
        var entries = new List();
        var lastEntryDirection = Directions.None;
        var colinearSegments = false;
        if (bestEntry != null) {
            while (bestEntry != null) {
                if (bestEntry.Direction != lastEntryDirection) {
                    entries.Insert(0, bestEntry);
                    lastEntryDirection = bestEntry.Direction;
                    colinearSegments = false;
                }
                else {
                    colinearSegments = true;
                }
                if (bestEntry.PreviousEntry == null) {
                    if (colinearSegments) {
                        entries.Insert(0, bestEntry);
                    }
                    break;
                }
                bestEntry = bestEntry.PreviousEntry;
            }
        }
        return entries;
    };
    ShortestPath.prototype.GetPoints = function (entries) {
        var points = new PointList();
        if (entries.size() > 0) {
            var last = entries.size() - 1;
            if (entries.size() > 4) {
                var count = entries.size();
                if (entries.get(count - 2).Direction == entries.get(count - 4).Direction) {
                    var source = entries.get(count - 4).Vertex;
                    var target = null;
                    var next = source.FindNextVertex(entries.get(count - 4).Direction);
                    while (next != null) {
                        target = next;
                        next = next.FindNextVertex(entries.get(count - 4).Direction);
                    }
                    if (target != null && this.targetConnector.TargetEntrance != null) {
                        var segment = new Segment(source.Point, target.Point);
                        var maxVisSegment = this.targetConnector.TargetEntrance.MaxVisibilitySegment;
                        if (maxVisSegment != null) {
                            var intersectingPt;
                            var args = Utility.SegmentIntersects(segment, maxVisSegment, intersectingPt);
                            intersectingPt = args.intersect;
                            if (args.isInterSect) {
                                points.add(intersectingPt);
                                points.add(entries.get(count - 1).Vertex.Point);
                                last = count - 5;
                            }
                        }
                    }
                }
            }
            for (var i = last; i >= 0; i--) {
                points.Insert(0, entries.get(i).Vertex.Point);
            }
        }
        return points;
    };
    ShortestPath.prototype.FindPath = function (possibleEntries) {
        var bestCost = Number.POSITIVE_INFINITY;
        var bestEntry = null;
        for (var i = 0; i < possibleEntries.size(); i++) {
            var path = possibleEntries.get(i);
            if (!this.cancel && (bestEntry == null || (path.getMinimalBend() < bestEntry.NumberOfBends
                || (path.getIsPreferred()
                    && path.getMinimalBend() == bestEntry.NumberOfBends)))) {
                var sourcePt = path.getSourceEntry().Point;
                var targetPt = path.getTargetEntry().Point;
                this.bendsImportance = Math.max(0.01, sourcePt.ManhattanDistance(targetPt) * (this.bendEquivalence * 0.01));
                this.mode = RoutingSolution.Best;
                var lastEntry = this.FindPath_Point(sourcePt, targetPt);
                if (lastEntry != null && (bestEntry == null || bestCost > lastEntry.Cost)) {
                    bestEntry = lastEntry;
                    bestCost = lastEntry.Cost;
                }
            }
            else {
                break;
            }
        }
        return bestEntry;
    };
    ShortestPath.prototype.FindPath_Point = function (source, target) {
        source.round();
        target.round();
        this.InitializePath(source, target);
        var targetVertex = this.visibilityGraph.FindVertex(target);
        var bestEntry;
        var bestVertex;
        var w = 0;
        while (this.queue.Count() > 0) {
            if (this.cancel)
                break;
            w++;
            bestEntry = this.queue.Dequeue();
            bestVertex = bestEntry.Vertex;
            if (targetVertex == bestVertex) {
                this.Cleanup();
                return bestEntry;
            }
            bestEntry.Closed = true;
            var neighbor;
            for (var k = 0; k < this.neighbors.length; k++) {
                neighbor = this.neighbors[k];
                neighbor.Clear();
            }
            var preferredDirection = Extensions.Right(bestEntry.Direction);
            if (preferredDirection != Directions.None) {
                this.ExtendPathAlongInEdges(bestEntry, preferredDirection);
                this.ExtendPathAlongOutEdges(bestEntry, preferredDirection);
                for (var s = 0; s < this.neighbors.length; s++) {
                    neighbor = this.neighbors[s];
                    if (neighbor.Vertex != null) {
                        this.ExtendPathToNeighborVertex(bestEntry, neighbor.Vertex, neighbor.Weight);
                    }
                }
            }
        }
        this.Cleanup();
        return null;
    };
    ShortestPath.prototype.InitializePath = function (source, target) {
        this.queue = new VertexQueue();
        var sourceVertex = this.visibilityGraph.FindVertex(source);
        var targetVertex = this.visibilityGraph.FindVertex(target);
        this.Source = sourceVertex;
        this.InitEntryDirectionsAtTarget(targetVertex);
        if (sourceVertex != null) {
            var entry = new VertexEntry(sourceVertex, null, 0, 0, 0);
            entry.Closed = true;
            this.EnqueueOutEdges(entry);
            this.EnqueueInEdges(entry);
        }
    };
    ShortestPath.prototype.ExtendPathAlongInEdges = function (source, preferredDirection) {
        var inEdge = source.Vertex.getWestEdge();
        if (inEdge != null)
            this.ExtendPathAlongEdge(source, inEdge.getSource(), inEdge, preferredDirection);
        inEdge = source.Vertex.getSouthEdge();
        if (inEdge != null)
            this.ExtendPathAlongEdge(source, inEdge.getSource(), inEdge, preferredDirection);
    };
    ShortestPath.prototype.ExtendPathAlongOutEdges = function (source, preferredDirection) {
        var outEdge = source.Vertex.getEastEdge();
        if (outEdge != null)
            this.ExtendPathAlongEdge(source, outEdge.getTarget(), outEdge, preferredDirection);
        outEdge = source.Vertex.getNorthEdge();
        if (outEdge != null)
            this.ExtendPathAlongEdge(source, outEdge.getTarget(), outEdge, preferredDirection);
    };
    ShortestPath.prototype.ExtendPathAlongEdge = function (source, neighborVertex, edge, preferredDirections) {
        if (source.PreviousEntry == null || neighborVertex != source.PreviousEntry.Vertex) {
            var neighbor = this.neighbors[2];
            var neighborDirection = source.Vertex.Point.FindDirection(neighborVertex.Point);
            if (neighborDirection != source.Direction) {
                neighbor = this.neighbors[neighborDirection == preferredDirections ? 1 : 0];
            }
            neighbor.Set(neighborVertex, edge.getWeight());
        }
        else if (neighborVertex == source.PreviousEntry.Vertex) {
            if (source.Vertex.getDegree() > 1 || source.Vertex != this.Source) {
                this.ExtendPathToNeighborVertex(source, neighborVertex, edge.getWeight());
            }
        }
    };
    ShortestPath.prototype.EnqueueEdges = function (vertexEntry, edge, edgeDirection) {
        var weight = edge.getWeight();
        if ((this.EntryDirectionsToTarget & edge.getSourcePoint().FindDirection(edge.getTargetPoint())) == 0)
            weight = 1.5;
        var target = null;
        switch (edgeDirection) {
            case Directions.East:
            case Directions.North:
                target = edge.getTarget();
                break;
            case Directions.West:
            case Directions.South:
                target = edge.getSource();
                break;
        }
        this.ExtendPathToNeighborVertex(vertexEntry, target, weight);
    };
    ShortestPath.prototype.EnqueueOutEdges = function (source) {
        var sourceVertex = source.Vertex;
        if (sourceVertex.getEastEdge() != null)
            this.EnqueueEdges(source, sourceVertex.getEastEdge(), Directions.East);
        if (sourceVertex.getNorthEdge() != null)
            this.EnqueueEdges(source, sourceVertex.getNorthEdge(), Directions.North);
    };
    ShortestPath.prototype.EnqueueInEdges = function (source) {
        var sourceVertex = source.Vertex;
        if (sourceVertex.getWestEdge() != null)
            if (source.PreviousEntry == null || sourceVertex.getWestEdge().getSource() != source.PreviousEntry.Vertex)
                this.EnqueueEdges(source, sourceVertex.getWestEdge(), Directions.West);
        if (sourceVertex.getSouthEdge() != null)
            if (source.PreviousEntry == null || sourceVertex.getSouthEdge().getSource() != source.PreviousEntry.Vertex)
                this.EnqueueEdges(source, sourceVertex.getSouthEdge(), Directions.South);
    };
    ShortestPath.prototype.ExtendPathToNeighborVertex = function (source, neighborVertex, weight) {
        var direction = source.Vertex.Point.FindDirection(neighborVertex.Point);
        var neighborEntry = null;
        if (neighborVertex.VertexEntries != null)
            neighborEntry = neighborVertex.VertexEntries[Extensions.ToIndex(direction)];
        if (neighborEntry == null) {
            if (!this.CheckExistingReverseEntry(source, neighborVertex, weight))
                this.CreateAndEnqueueEntryToNeighborVertex(source, neighborVertex, weight);
        }
        else if (!neighborEntry.Closed && this.mode != RoutingSolution.Quick) {
            var args = this.UpdateEntryToNeighborVertexIfNeeded(source, neighborEntry, weight);
            weight = args.weight;
        }
    };
    ShortestPath.prototype.UpdateEntryToNeighborVertexIfNeeded = function (bestEntry, neigEntry, weight) {
        var numberOfBends = 0;
        var length = 0;
        var args = this.UpdatePathLength(bestEntry, neigEntry.Vertex, weight, numberOfBends, length);
        var dirToNeighbor = args.direction;
        weight = args.weight;
        numberOfBends = args.bends;
        length = args.length;
        if (this.CombinedCost(length, numberOfBends) < this.CombinedCost(neigEntry.Length, neigEntry.NumberOfBends)) {
            var newCost = this.CombinedCost(length, numberOfBends) + this.HeuristicDistanceFromVertexToTarget(neigEntry.Vertex.Point, dirToNeighbor);
            neigEntry.ResetEntry(bestEntry, newCost, numberOfBends, length);
            this.queue.DecreasePriority(neigEntry, newCost);
        }
        return { weight: weight };
    };
    ShortestPath.prototype.CreateAndEnqueueEntryToNeighborVertex = function (source, neighborVertex, weight) {
        var length = 0;
        var bends = 0;
        var args = this.UpdatePathLength(source, neighborVertex, weight, bends, length);
        var direction = args.direction;
        weight = args.weight;
        bends = args.bends;
        length = args.length;
        var cost = this.CombinedCost(length, bends) + this.HeuristicDistanceFromVertexToTarget(neighborVertex.Point, direction);
        if (cost < this.upperBoundCost) {
            if (neighborVertex.VertexEntries == null) {
                this.visitedVertices.add(neighborVertex);
            }
            this.EnqueueVertex(neighborVertex, source, length, cost, bends);
        }
    };
    ShortestPath.prototype.ToIndex = function (direction) {
        switch (direction) {
            case Directions.North:
                return 0;
            case Directions.East:
                return 1;
            case Directions.South:
                return 2;
            case Directions.West:
                return 3;
            default:
                break;
        }
    };
    ShortestPath.prototype.CheckExistingReverseEntry = function (bestEntry, neighbor, weight) {
        if (bestEntry.Vertex.VertexEntries != null) {
            var reverseDirection = neighbor.Point.FindDirection(bestEntry.Vertex.Point);
            if (reverseDirection != Directions.None) {
                var reverseEntry = bestEntry.Vertex.VertexEntries[this.ToIndex(reverseDirection)];
                if (reverseEntry != null) {
                    this.CheckTheNeedOfReverseEntry(bestEntry, reverseEntry, weight);
                    return true;
                }
            }
        }
        return false;
    };
    ShortestPath.prototype.CheckTheNeedOfReverseEntry = function (bestEntry, reverseEntry, weight) {
        var bends = 0;
        var length = 0;
        var neighborVertex = reverseEntry.PreviousEntry.Vertex;
        var args = this.UpdatePathLength(bestEntry, neighborVertex, weight, bends, length);
        var direction = args.direction;
        weight = args.weight;
        bends = args.bends;
        length = args.length;
        if (direction != Directions.None) {
            if (this.CombinedCost(length, bends) < this.CombinedCost(reverseEntry.Length, reverseEntry.NumberOfBends)) {
                var cost = this.CombinedCost(length, bends) + this.HeuristicDistanceFromVertexToTarget(neighborVertex.Point, direction);
                this.EnqueueVertex(neighborVertex, bestEntry, length, cost, bends);
            }
        }
    };
    ShortestPath.prototype.CombinedCost = function (length, bends) {
        return Number((this.bendsImportance * bends + this.lengthImportance * length).toFixed(4));
    };
    ShortestPath.prototype.UpdatePathLength = function (previous, current, weight, bends, length) {
        var direction = previous.Vertex.Point.FindDirection(current.Point);
        if (this.mode == RoutingSolution.Quick) {
            length = 0;
            bends = previous.NumberOfBends;
            var preferedDirection = current.Point.FindDirection(this.Target.Point);
            var priority = 0;
            if (previous.Direction != Directions.None) {
                if ((direction & preferedDirection) != Directions.None) {
                    if (previous.Direction == direction) {
                        priority = 0;
                    }
                    else {
                        priority = 0;
                    }
                }
                else {
                    priority = 2;
                }
            }
            bends += priority;
        }
        else {
            length = previous.Length + previous.Vertex.Point.ManhattanDistance(current.Point) * weight;
            bends = previous.NumberOfBends;
            if (previous.Direction != Directions.None && previous.Direction != direction) {
                bends++;
            }
        }
        return { direction: direction, weight: weight, bends: bends, length: length };
    };
    ShortestPath.prototype.EnqueueVertex = function (vertex, previous, length, cost, bends) {
        var entry = new VertexEntry(vertex, previous, length, bends, cost);
        this.queue.Enqueue(entry);
        vertex.SetVertexEntry(entry);
        return entry;
    };
    ShortestPath.prototype.InitEntryDirectionsAtTarget = function (vertex) {
        this.Target = vertex;
        this.EntryDirectionsToTarget = Directions.None;
        if (vertex.getEastEdge() != null)
            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget || Directions.East;
        if (vertex.getNorthEdge() != null)
            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget || Directions.North;
        if (vertex.getWestEdge() != null)
            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget || Directions.West;
        if (vertex.getSouthEdge() != null)
            this.EntryDirectionsToTarget = this.EntryDirectionsToTarget || Directions.South;
        return this.EntryDirectionsToTarget != Directions.None;
    };
    ShortestPath.prototype.HeuristicDistanceFromVertexToTarget = function (point, entryDirToVertex) {
        var vectorToTarget = this.Target.Point.subtract(point);
        var dirToTarget = Extensions.VectorDirection(vectorToTarget);
        if (vectorToTarget.equals(new Point(0, 0)))
            return 0;
        var numberOfBends = 0;
        if (entryDirToVertex == Directions.None) {
            entryDirToVertex = Directions.East | Directions.North | Directions.West | Directions.South;
            numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);
        }
        else {
            numberOfBends = this.GetNumberOfBends(entryDirToVertex, dirToTarget);
        }
        return this.CombinedCost(point.ManhattanDistance(this.Target.Point), numberOfBends);
    };
    ShortestPath.prototype.GetNumberOfBends = function (entryDirToVertex, dirToTarget) {
        return Extensions.IsPureDirection(dirToTarget) ? this.GetNumberOfBendsForPureDirection(entryDirToVertex, dirToTarget) : ShortestPath.GetBendsForNotPureDirection(dirToTarget, entryDirToVertex, this.EntryDirectionsToTarget);
    };
    ShortestPath.prototype.GetNumberOfBendsForPureDirection = function (entryDirToVertex, dirToTarget) {
        if ((dirToTarget & entryDirToVertex) == dirToTarget) {
            if (Extensions.Contains(this.EntryDirectionsToTarget, dirToTarget)) {
                return 0;
            }
            if (Extensions.Contains(this.EntryDirectionsToTarget, Extensions.Left(dirToTarget)) || Extensions.Contains(this.EntryDirectionsToTarget, Extensions.Right(dirToTarget))) {
                return 2;
            }
            return 4;
        }
        return this.GetNumberOfBendsForPureDirection(ShortestPath.AddOneTurn[entryDirToVertex], dirToTarget) + 1;
    };
    ShortestPath.GetBendsForNotPureDirection = function (dirToTarget, entryDirToVertex, entryDirectionsToTarget) {
        var a = dirToTarget & entryDirToVertex;
        if (entryDirToVertex != Directions.None) {
            if (a == Directions.None) {
                return 1;
            }
            var b = dirToTarget & entryDirectionsToTarget;
            if (b == Directions.None) {
                return 2;
            }
            return a == dirToTarget ? 1 : 2;
        }
        return this.GetBendsForNotPureDirection(dirToTarget, ShortestPath.AddOneTurn[entryDirToVertex], ShortestPath.AddOneTurn[entryDirectionsToTarget]) + 1;
    };
    ShortestPath.prototype.Cleanup = function () {
        for (var i = 0; i < this.visitedVertices.size(); i++) {
            this.visitedVertices.get(i).RemoveVertexEntries();
        }
        this.visitedVertices.Clear();
        this.queue = null;
    };
    ShortestPath.prototype.CancelRouting = function () {
        this.cancel = true;
    };
    ShortestPath.AddOneTurn = new Array(Directions.None, Directions.North | Directions.East | Directions.West, Directions.North | Directions.East | Directions.South, 15, Directions.East | Directions.South | Directions.West, 15, 15, 15, 13, 15, 15, 15, 15, 15, 15, 15);
    return ShortestPath;
}());
var Router = (function () {
    function Router() {
        this.obstaclesToAdd = new List();
        this.obstaclesToRemove = new List();
        this.BendEquivalence = 0;
        this.ObstaclePadding = 0;
        this.cancel = false;
        this.graph = null;
        this.obstacleTree = null;
        this.portManager = null;
        this.isAddingObstacle = false;
        this.isRemovingObstacle = false;
        this.Priority = RoutingPriority.Default;
        this.BendEquivalence = 5;
        this.ObstaclePadding = 12;
        this.horizontalSegmentTree = new SegmentTree(false, this);
        this.verticalSegmentTree = new SegmentTree(true, this);
        this.horizontalSegmentTree.setPerpendicularTree(this.verticalSegmentTree);
        this.verticalSegmentTree.setPerpendicularTree(this.horizontalSegmentTree);
        this.vertexToRemove = {};
    }
    Router.prototype.getHorizontalSegmentTree = function () {
        return this.horizontalSegmentTree;
    };
    Router.prototype.getVerticalSegmentTree = function () {
        return this.verticalSegmentTree;
    };
    Router.prototype.Router = function (priority, bendEquivalence, padding, diag) {
        this.diagram = diag;
        this.Priority = priority;
        this.BendEquivalence = bendEquivalence;
        this.ObstaclePadding = padding;
        this.horizontalSegmentTree = new SegmentTree(false, this);
        this.verticalSegmentTree = new SegmentTree(true, this);
        this.horizontalSegmentTree.setPerpendicularTree(this.verticalSegmentTree);
        this.verticalSegmentTree.setPerpendicularTree(this.horizontalSegmentTree);
        return this;
    };
    Router.prototype.MinimumSegmentLength = function (points) {
        if (points.size() > 1) {
            var start1 = points.ElementAt(0);
            var start2 = points.ElementAt(points.size() - 2);
            var end1 = points.ElementAt(1);
            var end2 = points.ElementAt(points.size() - 1);
            var length1 = Extensions.FindDistance(start1, end1, Extensions.GetOrientation(Extensions.FindDirection(start1, end1)));
            var length2 = Extensions.FindDistance(start2, end2, Extensions.GetOrientation(Extensions.FindDirection(start2, end2)));
            return Math.min(Number(Math.round(length1).toFixed(4)), Number(Math.round(length2).toFixed(4)));
        }
        return 0;
    };
    Router.prototype.IsMinimalPointCollection = function (points) {
        if (points.size() > 1) {
            var start1 = points.ElementAt(0);
            var start2 = points.ElementAt(points.size() - 2);
            var end1 = points.ElementAt(1);
            var end2 = points.ElementAt(points.size() - 1);
            var orientation1 = Extensions.GetOrientation(start1.FindDirection(end1));
            var orientation2 = Extensions.GetOrientation(start2.FindDirection(end2));
            if (orientation1 == orientation2 && points.size() <= 4)
                return true;
            else if (orientation1 != orientation2 && points.size() == 3)
                return true;
        }
        return false;
    };
    Router.prototype.GenerateVisibilityGraph = function (nodes, spatialSearch) {
        this.currentBounds = Rect.empty;
        var obstacles = new List();
        this.obstacleTree = new ObstacleTree();
        this.obstacleTree.InitObstacles(obstacles, this.ObstaclePadding, spatialSearch);
        this.graph = new VisibilityGraph();
        var targetGeometry = new EdgeGeometry();
        this.portManager = new PortManager(this.horizontalSegmentTree, this.verticalSegmentTree, this.obstacleTree, this.graph, targetGeometry, this.ObstaclePadding);
        this.pathfinder = new ShortestPath(this.graph, this.BendEquivalence, targetGeometry);
        if (nodes.length > 0) {
            for (var i = 0; i < nodes.length; i++) {
                nodes[i]._obstacle = null;
                this.AddNode(nodes[i]);
            }
            this.InvalidateRouter();
        }
    };
    Router.prototype.RouteEdge = function (edge, diagram) {
        this.diagram = diagram;
        var currentSegPoints = new PointList();
        var newSegPoints = new PointList();
        this.InvalidateRouter();
        var args = this.portManager.IsCurrentConnectionSegmentsValid(edge, currentSegPoints);
        currentSegPoints = args.points;
        if (this.CanRoute(edge) && edge._sourceNodeInfo != null && edge._targetNodeInfo != null) {
            {
                this.portManager.temporaryAddition = true;
                var intersectingPoints = this.portManager.GetPortVisibilityIntersection(edge);
                if (intersectingPoints == null || !(intersectingPoints.size() > 0)) {
                    if (this.portManager.AddControlPointsToGraph(edge)) {
                        var srcPort = edge._sourcePortInfo ? edge._sourcePortInfo : edge._sourceNodeInfo._obstacle.CenterPort;
                        var tarPort = edge._targetPortInfo ? edge._targetPortInfo : edge._targetNodeInfo._obstacle.CenterPort;
                        newSegPoints = this.pathfinder.GetSingleStagePath(this.GetPossibleEntries(srcPort, tarPort));
                    }
                }
                else {
                    newSegPoints = intersectingPoints;
                    if (newSegPoints.size() == 0)
                        edge._points = newSegPoints;
                }
                if (newSegPoints.size() > 0) {
                    if (currentSegPoints.size() > 0) {
                        if (newSegPoints.size() < currentSegPoints.size()) {
                            edge._points = newSegPoints;
                        }
                        else if (newSegPoints.size() > currentSegPoints.size()) {
                            edge._points = currentSegPoints;
                        }
                        else {
                            var curSegLength = this.MinimumSegmentLength(currentSegPoints);
                            var newSegLength = this.MinimumSegmentLength(newSegPoints);
                            if (curSegLength < this.ObstaclePadding && curSegLength < newSegLength) {
                                edge._points = newSegPoints;
                            }
                            else {
                                var newLength = Extensions.GetLengthFromListOfPoints(newSegPoints);
                                var curLength = Extensions.GetLengthFromListOfPoints(currentSegPoints);
                                if (newLength <= curLength) {
                                    edge._points = newSegPoints;
                                }
                                else
                                    edge._points = currentSegPoints;
                            }
                        }
                    }
                    else {
                        edge._points = newSegPoints;
                    }
                }
            }
        }
        else if (this.CanRoute(edge) && (edge._sourceNodeInfo != null || edge._targetNodeInfo != null)) {
            this.portManager.temporaryAddition = true;
            var sourcePort = edge._sourcePortInfo;
            var targetPort = edge._targetPortInfo;
            if (sourcePort == null && edge._sourceNodeInfo instanceof IObstacle)
                sourcePort = edge._sourceNodeInfo._obstacle.CenterPort;
            else
                sourcePort = edge._sourcePointInfo;
            if (targetPort == null && edge._targetNodeInfo instanceof IObstacle) {
                targetPort = edge._targetNodeInfo._obstacle.CenterPort;
            }
            else
                targetPort = edge._targetPointInfo;
            var targetPortLocation = targetPort.getLocation();
            targetPort.setLocation(this.portManager.GetValidPortLocation(targetPortLocation));
            if (this.portManager.AddControlPointsToGraph(edge)) {
                edge._points = this.pathfinder.GetSingleStagePath(this.GetPossibleEntries(sourcePort, targetPort));
                if (edge._points != null && edge._points.Count > 0) {
                    edge._points.RemoveAt(edge._points.Count - 1);
                    edge._points.Insert(edge._points.Count, targetPortLocation);
                }
            }
            else {
                edge._points = currentSegPoints;
            }
        }
        else {
            edge._points = new PointList();
        }
        this.portManager.RemoveEdgeGeometryFromGraph();
        this.portManager.temporaryAddition = false;
    };
    Router.prototype.CanRoute = function (connector) {
        if (ej.datavisualization.Diagram.Util.canRouteConnector(connector, this.diagram)) {
            if (connector.sourcePort != null && connector.targetPort != null) {
                var sourcePort = connector.sourcePort;
                var targetPort = connector.sourcePort;
                var sourcePoint = new Point(connector.sourcePoint.x, connector.sourcePoint.y);
                var targetPoint = new Point(connector.targetPoint.x, connector.targetPoint.y);
                var source = new Rect().Rect(new Point(sourcePoint.x, sourcePoint.y), new Point(sourcePoint.x, sourcePoint.y));
                var target = new Rect().Rect(new Point(targetPoint.x, targetPoint.y), new Point(targetPoint.x, targetPoint.y));
                source = source.Inflate(this.ObstaclePadding);
                target = target.Inflate(this.ObstaclePadding);
                if (source.intersects(target))
                    return false;
            }
            return true;
        }
    };
    Router.prototype.AddVertex = function (point) {
        var vertex = this.graph.AddVertex(point);
        if (Extensions.Count(this.vertexToRemove) != 0) {
            if (Extensions.ContainsKey(this.vertexToRemove, vertex.Point))
                Extensions.Remove(this.vertexToRemove, vertex.Point);
        }
        return vertex;
    };
    Router.prototype.GetMaximumVisibility = function (start, direction) {
        if (direction != Directions.None) {
            var endPoint;
            if (direction == Directions.West) {
                endPoint = new Point(this.currentBounds.x, start.y);
            }
            else if (direction == Directions.East) {
                endPoint = new Point(this.currentBounds.right(), start.y);
            }
            else if (direction == Directions.South) {
                endPoint = new Point(start.x, this.currentBounds.top());
            }
            else {
                endPoint = new Point(start.x, this.currentBounds.bottom());
            }
            var segment = new Segment(start, endPoint);
            if (this.obstacleTree.FindMaximumVisibility(segment, this.currentNode)) {
                if (Extensions.IsAscending(direction)) {
                    return new Segment(segment.StartPoint, segment.EndPoint);
                }
                else
                    return new Segment(segment.EndPoint, segment.StartPoint);
            }
        }
        return null;
    };
    Router.prototype.ResetDependentCollection = function () {
        for (var key in this.vertexToRemove) {
            var vertex = Extensions.ElementAt(this.vertexToRemove, key);
            this.graph.RemoveVertex(vertex);
        }
        this.vertexToRemove = Extensions.Clear(this.vertexToRemove);
        this.horizontalSegmentTree.getCoordsToReconstruct().Clear();
        this.verticalSegmentTree.getCoordsToReconstruct().Clear();
    };
    Router.prototype.InvalidateRouter = function () {
        while (this.obstaclesToRemove.size()) {
            var obstacle = this.obstaclesToRemove.get(0);
            this.obstaclesToRemove.RemoveAt(0);
            this.RemoveObstacleforNode(obstacle);
        }
        while (this.obstaclesToAdd.size()) {
            var obstacle = this.obstaclesToAdd.get(0);
            this.obstaclesToAdd.RemoveAt(0);
            this.AddObstacleforNode(obstacle);
        }
    };
    Router.prototype.ForceInvalidateRouter = function () {
        this.InvalidateRouter();
    };
    Router.prototype.AddNode = function (node) {
        if (!this.obstaclesToAdd.contains(node)) {
            if (node._obstacle == null || this.obstaclesToRemove.contains(node)) {
                this.obstaclesToAdd.add(node);
            }
        }
    };
    Router.prototype.RemoveNode = function (node) {
        if (node._obstacle != null && !this.obstaclesToRemove.contains(node)) {
            this.obstaclesToRemove.add(node);
        }
    };
    Router.prototype.AddObstacleforNode = function (node) {
        this.portManager.temporaryAddition = false;
        this.isAddingObstacle = true;
        this.ResetDependentCollection();
        var jsBounds = ej.datavisualization.Diagram.Util.bounds(node);
        var nBounds = new Rect(jsBounds.left, jsBounds.top, jsBounds.right - jsBounds.left, jsBounds.bottom - jsBounds.top);
        var obstacleTreeBounds = this.obstacleTree.Rectangle;
        if (node._obstacle == null && !(nBounds.width == 0) && !(nBounds.height == 0)) {
            this.currentNode = node;
            node._obstacle = new Obstacle()._obstacle(nBounds, this.ObstaclePadding);
            var x = 0, y = 0, right = 0, bottom = 0;
            if (node._obstacle.getPaddedBounds() != null) {
                nBounds = node._obstacle.getPaddedBounds().round();
                x = Utility.ToRoundedInt(nBounds.left());
                y = Utility.ToRoundedInt(nBounds.top());
                right = Utility.ToRoundedInt(nBounds.right());
                bottom = Utility.ToRoundedInt(nBounds.bottom());
                var trimValue = 0;
                if (trimValue != 0) {
                    x += x % trimValue != 0 ? trimValue - (x % trimValue) : 0;
                    y += y % trimValue != 0 ? trimValue - (y % trimValue) : 0;
                    right -= right % trimValue != 0 ? right % trimValue : 0;
                    bottom -= bottom % trimValue != 0 ? bottom % trimValue : 0;
                    nBounds = new Rect(x, y, right - x, bottom - y);
                    node._obstacle.setPaddedBounds(nBounds);
                }
                node._outerBounds = nBounds;
                node._obstacle.CenterPort = new CenterPort(node._obstacle.getPaddedBounds().center());
            }
            if (this.verticalSegmentTree.getVectors().Count() != 0 && this.horizontalSegmentTree.getVectors().Count() != 0) {
                x = Math.min(this.horizontalSegmentTree.getStart(), x);
                y = Math.min(this.verticalSegmentTree.getStart(), y);
                right = Math.max(this.horizontalSegmentTree.getEnd(), right);
                bottom = Math.max(this.verticalSegmentTree.getEnd(), bottom);
            }
            if (x < obstacleTreeBounds.left() || right > obstacleTreeBounds.right()) {
                this.horizontalSegmentTree.ExpandOrCollapseSegmentTree(x, right, true);
            }
            if (y < obstacleTreeBounds.top() || bottom > obstacleTreeBounds.bottom()) {
                this.verticalSegmentTree.ExpandOrCollapseSegmentTree(y, bottom, true);
            }
            this.obstacleTree.Rectangle = new Rect(x, y, right - x, bottom - y);
            this.currentBounds = this.obstacleTree.Rectangle;
            this.horizontalSegmentTree.InitializeVectorCoordinate(nBounds);
            this.verticalSegmentTree.InitializeVectorCoordinate(nBounds);
            this.horizontalSegmentTree.InsertObstacle(nBounds);
            this.verticalSegmentTree.InsertObstacle(nBounds);
            this.horizontalSegmentTree.SplitSegments(nBounds);
            this.verticalSegmentTree.SplitSegments(nBounds);
            this.horizontalSegmentTree.RemoveUnUsedVector();
            this.verticalSegmentTree.RemoveUnUsedVector();
            this.ResetDependentCollection();
        }
        this.isAddingObstacle = false;
        this.portManager.temporaryAddition = true;
    };
    Router.prototype.RemoveObstacleforNode = function (obstacle) {
        if (obstacle._obstacle != null) {
            var obstacles = {};
            var nBounds = (obstacle._obstacle.getPaddedBounds() && obstacle._obstacle) ? obstacle._obstacle.getPaddedBounds().round() : new Rect(0, 0, 0, 0);
            obstacles = Extensions.add(obstacles, obstacle, nBounds);
            obstacle._obstacle = null;
            this.GetIntersectionObstacle(nBounds, obstacles);
            for (var nodeObstacle in obstacles) {
                this.RemoveObstacle(Extensions.getFromDictionary(obstacles, Extensions.KeytAt(obstacles, nodeObstacle)));
                delete obstacle._obstacle;
            }
            for (var nodeObstacle in obstacles) {
                var key = Extensions.KeytAt(obstacles, nodeObstacle);
                if (key.name !== obstacle.name)
                    this.AddNode(key);
            }
        }
    };
    Router.prototype.RemoveObstacle = function (nBounds) {
        this.portManager.temporaryAddition = false;
        this.isRemovingObstacle = true;
        this.vertexToRemove = {};
        this.horizontalSegmentTree.getCoordsToReconstruct().Clear();
        this.verticalSegmentTree.getCoordsToReconstruct().Clear();
        this.horizontalSegmentTree.InitializeVectorCoordinate(nBounds);
        this.verticalSegmentTree.InitializeVectorCoordinate(nBounds);
        this.ConnectSegmentDelegate(nBounds, true);
        this.ConnectSegmentDelegate(nBounds, false);
        this.horizontalSegmentTree.RemoveObstacle(nBounds, this);
        this.verticalSegmentTree.RemoveObstacle(nBounds, this);
        this.DisconnectVertexandEdges(this.horizontalSegmentTree);
        this.DisconnectVertexandEdges(this.verticalSegmentTree);
        this.horizontalSegmentTree.RemoveUnUsedVector();
        this.verticalSegmentTree.RemoveUnUsedVector();
        if (this.verticalSegmentTree.getVectors().Count() != 0) {
            var verticalCount = this.verticalSegmentTree.getVectors().Count();
            var horizontalCount = this.horizontalSegmentTree.getVectors().Count();
            var left = verticalCount > 0 ? Number(this.verticalSegmentTree.getVectors().KeyAt(0)) : 0;
            var top = horizontalCount > 0 ? Number(this.horizontalSegmentTree.getVectors().KeyAt(0)) : 0;
            var right = verticalCount > 0 ? Number(this.verticalSegmentTree.getVectors().KeyAt(this.verticalSegmentTree.getVectors().Count() - 1)) : 0;
            var bottom = horizontalCount > 0 ? Number(this.horizontalSegmentTree.getVectors().KeyAt(this.horizontalSegmentTree.getVectors().Count() - 1)) : 0;
            this.obstacleTree.Rectangle = new Rect(left, top, right - left, bottom - top);
            this.horizontalSegmentTree.ExpandOrCollapseSegmentTree(left, right);
            this.verticalSegmentTree.ExpandOrCollapseSegmentTree(top, bottom);
        }
        else
            this.obstacleTree.Rectangle = Rect.empty;
        this.currentBounds = this.obstacleTree.Rectangle;
        if (Extensions.Count(this.vertexToRemove) != 0) {
            for (var i in this.vertexToRemove) {
                this.graph.RemoveVertex(Extensions.getFromDictionary(this.vertexToRemove, Extensions.KeytAt(this.vertexToRemove, i)));
            }
            this.vertexToRemove = Extensions.Clear(this.vertexToRemove);
        }
        this.isRemovingObstacle = false;
        this.portManager.temporaryAddition = true;
    };
    Router.prototype.GetIntersectionObstacle = function (bounds, obstacles) {
        var intersectingObstacles = this.obstacleTree.FindNodes(bounds);
        for (var i = 0; i < intersectingObstacles.size(); i++) {
            var nodeObstacle = intersectingObstacles.get(Number(i));
            if (nodeObstacle._obstacle != null) {
                var nBounds = nodeObstacle._obstacle.getPaddedBounds().round();
                obstacles = Extensions.add(obstacles, nodeObstacle, nBounds);
                nodeObstacle._obstacle = null;
                this.GetIntersectionObstacle(nBounds, obstacles);
            }
        }
    };
    Router.prototype.SplitSegment = function (bounds, vector) {
        var topPt = Utility.ToRoundedInt(bounds.top()), bottomPt = Utility.ToRoundedInt(bounds.bottom());
        var leftPt = Utility.ToRoundedInt(bounds.left()), rightPt = Utility.ToRoundedInt(bounds.right());
        var perpSegmentTree = vector.getParentTree().getPerpendicularTree();
        var startSegment = vector.FindSegment(!vector.getIsVertical() ? leftPt : topPt);
        var endSegment = vector.FindSegment(!vector.getIsVertical() ? rightPt : bottomPt);
        var startPoint = !vector.getIsVertical() ? new Point(leftPt, vector.getCoord()) : new Point(vector.getCoord(), topPt);
        var endPoint = !vector.getIsVertical() ? new Point(rightPt, vector.getCoord()) : new Point(vector.getCoord(), bottomPt);
        if (startSegment != null) {
            var perpStartSegVector = perpSegmentTree.getVectors().GetValue(!vector.getIsVertical() ? leftPt : topPt);
            var perpStartSegment = perpStartSegVector.FindSegment(vector.getCoord());
            var direction = vector.getIsVertical() ? Directions.North : Directions.East;
            if (perpStartSegment != null) {
                this.RemoveEdgesBetween(startPoint, endPoint, direction);
            }
            else {
                var vertex = this.graph.FindVertex(startSegment.getStartPoint());
                while (vertex != null) {
                    var nextVertex = vertex.FindNextVertex(direction);
                    if (nextVertex && nextVertex.Point.OperatorLessThan(startPoint)) {
                        vertex = nextVertex;
                    }
                    else {
                        this.RemoveEdgesBetween(vertex.Point, endPoint, direction);
                        startSegment.UpdateSegmentPoint(vertex.Point, false);
                        startSegment.RemoveNotInRangeSharedCoordinates();
                        break;
                    }
                }
            }
        }
        if (endSegment != null) {
            var perpEndSegVector = perpSegmentTree.getVectors().GetValue(!vector.getIsVertical() ? rightPt : bottomPt);
            var perpEndSegment = perpEndSegVector.FindSegment(vector.getCoord());
            var direction = vector.getIsVertical() ? Directions.South : Directions.West;
            if (perpEndSegment != null) {
                this.RemoveEdgesBetween(endPoint, startPoint, direction);
            }
            else {
                var vertex = this.graph.FindVertex(endSegment.getEndPoint());
                while (vertex != null) {
                    var nextVertex = vertex.FindNextVertex(direction);
                    if (nextVertex != null && nextVertex.Point.OperatorGreaterThan(endPoint)) {
                        vertex = nextVertex;
                    }
                    else {
                        this.RemoveEdgesBetween(vertex.Point, startPoint, direction);
                        endSegment.UpdateSegmentPoint(vertex.Point, true);
                        endSegment.RemoveNotInRangeSharedCoordinates();
                        break;
                    }
                }
            }
        }
        this.RemoveUnsharedSegmentsFromVector(vector);
    };
    Router.prototype.RemoveEdgesBetween = function (startPoint, endPoint, direction) {
        var prevVertex = this.graph.FindVertex(startPoint);
        if (prevVertex != null) {
            var currentVertex = prevVertex.FindNextVertex(direction);
            var isStartLess = startPoint.OperatorLessThan(endPoint) ? true : false;
            while (currentVertex != null && ((isStartLess && currentVertex.Point.OperatorLessThan(endPoint)) || (!isStartLess && currentVertex.Point.OperatorGreaterThan(endPoint)))) {
                if (!Extensions.ContainsKey(this.vertexToRemove, currentVertex.Point))
                    this.vertexToRemove = Extensions.add(this.vertexToRemove, currentVertex.Point, currentVertex);
                var edge = this.graph.RemoveEdge(prevVertex, currentVertex);
                prevVertex = currentVertex;
                currentVertex = prevVertex.FindNextVertex(direction);
            }
            if (currentVertex != null) {
                this.graph.RemoveEdge(prevVertex, currentVertex);
            }
        }
    };
    Router.prototype.ConnectSegmentDelegate = function (bounds, isHorizontal) {
        var segmentTree = isHorizontal ? this.verticalSegmentTree : this.horizontalSegmentTree;
        var topPt = Utility.ToRoundedInt(bounds.top()), bottomPt = Utility.ToRoundedInt(bounds.bottom());
        var leftPt = Utility.ToRoundedInt(bounds.left()), rightPt = Utility.ToRoundedInt(bounds.right());
        var coord1 = segmentTree.getIsVertical() ? Utility.ToRoundedInt(bounds.left()) : Utility.ToRoundedInt(bounds.top());
        var coord2 = segmentTree.getIsVertical() ? Utility.ToRoundedInt(bounds.right()) : Utility.ToRoundedInt(bounds.bottom());
        var startIndex = segmentTree.getVectors().IndexOfKey(coord1);
        var endIndex = segmentTree.getVectors().IndexOfKey(coord2);
        var index = startIndex + 1;
        while (index < endIndex) {
            var vector = segmentTree.getVectors().GetValue(segmentTree.getVectors().KeyAt(index));
            var startSegment = vector.FindSegment(isHorizontal ? topPt : leftPt);
            var endSegment = vector.FindSegment(isHorizontal ? bottomPt : rightPt);
            var dir = isHorizontal ? Directions.North : Directions.East;
            if (startSegment != endSegment) {
                if (startSegment != null) {
                    var endPt = startSegment.getEndPoint();
                    var sharedCoordToRemove = isHorizontal ? Utility.ToRoundedInt(endPt.y) : Utility.ToRoundedInt(endPt.x);
                    startSegment.RemoveSharedCoordinates(sharedCoordToRemove);
                }
                if (endSegment != null) {
                    var startPt = endSegment.getStartPoint();
                    var sharedCoordToRemove = isHorizontal ? Utility.ToRoundedInt(startPt.y) : Utility.ToRoundedInt(startPt.x);
                    endSegment.RemoveSharedCoordinates(sharedCoordToRemove);
                }
                if (startSegment != null && endSegment != null) {
                    startSegment.UpdateSegmentPoint(endSegment.getEndPoint(), false);
                    for (var i = 0; i < endSegment.getSharedCoordinates().Count(); i++) {
                        var coordinate = endSegment.getSharedCoordinates().KeyAt(i);
                        var value = endSegment.getSharedCoordinates().GetValue(coordinate);
                        startSegment.getSharedCoordinates().Add(value, coordinate);
                    }
                    endSegment.getSharedCoordinates().Clear();
                    this.RefreshSegmentEgdes(startSegment);
                    vector.RemoveSegmentFromVector(endSegment);
                }
                else {
                    if (startSegment != null) {
                        var segment = this.GetMaximumVisibility(startSegment.getEndPoint(), dir);
                        if (segment == null) {
                            var mirrorPoint = dir == Directions.East ? new Point(rightPt, startSegment.getEndPoint().y) : new Point(startSegment.getEndPoint().x, bottomPt);
                            segment = this.GetMaximumVisibility(mirrorPoint, Extensions.OppositeDirection(dir));
                            if (segment != null && (segment.StartPoint.equals(startSegment.getStartPoint()) || segment.StartPoint.equals(startSegment.getEndPoint()))) {
                                var temp = this.GetMaximumVisibility(mirrorPoint, dir);
                                if (temp != null && !temp.StartPoint.equals(temp.EndPoint)) {
                                    segment.EndPoint = temp.EndPoint;
                                }
                                else
                                    segment = null;
                            }
                            else
                                segment = null;
                        }
                        if (segment != null) {
                            var segIndex = vector.getSegments().IndexOf(startSegment);
                            var nextSegment = null;
                            if (segIndex < vector.getSegments().size() - 1)
                                nextSegment = vector.getSegments().get(segIndex + 1);
                            if (nextSegment != null && nextSegment.getStartPoint().OperatorLessThan(segment.EndPoint)) {
                                startSegment.UpdateSegmentPoint(nextSegment.getEndPoint(), false);
                                for (var i = 0; i < nextSegment.getSharedCoordinates().Count(); i++) {
                                    coordinate = nextSegment.getSharedCoordinates().KeyAt(i);
                                    startSegment.getSharedCoordinates().Add(nextSegment.getSharedCoordinates().GetValue(coordinate), coordinate);
                                }
                                nextSegment.getSharedCoordinates().Clear();
                                this.RefreshSegmentEgdes(startSegment);
                                vector.RemoveSegmentFromVector(nextSegment);
                            }
                            else {
                                startSegment.UpdateSegmentPoint(segment.EndPoint, false);
                                this.RefreshSegmentEgdes(startSegment);
                            }
                        }
                    }
                    else if (endSegment != null) {
                        var segment = this.GetMaximumVisibility(endSegment.getStartPoint(), Extensions.OppositeDirection(dir));
                        if (segment == null) {
                            var mirrorPoint = dir == Directions.East ? new Point(leftPt, endSegment.getEndPoint().y) : new Point(endSegment.getEndPoint().x, topPt);
                            segment = this.GetMaximumVisibility(mirrorPoint, Extensions.OppositeDirection(dir));
                            if (segment != null && (segment.EndPoint.equals(endSegment.getStartPoint()) || segment.EndPoint.equals(endSegment.getEndPoint()))) {
                                var temp = this.GetMaximumVisibility(mirrorPoint, dir);
                                if (temp != null && !temp.StartPoint.equals(temp.EndPoint))
                                    segment.StartPoint = temp.StartPoint;
                                else
                                    segment = null;
                            }
                            else {
                                segment = null;
                            }
                        }
                        if (segment != null) {
                            var segIndex = vector.getSegments().IndexOf(endSegment);
                            var prevSegment = null;
                            if (segIndex > 0)
                                prevSegment = vector.getSegments().get(segIndex - 1);
                            if (prevSegment != null && prevSegment.getEndPoint().OperatorGreaterThan(segment.StartPoint)) {
                                prevSegment.UpdateSegmentPoint(endSegment.getEndPoint(), false);
                                for (var i = 0; i < endSegment.getSharedCoordinates().Count(); i++) {
                                    coordinate = endSegment.getSharedCoordinates().KeyAt(i);
                                    prevSegment.getSharedCoordinates().Add(endSegment.getSharedCoordinates().GetValue(coordinate), coordinate);
                                }
                                endSegment.getSharedCoordinates().Clear();
                                this.RefreshSegmentEgdes(prevSegment);
                                vector.RemoveSegmentFromVector(endSegment);
                            }
                            else {
                                endSegment.UpdateSegmentPoint(segment.StartPoint, true);
                                this.RefreshSegmentEgdes(endSegment);
                            }
                        }
                    }
                }
            }
            index++;
        }
    };
    Router.prototype.ExtendScanSegment = function (segment, point, isStart) {
        var vertex = isStart ? this.graph.FindVertex(segment.getStartPoint()) : this.graph.FindVertex(segment.getEndPoint());
        if (vertex != null) {
            if (isStart) {
                this.portManager.ConnectVertices_vertex(this.AddVertex(point), vertex);
            }
            else {
                this.portManager.ConnectVertices_vertex(vertex, this.AddVertex(point));
            }
        }
    };
    Router.prototype.ConstructVertexandEdges = function (segments) {
        for (var i = 0; i < segments.size(); i++)
            this.RefreshSegmentEgdes(segments.get(i));
    };
    Router.prototype.DisconnectVertexandEdges = function (segmentTree) {
        for (var i = 0; i < segmentTree.getCoordsToReconstruct().size(); i++) {
            this.RemoveUnsharedSegmentsFromVector(segmentTree.getVectors().GetValue(segmentTree.getCoordsToReconstruct().get(i)));
        }
        segmentTree.getCoordsToReconstruct().Clear();
    };
    Router.prototype.RemoveUnsharedSegmentsFromVector = function (vector) {
        var perpSegmentTree = !vector.getIsVertical() ? this.verticalSegmentTree : this.horizontalSegmentTree;
        var i = 0;
        while (i < vector.getSegments().size()) {
            var segment = vector.getSegments().get(i);
            if (segment.getSharedCoordinates().Count() != 0) {
                i++;
                continue;
            }
            else {
                var perpCoords = new List();
                var vertex = this.graph.FindVertex(segment.getStartPoint()), prev = null;
                var direction = vector.getIsVertical() ? Directions.North : Directions.East;
                while (vertex != null) {
                    var vertexPt = vertex.Point;
                    var perpSegmentCoord = vector.getIsVertical() ? Utility.ToRoundedInt(vertex.Point.y) : Utility.ToRoundedInt(vertex.Point.x);
                    if (perpSegmentTree.getVectors().Count() != 0 && perpSegmentTree.getVectors().ContainsKey(perpSegmentCoord)) {
                        var perpDirection = vector.getIsVertical() ? Directions.East : Directions.North;
                        if (this.portManager.DisconnectVertexInDirection(vertex, perpDirection)) {
                            perpCoords.add(perpSegmentCoord);
                        }
                        else {
                            var perpSegVector = perpSegmentTree.getVectors().GetValue(perpSegmentCoord);
                            var perpSegment = perpSegVector.FindSegment(vector.getCoord());
                            if (perpSegment != null) {
                                this.portManager.RemoveVertexFromSegment_vertex(perpSegment, vertex);
                                perpCoords.add(perpSegmentCoord);
                            }
                        }
                    }
                    if (!Extensions.ContainsKey(this.vertexToRemove, vertex.Point))
                        this.vertexToRemove = Extensions.add(this.vertexToRemove, vertex.Point, vertex);
                    if (prev != null)
                        this.graph.RemoveEdge(prev, vertex);
                    prev = vertex;
                    vertex = vertex.FindNextVertex(direction);
                    if (prev == vertex) {
                        vertex = null;
                    }
                }
                vector.RemoveSegmentFromVector(segment);
                for (var m = 0; m < perpCoords.size(); m++) {
                    var perpCoord = perpCoords.get(m);
                    if (perpSegmentTree.getVectors().ContainsKey(perpCoord) && !perpSegmentTree.getCoordsToReconstruct().contains(perpCoord))
                        this.RemoveUnsharedSegmentsFromVector(perpSegmentTree.getVectors().GetValue(perpCoord));
                }
            }
        }
    };
    Router.prototype.RefreshSegmentEgdes = function (segment) {
        if (segment != null && segment.getSharedCoordinates().Count() != 0) {
            var isSegVertical = segment.getIsVertical();
            var edgeDirection = isSegVertical ? Directions.North : Directions.East;
            var perpSegmentTree = !isSegVertical ? this.verticalSegmentTree : this.horizontalSegmentTree;
            var startIndex = perpSegmentTree.FindIndexNumber(segment.getStart());
            var endIndex = perpSegmentTree.FindIndexNumber(segment.getEnd());
            var segCoord = segment.getParentVector().getCoord();
            if (startIndex != endIndex) {
                var vertex = this.AddVertex(segment.getStartPoint());
                var perpVectors = Utility.ToList(perpSegmentTree.getVectors().Items()).GetRange(startIndex, endIndex - startIndex + 1);
                var perpVectors;
                for (var i = 0; i < perpVectors.size(); i++) {
                    var perpVector = perpVectors.get(i).value;
                    var perpScanSegment = perpVector.FindSegment(segCoord);
                    if (perpScanSegment != null) {
                        var intersectingPt = isSegVertical ? new Point(segCoord, perpVector.getCoord()) : new Point(perpVector.getCoord(), segCoord);
                        var newVertex = this.AddVertex(intersectingPt);
                        this.portManager.AddVertexToSegment(perpScanSegment, newVertex);
                        if (i != 0)
                            this.portManager.ConnectVertices_vertex(vertex, newVertex, 1, edgeDirection);
                        vertex = newVertex;
                    }
                    else if (i == perpVectors.size() - 1) {
                        var intersectingPt = isSegVertical ? new Point(segCoord, perpVector.getCoord()) : new Point(perpVector.getCoord(), segCoord);
                        this.portManager.ConnectVertices_vertex(vertex, this.AddVertex(intersectingPt), 1, edgeDirection);
                    }
                }
            }
        }
    };
    Router.prototype.GetScanSegmentsFromBounds = function (bounds, vector) {
        var segments = new List();
        var segmentTree = vector.getIsVertical() ? this.horizontalSegmentTree : this.verticalSegmentTree;
        var startIndex = segmentTree.FindIndex(bounds.topLeft().round());
        var endIndex = segmentTree.FindIndex(bounds.bottomRight().round());
        var coord = Utility.ToRoundedInt(bounds.left());
        var startPoint = vector.getCoord() === coord ? bounds.topLeft() : bounds.topRight();
        var endPoint = vector.getCoord() === coord ? bounds.bottomLeft() : bounds.bottomRight();
        if (!vector.getIsVertical()) {
            coord = Utility.ToRoundedInt(bounds.top());
            startPoint = vector.getCoord() === coord ? bounds.topLeft() : bounds.bottomLeft();
            endPoint = vector.getCoord() === coord ? bounds.topRight() : bounds.bottomRight();
        }
        startPoint = startPoint.round();
        endPoint = endPoint.round();
        if (startIndex != endIndex) {
            var index = startIndex;
            var prevIntersectingPt = new Point();
            while (index < endIndex) {
                var perpSegmentVector = segmentTree.getVectors().GetValue(segmentTree.getVectors().KeyAt(index));
                var perpScanSegment = perpSegmentVector.FindSegment(vector.getCoord());
                if (perpScanSegment != null) {
                    var startSegment = vector.FindSegment(!vector.getIsVertical() ? startPoint.x : startPoint.y);
                    var endSegment = vector.FindSegment(!vector.getIsVertical() ? endPoint.x : endPoint.y);
                    var intersectingPt = new Point(perpSegmentVector.Coord, vector.getCoord());
                    if (vector.getIsVertical()) {
                        intersectingPt = new Point(vector.getCoord(), perpSegmentVector.Coord);
                    }
                    if ((startSegment == null || !startSegment.Contains(intersectingPt)) && (endSegment == null || !endSegment.Contains(intersectingPt))) {
                        var point = new Point(perpSegmentVector.Coord + 1, vector.getCoord());
                        if (vector.getIsVertical())
                            point = new Point(vector.getCoord(), perpSegmentVector.Coord + 1);
                        if ((startSegment == null || !startSegment.Contains(point)) && (endSegment == null || !endSegment.Contains(point))) {
                            var segment = vector.GetScanSegment(point);
                            if (segment != null && !segments.contains(segment)) {
                                if (segment.getStartPoint().equals(intersectingPt)) {
                                    segments.add(segment);
                                }
                                else {
                                    vector.RemoveSegmentFromVector(segment);
                                }
                            }
                            else if (segment == null) {
                                if (index > startIndex) {
                                    var tempPt = new Point(perpSegmentVector.Coord - 1, vector.getCoord());
                                    if (vector.getIsVertical()) {
                                        tempPt = new Point(vector.getCoord(), perpSegmentVector.Coord - 1);
                                    }
                                    if (tempPt.equals(prevIntersectingPt)) {
                                        vector.GetScanSegment_startPoint(tempPt, intersectingPt);
                                    }
                                }
                            }
                        }
                    }
                    prevIntersectingPt = intersectingPt;
                }
                index++;
            }
        }
        return segments;
    };
    Router.prototype.GetPossibleEntries = function (sourcePort, targetPort) {
        var bendCount = 2;
        var possibleEntries = new List();
        var preferredDirectons = new List();
        var inversePreDir = new List();
        var sourceEntries = this.portManager.FindEntrances(sourcePort);
        var targetEntries = this.portManager.FindEntrances(targetPort);
        var srcLocation = sourcePort.getLocation();
        var tarLocation = targetPort.getLocation();
        preferredDirectons.add(Extensions.FindDirection_orientation(srcLocation, tarLocation, Orientation.Horizontal));
        preferredDirectons.add(Extensions.FindDirection_orientation(srcLocation, tarLocation, Orientation.Vertical));
        for (var i = 0; i < preferredDirectons.size(); i++) {
            var directon = preferredDirectons.get(i);
            inversePreDir.add(Extensions.OppositeDirection(directon));
        }
        for (var i = 0; i < sourceEntries.size(); i++) {
            var srcEntry = sourceEntries.get(i);
            for (var j = 0; j < targetEntries.size(); j++) {
                var tarEntry = targetEntries.get(j);
                var isTarAtTop = srcEntry.Point.y > tarEntry.Point.y;
                var isTarAtLeft = srcEntry.Point.x > tarEntry.Point.x;
                if (srcEntry.getEastEdge() != null) {
                    var isPreferred = preferredDirectons.contains(Directions.East);
                    if (tarEntry.getEastEdge() != null) {
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry));
                    }
                    if (tarEntry.getWestEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.West);
                        bendCount = isTarAtLeft ? 4 : 2;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getSouthEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.South);
                        bendCount = !isTarAtTop && !isTarAtLeft ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getNorthEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.North);
                        bendCount = isTarAtTop && !isTarAtLeft ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                }
                if (srcEntry.getWestEdge() != null) {
                    var isPreferred = preferredDirectons.contains(Directions.West);
                    if (tarEntry.getWestEdge() != null) {
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry));
                    }
                    if (tarEntry.getEastEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.East);
                        bendCount = isTarAtLeft ? 2 : 4;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getSouthEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.South);
                        bendCount = !isTarAtTop && isTarAtLeft ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getNorthEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.North);
                        bendCount = isTarAtTop && isTarAtLeft ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                }
                if (srcEntry.getNorthEdge() != null) {
                    var isPreferred = preferredDirectons.contains(Directions.North);
                    if (tarEntry.getNorthEdge() != null) {
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry));
                    }
                    if (tarEntry.getSouthEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.South);
                        bendCount = isTarAtTop ? 4 : 2;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getEastEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.East);
                        bendCount = !isTarAtTop && isTarAtLeft ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getWestEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.West);
                        bendCount = !isTarAtTop && !isTarAtLeft ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                }
                if (srcEntry.getSouthEdge() != null) {
                    var isPreferred = preferredDirectons.contains(Directions.South);
                    if (tarEntry.getSouthEdge() != null) {
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry));
                    }
                    if (tarEntry.getNorthEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.North);
                        bendCount = isTarAtTop ? 2 : 4;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getEastEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.East);
                        bendCount = isTarAtLeft && isTarAtTop ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                    if (tarEntry.getWestEdge() != null) {
                        isPreferred = isPreferred && inversePreDir.contains(Directions.West);
                        bendCount = isTarAtTop && !isTarAtLeft ? 1 : 3;
                        possibleEntries.add(new ConnectablePath(bendCount, srcEntry, tarEntry, isPreferred));
                    }
                }
            }
        }
        return this.sortPossibleEntries(possibleEntries);
    };
    Router.prototype.sortPossibleEntries = function (possibleEntries) {
        var falseReturn = new List();
        var trueReturn = new List();
        for (var i = 0; i < possibleEntries.size(); i++) {
            var tempEntries = possibleEntries.get(i);
            if (!tempEntries.getIsPreferred())
                falseReturn.add(tempEntries);
            else
                trueReturn.add(tempEntries);
        }
        falseReturn.sortByKey("MinimalBend");
        trueReturn.sortByKey("MinimalBend");
        possibleEntries.Clear();
        possibleEntries.AddRange(trueReturn);
        possibleEntries.AddRange(falseReturn);
        return possibleEntries;
    };
    return Router;
}());
var ConnectablePath = (function () {
    function ConnectablePath(minimalBend, source, target, isPerferred) {
        if (isPerferred === void 0) { isPerferred = false; }
        this.m_MinimalBend = minimalBend;
        this.m_SourceEntry = source;
        this.m_TargetEntry = target;
        this.m_IsPreferred = isPerferred;
    }
    ConnectablePath.prototype.getMinimalBend = function () {
        return this.m_MinimalBend;
    };
    ConnectablePath.prototype.getIsPreferred = function () {
        return this.m_IsPreferred;
    };
    ConnectablePath.prototype.getSourceEntry = function () {
        return this.m_SourceEntry;
    };
    ConnectablePath.prototype.getTargetEntry = function () {
        return this.m_TargetEntry;
    };
    return ConnectablePath;
}());
var SegmentTree = (function () {
    function SegmentTree(isVertical, router) {
        this._mStart = Number.MAX_VALUE;
        this._mEnd = Number.MIN_VALUE;
        this._mIsVertical = false;
        this.unUsedVectors = new List();
        this._mIsVertical = isVertical;
        this._mOrientation = isVertical ? SegmentOrientation.Vertical : SegmentOrientation.Horizontal;
        this._mRouter = router;
        this._mVectors = new SortedList();
        this._mCoordsToReconstruct = new List();
    }
    SegmentTree.prototype.getStart = function () {
        return this._mStart;
    };
    SegmentTree.prototype.setStart = function (value) {
        this._mStart = Math.floor(value);
    };
    SegmentTree.prototype.getEnd = function () {
        return this._mEnd;
    };
    SegmentTree.prototype.setEnd = function (value) {
        this._mEnd = Math.floor(value);
    };
    SegmentTree.prototype.getIsVertical = function () {
        return this._mIsVertical;
    };
    SegmentTree.prototype.getOrientation = function () {
        return this._mOrientation;
    };
    SegmentTree.prototype.getCoordsToReconstruct = function () {
        return this._mCoordsToReconstruct;
    };
    SegmentTree.prototype.setCoordsToReconstruct = function (value) {
        this._mCoordsToReconstruct = value != null ? value : new List();
    };
    SegmentTree.prototype.getVectors = function () {
        return this._mVectors;
    };
    SegmentTree.prototype.setVectors = function (value) {
        this._mVectors = value != null ? value : new SortedList();
    };
    SegmentTree.prototype.getPerpendicularTree = function () {
        return this._mPerpendicularTree;
    };
    SegmentTree.prototype.setPerpendicularTree = function (value) {
        this._mPerpendicularTree = value;
    };
    SegmentTree.prototype.getRouter = function () {
        return this._mRouter;
    };
    SegmentTree.prototype.setRouter = function (value) {
        this._mRouter = value;
    };
    SegmentTree.prototype.UpdateTreePoints = function () {
        if (this._mVectors.Count() != 0) {
            var startVector = this._mVectors.GetValue(this._mVectors.KeyAt(0));
            var endVector = this._mVectors.GetValue(this._mVectors.KeyAt(this._mVectors.Count() - 1));
            this.UpdateTreePoint(startVector.getStart(), true);
            this.UpdateTreePoint(endVector.getEnd(), false);
        }
        else {
            this.UpdateTreePoint(Number.MAX_VALUE, true);
            this.UpdateTreePoint(Number.MIN_VALUE, false);
        }
    };
    SegmentTree.prototype.UpdateTreePoint = function (point, isStart, isExpanding) {
        if (isExpanding === void 0) { isExpanding = false; }
        if (isStart && this._mStart != point)
            this._mStart = point;
        else if (!isStart && this._mEnd != point)
            this._mEnd = point;
        if (!isExpanding && this._mVectors.Count() == 0) {
            if (isStart)
                this._mStart = Number.MAX_VALUE;
            else
                this._mEnd = Number.MIN_VALUE;
        }
    };
    SegmentTree.prototype.ExpandOrCollapseSegmentTree = function (newStart, newEnd, isExpanding) {
        if (isExpanding === void 0) { isExpanding = false; }
        if (isExpanding) {
            for (var i in this._mVectors.Items()) {
                var vector = this._mVectors.ElementAt(i);
                if (this._mStart != newStart)
                    vector.ExpandSegmentVector(newStart, this._mStart, true);
                if (this._mEnd != newEnd)
                    vector.ExpandSegmentVector(newEnd, this._mEnd, false);
            }
        }
        this.UpdateTreePoint(newStart, true, isExpanding);
        this.UpdateTreePoint(newEnd, false, isExpanding);
    };
    SegmentTree.prototype.InitializeVectorCoordinate = function (bounds) {
        var vectorCoord1 = this._mIsVertical ? Utility.ToRoundedInt(bounds.left()) : Utility.ToRoundedInt(bounds.top());
        if (!(this._mVectors.ContainsKey(vectorCoord1))) {
            this._mVectors.Add(new SegmentVector(vectorCoord1, this._mStart, this._mEnd, this._mOrientation, this), vectorCoord1);
            this.unUsedVectors.add(vectorCoord1);
        }
        var vectorCoord2 = this._mIsVertical ? Utility.ToRoundedInt(bounds.right()) : Utility.ToRoundedInt(bounds.bottom());
        if (!this._mVectors.ContainsKey(vectorCoord2)) {
            this._mVectors.Add(new SegmentVector(vectorCoord2, this._mStart, this._mEnd, this._mOrientation, this), vectorCoord2);
            this.unUsedVectors.add(vectorCoord2);
        }
    };
    SegmentTree.prototype.RemoveVectorCoordinate = function (vector, skipUpdatingTree, index) {
        if (skipUpdatingTree === void 0) { skipUpdatingTree = false; }
        if (vector.getSegments().size() == 0) {
            this._mVectors.Remove(vector.getCoord());
            vector = null;
            if (skipUpdatingTree)
                this.UpdateTreePoints();
        }
    };
    SegmentTree.prototype.InsertObstacle = function (bounds) {
        var vectorCoords = new List();
        vectorCoords.add(this._mIsVertical ? Utility.ToRoundedInt(bounds.left()) : Utility.ToRoundedInt(bounds.top()));
        vectorCoords.add(this._mIsVertical ? Utility.ToRoundedInt(bounds.right()) : Utility.ToRoundedInt(bounds.bottom()));
        for (var i = 0; i < vectorCoords.size(); i++) {
            var vectorCoord = vectorCoords.get(i);
            var vector = this._mVectors.GetValue(vectorCoord);
            var segments = vector.InsertObstacle(bounds);
            vector.UpdateVectorPoints();
            if (segments.size() != 0) {
                for (var j = 0; j < segments.size(); j++) {
                    this._mRouter.RefreshSegmentEgdes(segments.get(j));
                }
                if (this.unUsedVectors.contains(vectorCoord))
                    this.unUsedVectors.Remove(vectorCoord);
            }
        }
    };
    SegmentTree.prototype.RemoveObstacle = function (bounds, router) {
        var segCollection1 = new List();
        var segCollection2 = new List();
        var vectorPoint1 = Math.floor(this._mIsVertical ? bounds.left() : bounds.top());
        var vectorPoint2 = Math.floor(this._mIsVertical ? bounds.right() : bounds.bottom());
        if (this._mVectors.ContainsKey(vectorPoint1)) {
            this._mCoordsToReconstruct.add(Math.floor(vectorPoint1));
            var args = this._mVectors.GetValue(vectorPoint1).RemoveObstacle(bounds, segCollection1);
            segCollection1 = args.SegCollection;
        }
        if (this._mVectors.ContainsKey(vectorPoint2)) {
            this._mCoordsToReconstruct.add(Math.floor(vectorPoint2));
            var args = this._mVectors.GetValue(vectorPoint2).RemoveObstacle(bounds, segCollection2);
            segCollection2 = args.SegCollection;
        }
        return null;
    };
    SegmentTree.prototype.SplitSegments = function (bounds) {
        var coord1 = this._mIsVertical ? Utility.ToRoundedInt(bounds.left()) : Utility.ToRoundedInt(bounds.top());
        var coord2 = this._mIsVertical ? Utility.ToRoundedInt(bounds.right()) : Utility.ToRoundedInt(bounds.bottom());
        var startIndex = this._mVectors.IndexOfKey(coord1), endIndex = this._mVectors.IndexOfKey(coord2);
        for (var index = startIndex + 1; index < endIndex; index++) {
            var vector = this._mVectors.GetValue(this._mVectors.KeyAt(index));
            vector.SplitSegment(bounds);
            this._mRouter.SplitSegment(bounds, vector);
        }
    };
    SegmentTree.prototype.RemoveUnUsedVector = function () {
        for (var i = 0; i < this.unUsedVectors.size(); i++)
            this.RemoveVectorCoordinate(this._mVectors.GetValue(this.unUsedVectors.get(i)), null);
        this.unUsedVectors.Clear();
    };
    SegmentTree.prototype.UpdateUnUsedVector = function (coord) {
        if (!this.unUsedVectors.contains(coord))
            this.unUsedVectors.add(coord);
    };
    SegmentTree.prototype.FindLast = function (point) {
        var mid = 0;
        var low = 0;
        var high = this._mVectors.Count() - 1;
        var lastVector = null;
        if (!this._mIsVertical) {
            var coord = point.y - 0.00001;
            while (high - low > 1) {
                mid = Math.floor((low + high) / 2);
                var obj = this._mVectors.ElementAt(mid);
                if (obj && obj.getCoord() < coord) {
                    low = Math.floor(mid);
                }
                else {
                    high = Math.floor(mid);
                }
            }
            var obj = this._mVectors.ElementAt(high);
            if (obj && coord > obj.getCoord()) {
                low = Math.floor(high);
            }
            var obj = this._mVectors.ElementAt(low);
            if (obj && coord > obj.getCoord()) {
                while (low > -1 && (this._mVectors.ElementAt(low).GetStart().x > point.x || this._mVectors.ElementAt(low).GetEnd().x < point.x)) {
                    low--;
                }
                if (low > -1)
                    lastVector = this._mVectors.ElementAt(low);
            }
            if (lastVector != null) {
                var index = low;
                while (index >= 0) {
                    var segment = this._mVectors.ElementAt(index).FindSegment(Utility.ToRoundedInt(point.x));
                    if (segment != null)
                        return segment;
                    index--;
                }
            }
        }
        else {
            var coord = point.x - 0.00001;
            while (high - low > 1) {
                mid = Math.floor(((low + high) / 2));
                var obj1 = this._mVectors.ElementAt(mid);
                if (obj1 && obj1.getCoord() < coord) {
                    low = mid;
                }
                else {
                    high = mid;
                }
            }
            var obj2 = this._mVectors.ElementAt(high);
            if (obj2 && coord > obj2.getCoord()) {
                low = high;
            }
            var obj3 = this._mVectors.ElementAt(low);
            if (obj3 && coord > obj3.getCoord()) {
                while (low > -1 && (this._mVectors.ElementAt(low).GetStart().y > point.y || this._mVectors.ElementAt(low).GetEnd().y < point.y)) {
                    low--;
                }
                if (low > -1)
                    lastVector = this._mVectors.ElementAt(low);
            }
            if (lastVector != null) {
                var index = low;
                while (index >= 0) {
                    var segment = this._mVectors.ElementAt(index).FindSegment(Utility.ToRoundedInt(point.y));
                    if (segment != null)
                        return segment;
                    index--;
                }
            }
        }
        return null;
    };
    SegmentTree.prototype.FindFirst = function (point) {
        var mid = 0;
        var low = 0;
        var high = this._mVectors.Count() - 1;
        var startVector = null;
        if (!this._mIsVertical) {
            var coord = point.y + 0.00001;
            while (high - low > 1) {
                mid = Math.floor((low + high) / 2);
                var obj = this._mVectors.ElementAt(mid);
                if (obj && obj.getCoord() < coord) {
                    low = Math.floor(mid);
                }
                else {
                    high = Math.floor(mid);
                }
            }
            var obj = this._mVectors.ElementAt(low);
            if (obj && coord <= obj.getCoord())
                high = Math.floor(low);
            var obj = this._mVectors.ElementAt(high);
            if (obj && coord < obj.getCoord()) {
                while (high < this._mVectors.Count() && (this._mVectors.ElementAt(high).GetStart().x > point.x || this._mVectors.ElementAt(high).GetEnd().x < point.x)) {
                    high++;
                }
                if (high < this._mVectors.Count())
                    startVector = this._mVectors.ElementAt(high);
            }
            if (startVector != null) {
                var index = high;
                while (index < this._mVectors.Count()) {
                    var segment = this._mVectors.ElementAt(index).FindSegment(Utility.ToRoundedInt(point.x));
                    if (segment != null)
                        return segment;
                    index++;
                }
            }
        }
        else {
            var coord = point.x + 0.0001;
            while (high - low > 1) {
                mid = Math.floor((low + high) / 2);
                var obj = this._mVectors.ElementAt(mid);
                if (obj && obj.getCoord() < coord) {
                    low = mid;
                }
                else {
                    high = mid;
                }
            }
            var obj = this._mVectors.ElementAt(low);
            if (obj && coord <= obj.getCoord())
                high = low;
            var obj = this._mVectors.ElementAt(high);
            if (obj && coord <= obj.getCoord()) {
                while (high < this._mVectors.Count() && (this._mVectors.ElementAt(high).GetStart().y > point.y || this._mVectors.ElementAt(high).GetEnd().y < point.y)) {
                    high++;
                }
                if (high < this._mVectors.Count())
                    startVector = this._mVectors.ElementAt(high);
            }
            if (startVector != null) {
                var index = high;
                while (index < this._mVectors.Count()) {
                    var segment = this._mVectors.ElementAt(index).FindSegment(Utility.ToRoundedInt(point.y));
                    if (segment != null)
                        return segment;
                    index++;
                }
            }
        }
        return null;
    };
    SegmentTree.prototype.FindIndex = function (point) {
        if (!this._mIsVertical) {
            if (this._mVectors.ContainsKey(Utility.ToRoundedInt(point.y))) {
                return this._mVectors.IndexOfKey(Utility.ToRoundedInt(point.y));
            }
        }
        else {
            if (this._mVectors.ContainsKey(Utility.ToRoundedInt(point.x))) {
                return this._mVectors.IndexOfKey(Utility.ToRoundedInt(point.x));
            }
        }
        return -1;
    };
    SegmentTree.prototype.FindIndexNumber = function (point) {
        if (this._mVectors.ContainsKey(point))
            return this._mVectors.IndexOfKey(point);
        return 0;
    };
    SegmentTree.prototype.FindFirstIndex = function (point) {
        var mid = 0;
        var low = 0;
        var high = this._mVectors.Count() - 1;
        var startVector = null;
        if (!this._mIsVertical) {
            var coord = point.y + 0.00001;
            while (high - low > 1) {
                mid = Math.floor((low + high) / 2);
                if (this._mVectors.ElementAt(mid).Coord < coord) {
                    low = Math.floor(mid);
                }
                else {
                    high = Math.floor(mid);
                }
            }
            if (coord <= this._mVectors.ElementAt(low).Coord) {
                high = low;
            }
            if (coord < this._mVectors.ElementAt(high).Coord) {
                while (high < this._mVectors.Count() && (this._mVectors.ElementAt(high).GetStart().x > point.x || this._mVectors.ElementAt(high).GetEnd().x < point.x)) {
                    high++;
                }
                if (high < this._mVectors.Count())
                    return high;
            }
        }
        else {
            var coord = point.x + 0.0001;
            while (high - low > 1) {
                mid = Math.floor((low + high) / 2);
                if (this._mVectors.ElementAt(mid).Coord < coord) {
                    low = Math.floor(mid);
                }
                else {
                    high = Math.floor(mid);
                }
            }
            if (coord <= this._mVectors.ElementAt(low).Coord)
                high = Math.floor(low);
            if (coord <= this._mVectors.ElementAt(high).Coord) {
                while (high < this._mVectors.Count() && (this._mVectors.ElementAt(high).GetStart().y > point.y || this._mVectors.ElementAt(high).GetEnd().y < point.y)) {
                    high++;
                }
                if (high < this._mVectors.Count())
                    return high;
            }
        }
        return -1;
    };
    SegmentTree.prototype.FindSegment = function (index, point, segmentCoord) {
        if (index < this._mVectors.Count() && index >= 0) {
            var coord = Utility.ToRoundedInt(point.y);
            if (!this._mIsVertical) {
                coord = Utility.ToRoundedInt(point.x);
            }
            segmentCoord = this._mVectors.ElementAt(index);
            return this._mVectors[segmentCoord].FindSegment(coord);
        }
        return null;
    };
    SegmentTree.prototype.FindScanSegment = function (point) {
        if (this._mIsVertical) {
            if (this._mVectors.ContainsKey(Utility.ToRoundedInt(point.y))) {
                return this._mVectors[Utility.ToRoundedInt(point.y)].FindSegment(Utility.ToRoundedInt(point.x));
            }
        }
        else {
            if (this._mVectors.ContainsKey(Utility.ToRoundedInt(point.x))) {
                return this._mVectors[Utility.ToRoundedInt(point.x)].FindSegment(Utility.ToRoundedInt(point.y));
            }
        }
        return null;
    };
    SegmentTree.prototype.GetEdgePassingThroughVertex = function (newVertex, perpendicularVectorCoord) {
        var vertexPt = newVertex.Point;
        var vertexCoordIndex = this._mVectors.IndexOfKey(this._mIsVertical ? Utility.ToRoundedInt(vertexPt.x) : Utility.ToRoundedInt(vertexPt.y));
        if (vertexCoordIndex != -1) {
            var dir = this._mIsVertical ? Directions.East : Directions.North;
            var prevVertex = null, nextVertex = null;
            var graph = this._mRouter.graph;
            for (var i = vertexCoordIndex - 1; i >= 0; i--) {
                var vectorCoord = Number(this._mVectors.KeyAt(i));
                if (this._mIsVertical) {
                    prevVertex = graph.FindVertexNumber(vectorCoord, perpendicularVectorCoord);
                }
                else {
                    prevVertex = graph.FindVertexNumber(perpendicularVectorCoord, vectorCoord);
                }
                if (prevVertex != null) {
                    nextVertex = prevVertex.FindNextVertex(dir);
                    if (nextVertex != null)
                        return this._mIsVertical ? prevVertex.getEastEdge() : prevVertex.getNorthEdge();
                }
            }
            for (var i = vertexCoordIndex + 1; i <= this._mVectors.Count() - 1; i++) {
                var vectorCoord = Number(this._mVectors.KeyAt(i));
                if (this._mIsVertical) {
                    nextVertex = graph.FindVertexNumber(vectorCoord, perpendicularVectorCoord);
                }
                else {
                    nextVertex = graph.FindVertexNumber(perpendicularVectorCoord, vectorCoord);
                }
                if (nextVertex != null) {
                    prevVertex = nextVertex.FindNextVertex(Extensions.OppositeDirection(dir));
                    if (prevVertex != null)
                        return this._mIsVertical ? prevVertex.getEastEdge() : prevVertex.getNorthEdge();
                }
            }
        }
        return null;
    };
    return SegmentTree;
}());
var SegmentVector = (function () {
    function SegmentVector(coord, start, end, orientation, parentTree) {
        this._mStart = 0;
        this._mEnd = 0;
        this._mCoord = 0;
        this._mIsVertical = false;
        this._mCoord = coord;
        this._mStart = start;
        this._mEnd = end;
        this._mParentTree = parentTree;
        this._mOrientation = orientation;
        this._mIsVertical = this._mOrientation == SegmentOrientation.Vertical;
        this._mSegments = new List();
    }
    SegmentVector.prototype.getStart = function () {
        return this._mStart;
    };
    SegmentVector.prototype.setStart = function (value) {
        this._mStart = value;
    };
    SegmentVector.prototype.getEnd = function () {
        return this._mEnd;
    };
    SegmentVector.prototype.setEnd = function (value) {
        this._mEnd = value;
    };
    SegmentVector.prototype.getCoord = function () {
        return this._mCoord;
    };
    SegmentVector.prototype.setCoord = function (value) {
        this._mCoord = Math.floor(value);
    };
    SegmentVector.prototype.getSegments = function () {
        return this._mSegments;
    };
    SegmentVector.prototype.setSegments = function (value) {
        this._mSegments = value;
    };
    SegmentVector.prototype.getOrientation = function () {
        return this._mOrientation;
    };
    SegmentVector.prototype.getIsVertical = function () {
        return this._mIsVertical;
    };
    SegmentVector.prototype.getParentTree = function () {
        return this._mParentTree;
    };
    SegmentVector.prototype.UpdateVectorPoints = function (isTreeExpansion) {
        if (isTreeExpansion === void 0) { isTreeExpansion = false; }
        if (this._mSegments.size() != 0) {
            var startSegment = this._mSegments.get(0), endSegment = this._mSegments.get(this._mSegments.size() - 1);
            this.UpdateVectorPoint(startSegment.getStart(), true, isTreeExpansion);
            this.UpdateVectorPoint(endSegment.getEnd(), false, isTreeExpansion);
        }
    };
    SegmentVector.prototype.UpdateVectorPoint = function (point, isStart, isTreeExpansion) {
        if (isTreeExpansion === void 0) { isTreeExpansion = false; }
        var doTreeUpdate = false;
        if (isStart && this._mStart != point) {
            this._mStart = point;
            doTreeUpdate = true;
        }
        else if (!isStart && this._mEnd != point) {
            this._mEnd = point;
            doTreeUpdate = true;
        }
        if (doTreeUpdate && this._mParentTree != null && !isTreeExpansion) {
            this._mParentTree.UpdateTreePoints();
        }
    };
    SegmentVector.prototype.AddSegmentToVector = function (segment, index) {
        if (index === void 0) { index = -1; }
        if (index == -1) {
            index = 0;
            var low = 0, high = this._mSegments.size() - 1;
            var segmentStart = segment.getStart();
            if (this._mSegments.size() == 1) {
                if (segmentStart >= this._mSegments.get(0).getStart())
                    index++;
            }
            else if (this._mSegments.size() > 1) {
                while (high - low > 1) {
                    var mid = Math.floor((low + high) / 2);
                    if (segmentStart >= this._mSegments.get(mid).getStart()) {
                        low = Math.floor(mid);
                    }
                    else {
                        high = Math.floor(mid);
                    }
                }
                var lowSegment = this._mSegments.get(low), highSegment = this._mSegments.get(high);
                if (segmentStart < lowSegment.getStart())
                    index = Math.floor(low);
                else if (segmentStart > highSegment.getStart())
                    index = high + 1;
                else
                    index = high;
            }
        }
        this._mSegments.Insert(index, segment);
        this.UpdateVectorPoints();
    };
    SegmentVector.prototype.RemoveSegmentFromVector = function (segment) {
        if (this._mSegments.size() != 0 && (segment.getSharedCoordinates().Count() == 0 || segment.getStart() === segment.getEnd())) {
            this._mSegments.Remove(segment);
            segment = null;
            this.UpdateVectorPoints();
        }
        if (this._mSegments.size() == 0)
            this._mParentTree.UpdateUnUsedVector(this._mCoord);
    };
    SegmentVector.prototype.ExpandSegmentVector = function (newTreeCoord, currentTreeCoord, isStart) {
        if (this._mSegments.size() != 0) {
            var segment = isStart ? this._mSegments.get(0) : this._mSegments.get(this._mSegments.size() - 1);
            var segPoint = isStart ? segment.getStartPoint() : segment.getEndPoint();
            var segTerminalPoint = isStart ? segment.getStart() : segment.getEnd();
            if (segTerminalPoint === currentTreeCoord && segTerminalPoint !== newTreeCoord) {
                var pt = this._mIsVertical ? new Point(segPoint.x, newTreeCoord) : new Point(newTreeCoord, segPoint.y);
                this._mParentTree.getRouter().ExtendScanSegment(segment, pt, isStart);
                segment.UpdateSegmentPoint(pt, isStart, true);
            }
        }
    };
    SegmentVector.prototype.InsertObstacle = function (bounds) {
        var top = Utility.ToRoundedInt(bounds.top()), bottom = Utility.ToRoundedInt(bounds.bottom());
        var left = Utility.ToRoundedInt(bounds.left()), right = Utility.ToRoundedInt(bounds.right());
        var segment1 = null, segment2 = null;
        var startPoint = this._mIsVertical ? new Point(this._mCoord, top) : new Point(left, this._mCoord);
        var endPoint = this._mIsVertical ? new Point(this._mCoord, bottom) : new Point(right, this._mCoord);
        var startCorner = this._mIsVertical ? top : left;
        var endCorner = this._mIsVertical ? bottom : right;
        segment1 = segment2 = this.GetScanSegment(startPoint);
        if (segment1 == null || segment1.getEnd() < endCorner)
            segment2 = this.GetScanSegment(endPoint);
        if (segment1 != null) {
            segment1.UpdateSharedCoordinates(startCorner);
            if (segment1.getEnd() < endCorner || (segment2 == null && segment1.getEnd() == endCorner))
                segment1.UpdateSharedCoordinates(segment1.getEnd());
        }
        if (segment2 != null) {
            segment2.UpdateSharedCoordinates(endCorner);
            if (segment2.getStart() > startCorner || (segment1 == null && segment2.getStart() == startCorner))
                segment2.UpdateSharedCoordinates(segment2.getStart());
        }
        var segments = this.GetScanSegmentsFromBounds(bounds, segment1, segment2);
        if (segments.size() != 0) {
            for (var i = 0; i < segments.size(); i++) {
                var segment = segments.get(i);
                if (segment != segment1 && segment != segment2) {
                    segment.UpdateSharedCoordinates(segment.getStart());
                    segment.UpdateSharedCoordinates(segment.getEnd());
                }
            }
        }
        if (segment1 != null)
            segments.Insert(0, segment1);
        if (segment1 != segment2)
            segments.Insert(segments.size(), segment2);
        return segments;
    };
    SegmentVector.prototype.RemoveObstacle_Where = function (Segments, startCorner, endCorner) {
        var segs = [];
        var count = this._mSegments.size();
        for (var i = 0; i < count; i++) {
            var segment = Segments.get(i);
            segs.push(segment);
        }
        segs.sort(function (a, b) {
            if (a.getStart() > startCorner && a.getEnd() < endCorner) {
                return 1;
            }
            else {
                return -1;
            }
        });
        var retList = new List();
        for (var i = 0; i < segs.length; i++) {
            retList.add(segs[i]);
        }
        return retList;
    };
    SegmentVector.prototype.RemoveObstacle = function (bounds, SegCollection) {
        var top = Utility.ToRoundedInt(bounds.top()), bottom = Utility.ToRoundedInt(bounds.bottom());
        var left = Utility.ToRoundedInt(bounds.left()), right = Utility.ToRoundedInt(bounds.right());
        SegCollection = new List();
        var startCorner = this._mIsVertical ? top : left;
        var endCorner = this._mIsVertical ? bottom : right;
        var segment1 = this.FindSegment(startCorner);
        var segment2 = this.FindSegment(endCorner);
        if (segment1 != null) {
            SegCollection.add(segment1);
            segment1.RemoveSharedCoordinates(startCorner);
            if (segment1.getEnd() < endCorner)
                segment1.RemoveSharedCoordinates(segment1.getEnd());
        }
        if (segment2 != null) {
            if (!SegCollection.contains(segment2))
                SegCollection.add(segment2);
            segment2.RemoveSharedCoordinates(endCorner);
            if (segment2.getStart() > startCorner)
                segment2.RemoveSharedCoordinates(segment2.getStart());
        }
        var segs = this.RemoveObstacle_Where(this._mSegments, startCorner, endCorner);
        if (segs.size() != 0) {
            for (var i = 0; i < segs.size(); i++) {
                var segment = segs.get(i);
                var keyIndex = 0;
                var sharedCoords = Object.keys(segment.getSharedCoordinates());
                while (keyIndex < sharedCoords.length) {
                    var sharedCoord = Number(sharedCoords[keyIndex]);
                    segment.RemoveSharedCoordinates(sharedCoord);
                    keyIndex++;
                }
            }
        }
        return { isRemove: false, SegCollection: SegCollection };
    };
    SegmentVector.prototype.SplitSegment = function (bounds) {
        if (this._mSegments.size() != 0) {
            var top = Utility.ToRoundedInt(bounds.top()), bottom = Utility.ToRoundedInt(bounds.bottom());
            var left = Utility.ToRoundedInt(bounds.left()), right = Utility.ToRoundedInt(bounds.right());
            var startCorner = this._mIsVertical ? top : left;
            var endCorner = this._mIsVertical ? bottom : right;
            var segment1 = null, segment2 = null;
            segment1 = segment2 = this.FindSegment(startCorner);
            if (segment1 == null || segment1.getEnd() < endCorner)
                segment2 = this.FindSegment(endCorner);
            var newfirstSegEnd = this._mIsVertical ? new Point(this._mCoord, top) : new Point(left, this._mCoord);
            var newSecSegStart = this._mIsVertical ? new Point(this._mCoord, bottom) : new Point(right, this._mCoord);
            if (segment1 != null && segment2 != null && segment1 == segment2) {
                segment2 = this.GetScanSegment_startPoint(newSecSegStart, segment1.getEndPoint(), this._mSegments.IndexOf(segment1) + 1);
                segment2.setSharedCoordinates(segment1.getSharedCoordinates().Clone());
                segment1.UpdateSegmentPoint(newfirstSegEnd, false);
            }
            else {
                if (segment1 != null)
                    segment1.UpdateSegmentPoint(newfirstSegEnd, false);
                if (segment2 != null)
                    segment2.UpdateSegmentPoint(newSecSegStart, true);
            }
            if (segment1 != null)
                segment1.RemoveNotInRangeSharedCoordinates();
            if (segment2 != null)
                segment2.RemoveNotInRangeSharedCoordinates();
            var segs = this.SplitSegment_Where(startCorner, endCorner);
            if (segs.size() != 0) {
                for (var k = 0; k < segs.size(); k++)
                    segs.get(k).getSharedCoordinates().Clear();
            }
        }
    };
    SegmentVector.prototype.SplitSegment_Where = function (startCorner, endCorner) {
        var list = new List();
        for (var i = 0; i < this._mSegments.size(); i++) {
            var obj = this._mSegments.get(i);
            if (obj.getStart() > startCorner && obj.getEnd() < endCorner)
                list.add(obj);
        }
        return list;
    };
    SegmentVector.prototype.GetScanSegmentsFromBounds = function (bounds, startSegment, endSegment) {
        var segments = new List();
        if (startSegment != null && endSegment != null && startSegment == endSegment)
            return segments;
        var perpSegmentTree = this._mParentTree.getPerpendicularTree();
        if (perpSegmentTree.getVectors().Count() != 0) {
            var startIndex = perpSegmentTree.FindIndex(bounds.topLeft().round());
            var endIndex = perpSegmentTree.FindIndex(bounds.bottomRight().round());
            var index = startIndex;
            var prevIntersectingPt = null;
            while (index < endIndex) {
                var perpSegCoord = Number(perpSegmentTree.getVectors().KeyAt(index));
                var intersectingPt = this._mIsVertical ? new Point(this._mCoord, perpSegCoord) : new Point(perpSegCoord, this._mCoord);
                if ((startSegment == null || !startSegment.Contains(intersectingPt)) && (endSegment == null || !endSegment.Contains(intersectingPt))) {
                    var perpSegmentVector = perpSegmentTree.getVectors().GetValue(perpSegCoord);
                    var perpScanSegment = perpSegmentVector.FindSegment(this._mCoord);
                    if (perpScanSegment != null) {
                        var point = this._mIsVertical ? new Point(this._mCoord, perpSegCoord + 1) : new Point(perpSegCoord + 1, this._mCoord);
                        if ((startSegment == null || !startSegment.Contains(point)) && (endSegment == null || !endSegment.Contains(point))) {
                            var segment = this.GetScanSegment(point);
                            if (segment != null && !segments.contains(segment)) {
                                if (segment.getStartPoint().equals(intersectingPt))
                                    segments.add(segment);
                                else
                                    this.RemoveSegmentFromVector(segment);
                            }
                            else if (segment == null) {
                                if (index > startIndex) {
                                    var tempPt = this._mIsVertical ? new Point(this._mCoord, perpSegCoord - 1) : new Point(perpSegCoord - 1, this._mCoord);
                                    if (prevIntersectingPt != null && tempPt.equals(prevIntersectingPt))
                                        this.GetScanSegment_startPoint(tempPt, intersectingPt);
                                }
                            }
                        }
                        prevIntersectingPt = intersectingPt;
                    }
                }
                index++;
            }
        }
        return segments;
    };
    SegmentVector.prototype.GetScanSegment = function (point) {
        var scanSegment = null;
        if (this._mSegments.size() != 0) {
            var coord = !this._mIsVertical ? Utility.ToRoundedInt(point.x) : Utility.ToRoundedInt(point.y);
            scanSegment = this.FindSegment(coord);
        }
        if (scanSegment == null && this._mParentTree != null) {
            var dir = !this._mIsVertical ? Directions.West : Directions.South;
            var segment = this._mParentTree.getRouter().GetMaximumVisibility(point, dir);
            if (segment != null) {
                var segment2 = this._mParentTree.getRouter().GetMaximumVisibility(point, Extensions.OppositeDirection(dir));
                if (segment2 != null)
                    segment.EndPoint = segment2.EndPoint;
                if (segment.StartPoint.OperatorNotEqual(segment.EndPoint)) {
                    scanSegment = new ScanSegment(segment.StartPoint, segment.EndPoint, this._mOrientation, this);
                    this.AddSegmentToVector(scanSegment);
                }
            }
        }
        return scanSegment;
    };
    SegmentVector.prototype.GetScanSegment_startPoint = function (startPoint, endPoint, insertAt) {
        if (insertAt === void 0) { insertAt = -1; }
        var scanSegment = null;
        if (insertAt == -1 && this._mSegments.size() != 0) {
            scanSegment = this.FindSegment(!this._mIsVertical ? Utility.ToRoundedInt(startPoint.x) : Utility.ToRoundedInt(startPoint.y));
            if (scanSegment == null)
                scanSegment = this.FindSegment(!this._mIsVertical ? Utility.ToRoundedInt(endPoint.x) : Utility.ToRoundedInt(endPoint.y));
        }
        if (scanSegment == null && this._mParentTree != null) {
            scanSegment = new ScanSegment(startPoint, endPoint, this._mOrientation, this);
            this.AddSegmentToVector(scanSegment, insertAt);
        }
        return scanSegment;
    };
    SegmentVector.prototype.FindSegment = function (coord) {
        var segment = null;
        if (this._mSegments.size() != 0) {
            var args = this.GetSegmentIndex(coord, segment);
            segment = args.segment;
        }
        return segment;
    };
    SegmentVector.prototype.GetSegmentIndex = function (coord, segment) {
        segment = null;
        if (this._mStart <= coord && this._mEnd >= coord) {
            var low = 0, high = this._mSegments.size() - 1, mid = -1;
            while (high - low > 1) {
                mid = Math.floor((low + high) / 2);
                if (coord >= this._mSegments.get(mid).getStart())
                    low = mid;
                else
                    high = mid;
            }
            if (low >= 0 && high >= 0) {
                if (this._mSegments.get(low).getEnd() >= coord) {
                    segment = this._mSegments.get(low);
                    return { index: low, segment: segment };
                }
                else if (this._mSegments.get(high).getStart() <= coord) {
                    segment = this._mSegments.get(high);
                    return { index: high, segment: segment };
                }
            }
        }
        return { index: -1, segment: segment };
    };
    SegmentVector.prototype.GetStart = function () {
        return this._mIsVertical ? new Point(this._mCoord, this._mStart) : new Point(this._mStart, this._mCoord);
    };
    SegmentVector.prototype.GetEnd = function () {
        return this._mIsVertical ? new Point(this._mCoord, this._mEnd) : new Point(this._mEnd, this._mCoord);
    };
    return SegmentVector;
}());
var ScanSegment = (function () {
    function ScanSegment(startPoint, endPoint, orientation, parentVector) {
        this._mIsVertical = false;
        this._mStart = 0;
        this._mEnd = 0;
        this._mStartPoint = startPoint.round();
        this._mEndPoint = endPoint.round();
        this._mSharedCoordinates = new SortedList();
        this._mParentVector = parentVector;
        this._mOrientation = orientation;
        this._mIsVertical = this._mOrientation == SegmentOrientation.Vertical;
        this._mStart = this._mIsVertical ? this._mStartPoint.y : this._mStartPoint.x;
        this._mEnd = this._mIsVertical ? this._mEndPoint.y : this._mEndPoint.x;
    }
    ScanSegment.prototype.getStart = function () {
        return Math.floor(this._mStart);
    };
    ScanSegment.prototype.getEnd = function () {
        return Math.floor(this._mEnd);
    };
    ScanSegment.prototype.getStartPoint = function () {
        return this._mStartPoint;
    };
    ScanSegment.prototype.getEndPoint = function () {
        return this._mEndPoint;
    };
    ScanSegment.prototype.getOrientation = function () {
        return this._mOrientation;
    };
    ScanSegment.prototype.getIsVertical = function () {
        return this._mIsVertical;
    };
    ScanSegment.prototype.getSharedCoordinates = function () {
        return this._mSharedCoordinates;
    };
    ScanSegment.prototype.setSharedCoordinates = function (value) {
        this._mSharedCoordinates = value != null ? value : new SortedList();
    };
    ScanSegment.prototype.getParentVector = function () {
        return this._mParentVector;
    };
    ScanSegment.prototype.Contains = function (pt) {
        var temptPt = this._mIsVertical ? Utility.ToRoundedInt(pt.y) : Utility.ToRoundedInt(pt.x);
        return temptPt >= this._mStart && temptPt <= this._mEnd;
    };
    ScanSegment.prototype.UpdateSegmentPoint = function (point, isStart, isTreeExpansion) {
        if (isTreeExpansion === void 0) { isTreeExpansion = false; }
        var doVectorUpdate = false;
        point = point.round();
        if (isStart && !this._mStartPoint.equals(point)) {
            this._mStartPoint = point;
            this._mStart = this._mIsVertical ? this._mStartPoint.y : this._mStartPoint.x;
            doVectorUpdate = true;
        }
        else if (!isStart && !this._mEndPoint.equals(point)) {
            this._mEndPoint = point;
            this._mEnd = this._mIsVertical ? this._mEndPoint.y : this._mEndPoint.x;
            doVectorUpdate = true;
        }
        if (doVectorUpdate && this._mParentVector != null) {
            this._mParentVector.UpdateVectorPoints(isTreeExpansion);
        }
    };
    ScanSegment.prototype.UpdateSharedCoordinates = function (value) {
        if (this._mSharedCoordinates.ContainsKey(value)) {
            this._mSharedCoordinates.Update(value, this._mSharedCoordinates.GetValue(value) + 1);
        }
        else
            this._mSharedCoordinates.Add(1, value);
    };
    ScanSegment.prototype.RemoveSharedCoordinates = function (value) {
        if (this._mSharedCoordinates.ContainsKey(value)) {
            this._mSharedCoordinates.Update(value, this._mSharedCoordinates.GetValue(value) - 1);
            if (this._mSharedCoordinates.GetValue(value) == 0)
                this._mSharedCoordinates.Remove(value);
        }
    };
    ScanSegment.prototype.RemoveNotInRangeSharedCoordinates = function () {
        if ((this._mSharedCoordinates.Count()) != 0) {
            var segStart = this._mStart, segEnd = this._mEnd;
            var coordRemovedNearToStart = null, coordRemovedNearToEnd = null;
            if (segStart === (segEnd))
                this._mSharedCoordinates.Clear();
            else {
                var index = 0;
                while (index < (this._mSharedCoordinates.Count())) {
                    var coord = Number(this._mSharedCoordinates.KeyAt(index));
                    if (coord < segStart || coord > segEnd) {
                        if (this._mSharedCoordinates.ContainsKey(coord))
                            this._mSharedCoordinates.Remove(coord);
                        if (coord < segStart)
                            coordRemovedNearToStart = coord;
                        else if (coordRemovedNearToEnd == null)
                            coordRemovedNearToEnd = coord;
                    }
                    else
                        index++;
                }
                if (this._mSharedCoordinates.Count() % 2 != 0) {
                    if (coordRemovedNearToStart != null) {
                        var currentStartingCoord = Number(this._mSharedCoordinates.KeyAt(0));
                        if (currentStartingCoord > segStart)
                            this.UpdateSharedCoordinates(segStart);
                        else if (currentStartingCoord == segStart)
                            this.RemoveSharedCoordinates(segStart);
                    }
                    if (coordRemovedNearToEnd != null) {
                        var currentEndingCoord = Number(this._mSharedCoordinates.KeyAt(this._mSharedCoordinates.Count() - 1));
                        if (currentEndingCoord < segEnd)
                            this.UpdateSharedCoordinates(segEnd);
                        else if (currentEndingCoord == segEnd)
                            this.RemoveSharedCoordinates(segEnd);
                    }
                }
            }
        }
    };
    return ScanSegment;
}());
var VisibilityGraphGeneration = (function () {
    function VisibilityGraphGeneration() {
    }
    VisibilityGraphGeneration.getRouter = function () {
        return this.router;
    };
    VisibilityGraphGeneration.setRouter = function (value) {
        this.router = value;
    };
    VisibilityGraphGeneration.GetVertices = function () {
        var __result = new Array();
        if (this.router.graph) {
            var Vertices = this.router.graph.getVertices();
            for (var i = 0; i < Vertices.length; i++) {
                __result.push(new Point(Vertices[i].Point.x, Vertices[i].Point.y));
            }
        }
        return __result;
    };
    VisibilityGraphGeneration.GetSegmentTree = function () {
        var __result = [];
        var pt = new Point(this.router.getHorizontalSegmentTree().getStart(), this.router.getVerticalSegmentTree().getStart());
        var nodeTemplate = ej.util.getObject("drawLine", window);
        for (var i = 0; i < (this.router.getHorizontalSegmentTree().getVectors().Count()); i++) {
            var vector = this.router.getHorizontalSegmentTree().getVectors().GetValue(this.router.getHorizontalSegmentTree().getVectors().KeyAt(i));
            for (var j = 0; j < vector.getSegments().size(); j++) {
                var seg = vector.getSegments().get(j);
                var start = seg.getStartPoint();
                var end = seg.getEndPoint();
                nodeTemplate(new Tuple(new Point(start.x, start.y), new Point(end.x, end.y)));
            }
        }
        for (var i = 0; i < (this.router.getVerticalSegmentTree().getVectors().Count()); i++) {
            var vector = this.router.getVerticalSegmentTree().getVectors().GetValue(this.router.getVerticalSegmentTree().getVectors().KeyAt(i));
            for (var j = 0; j < vector.getSegments().size(); j++) {
                seg = vector.getSegments().get(j);
                var start = seg.getStartPoint();
                var end = seg.getEndPoint();
                nodeTemplate(new Tuple(new Point(start.x, start.y), new Point(end.x, end.y)));
            }
        }
        return __result;
    };
    VisibilityGraphGeneration.GetEdges = function () {
        var __result = new Array();
        if (this.router.graph) {
            var edges = this.router.graph.getEdges();
            for (var i = 0; i < edges.size(); i++) {
                var edge = (edges.get(i));
                __result.push(new Tuple(new Point(edge.getSource().Point.x, edge.getSource().Point.y), new Point(edge.getTarget().Point.x, edge.getTarget().Point.y)));
            }
        }
        return __result;
    };
    VisibilityGraphGeneration.router = new Router();
    return VisibilityGraphGeneration;
}());
var IObstaclePort = (function () {
    function IObstaclePort() {
    }
    IObstaclePort.prototype.getLocation = function () {
        return this.Location;
    };
    IObstaclePort.prototype.setLocation = function (value) {
        this.Location = value;
    };
    IObstaclePort.prototype.getDirection = function () {
        return this.Direction;
    };
    IObstaclePort.prototype.setDirection = function (value) {
        this.Direction = value;
    };
    return IObstaclePort;
}());
var Obstacle = (function () {
    function Obstacle() {
        this.isBorder = false;
    }
    Obstacle.prototype.getPaddedBounds = function () {
        return this._mPaddedRegion;
    };
    Obstacle.prototype.setPaddedBounds = function (value) {
        this._mPaddedRegion = value;
        if (this._mPaddedRegion != null && this._mPaddedRegion != Rect.empty) {
            var rect = this._mPaddedRegion;
            this.topLeft = new PolylinePoint(rect.topLeft());
            this.topRight = new PolylinePoint(rect.topRight());
            this.bottomLeft = new PolylinePoint(rect.bottomLeft());
            this.bottomRight = new PolylinePoint(rect.bottomRight());
            if (this._mActualBounds != null) {
                var region = this._mActualBounds;
                if (region.width == 0) {
                    this.topLeft.setNext(this.bottomLeft);
                    this.topLeft.setPrev(this.bottomLeft);
                    this.topRight.setNext(this.bottomLeft);
                    this.topRight.setPrev(this.bottomLeft);
                    this.bottomLeft.setNext(this.topLeft);
                    this.bottomLeft.setPrev(this.topLeft);
                    this.bottomRight.setNext(this.topLeft);
                    this.bottomRight.setPrev(this.topLeft);
                }
                else if (region.height == 0) {
                    this.topLeft.setNext(this.topRight);
                    this.topLeft.setPrev(this.topRight);
                    this.bottomLeft.setNext(this.topRight);
                    this.bottomLeft.setPrev(this.topRight);
                    this.topRight.setNext(this.topLeft);
                    this.topRight.setPrev(this.topLeft);
                    this.bottomRight.setNext(this.topLeft);
                    this.bottomRight.setPrev(this.topLeft);
                }
                else {
                    this.topLeft.setPrev(this.topRight);
                    this.topRight.setPrev(this.bottomRight);
                    this.bottomRight.setPrev(this.bottomLeft);
                    this.bottomLeft.setPrev(this.topLeft);
                    this.topLeft.setNext(this.bottomLeft);
                    this.bottomLeft.setNext(this.bottomRight);
                    this.bottomRight.setNext(this.topRight);
                    this.topRight.setNext(this.topLeft);
                }
                this.StartVertex = this.topLeft;
            }
        }
    };
    Obstacle.prototype.getActualBounds = function () {
        return this._mActualBounds;
    };
    Obstacle.prototype.setActualBounds = function (value) {
        this._mActualBounds = value;
    };
    Obstacle.prototype._obstacle = function (region, padding, isObject) {
        if (padding === void 0) { padding = 12; }
        if (isObject === void 0) { isObject = true; }
        if (isObject == false) {
            this.isBorder = true;
        }
        this.SetRegion(region, padding);
        return this;
    };
    Obstacle.prototype.CreateInitialSides = function (start, direction) {
        this.LowSide = new ObstacleSide(this, start, direction, ScanDirection.Right == direction);
        this.LowSide.SideType = ObstacleSideType.Low;
        this.HighSide = new ObstacleSide(this, start, direction, ScanDirection.Top == direction);
        this.HighSide.SideType = ObstacleSideType.High;
        if (Utility.CheckWithScanDirection(direction, this.HighSide.getStart(), this.HighSide.getEnd())) {
            this.HighSide = new ObstacleSide(this, direction == ScanDirection.Right ? this.topRight : this.bottomLeft, direction, ScanDirection.Top == direction);
            this.HighSide.SideType = ObstacleSideType.High;
        }
    };
    Obstacle.prototype.SetRegion = function (region, padding) {
        if (padding === void 0) { padding = 12; }
        this.setActualBounds(region);
        if (this.isBorder == false) {
            region.Inflate(padding).round();
        }
        this.setPaddedBounds(new Rect(Math.round(region.x), Math.round(region.y), Math.round(region.width), Math.round(region.height)));
    };
    return Obstacle;
}());
var ObstacleSide = (function () {
    function ObstacleSide(obstacle, startVertex, scanDir, traverseClockwise) {
        this.StartVertex = startVertex;
        this._obstacle = obstacle;
        this._mEndVertex = traverseClockwise ? startVertex.getNext() : startVertex.getPrev();
    }
    ObstacleSide.prototype.getEndVertex = function () {
        return this._mEndVertex;
    };
    ObstacleSide.prototype.setEndVertex = function (value) {
        this._mEndVertex = value;
    };
    ObstacleSide.prototype.getStart = function () {
        return this.StartVertex.Point;
    };
    ObstacleSide.prototype.getEnd = function () {
        return this.getEndVertex().Point;
    };
    return ObstacleSide;
}());
var CenterPort = (function () {
    function CenterPort(point) {
        this.Entrances = new List();
        this.VisibilityRectangle = Rect.empty;
        this.Location = point;
        this._mLocation = point;
    }
    CenterPort.prototype.AddPortEntrance = function (tree, point, node, direction) {
        var entrance = new PortEntrance(this, point, node, direction, tree);
        if (entrance.getCanExtend()) {
            this.Entrances.add(entrance);
            this.VisibilityRectangle.unitePoint(entrance.MaxVisibilitySegment.EndPoint);
        }
    };
    CenterPort.prototype.getLocation = function () {
        return this.Location.round();
    };
    CenterPort.prototype.setLocation = function (value) {
        this.Location = value;
    };
    CenterPort.prototype.getDirection = function () {
        return this.Direction;
    };
    CenterPort.prototype.setDirection = function (value) {
        this.Direction = value;
    };
    return CenterPort;
}());
var ObstaclePort = (function () {
    function ObstaclePort(location, direction) {
        this.Location = this._mLocation = location;
        this.Direction = this._mPortDirection = direction;
    }
    ObstaclePort.prototype.getLocation = function () {
        return this.Location.round();
    };
    ObstaclePort.prototype.setLocation = function (value) {
        this.Location = value;
    };
    ObstaclePort.prototype.getDirection = function () {
        return this.Direction;
    };
    ObstaclePort.prototype.setDirection = function (value) {
        this.Direction = value;
    };
    return ObstaclePort;
}());
var PortEntrance = (function () {
    function PortEntrance(port, location, node, direction, tree) {
        this.Port = port;
        this.Location = location;
        this.Direction = direction;
        var curDirection = Extensions.GetEquivalentDirection(direction);
        var pad = tree.ObstaclePadding;
        var startPoint = location;
        var endPoint = Utility.IntersectionWithRectangleBorder(tree.Rectangle, location, Extensions.GetEquivalentDirection(direction));
        var segment = new Segment(startPoint, endPoint);
        var firstHit;
        var args = tree.FindMaximumVisibility_hitNode(segment, node, null, firstHit, true);
        firstHit = args.hitNode;
        var newDirection = segment.StartPoint.FindDirection(segment.EndPoint);
        if (curDirection != newDirection) {
            segment.EndPoint = location;
        }
        this.FirstHit = firstHit;
        this.MaxVisibilitySegment = segment;
    }
    PortEntrance.prototype.getCanExtend = function () {
        return Extensions.FindDirection(this.MaxVisibilitySegment.StartPoint, this.MaxVisibilitySegment.EndPoint) != Directions.None;
    };
    PortEntrance.prototype.getWantVisibilityIntersection = function () {
        return this.getCanExtend();
    };
    PortEntrance.prototype.getIsVertical = function () {
        return this.Direction == PortDirection.Top || this.Direction == PortDirection.Bottom;
    };
    return PortEntrance;
}());
var PortManager = (function () {
    function PortManager(horizontalTree, verticalTree, obstacleTree, graph, geometry, padding) {
        this.visibilityGraph = null;
        this.padding = 0;
        this.canRoute = false;
        this.temporaryAddition = true;
        this.InitialWeight = 1;
        this.NormalWeight = 1;
        this.edgesToRestore = new List();
        this.addedEdges = new List();
        this.addedVertices = new List();
        this.lastExtendedVertex = null;
        this.HorizontalScanSegmentTree = horizontalTree;
        this.VerticalScanSegmentTree = verticalTree;
        this.visibilityGraph = graph;
        this.targetGeometry = geometry;
        this.padding = padding;
        this.ObstacleTree = obstacleTree;
    }
    PortManager.prototype.AddControlPointsToGraph = function (geometry) {
        this.addedEdges = new List();
        this.addedVertices = new List();
        this.canRoute = true;
        this.targetGeometry.Connector = geometry;
        this.targetGeometry.CurrentEnd = ConnectionEnd.Source;
        if (geometry._sourceNodeInfo != null) {
            this.AddEndPointToGraph(geometry._sourcePortInfo, geometry._sourceNodeInfo);
        }
        else {
            this.AddEndPointToGraph(geometry._sourcePointInfo, geometry._sourceNodeInfo);
        }
        if (this.canRoute) {
            this.targetGeometry.CurrentEnd = ConnectionEnd.Target;
            if (geometry._targetNodeInfo != null) {
                this.AddEndPointToGraph(geometry._targetPortInfo, geometry._targetNodeInfo);
            }
            else {
                this.AddEndPointToGraph(geometry._targetPointInfo, geometry._targetNodeInfo);
            }
        }
        return this.canRoute;
    };
    PortManager.prototype.AddEndPointToGraph = function (port, node) {
        if ((port == null || port instanceof IObstaclePort) && (node instanceof IObstacle || (node && (node._type === "node" || node.type === "bpmn")))) {
            if (port == null) {
                this.AddFreePointToGraph(node);
            }
            else {
                this.canRoute = this.AddPortToGraph(port, node);
            }
        }
        else if (port != null) {
            this.canRoute = this.AddPortToGraph(port, node);
        }
    };
    PortManager.prototype.AddPortToGraph = function (port, endNode) {
        return this.AddPortToGraph_portDirection(port.getLocation(), port.getDirection(), endNode);
    };
    PortManager.prototype.AddPortToGraph_portDirection = function (portLocation, portDirection, endNode) {
        var point = new Point(Utility.ToRoundedInt(portLocation.x), Utility.ToRoundedInt(portLocation.y));
        var vertex;
        if (this.ObstacleTree.Rectangle.containsPoint(point)) {
            vertex = this.AddVertex(point);
            var direction = portDirection;
            var perpSegment = null;
            var isHorizontal = false;
            if (Extensions.GetOrientation_PortDirection(direction) == Orientation.Horizontal) {
                isHorizontal = true;
            }
            perpSegment = this.FindTheClosestPerpendicularEdge(point, portDirection);
            var segment = new Segment(point, Utility.IntersectionWithRectangleBorder(this.ObstacleTree.Rectangle, point, Extensions.GetEquivalentDirection(portDirection)));
            if (this.ObstacleTree.RestrictSegmentWithinFreeSpace(this.targetGeometry.Connector, segment, endNode)) {
                var nextPoint;
                if (perpSegment != null) {
                    var intersectingPt = this.GetIntersectingPoint(perpSegment, point, !isHorizontal);
                    if (segment.Contains(intersectingPt)) {
                        nextPoint = intersectingPt;
                        var target = this.AddVertex(intersectingPt);
                        if (vertex.Point.OperatorNotEqual(intersectingPt))
                            this.ConnectVertices_vertex(vertex, target, this.InitialWeight);
                        this.AddEdgeToClosestPerpSegment(perpSegment, intersectingPt, true);
                        this.ExtendTheEdgeToAdjacentEdges(nextPoint, portDirection, segment, !isHorizontal);
                        return true;
                    }
                    else if (endNode != null) {
                        var edgePt = Utility.IntersectionWithRectangleBorder(endNode._outerBounds, point, Extensions.GetEquivalentDirection(portDirection));
                        var distanceBtwnEndPoint = Math.abs(edgePt.distance(segment.EndPoint));
                        if (segment.Contains(edgePt) && distanceBtwnEndPoint < 2 * this.padding && distanceBtwnEndPoint >= 4) {
                            nextPoint = Extensions.Transform(edgePt, distanceBtwnEndPoint / 2, Extensions.GetEquivalentDirection(portDirection));
                            var target = this.AddVertex(nextPoint);
                            if (vertex.Point.OperatorNotEqual(nextPoint))
                                this.ConnectVertices_vertex(vertex, target, this.InitialWeight);
                            this.AddEdgesToParallelSegments(nextPoint, Extensions.GetOrientation_PortDirection(portDirection), segment, endNode);
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    PortManager.prototype.AddCornerToVisibilityGraph = function (port, endNode, preference) {
        if (preference === void 0) { preference = null; }
        this.lastExtendedVertex = null;
        var point = port.getLocation();
        var portDirection = port.getDirection();
        var portLocation = point;
        var vertex;
        if (this.ObstacleTree.Rectangle.containsPoint(point)) {
            this.SegmentStartPoint = this.SegmentEndPoint = point;
            vertex = this.AddVertex(point);
            var direction = portDirection;
            var perpSegment = null;
            var isHorizontal = false;
            if (Extensions.GetOrientation_PortDirection(direction) == Orientation.Horizontal) {
                isHorizontal = true;
            }
            perpSegment = this.FindTheClosestPerpendicularEdge(point, portDirection);
            var segment = new Segment(point, Utility.IntersectionWithRectangleBorder(this.ObstacleTree.Rectangle, point, Extensions.GetEquivalentDirection(portDirection)));
            if (this.ObstacleTree.RestrictSegmentWithinFreeSpace(this.targetGeometry.Connector, segment, endNode)) {
                var nextPoint;
                if (perpSegment != null) {
                    var intersectingPt = this.GetIntersectingPoint(perpSegment, point, !isHorizontal);
                    if (segment.Contains(intersectingPt)) {
                        nextPoint = intersectingPt;
                        var target = this.AddVertex(intersectingPt);
                        this.lastExtendedVertex = target;
                        if (vertex.Point.OperatorNotEqual(intersectingPt))
                            this.ConnectVertices_vertex(vertex, target, this.InitialWeight);
                        this.AddEdgeToClosestPerpSegment(perpSegment, intersectingPt, true);
                        this.ExtendTheEdgeToAdjacentEdges(nextPoint, portDirection, segment, !isHorizontal, preference);
                        if (this.lastExtendedVertex != null)
                            this.SegmentEndPoint = this.lastExtendedVertex.Point;
                        return;
                    }
                }
                this.ExtendTheEdgeToAdjacentEdges(portLocation, portDirection, segment, !isHorizontal, preference);
                if (this.lastExtendedVertex != null)
                    this.SegmentEndPoint = this.lastExtendedVertex.Point;
            }
        }
    };
    PortManager.prototype.GetStartVertexPoint = function (point, isHorizontal) {
        if (isHorizontal) {
            if (point.x == this.ObstacleTree.Rectangle.x - 1) {
                return new Point(point.x + 1, point.y);
            }
        }
        else {
            if (point.y == this.ObstacleTree.Rectangle.y - 1) {
                return new Point(point.x, point.y + 1);
            }
        }
        return point;
    };
    PortManager.prototype.GetEndVertexPoint = function (point, isHorizontal) {
        if (isHorizontal) {
            if (point.x == this.ObstacleTree.Rectangle.right() + 1) {
                return new Point(point.x - 1, point.y);
            }
        }
        else {
            if (point.y == this.ObstacleTree.Rectangle.bottom() + 1) {
                return new Point(point.x, point.y - 1);
            }
        }
        return point;
    };
    PortManager.prototype.GetStartSegmentPoint = function (point, isHorizontal, force) {
        if (force === void 0) { force = false; }
        if (isHorizontal) {
            if (point.x == this.ObstacleTree.Rectangle.x || force) {
                return new Point(point.x - 1, point.y);
            }
        }
        else {
            if (point.y == this.ObstacleTree.Rectangle.y || force) {
                return new Point(point.x, point.y - 1);
            }
        }
        return point;
    };
    PortManager.prototype.GetEndSegmentPoint = function (point, isHorizontal, force) {
        if (force === void 0) { force = false; }
        if (isHorizontal) {
            if (point.x == this.ObstacleTree.Rectangle.right() || force) {
                return new Point(point.x + 1, point.y);
            }
        }
        else {
            if (point.y == this.ObstacleTree.Rectangle.bottom() || force) {
                return new Point(point.x, point.y + 1);
            }
        }
        return point;
    };
    PortManager.prototype.FindTheClosestPerpendicularEdge = function (point, direction) {
        var perpSegment = null;
        var intersectingSegments = Extensions.GetOrientation_PortDirection(direction) == Orientation.Horizontal ? this.VerticalScanSegmentTree : this.HorizontalScanSegmentTree;
        switch (direction) {
            case PortDirection.Bottom:
            case PortDirection.Right:
                var _point = intersectingSegments.FindFirst(point);
                perpSegment = _point ? _point : intersectingSegments.FindScanSegment(point);
                break;
            case PortDirection.Left:
            case PortDirection.Top:
                _point = intersectingSegments.FindLast(point);
                perpSegment = _point ? _point : intersectingSegments.FindScanSegment(point);
                break;
        }
        return perpSegment;
    };
    PortManager.prototype.AddFreePointToGraph = function (node) {
        var port = node._obstacle.CenterPort;
        if (port.Entrances == null || port.Entrances.size() == 0) {
            this.CreatePortEntrances(node, port, node._obstacle);
        }
        this.canRoute = false;
        for (var i = 0; i < port.Entrances.size(); i++) {
            var entrance = port.Entrances.get(Number(i));
            if (this.AddPortToGraph_portDirection(entrance.Location, entrance.Direction, node)) {
                this.canRoute = true;
            }
        }
    };
    PortManager.prototype.AddEdgesToParallelSegments = function (point, orientation, segment, endNode) {
        var lowSide, highSide;
        var isHorizontal = false;
        var scanSegmentTree = orientation == Orientation.Horizontal ? this.HorizontalScanSegmentTree : this.VerticalScanSegmentTree;
        lowSide = scanSegmentTree.FindLast(point);
        highSide = scanSegmentTree.FindFirst(point);
        var lowDirection, highDirection;
        if (orientation == Orientation.Horizontal) {
            isHorizontal = true;
            lowDirection = PortDirection.Top;
            highDirection = PortDirection.Bottom;
        }
        else {
            isHorizontal = false;
            lowDirection = PortDirection.Left;
            highDirection = PortDirection.Right;
        }
        if (lowSide != null) {
            this.ConnectToParallelEdge(lowSide, point, lowDirection, isHorizontal, endNode);
        }
        if (highSide != null) {
            this.ConnectToParallelEdge(highSide, point, highDirection, isHorizontal, endNode);
        }
    };
    PortManager.prototype.ConnectToParallelEdge = function (segment, start, portDirection, isHorizontal, endNode) {
        var intersect = this.GetIntersectingPoint(segment, start, isHorizontal);
        var borderIntersect = Utility.IntersectionWithRectangleBorder(this.ObstacleTree.Rectangle, intersect, Extensions.GetEquivalentDirection(portDirection));
        var parallelSeg = new Segment(start, borderIntersect);
        var portEntrance = this.targetGeometry.GetCurrentEntrance();
        if (portEntrance != null &&
            this.ObstacleTree.RestrictSegmentWithinFreeSpace(this.targetGeometry.Connector, parallelSeg, endNode, portEntrance.FirstHit) && parallelSeg.Contains(intersect)) {
            this.AddVertexAndEdges(start, intersect, 1);
            this.AddEdgeToClosestPerpSegment(segment, intersect, true);
            this.ExtendTheEdgeToAdjacentEdges(intersect, portDirection, parallelSeg, false);
        }
    };
    PortManager.prototype.AddEdgeToClosestPerpSegment = function (nearestSeg, intersectPt, isOverlapped) {
        if (nearestSeg.getStartPoint().equals(intersectPt) || nearestSeg.getEndPoint().equals(intersectPt))
            return;
        if (intersectPt.FindDirection(nearestSeg.getStartPoint()) == nearestSeg.getStartPoint().FindDirection(nearestSeg.getEndPoint())) {
            this.AddVertexAndEdges(intersectPt, nearestSeg.getStartPoint(), isOverlapped ? this.InitialWeight : this.NormalWeight);
        }
        else if (nearestSeg.getEndPoint().FindDirection(intersectPt) == nearestSeg.getStartPoint().FindDirection(nearestSeg.getEndPoint())) {
            this.AddVertexAndEdges(nearestSeg.getEndPoint(), intersectPt, isOverlapped ? this.InitialWeight : this.NormalWeight);
        }
        else {
            var dir = nearestSeg.getIsVertical() ? Directions.North : Directions.East;
            var vertex = this.visibilityGraph.FindVertex(nearestSeg.getStartPoint());
            var prev = null;
            while (vertex != null) {
                if (vertex.Point.equals(intersectPt))
                    break;
                else {
                    if (prev != null && prev.Point.FindDirection(intersectPt) == intersectPt.FindDirection(vertex.Point)) {
                        var edge = this.visibilityGraph.FindEdge(prev.Point, vertex.Point);
                        if (edge != null) {
                            if (!(edge instanceof DynamicEdge) && this.temporaryAddition)
                                this.edgesToRestore.add(edge);
                            this.visibilityGraph.RemoveEdge_edge(edge, true);
                        }
                        var vertexAtIntersectPt = this.AddVertex(intersectPt);
                        this.ConnectVertices_vertex(prev, vertexAtIntersectPt, 1);
                        this.ConnectVertices_vertex(vertexAtIntersectPt, vertex, 1);
                        return;
                    }
                }
                prev = vertex;
                vertex = vertex.FindNextVertex(dir);
            }
            this.AddVertexAndEdges(nearestSeg.getStartPoint(), intersectPt, isOverlapped ? this.InitialWeight : this.NormalWeight);
        }
    };
    PortManager.prototype.AddVertexToSegment = function (segment, newVertex) {
        if (newVertex.Point.equals(segment.getStartPoint()) || newVertex.Point.equals(segment.getEndPoint()))
            return;
        var dir = segment.getIsVertical() ? Directions.North : Directions.East;
        var nextVertex = newVertex.FindNextVertex(dir);
        if (nextVertex == null) {
            var prevVertex = newVertex.FindNextVertex(Extensions.OppositeDirection(dir));
            if (prevVertex == null) {
                var vector = segment.getParentVector();
                var perpSegmentTree = vector.getParentTree().getPerpendicularTree();
                var edge = perpSegmentTree.GetEdgePassingThroughVertex(newVertex, vector.getCoord());
                if (edge != null) {
                    prevVertex = edge.getSource();
                    nextVertex = edge.getTarget();
                    edge.ResetFields(prevVertex, newVertex, dir, 1);
                    this.visibilityGraph.CreateEdge(newVertex, nextVertex, dir, 1);
                }
            }
        }
    };
    PortManager.prototype.RemoveVertexFromSegment = function (segment, intersectPt) {
        var dir = segment.getIsVertical() ? Directions.North : Directions.East;
        if (intersectPt.equals(segment.getStartPoint())) {
            var vertex = this.visibilityGraph.FindVertex(segment.getStartPoint());
            if (vertex != null) {
                var nextVertex = vertex.FindNextVertex(dir);
                if (nextVertex != null) {
                    this.visibilityGraph.RemoveEdge(vertex, nextVertex);
                    segment.UpdateSegmentPoint(nextVertex.Point, true);
                }
            }
        }
        else if (intersectPt.equals(segment.getEndPoint())) {
            var vertex = this.visibilityGraph.FindVertex(segment.getEndPoint());
            if (vertex != null) {
                var prevVertex = vertex.FindNextVertex(Extensions.OppositeDirection(dir));
                if (prevVertex != null) {
                    this.visibilityGraph.RemoveEdge(prevVertex, vertex);
                    segment.UpdateSegmentPoint(prevVertex.Point, false);
                }
            }
        }
        else {
            var prev = null;
            var vertex = this.visibilityGraph.FindVertex(segment.getStartPoint());
            while (vertex != null) {
                var nextVertex = vertex.FindNextVertex(dir);
                if (prev != null && nextVertex != null && vertex.Point.equals(intersectPt)) {
                    this.visibilityGraph.RemoveEdge(prev, vertex);
                    this.visibilityGraph.RemoveEdge(vertex, nextVertex);
                    this.ConnectVertices_vertex(prev, nextVertex);
                    break;
                }
                prev = vertex;
                vertex = nextVertex;
            }
        }
    };
    PortManager.prototype.RemoveVertexFromSegment_vertex = function (segment, vertexToRemove) {
        if (vertexToRemove != null) {
            var dir = segment.getIsVertical() ? Directions.North : Directions.East;
            if (vertexToRemove.Point.equals(segment.getStartPoint())) {
                var nextVertex = vertexToRemove.FindNextVertex(dir);
                if (nextVertex != null) {
                    this.visibilityGraph.RemoveEdge(vertexToRemove, nextVertex);
                    segment.UpdateSegmentPoint(nextVertex.Point, true);
                    segment.RemoveNotInRangeSharedCoordinates();
                }
            }
            else if (vertexToRemove.Point.equals(segment.getEndPoint())) {
                var prevVertex = vertexToRemove.FindNextVertex(Extensions.OppositeDirection(dir));
                if (prevVertex != null) {
                    this.visibilityGraph.RemoveEdge(prevVertex, vertexToRemove);
                    segment.UpdateSegmentPoint(prevVertex.Point, false);
                    segment.RemoveNotInRangeSharedCoordinates();
                }
            }
            else {
                this.DisconnectVertexInDirection(vertexToRemove, dir);
            }
        }
    };
    PortManager.prototype.DisconnectVertexInDirection = function (vertexToRemove, direction) {
        var nextVertex = vertexToRemove.FindNextVertex(direction);
        var prevVertex = vertexToRemove.FindNextVertex(Extensions.OppositeDirection(direction));
        if (nextVertex != null && prevVertex != null) {
            this.visibilityGraph.RemoveEdge(prevVertex, vertexToRemove);
            var edge = this.visibilityGraph.FindEdge_vertex(vertexToRemove, nextVertex);
            if (edge) {
                edge.ClearProperties();
                edge.ResetFields(prevVertex, nextVertex, direction);
                return true;
            }
        }
        return false;
    };
    PortManager.prototype.ExtendTheEdgeToAdjacentEdges = function (start, direction, segment, isOverlapped, preference) {
        if (preference === void 0) { preference = null; }
        var startVertex = this.visibilityGraph.FindVertex(start);
        if (startVertex != null) {
            var dirToExtend = Extensions.GetEquivalentDirection(direction);
            var sourceDirection, targetDirection;
            sourceDirection = preference != null ? preference : Extensions.Left(dirToExtend);
            var sourceVertex = startVertex.FindNextVertex(sourceDirection);
            if (sourceVertex == null) {
                sourceDirection = Extensions.OppositeDirection(sourceDirection);
            }
            targetDirection = Extensions.OppositeDirection(sourceDirection);
            if (!this.ExtendEdge(startVertex, dirToExtend, sourceDirection, targetDirection, isOverlapped, segment)) {
                this.ExtendEdge(startVertex, dirToExtend, targetDirection, sourceDirection, isOverlapped, segment);
            }
        }
    };
    PortManager.prototype.AddVertexAndEdges = function (start, next, weight) {
        this.ConnectVertices_vertex(this.AddVertex(start), this.AddVertex(next), weight);
    };
    PortManager.prototype.ConnectVertices = function (start, end, weight) {
        if (weight === void 0) { weight = 1; }
        this.ConnectVertices_vertex(this.AddVertex(start), this.AddVertex(end), 1);
    };
    PortManager.prototype.ExtendEdge = function (startVertex, dirToExtend, sourceDirection, targetDirection, isOverlapped, visibilitySegment) {
        isOverlapped = false;
        var firstSegmentLength = 0;
        var isHorizontal = (dirToExtend == Directions.East || dirToExtend == Directions.West) ? true : false;
        var source = startVertex.FindNextVertex(sourceDirection);
        var target = null;
        var nextExtendVertex = null;
        var extendedEdgeCount = 0;
        var considerOppositeEdgeToo = false;
        if (source != null) {
            for (;;) {
                var args = this.GetNextSource(source, dirToExtend, source);
                source = args.source;
                if (!args.nextSource) {
                    break;
                }
                var nextExtendPoint = this.FindBendPoint(startVertex, source, isHorizontal);
                nextExtendVertex = null;
                if (visibilitySegment.StartPoint.FindDirection(nextExtendPoint) == nextExtendPoint.FindDirection(visibilitySegment.EndPoint) || visibilitySegment.StartPoint.equals(nextExtendPoint) || visibilitySegment.EndPoint.equals(nextExtendPoint)) {
                    nextExtendVertex = this.AddVertex(nextExtendPoint);
                    this.lastExtendedVertex = nextExtendVertex;
                }
                else {
                    if (dirToExtend == Directions.East) {
                        var lastSegment = this.VerticalScanSegmentTree.FindLast(visibilitySegment.EndPoint);
                        if (lastSegment != null) {
                            nextExtendPoint = new Point(lastSegment.getStartPoint().x, nextExtendPoint.y);
                            nextExtendVertex = this.AddVertex(nextExtendPoint);
                            this.lastExtendedVertex = nextExtendVertex;
                        }
                    }
                    else if (dirToExtend == Directions.West) {
                        var lastSegment = this.VerticalScanSegmentTree.FindFirst(visibilitySegment.EndPoint);
                        if (lastSegment != null) {
                            nextExtendPoint = new Point(lastSegment.getStartPoint().x, nextExtendPoint.y);
                            nextExtendVertex = this.AddVertex(nextExtendPoint);
                            this.lastExtendedVertex = nextExtendVertex;
                        }
                    }
                    else if (dirToExtend == Directions.South) {
                        var lastSegment = this.HorizontalScanSegmentTree.FindFirst(visibilitySegment.EndPoint);
                        if (lastSegment != null) {
                            nextExtendPoint = new Point(nextExtendPoint.x, lastSegment.getStartPoint().y);
                            nextExtendVertex = this.AddVertex(nextExtendPoint);
                            this.lastExtendedVertex = nextExtendVertex;
                        }
                    }
                    else if (dirToExtend == Directions.North) {
                        var lastSegment = this.HorizontalScanSegmentTree.FindLast(visibilitySegment.EndPoint);
                        if (lastSegment != null) {
                            nextExtendPoint = new Point(nextExtendPoint.x, lastSegment.getStartPoint().y);
                            nextExtendVertex = this.AddVertex(nextExtendPoint);
                            this.lastExtendedVertex = nextExtendVertex;
                        }
                    }
                }
                target = this.GetNextTarget(source, targetDirection, nextExtendPoint);
                if (nextExtendVertex != null) {
                    var nextSource = source.FindNextVertex(source.Point.FindDirection(nextExtendPoint));
                    if (nextSource != null)
                        this.ConnectVertices_vertex(source, nextExtendVertex, isOverlapped ? this.InitialWeight : this.NormalWeight);
                    this.ConnectVertices_vertex(startVertex, nextExtendVertex, 1);
                    startVertex = nextExtendVertex;
                }
                else
                    break;
                extendedEdgeCount++;
            }
        }
        if (considerOppositeEdgeToo)
            return false;
        return target != null;
    };
    PortManager.prototype.GetNextSource = function (startVertex, dirToExtend, source) {
        source = startVertex.FindNextVertex(dirToExtend);
        return { nextSource: source != null, source: source };
    };
    PortManager.prototype.GetNextTarget = function (sourceVertex, targetDirection, nextExtendPoint) {
        var direction = targetDirection;
        var target = sourceVertex;
        while (direction == targetDirection) {
            sourceVertex = target;
            target = sourceVertex.FindNextVertex(targetDirection);
            if (target == null)
                break;
            if (target.Point.equals(nextExtendPoint)) {
                return target.FindNextVertex(targetDirection);
            }
            direction = target.Point.FindDirection(nextExtendPoint);
        }
        return target;
    };
    PortManager.prototype.FindBendPoint = function (start, end, isHorizontal) {
        if (isHorizontal) {
            return new Point(end.Point.x, start.Point.y);
        }
        return new Point(start.Point.x, end.Point.y);
    };
    PortManager.prototype.AddEdgeToClosestPerpSegments = function (nearestSeg, intersectPt, isOverlapped) {
        var dir = nearestSeg.getIsVertical() ? Directions.North : Directions.East;
        var vertex = this.visibilityGraph.FindVertex(nearestSeg.getStartPoint());
        var prev = null;
        while (vertex != null) {
            if (vertex.Point.equals(intersectPt))
                break;
            else {
                if (prev != null && prev.Point.FindDirection(intersectPt) == intersectPt.FindDirection(vertex.Point)) {
                    var edge = this.visibilityGraph.FindEdge(prev.Point, vertex.Point);
                    if (edge != null) {
                        if (!(edge instanceof DynamicEdge) && this.temporaryAddition)
                            this.edgesToRestore.add(edge);
                        this.visibilityGraph.RemoveEdge_edge(edge, true);
                    }
                    return;
                }
            }
            prev = vertex;
            vertex = vertex.FindNextVertex(dir);
        }
    };
    PortManager.prototype.FindOrAddEdge = function (sourceVertex, targetVertex, weight, swap) {
        var direction = sourceVertex.Point.FindDirection(targetVertex.Point);
        var bracketSource, bracketTarget;
        var sourceEnd = false;
        var srcDirVertex = sourceVertex.FindNextVertex(direction);
        if (srcDirVertex == null) {
            swap = true;
            sourceEnd = false;
        }
        var args = this.FindExistingEdgeEnds(sourceVertex, targetVertex, direction, bracketSource, bracketTarget, sourceEnd, swap);
        var contained = args.isBracketTarget;
        bracketSource = args.bracketSource;
        bracketTarget = args.bracketTarget;
        sourceEnd = args.sourceEnd;
        swap = args.swap;
        if (!contained && !sourceEnd) {
            args = this.FindExistingEdgeEnds(bracketSource != null ? bracketSource : sourceVertex, bracketTarget != null ? bracketTarget : targetVertex, direction, bracketSource, bracketTarget, sourceEnd, true);
            contained = args.isBracketTarget;
            bracketSource = args.bracketSource;
            bracketTarget = args.bracketTarget;
            sourceEnd = args.sourceEnd;
            swap = args.swap;
        }
        if (contained) {
            var edge;
            edge = this.visibilityGraph.FindEdge(bracketSource.Point, bracketTarget.Point);
            if (edge != null && edge.getSource() == sourceVertex && edge.getTarget() == targetVertex)
                return;
            if (edge != null) {
                if (edge.getSourcePoint().OperatorLessThan(sourceVertex.Point) && edge.getTargetPoint().OperatorGreaterThan(targetVertex.Point)) {
                }
                var splitVertex;
                if (sourceEnd) {
                    splitVertex = sourceVertex;
                }
                else {
                    splitVertex = targetVertex;
                }
                this.SplitEdge(splitVertex, edge);
            }
            else {
                this.CreateEdge(sourceVertex, targetVertex, weight);
            }
        }
        else {
            if (bracketSource != null && bracketSource != sourceVertex && bracketSource.Point.FindDirection(targetVertex.Point) == direction) {
                this.CreateEdge(bracketSource, targetVertex, weight);
            }
            else if (bracketTarget != null && bracketTarget != targetVertex && bracketTarget.Point.FindDirection(sourceVertex.Point) == Extensions.OppositeDirection(direction)) {
                this.CreateEdge(sourceVertex, bracketTarget, weight);
            }
            else {
                this.CreateEdge(sourceVertex, targetVertex, weight);
            }
        }
    };
    PortManager.prototype.InsertEdge = function (source, target) {
        this.InsertEdge_vertex(this.AddVertex(source), this.AddVertex(target));
    };
    PortManager.prototype.InsertEdge_vertex = function (sourceVertex, targetVertex) {
        var direction = sourceVertex.Point.FindDirection(targetVertex.Point);
        var nextVertex = sourceVertex.FindNextVertex(direction);
        var lastTarget = sourceVertex;
        if (nextVertex != null) {
            while (nextVertex != null && nextVertex != targetVertex) {
                if (nextVertex == targetVertex)
                    break;
                if (nextVertex.Point.OperatorLessThan(targetVertex.Point)) {
                    lastTarget = nextVertex;
                }
                else {
                    var edge = this.visibilityGraph.FindEdge(lastTarget.Point, nextVertex.Point);
                    this.SplitEdge(targetVertex, edge);
                    break;
                }
                lastTarget = nextVertex;
                nextVertex = lastTarget.FindNextVertex(direction);
            }
        }
        else
            this.CreateEdge(sourceVertex, targetVertex, 1);
    };
    PortManager.prototype.GetIntersectingPoint = function (segment, point, isHorizontal) {
        if (isHorizontal) {
            return new Point(Utility.ToRoundedInt(point.x), segment.getStartPoint().y);
        }
        else {
            return new Point(segment.getStartPoint().x, Utility.ToRoundedInt(point.y));
        }
    };
    PortManager.prototype.CreatePortEntrances = function (node, port, obstacle) {
        var entrances = new List();
        if (port != null) {
            var location = port.getLocation();
            var obstacleTree = this.ObstacleTree.Rectangle;
            port.Entrances.Clear();
            var segment = new Segment(new Point(obstacleTree.left(), location.y), new Point(obstacleTree.right(), location.y));
            var intersections = Utility.GetIntersections(segment, obstacle.StartVertex);
            if (intersections.size() > 0) {
                for (var i = 0; i < intersections.size(); i++) {
                    var intersection = intersections.get(i);
                    if (intersection.x < location.x) {
                        port.AddPortEntrance(this.ObstacleTree, new Point(intersection.x + this.ObstacleTree.ObstaclePadding, intersection.y), node, PortDirection.Left);
                    }
                    else {
                        port.AddPortEntrance(this.ObstacleTree, new Point(intersection.x - this.ObstacleTree.ObstaclePadding, intersection.y), node, PortDirection.Right);
                    }
                }
            }
            segment = new Segment(new Point(location.x, obstacleTree.top()), new Point(location.x, obstacleTree.bottom()));
            intersections = Utility.GetIntersections(segment, obstacle.StartVertex);
            if (intersections.size() > 0) {
                for (var i = 0; i < intersections.size(); i++) {
                    var intersection = intersections.get(i);
                    if (intersection.y < location.y) {
                        port.AddPortEntrance(this.ObstacleTree, new Point(intersection.x, intersection.y + this.ObstacleTree.ObstaclePadding), node, PortDirection.Top);
                    }
                    else {
                        port.AddPortEntrance(this.ObstacleTree, new Point(intersection.x, intersection.y - this.ObstacleTree.ObstaclePadding), node, PortDirection.Bottom);
                    }
                }
            }
            return port.Entrances;
        }
        return entrances;
    };
    PortManager.prototype.FindEntrances = function (port) {
        var vertices = new List();
        if (port instanceof CenterPort) {
            var centerPort = port;
            for (var i = 0; i < centerPort.Entrances.size(); i++) {
                var entrance = centerPort.Entrances.get(i);
                var vertex = this.visibilityGraph.FindVertex(entrance.Location);
                vertices.add(vertex);
            }
        }
        else {
            var vertex = this.visibilityGraph.FindVertex(port.getLocation());
            vertices.add(vertex);
        }
        var i = 0;
        while (i < vertices.size()) {
            if (vertices.get(i).getDegree() == 0) {
                vertices.RemoveAt(i);
                continue;
            }
            i++;
        }
        return vertices;
    };
    PortManager.prototype.GetPortVisibilityIntersection = function (geometry) {
        var sourcePortInfo = geometry._sourcePortInfo;
        var targetPortInfo = geometry._targetPortInfo;
        var sourceNodeInfo = geometry._sourceNodeInfo;
        var targetNodeInfo = geometry._targetNodeInfo;
        if (sourcePortInfo != null && targetPortInfo != null) {
            var sourceEntrance = new PortEntrance(sourcePortInfo, sourcePortInfo.getLocation(), sourceNodeInfo, sourcePortInfo.getDirection(), this.ObstacleTree);
            var targetEntrance = new PortEntrance(targetPortInfo, targetPortInfo.getLocation(), targetNodeInfo, targetPortInfo.getDirection(), this.ObstacleTree);
            this.targetGeometry.SourceEntrance = sourceEntrance;
            this.targetGeometry.TargetEntrance = targetEntrance;
            var points = this.GetPathPoints(geometry, sourceEntrance, targetEntrance);
            if (points != null)
                return points;
            else {
                return this.CheckForLessDistanceBetweenSourceAndTarget(sourceNodeInfo, targetNodeInfo, sourcePortInfo, targetPortInfo);
            }
        }
        else if (sourceNodeInfo != null && sourceNodeInfo._obstacle != null && targetNodeInfo != null && targetNodeInfo._obstacle != null) {
            var sourcePort = sourceNodeInfo._obstacle.CenterPort;
            var targetPort = targetNodeInfo._obstacle.CenterPort;
            var souEntrances = this.CreatePortEntrances(sourceNodeInfo, sourcePort, sourceNodeInfo._obstacle);
            var taEntrances = this.CreatePortEntrances(targetNodeInfo, targetPort, targetNodeInfo._obstacle);
            if (!(sourcePort.VisibilityRectangle.intersects(targetPort.VisibilityRectangle))) {
                return null;
            }
            for (var i = 0; i < souEntrances.size(); i++) {
                sourceEntrance = souEntrances.get(Number(i));
                if (!sourceEntrance.getWantVisibilityIntersection())
                    continue;
                for (var j = 0; j < taEntrances.size(); j++) {
                    targetEntrance = taEntrances.get(Number(j));
                    if (!targetEntrance.getWantVisibilityIntersection())
                        continue;
                    var points = this.GetPathPoints(geometry, sourceEntrance, targetEntrance);
                    if (points != null)
                        return points;
                }
            }
        }
        return null;
    };
    PortManager.prototype.CheckForLessDistanceBetweenSourceAndTarget = function (sourceNodeInfo, targetNodeInfo, sourcePortInfo, targetPortInfo) {
        if (sourcePortInfo.getDirection() == Extensions.OppositeDirection_Port(targetPortInfo.getDirection())) {
            var sourceEdge = Utility.IntersectionWithRectangleBorder(sourceNodeInfo._outerBounds, sourcePortInfo.getLocation(), Extensions.GetEquivalentDirection(sourcePortInfo.getDirection()));
            var targetEdge = Utility.IntersectionWithRectangleBorder(targetNodeInfo._outerBounds, targetPortInfo.getLocation(), Extensions.GetEquivalentDirection(targetPortInfo.getDirection()));
            var distance = Extensions.FindDistance(sourceEdge, targetEdge, Extensions.GetOrientation_PortDirection(targetPortInfo.getDirection()));
            if (distance < 2 * this.padding && distance > 4) {
                var orientation = Extensions.GetOrientation_PortDirection(sourcePortInfo.getDirection());
                var start = Extensions.Transform(sourceEdge, distance / 2, Extensions.GetEquivalentDirection(sourcePortInfo.getDirection()));
                var xx = Extensions.GetOrientation_PortDirection(sourcePortInfo.getDirection());
                var segment = new Segment(start, Utility.IntersectionWithRectangleBorder(this.ObstacleTree.Rectangle, start, Extensions.FindDirectionOrientation(sourcePortInfo.getLocation(), targetPortInfo.getLocation(), Extensions.OppositeOrientation(xx))));
                var endPoint = Extensions.Transform(targetEdge, distance / 2, Extensions.GetEquivalentDirection(Extensions.OppositeDirection_Port(sourcePortInfo.getDirection())));
                if (this.ObstacleTree.FindMaximumVisibility(segment, sourceNodeInfo) && segment.Contains(endPoint)) {
                    var list = new PointList();
                    list.add(sourcePortInfo.getLocation());
                    list.add(start);
                    list.add(endPoint);
                    list.add(targetPortInfo.getLocation());
                    return list;
                }
            }
        }
        return null;
    };
    PortManager.prototype.GetPathPoints = function (geometry, sourceEntrance, targetEntrance) {
        var points = null;
        if (sourceEntrance.Direction == Extensions.OppositeDirection_Port(targetEntrance.Direction) && sourceEntrance.FirstHit == geometry._targetNodeInfo && targetEntrance.FirstHit == geometry._sourceNodeInfo) {
            return new PointList();
        }
        if (sourceEntrance.getIsVertical() == targetEntrance.getIsVertical()) {
            points = this.GetPathPointsFromCollinearPorts(sourceEntrance, targetEntrance);
        }
        else {
            points = this.GetPathPointsFromIntersectingPorts(sourceEntrance, targetEntrance);
        }
        return points;
    };
    PortManager.prototype.GetPathPointsFromCollinearPorts = function (sourceEntrance, targetEntrance) {
        if (!(Utility.AreEquivalentLines(sourceEntrance.MaxVisibilitySegment, targetEntrance.MaxVisibilitySegment))) {
            return null;
        }
        if (sourceEntrance.MaxVisibilitySegment.StartPoint.equals(sourceEntrance.MaxVisibilitySegment.EndPoint)) {
            return null;
        }
        var list = new PointList();
        list.add(sourceEntrance.Location);
        list.add(targetEntrance.Location);
        return list;
    };
    PortManager.prototype.GetPathPointsFromIntersectingPorts = function (sourceEntrance, targetEntrance) {
        var intersectingPoint;
        var args = Utility.SegmentIntersects(sourceEntrance.MaxVisibilitySegment, targetEntrance.MaxVisibilitySegment, intersectingPoint);
        intersectingPoint = args.intersect;
        if (!args.isInterSect) {
            return null;
        }
        var list = new PointList();
        list.add(sourceEntrance.Location);
        list.add(intersectingPoint);
        list.add(targetEntrance.Location);
        return list;
    };
    PortManager.prototype.CreateEdge = function (sourceVertex, targetVertex, weight, direction) {
        if (direction === void 0) { direction = Directions.None; }
        if (this.temporaryAddition) {
            if (sourceVertex.Point.OperatorGreaterThan(targetVertex.Point)) {
                var temp = sourceVertex;
                sourceVertex = targetVertex;
                targetVertex = temp;
            }
            var newEdge = this.visibilityGraph.FindEdge_vertex(sourceVertex, targetVertex);
            if (newEdge == null) {
                newEdge = new DynamicEdge(sourceVertex, targetVertex, weight);
                this.addedEdges.add(newEdge);
                VisibilityGraph.AddEdge(newEdge);
            }
        }
        else {
            this.visibilityGraph.AddEdge(sourceVertex, targetVertex, direction, weight);
        }
    };
    PortManager.prototype.SplitEdge = function (splitVertex, edge) {
        if (splitVertex.Point.equals(edge.getSourcePoint()) || splitVertex.Point.equals(edge.getTargetPoint()))
            return;
        if (!(edge instanceof DynamicEdge) && this.temporaryAddition)
            this.edgesToRestore.add(edge);
        this.visibilityGraph.RemoveEdge_edge(edge, true);
        this.CreateEdge(splitVertex, edge.getTarget(), edge.getWeight());
        this.CreateEdge(edge.getSource(), splitVertex, edge.getWeight());
    };
    PortManager.prototype.FindExistingEdgeEnds = function (sourceVertex, targetVertex, direction, bracketSource, bracketTarget, sourceEnd, swap) {
        sourceEnd = false;
        if (swap) {
            sourceEnd = true;
            var temp = sourceVertex;
            sourceVertex = targetVertex;
            targetVertex = temp;
            direction = Extensions.OppositeDirection(direction);
        }
        bracketSource = sourceVertex;
        for (;;) {
            bracketTarget = bracketSource.FindNextVertex(direction);
            if (bracketTarget == null) {
                break;
            }
            else if (bracketTarget.Point.equals(targetVertex.Point)) {
                break;
            }
            else if (direction == targetVertex.Point.FindDirection(bracketTarget.Point)) {
                break;
            }
            bracketSource = bracketTarget;
        }
        if (swap) {
            var temp = bracketSource;
            bracketSource = bracketTarget;
            bracketTarget = temp;
            return { isBracketTarget: bracketSource != null, bracketSource: bracketSource, bracketTarget: bracketTarget, sourceEnd: sourceEnd, swap: swap };
        }
        return { isBracketTarget: bracketTarget != null, bracketSource: bracketSource, bracketTarget: bracketTarget, sourceEnd: sourceEnd, swap: swap };
    };
    PortManager.prototype.AddVertex = function (point) {
        var vertex = this.visibilityGraph.FindVertex(point);
        if (vertex == null) {
            vertex = this.visibilityGraph.AddVertex(point);
            if (this.temporaryAddition)
                this.addedVertices.add(vertex);
        }
        return vertex;
    };
    PortManager.prototype.RestoreEdges = function () {
        for (var i = 0; i < this.edgesToRestore.size(); i++) {
            VisibilityGraph.AddEdge(this.edgesToRestore.get(i));
        }
        this.edgesToRestore.Clear();
    };
    PortManager.prototype.RemoveAddedEdges = function () {
        for (var i = 0; i < this.addedEdges.size(); i++) {
            this.visibilityGraph.RemoveEdge_edge(this.addedEdges.get(i));
        }
        this.addedEdges.Clear();
    };
    PortManager.prototype.RemoveAddedVertices = function () {
        for (var i = 0; i < this.addedVertices.size(); i++) {
            this.visibilityGraph.RemoveVertex(this.addedVertices.get(i));
        }
        this.addedVertices.Clear();
    };
    PortManager.prototype.RemoveEdgeGeometryFromGraph = function () {
        this.RemoveAddedVertices();
        this.RemoveAddedEdges();
        this.RestoreEdges();
    };
    PortManager.prototype.GetValidPortLocation = function (point) {
        if (!this.ObstacleTree.Rectangle.containsPoint(point)) {
            var bounds = this.ObstacleTree.Rectangle;
            var left = bounds.left(), right = bounds.right();
            var top = bounds.top(), bottom = bounds.bottom();
            var cornerPoints = new PointList().PointList([
                new Point(left, top), new Point(right, top),
                new Point(right, bottom),
                new Point(left, bottom),
                new Point(left, top)]);
            var line1 = new PointList().PointList([point, new Point(left, point.y)]);
            var line2 = new PointList().PointList([point, new Point(point.x, top)]);
            var intercepts = LineExtensions.Intersect_PointCollection(line1, cornerPoints, false);
            intercepts = intercepts.Concat(LineExtensions.Intersect_PointCollection(line2, cornerPoints, false));
            if (intercepts.size() == 0) {
                intercepts = new PointList().PointList([
                    bounds.topLeft,
                    bounds.topRight,
                    bounds.bottomLeft,
                    bounds.bottomRight
                ]);
            }
            var intersectingPoint = point;
            var minDistance = null;
            for (var k = 0; k < intercepts.size(); k++) {
                var pt = intercepts.get(k);
                var distance = Math.sqrt(Math.pow((point.x - pt.x), 2) + Math.pow((point.y - pt.y), 2));
                distance = Math.round(distance);
                if (minDistance == null || Math.min(minDistance, distance) === (distance)) {
                    minDistance = distance;
                    intersectingPoint = pt;
                }
            }
            point = intersectingPoint;
        }
        return point;
    };
    PortManager.prototype.IsCurrentConnectionSegmentsValid = function (edge, points) {
        var wrapper = edge;
        if (wrapper != null) {
            var pts = ej.datavisualization.Diagram.Util.getPoints(wrapper);
            for (var i = 0; i < pts.length; i++) {
                if (!(i > 0 && points.get(points.size() - 1) == (pts[i])) || i == 0) {
                    points.add(pts[i]);
                }
            }
            var cbounds = wrapper._outerBounds;
            var bounds = new Rect().Rect(pts[0], pts[pts.length - 1]);
            var nodes = this.ObstacleTree.FindNodes(bounds);
            if (nodes && nodes.size() > 0 && points.size() > 0) {
                for (var i = 0; i < nodes.size(); i++) {
                    var obstacle = nodes.get(i);
                    var obsBounds = obstacle._obstacle.getPaddedBounds() ? obstacle._obstacle.getPaddedBounds() : new Rect();
                    var cornerpts = new PointList();
                    cornerpts.add(new Point(obsBounds.left(), obsBounds.top()));
                    cornerpts.add(new Point(obsBounds.right(), obsBounds.top()));
                    cornerpts.add(new Point(obsBounds.right(), obsBounds.bottom()));
                    cornerpts.add(new Point(obsBounds.left(), obsBounds.bottom()));
                    cornerpts.add(new Point(obsBounds.left(), obsBounds.top()));
                    var intersecpts = new PointList();
                    intersecpts.AddRange(LineExtensions.Intersect_PointCollection(cornerpts, points, false));
                    if (intersecpts.size() > 0) {
                        if (wrapper._sourceNodeInfo == obstacle || wrapper._targetNodeInfo == obstacle) {
                            var j = 0, count = points.size();
                            var lastSegRect = new Rect().Rect(points.get(count - 1), points.get(count - 2));
                            var firstSegRect = new Rect().Rect(points.get(0), points.get(1));
                            while (j < intersecpts.size()) {
                                if (lastSegRect.containsPoint(intersecpts.get(j)) || firstSegRect.containsPoint(intersecpts.get(j))) {
                                    intersecpts.RemoveAt(j);
                                }
                                else {
                                    j++;
                                }
                            }
                        }
                        if (intersecpts.size() > 0) {
                            return {
                                canValid: false,
                                points: new PointList()
                            };
                        }
                    }
                }
            }
            return {
                canValid: true,
                points: points
            };
        }
        return {
            canValid: false,
            points: new PointList()
        };
    };
    PortManager.prototype.GetLineSegment = function (startPoint, direction, start, end, checkAdjcant) {
        if (checkAdjcant === void 0) { checkAdjcant = true; }
        var hit;
        var endPoint = Utility.IntersectionWithRectangleBorder(this.ObstacleTree.Rectangle, startPoint, direction);
        var segment = new Segment(startPoint, endPoint);
        var args = this.ObstacleTree.FindMaximumVisibility_hitNode(segment, start, end, hit);
        hit = args.hitNode;
        if (checkAdjcant) {
            var delX = 0, delY = 0;
            if (Extensions.GetOrientation(direction) == Orientation.Horizontal)
                delY = 5;
            else
                delX = 5;
            var segment1 = this.GetLineSegment(new Point(startPoint.x + delX, startPoint.y + delY), direction, start, end, false);
            var segment2 = this.GetLineSegment(new Point(startPoint.x - delX, startPoint.y - delY), direction, start, end, false);
            if (Extensions.GetOrientation(direction) == Orientation.Horizontal) {
                if (segment.Bounds.width > segment1.Bounds().width)
                    segment = new Segment(startPoint, new Point(segment1.EndPoint.x, segment.EndPoint.y));
                if (segment.Bounds.width > segment2.Bounds().width)
                    segment = new Segment(startPoint, new Point(segment2.EndPoint.x, segment.EndPoint.y));
            }
            else {
                if (segment.Bounds.height > segment1.Bounds().height)
                    segment = new Segment(startPoint, new Point(segment.EndPoint.x, segment1.EndPoint.y));
                if (segment.Bounds.height > segment2.Bounds().height)
                    segment = new Segment(startPoint, new Point(segment.EndPoint.x, segment2.EndPoint.y));
            }
        }
        return segment;
    };
    PortManager.prototype.IsEndPointChanged = function (connector) {
        var isModified = true;
        if (connector._points != null && connector._points.size() > 0) {
            connector._points = (connector._points);
            var sourcePoint = new Point(), targetPoint = new Point();
            if (connector.sourcePoint)
                sourcePoint = connector.sourcePoint;
            if (connector.targetPoint)
                targetPoint = connector.targetPoint;
            if (connector._points.ElementAt(0).equals(sourcePoint) && connector._points.ElementAt(connector._points.size() - 1).equals(targetPoint))
                isModified = false;
        }
        return isModified;
    };
    PortManager.prototype.ConnectVertices_vertex = function (startVertex, nextVertex, weight, direction) {
        if (weight === void 0) { weight = 1; }
        if (direction === void 0) { direction = Directions.None; }
        if (startVertex != nextVertex) {
            if (this.temporaryAddition) {
                var swapped = false;
                if (startVertex.Point.OperatorGreaterThan(nextVertex.Point)) {
                    var temp = nextVertex;
                    nextVertex = startVertex;
                    startVertex = temp;
                    swapped = true;
                }
                this.FindOrAddEdge(startVertex, nextVertex, weight, swapped);
            }
            else
                this.CreateEdge(startVertex, nextVertex, weight, direction);
        }
    };
    return PortManager;
}());
var LineUtil = (function () {
    function LineUtil(x1, y1, x2, y2) {
        this.X1 = 0;
        this.Y1 = 0;
        this.X2 = 0;
        this.Y2 = 0;
        this.X1 = x1;
        this.X2 = x2;
        this.Y1 = y1;
        this.Y2 = y2;
    }
    return LineUtil;
}());
var LineExtensions = (function () {
    function LineExtensions() {
    }
    LineExtensions.Intersect = function (s, t, POI) {
        var isInterSect = false;
        POI = new Point(0, 0);
        var L1 = s;
        var L2 = t;
        var d = (L2.Y2 - L2.Y1) * (L1.X2 - L1.X1) - (L2.X2 - L2.X1) * (L1.Y2 - L1.Y1);
        var n_a = (L2.X2 - L2.X1) * (L1.Y1 - L2.Y1) - (L2.Y2 - L2.Y1) * (L1.X1 - L2.X1);
        var n_b = (L1.X2 - L1.X1) * (L1.Y1 - L2.Y1) - (L1.Y2 - L1.Y1) * (L1.X1 - L2.X1);
        if (d == 0)
            isInterSect = false;
        var ua = n_a / d;
        var ub = n_b / d;
        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
            POI.x = L1.X1 + (ua * (L1.X2 - L1.X1));
            POI.y = L1.Y1 + (ua * (L1.Y2 - L1.Y1));
            isInterSect = true;
        }
        return {
            isInterSect: isInterSect,
            POI: POI
        };
    };
    LineExtensions.Intersect_PointCollection = function (polyLine1, polyLine2, self) {
        if (self && polyLine2.size() >= 2) {
            polyLine2.RemoveAt(0);
            polyLine2.RemoveAt(0);
        }
        var intersect = new PointList();
        for (var i = 0; i < polyLine1.size() - 1; i++) {
            intersect.AddRange(this.Intersect_PointList(polyLine1.get(i), polyLine1.get(i + 1), polyLine2));
            if (self && polyLine2.size() >= 1) {
                polyLine2.RemoveAt(0);
            }
        }
        return intersect;
    };
    LineExtensions.Intersect_PointList = function (lineStart, lineEnd, polyLine) {
        var intersect = new PointList();
        for (var i = 0; i < polyLine.size() - 1; i++) {
            var p = this.Intersect_Points(lineStart, lineEnd, polyLine.get(i), polyLine.get(i + 1));
            if (!p.equals(new Point(0, 0))) {
                intersect.add(p);
            }
        }
        return intersect;
    };
    LineExtensions.Intersect_Points = function (start1, end1, start2, end2) {
        var l1 = new LineUtil(start1.x, start1.y, end1.x, end1.y);
        var l2 = new LineUtil(start2.x, start2.y, end2.x, end2.y);
        var args = this.Intersect(l1, l2, end2);
        end2 = args.POI;
        if (args.isInterSect) {
            return end2;
        }
        else {
            return new Point(0, 0);
        }
    };
    return LineExtensions;
}());
var Vertex = (function () {
    function Vertex(pt) {
        this._mEastEdge = null;
        this._mWestEdge = null;
        this._mSouthEdge = null;
        this._mNorthEdge = null;
        this.Point = pt;
    }
    Vertex.prototype.getEastEdge = function () {
        return this._mEastEdge;
    };
    Vertex.prototype.setEastEdge = function (value) {
        this._mEastEdge = value;
    };
    Vertex.prototype.getWestEdge = function () {
        return this._mWestEdge;
    };
    Vertex.prototype.setWestEdge = function (value) {
        this._mWestEdge = value;
    };
    Vertex.prototype.getSouthEdge = function () {
        return this._mSouthEdge;
    };
    Vertex.prototype.setSouthEdge = function (value) {
        this._mSouthEdge = value;
    };
    Vertex.prototype.getNorthEdge = function () {
        return this._mNorthEdge;
    };
    Vertex.prototype.setNorthEdge = function (value) {
        this._mNorthEdge = value;
    };
    Vertex.prototype.getDegree = function () {
        var count = 0;
        if (this._mEastEdge != null)
            count++;
        if (this._mWestEdge != null)
            count++;
        if (this._mNorthEdge != null)
            count++;
        if (this._mSouthEdge != null)
            count++;
        return count;
    };
    Vertex.prototype.RemoveEdgeAt = function (direction) {
        switch (direction) {
            case Directions.East:
                this._mEastEdge = null;
                break;
            case Directions.West:
                this._mWestEdge = null;
                break;
            case Directions.North:
                this._mNorthEdge = null;
                break;
            case Directions.South:
                this._mSouthEdge = null;
                break;
        }
    };
    Vertex.prototype.TryGetOutEdge = function (vertex, edge) {
        edge = null;
        if (this._mEastEdge != null && this._mEastEdge.getTarget() == vertex)
            edge = this._mEastEdge;
        else if (this._mNorthEdge != null && this._mNorthEdge.getTarget() == vertex)
            edge = this._mNorthEdge;
        return {
            edge: edge, canOut: edge != null ? true : false
        };
    };
    Vertex.prototype.TryGetInEdge = function (vertex, edge) {
        edge = null;
        if (this._mWestEdge != null && this._mWestEdge.getTarget() == vertex)
            edge = this._mWestEdge;
        else if (this._mSouthEdge != null && this._mSouthEdge.getTarget() == vertex)
            edge = this._mSouthEdge;
        return {
            edge: edge, canIn: edge != null ? true : false
        };
    };
    Vertex.prototype.ClearEdges = function () {
        this._mEastEdge = null;
        this._mNorthEdge = null;
        this._mSouthEdge = null;
        this._mWestEdge = null;
    };
    Vertex.prototype.SetVertexEntry = function (entry) {
        if (this.VertexEntries == null) {
            this.VertexEntries = new Array(4);
        }
        this.VertexEntries[Extensions.ToIndex(entry.Direction)] = entry;
    };
    Vertex.prototype.RemoveVertexEntries = function () {
        this.VertexEntries = null;
    };
    Vertex.prototype.FindNextVertex = function (direction) {
        var edge = null;
        if (direction == Directions.East)
            edge = this._mEastEdge;
        else if (direction == Directions.West)
            edge = this._mWestEdge;
        else if (direction == Directions.North)
            edge = this._mNorthEdge;
        else if (direction == Directions.South)
            edge = this._mSouthEdge;
        if (edge != null) {
            if (direction == Directions.East || direction == Directions.North)
                return edge.getTarget();
            else
                return edge.getSource();
        }
        return null;
    };
    Vertex.prototype.DisconnectEdges = function () {
        if (this._mEastEdge != null)
            this._mEastEdge.getTarget().RemoveEdgeAt(Directions.West);
        if (this._mNorthEdge != null)
            this._mNorthEdge.getTarget().RemoveEdgeAt(Directions.South);
        if (this._mWestEdge != null)
            this._mWestEdge.getSource().RemoveEdgeAt(Directions.East);
        if (this._mSouthEdge != null)
            this._mSouthEdge.getSource().RemoveEdgeAt(Directions.North);
    };
    return Vertex;
}());
var Edge = (function () {
    function Edge(source, target, weight) {
        this._mSource = null;
        this._mTarget = null;
        this._mSourcePoint = new Point();
        this._mTargetPoint = new Point();
        this._mLength = 0;
        this._mWeight = 0;
        this._mEdgeDirection = Directions.None;
        this.Edge(source, target);
        this._mWeight = weight;
        this.SetEdgeDirection();
        switch (this._mEdgeDirection) {
            case Directions.East:
                this._mSource.setEastEdge(this);
                this._mTarget.setWestEdge(this);
                break;
            case Directions.North:
                this._mSource.setNorthEdge(this);
                this._mTarget.setSouthEdge(this);
                break;
            case Directions.West:
                this._mSource.setWestEdge(this);
                this._mTarget.setEastEdge(this);
                break;
            case Directions.South:
                this._mSource.setSouthEdge(this);
                this._mTarget.setNorthEdge(this);
                break;
        }
    }
    Edge.prototype.getSource = function () {
        return this._mSource;
    };
    Edge.prototype.getTarget = function () {
        return this._mTarget;
    };
    Edge.prototype.getSourcePoint = function () {
        return this._mSourcePoint;
    };
    Edge.prototype.getTargetPoint = function () {
        return this._mTargetPoint;
    };
    Edge.prototype.getLength = function () {
        return this._mLength;
    };
    Edge.prototype.getWeight = function () {
        return this._mWeight;
    };
    Edge.prototype.getEdgeDirection = function () {
        return this._mEdgeDirection;
    };
    Edge.prototype.Edge = function (source, target) {
        this._mSource = source;
        this._mTarget = target;
        this._mSourcePoint = this._mSource != null ? this._mSource.Point : new Point();
        this._mTargetPoint = this._mTarget != null ? this._mTarget.Point : new Point();
    };
    Edge.prototype.EdgeWeight = function (source, target, direction, weight) {
        this.Edge(source, target);
        this._mWeight = weight;
        this._mEdgeDirection = direction;
        switch (this._mEdgeDirection) {
            case Directions.East:
                this._mSource.setEastEdge(this);
                this._mTarget.setWestEdge(this);
                break;
            case Directions.North:
                this._mSource.setNorthEdge(this);
                this._mTarget.setSouthEdge(this);
                break;
            case Directions.West:
                this._mSource.setWestEdge(this);
                this._mTarget.setEastEdge(this);
                break;
            case Directions.South:
                this._mSource.setSouthEdge(this);
                this._mTarget.setNorthEdge(this);
                break;
        }
        return this;
    };
    Edge.prototype.ResetFields = function (source, target, direction, weight) {
        if (direction === void 0) { direction = Directions.None; }
        if (weight === void 0) { weight = 1; }
        if (this._mSource != source) {
            this._mSource = source;
            this._mSourcePoint = this._mSource != null ? this._mSource.Point : new Point();
        }
        if (this._mTarget != target) {
            this._mTarget = target;
            this._mTargetPoint = this._mTarget != null ? this._mTarget.Point : new Point();
        }
        this._mWeight = weight;
        if (direction == Directions.None)
            this.SetEdgeDirection();
        else
            this._mEdgeDirection = direction;
        switch (this._mEdgeDirection) {
            case Directions.East:
                this._mSource.setEastEdge(this);
                this._mTarget.setWestEdge(this);
                break;
            case Directions.North:
                this._mSource.setNorthEdge(this);
                this._mTarget.setSouthEdge(this);
                break;
            case Directions.West:
                this._mSource.setWestEdge(this);
                this._mTarget.setEastEdge(this);
                break;
            case Directions.South:
                this._mSource.setSouthEdge(this);
                this._mTarget.setNorthEdge(this);
                break;
        }
    };
    Edge.prototype.ReversedClone = function () {
        return new this.Edge(this.getTarget(), this.getSource());
    };
    Edge.prototype.Clone = function () {
        return new this.Edge(this.getSource(), this.getTarget());
    };
    Edge.prototype.ClearProperties = function () {
        if (this._mSource != null && this._mTarget != null) {
            this._mSource.RemoveEdgeAt(this._mEdgeDirection);
            this._mTarget.RemoveEdgeAt(Extensions.OppositeDirection(this._mEdgeDirection));
        }
    };
    Edge.prototype.SetEdgeDirection = function () {
        var startX = this._mSourcePoint.x, endX = this._mTargetPoint.x;
        if (startX != endX)
            this._mEdgeDirection = endX > startX ? Directions.East : Directions.West;
        else {
            var startY = this._mSourcePoint.y, endY = this._mTargetPoint.y;
            if (startY != endY)
                this._mEdgeDirection = endY > startY ? Directions.North : Directions.South;
        }
    };
    return Edge;
}());
var DynamicEdge = (function (_super) {
    __extends(DynamicEdge, _super);
    function DynamicEdge(source, target, weight) {
        _super.call(this, source, target, weight);
    }
    return DynamicEdge;
}(Edge));
var VertexEntry = (function () {
    function VertexEntry(vertex, prevEntry, length, bends, cost) {
        this.TimeStamp = 0;
        this.Length = 0;
        this.Cost = 0;
        this.NumberOfBends = 0;
        this.Closed = false;
        this.Vertex = vertex;
        this.PreviousEntry = prevEntry;
        this.Length = length;
        this.NumberOfBends = bends;
        cost = Math.round(cost);
        this.Cost = cost;
        this.Direction = prevEntry != null ? prevEntry.Vertex.Point.FindDirection(vertex.Point) : Directions.None;
    }
    VertexEntry.prototype.ResetEntry = function (previousEntry, cost, bends, length) {
        this.PreviousEntry = previousEntry;
        cost = Math.round(cost);
        this.Cost = cost;
        this.NumberOfBends = bends;
        this.Length = length;
    };
    VertexEntry.prototype.CompareTo = function (other) {
        var result = Extensions.CompareTo(this.Cost, other.Cost);
        return result != 0 ? result : Extensions.CompareTo(other.TimeStamp, this.TimeStamp);
    };
    VertexEntry.prototype.ToString = function () {
        if (this.PreviousEntry != null)
            return "" + this.PreviousEntry.ToString() + " -> (" + this.Vertex.Point.x + ", " + this.Vertex.Point.y + ")";
        else
            return "(" + this.Vertex.Point.x + ", " + this.Vertex.Point.y + ")";
    };
    return VertexEntry;
}());
var VisibilityGraph = (function () {
    function VisibilityGraph() {
        this.Graph = new Dictionary();
        this.EdgesCache = new Stack();
        this.VertexFactory = (function (point) { return new Vertex(point); });
    }
    VisibilityGraph.prototype.getEdges = function () {
        var _mEdges = new List();
        this.getVertices().forEach(function (vertex) {
            if (vertex.EastEdge != null)
                _mEdges.add(vertex.EastEdge);
            if (vertex.NorthEdge != null)
                _mEdges.add(vertex.NorthEdge);
        });
        return _mEdges;
    };
    VisibilityGraph.prototype.getVertices = function () {
        var list = [];
        if (this.Graph) {
            var count = this.Graph.Count();
            for (var i = 0; i < count; i++) {
                var graphE = this.Graph.GetValue(this.Graph.KeyAt(i));
                var jcount = graphE.Count();
                for (var j = 0; j < jcount; j++) {
                    var entry = graphE.GetValue(graphE.KeyAt(j));
                    list.push(entry);
                }
            }
        }
        return list;
    };
    VisibilityGraph.prototype.FindVertex = function (point) {
        return this.FindVertexNumber(Utility.ToRoundedInt(point.x), Utility.ToRoundedInt(point.y));
    };
    VisibilityGraph.prototype.FindVertexNumber = function (x, y) {
        if (this.Graph.ContainsKey(x)) {
            var graphEntry = this.Graph.GetValue(x);
            if (graphEntry.ContainsKey(y))
                return graphEntry.GetValue(y);
        }
        return null;
    };
    VisibilityGraph.prototype.FindEdge = function (sourcePt, targetPt) {
        return this.FindEdge_vertex(this.FindVertex(sourcePt), this.FindVertex(targetPt));
    };
    VisibilityGraph.prototype.FindEdge_vertex = function (sourceVertex, targetVertex) {
        var edge = null;
        if (sourceVertex != null && targetVertex != null) {
            var args = sourceVertex.TryGetOutEdge(targetVertex, edge);
            edge = args.edge;
        }
        return edge;
    };
    VisibilityGraph.prototype.AddVertex = function (point) {
        var vertex = null;
        var x = Utility.ToRoundedInt(point.x), y = Utility.ToRoundedInt(point.y);
        if (this.Graph.ContainsKey(x)) {
            var graphEntry = this.Graph.GetValue(x);
            if (graphEntry.ContainsKey(y))
                vertex = graphEntry.GetValue(y);
            else {
                vertex = new Vertex(point);
                graphEntry.Add(vertex, y);
            }
        }
        else {
            vertex = new Vertex(point);
            var object = new Dictionary();
            object.Add(vertex, y);
            this.Graph.Add(object, x);
        }
        return vertex;
    };
    VisibilityGraph.prototype.ContainsVertex = function (point) {
        var x = Utility.ToRoundedInt(point.x), y = Utility.ToRoundedInt(point.y);
        if (this.Graph.ContainsKey(x)) {
            return this.Graph[this.Graph.IndexOfKey(x)].ContainsKey(y);
        }
        return false;
    };
    VisibilityGraph.prototype.CreateEdge = function (source, target, direction, weight) {
        if (direction === void 0) { direction = Directions.None; }
        if (weight === void 0) { weight = 1; }
        var edge = null;
        if (this.EdgesCache.Count() != 0) {
            edge = this.EdgesCache.Pop();
            edge.ResetFields(source, target, direction, weight);
        }
        else if (direction != Directions.None)
            edge = new Edge(source, target, weight).EdgeWeight(source, target, direction, weight);
        else
            edge = new Edge(source, target, weight);
        return edge;
    };
    VisibilityGraph.prototype.AddEdge_Point = function (sourcePt, targetPt) {
        var source = this.FindVertex(sourcePt), target = this.FindVertex(targetPt);
        if (source == null)
            source = this.AddVertex(sourcePt);
        if (target == null)
            target = this.AddVertex(targetPt);
        return this.AddEdge(source, target);
    };
    VisibilityGraph.prototype.AddEdge = function (source, target, direction, weight) {
        if (direction === void 0) { direction = Directions.None; }
        if (weight === void 0) { weight = 1; }
        var _vertex = this.FindEdge_vertex(source, target);
        return _vertex ? _vertex : this.CreateEdge(source, target, direction, weight);
    };
    VisibilityGraph.AddEdge = function (edge) {
        if (edge.getSource() != null && edge.getTarget() != null) {
            switch (edge.getEdgeDirection()) {
                case Directions.East:
                    edge.getSource().setEastEdge(edge);
                    edge.getTarget().setWestEdge(edge);
                    break;
                case Directions.North:
                    edge.getSource().setNorthEdge(edge);
                    edge.getTarget().setSouthEdge(edge);
                    break;
                case Directions.West:
                    edge.getSource().setWestEdge(edge);
                    edge.getTarget().setEastEdge(edge);
                    break;
                case Directions.South:
                    edge.getSource().setSouthEdge(edge);
                    edge.getTarget().setNorthEdge(edge);
                    break;
            }
        }
    };
    VisibilityGraph.prototype.RemoveVertex = function (vertex) {
        if (vertex != null) {
            vertex.DisconnectEdges();
            var x = Utility.ToRoundedInt(vertex.Point.x), y = Utility.ToRoundedInt(vertex.Point.y);
            if (this.Graph.ContainsKey(x)) {
                var graphEntry = this.Graph.GetValue(x);
                if (graphEntry.ContainsKey(y))
                    graphEntry.Remove(y);
                if (graphEntry.Count() == 0)
                    this.Graph.Remove(x);
            }
            vertex = null;
        }
    };
    VisibilityGraph.prototype.RemoveEdge = function (source, target) {
        var edge = this.FindEdge_vertex(source, target);
        if (edge != null)
            this.RemoveEdge_edge(edge);
        return edge;
    };
    VisibilityGraph.prototype.RemoveEdge_point = function (sourcePt, targetPt) {
        var edge = this.FindEdge(sourcePt, targetPt);
        if (edge != null)
            this.RemoveEdge_edge(edge);
    };
    VisibilityGraph.prototype.RemoveEdge_edge = function (edge, skipCache) {
        if (skipCache === void 0) { skipCache = false; }
        edge.ClearProperties();
        if (!skipCache && !(edge instanceof DynamicEdge))
            this.EdgesCache.Push(edge);
        edge = null;
    };
    VisibilityGraph.prototype.ClearEdges = function () {
        this.getVertices().forEach(function (vertex) { vertex.ClearEdges(); });
    };
    VisibilityGraph.stackCapacity = 1000;
    return VisibilityGraph;
}());
var EdgeGeometry = (function () {
    function EdgeGeometry() {
    }
    EdgeGeometry.prototype.GetCurrentEnd = function () {
        if (this.CurrentEnd == ConnectionEnd.Source)
            return this.SourceEntrance.Location;
        return this.TargetEntrance.Location;
    };
    EdgeGeometry.prototype.GetOppositeEnd = function () {
        if (this.CurrentEnd == ConnectionEnd.Target) {
            if (this.Connector._sourceNodeInfo != null) {
                return this.Connector._sourcePortInfo != null ? this.Connector._sourcePortInfo.getLocation() : this.Connector._sourceNodeInfo._outerBounds.center();
            }
            else {
                return this.Connector._sourcePointInfo.getLocation();
            }
        }
        if (this.Connector._targetNodeInfo != null) {
            return this.Connector._targetPortInfo != null ? this.Connector._targetPortInfo.getLocation() : this.Connector._targetNodeInfo._outerBounds.center();
        }
        else {
            return this.Connector._targetPointInfo.getLocation();
        }
    };
    EdgeGeometry.prototype.GetCurrentEntrance = function () {
        if (this.CurrentEnd == ConnectionEnd.Source)
            return this.SourceEntrance;
        return this.TargetEntrance;
    };
    return EdgeGeometry;
}());
;

(function ($, ej) {
    "use strict";

    //#region ZoomAndPan
    ej.datavisualization.Diagram.ZoomUtil = {
        zoomPan: function (diagram, currentZoom, deltaX, deltaY, focusPoint, isZoom) {
            if ((isZoom && ej.datavisualization.Diagram.Util.canZooming(diagram)) || (!isZoom && ej.datavisualization.Diagram.Util.canPanning(diagram))) {
                var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(diagram, true);
                var oVal = {
                    zoom: diagram._getCurrentZoom(), horizontalOffset: diagram._hScrollOffset,
                    verticalOffset: diagram._vScrollOffset, viewPort: viewPort
                };
                var matrix = ej.Matrix.identity();
                ej.Matrix.scale(matrix, diagram._currZoom, diagram._currZoom);
                ej.Matrix.translate(matrix, -diagram._hScrollOffset, -diagram._vScrollOffset);
                var newScale = diagram._currZoom * currentZoom;
                if (newScale > diagram.model.scrollSettings.maxZoom) {
                    currentZoom = diagram.model.scrollSettings.maxZoom / diagram._currZoom;
                }
                else if (newScale < diagram.model.scrollSettings.minZoom) {
                    currentZoom = diagram.model.scrollSettings.minZoom / diagram._currZoom;
                }
                var dMatrix = ej.Matrix.identity();
                var pivot;
                if (focusPoint) {
                    pivot = ej.Matrix.transform(matrix, focusPoint);
                }
                else {
                    pivot = ej.datavisualization.Diagram.Point($(diagram.element).width() / 2, $(diagram.element).height() / 2);
                }
                ej.Matrix.scale(dMatrix, currentZoom, currentZoom, pivot.x, pivot.y);
                newScale = diagram._currZoom * currentZoom;
                ej.Matrix.translate(dMatrix, deltaX, deltaY);
                ej.Matrix.multiply(matrix, dMatrix);
                var point = ej.Matrix.transform(matrix, ej.datavisualization.Diagram.Point(0, 0));
                diagram._compareModelProperty("scrollSettings", true);
                this._applyTransform(diagram, newScale, point, isZoom, viewPort);
                var nVal = {
                    zoom: diagram._getCurrentZoom(), horizontalOffset: diagram._hScrollOffset,
                    verticalOffset: diagram._vScrollOffset, viewPort: viewPort
                };
                diagram._eventCause["scrollChange"] = ej.datavisualization.Diagram.ScrollChangeCause.Zoom;
                if (!isZoom) diagram._eventCause["scrollChange"] = ej.datavisualization.Diagram.ScrollChangeCause.Pan;
                diagram._raiseEvent("scrollChange", { newValues: nVal, oldValues: oVal });
            }
        },
        _applyTransform: function (diagram, currentZoom, point, isZoom, viewPort) {
            diagram._currZoom = currentZoom;
            var zoomX = point.x * -1;
            var zoomY = point.y * -1;
            var bounds = diagram._getDigramBounds();
            if (!isZoom) {
                if (diagram._scrollLimit() !== ej.datavisualization.Diagram.ScrollLimit.Infinity) {
                    if (diagram._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Diagram) {
                        bounds.x -= diagram.model.scrollSettings.padding.left;
                        bounds.y -= diagram.model.scrollSettings.padding.top;
                        bounds.width += diagram.model.scrollSettings.padding.left + diagram.model.scrollSettings.padding.right;
                        bounds.height += diagram.model.scrollSettings.padding.top + diagram.model.scrollSettings.padding.bottom;
                        var isBoundsWidthHigh = bounds.width * diagram._currZoom > viewPort.width;
                        var isBoundsHeightHigh = bounds.height * diagram._currZoom > viewPort.height;
                        var diffX = (bounds.width + bounds.x) * diagram._currZoom - viewPort.width;
                        var diffY = (bounds.height + bounds.y) * diagram._currZoom - viewPort.height;
                        if ((!isBoundsWidthHigh && zoomX > diagram._hScrollOffset && zoomX > bounds.x * diagram._currZoom) || (isBoundsWidthHigh && zoomX < diagram._hScrollOffset && zoomX < bounds.x * diagram._currZoom))
                            zoomX = diagram._hScrollOffset;
                        else if ((!isBoundsWidthHigh && zoomX < diagram._hScrollOffset && zoomX < diffX) || (isBoundsWidthHigh && zoomX > diagram._hScrollOffset && zoomX > diffX))
                            zoomX = diagram._hScrollOffset;
                        if ((!isBoundsHeightHigh && zoomY > diagram._vScrollOffset && zoomY > bounds.y * diagram._currZoom) || (isBoundsHeightHigh && zoomY < diagram._vScrollOffset && zoomY < bounds.y * diagram._currZoom))
                            zoomY = diagram._vScrollOffset;
                        else if ((!isBoundsHeightHigh && zoomY < diagram._vScrollOffset && zoomY < diffY) || (isBoundsHeightHigh && zoomY > diagram._vScrollOffset && zoomY > diffY))
                            zoomY = diagram._vScrollOffset;
                    }
                    else {
                        if (zoomX < diagram._hScrollbar.model.minimum && !(diagram._hScrollbar.model.minimum == 0 && -diagram._hScrollOffset > point.x))
                            zoomX = diagram._hScrollOffset;
                        else if (zoomX > diagram._hScrollbar.model.maximum) {
                            zoomX = diagram._hScrollbar.model.maximum;
                        }
                        if (zoomY < diagram._vScrollbar.model.minimum && !(diagram._vScrollbar.model.minimum == 0 && -diagram._vScrollOffset > point.y))
                            zoomY = diagram._vScrollOffset;
                        else if (zoomY > diagram._vScrollbar.model.maximum) {
                            zoomY = diagram._vScrollbar.model.maximum;
                        }
                    }
                }
            }
            diagram._updateScrollOffset(zoomX, zoomY, true, isZoom);
        }
    };
    //#endregion 

    //#region PageSettings
    ej.datavisualization.Diagram.PageUtil = {
        _createPageBreaks: function (diagram) {
            this._removePageBreaks(diagram);
            var attr = { id: diagram._canvas.id + "pagebreaks", "pointer-events": "none" };
            var g = ej.datavisualization.Diagram.SvgContext._initializePageBreaks(diagram._svg, attr, diagram._pageBackgroundLayer);
            this._updatePageBreaks(g, diagram);
        },
        _removePageBreaks: function (diagram) {
            var g = diagram._svg.getElementById(diagram._canvas.id + "pagebreaks");
            if (g) { ej.datavisualization.Diagram.SvgContext._removePageBreaks(diagram._svg, g, diagram._pageBackgroundLayer); }
        },
        _updatePageBreaks: function (g, diagram) {
            var bounds = diagram._getDigramBounds();
            var pageSettings = diagram.model.pageSettings;
            var left = bounds.x;
            var right = bounds.width + bounds.x;
            var top = bounds.y;
            var bottom = bounds.height + bounds.y;
            var zoom = diagram._currZoom;
            var pHeight = diagram._pageHeight();
            var pWidth = diagram._pageWidth();
            var pMargin = diagram._pageMargin();
            var columncount = parseInt(Math.ceil((right - left) / pWidth));
            var rowcount = parseInt(Math.ceil((bottom - top) / pHeight));
            left = -diagram._canvas.clientLeft + (pMargin + left) * zoom;
            top = -diagram._canvas.clientTop + (pMargin + top) * zoom;
            var width = (pWidth * columncount - pMargin * 2) * zoom;
            var height = (pHeight * rowcount - pMargin * 2) * zoom;
            ej.datavisualization.Diagram.SvgContext._renderVPageBreakLine(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(left + width, top), diagram._svg, g);
            ej.datavisualization.Diagram.SvgContext._renderHPageBreakLine(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(left, top + height), diagram._svg, g);
            for (var column = 1; column < columncount; column++) {
                ej.datavisualization.Diagram.SvgContext._renderVPageBreakLine(ej.datavisualization.Diagram.Point(left + (pWidth * column - pMargin) * zoom, top),
                    ej.datavisualization.Diagram.Point(left + (pWidth * column - pMargin) * zoom, top + height), diagram._svg, g);
            }
            for (var row = 1; row < rowcount; row++) {
                ej.datavisualization.Diagram.SvgContext._renderHPageBreakLine(ej.datavisualization.Diagram.Point(left, top + (pHeight * row - pMargin) * zoom),
                    ej.datavisualization.Diagram.Point(left + width, top + (pHeight * row - pMargin) * zoom), diagram._svg, g);
            }
            ej.datavisualization.Diagram.SvgContext._renderVPageBreakLine(ej.datavisualization.Diagram.Point(left + width, top), ej.datavisualization.Diagram.Point(left + width, top + height), diagram._svg, g);
            ej.datavisualization.Diagram.SvgContext._renderHPageBreakLine(ej.datavisualization.Diagram.Point(left, top + height), ej.datavisualization.Diagram.Point(left + width, top + height), diagram._svg, g);
        },
        _updatePageSize: function (diagram, updatePage) {
            var swap = false;
            var pageOrientation = typeof diagram.model.pageSettings.pageOrientation === "string" ? diagram.model.pageSettings.pageOrientation : diagram._pageOrientation();
            var pageWidth = typeof diagram.model.pageSettings.pageWidth === "string" ? diagram.model.pageSettings.pageWidth : diagram._pageWidth();
            var pageHeight = typeof diagram.model.pageSettings.pageHeight === "string" ? diagram.model.pageSettings.pageHeight : diagram._pageHeight();
            if (pageOrientation == ej.datavisualization.Diagram.PageOrientations.Landscape) {
                if (pageHeight > pageWidth) {
                    swap = true;
                }
            }
            else {
                if (pageWidth > pageHeight) {
                    swap = true;
                }
            }
            if (swap) {
                var temp = pageWidth;
                diagram._pageWidth(pageHeight);
                diagram._pageHeight(temp);
            }
            var bounds = diagram._getDigramBounds();
            var zoom = diagram._currZoom;
            var left = bounds.x * zoom;
            var top = bounds.y * zoom;
            var width = bounds.width * zoom;
            var height = bounds.height * zoom;
            var pageSettings = diagram.model.pageSettings;
            if (diagram._pageBackgroundLayer && diagram._pageBackgroundLayer.firstChild) {
                ej.datavisualization.Diagram.SvgContext._updatePageBakground(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(width, height), diagram._svg, diagram._pageBackgroundLayer, diagram._pageBorderColor(), diagram._pageBackgroundColor(), diagram._pageBorderWidth());
            }
            else {
                ej.datavisualization.Diagram.SvgContext._renderPageSettingsRect(ej.datavisualization.Diagram.Point(left, top), ej.datavisualization.Diagram.Point(width, height), diagram._svg, diagram._pageBackgroundLayer, diagram._pageBorderColor(), diagram._pageBackgroundColor(), diagram._pageBorderWidth());
            }
            if (diagram.model.backgroundColor !== "transparent" || (diagram.model.backgroundImage && diagram.model.backgroundImage.source))
                ej.datavisualization.Diagram.SvgContext._updateBackground(diagram._hScrollOffset, diagram._vScrollOffset, diagram._currZoom, diagram);
            diagram._svg.document.style.left = 0;
            diagram._svg.document.style.top = 0;
            var check = false;
            if (!pageWidth) {
                if (!pageHeight) {
                    check = true;
                }
            }
            if (pageSettings.pageWidth && pageHeight) {
                if (diagram._showPageBreak()) {
                    this._createPageBreaks(diagram);
                }
                else {
                    this._removePageBreaks(diagram);
                }
            }
            if (!updatePage)
                ej.datavisualization.Diagram.ScrollUtil._setScrollContentSize(diagram);
        }
    };
    //#endregion

    //#region Scroller
    ej.datavisualization.Diagram.ScrollUtil = {
        _transform: function (diagram, hOffset, vOffset, canScale) {
            ej.datavisualization.Diagram.SvgContext.transformView(diagram, -hOffset, -vOffset);
            if (canScale) {
                ej.datavisualization.Diagram.SvgContext.scaleContent(diagram, diagram._currZoom);
            }
            this._updateRuler(diagram, hOffset, vOffset);
            ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram);
            // ej.datavisualization.Diagram.SvgContext._updateBackground(hOffset, vOffset, diagram._currZoom, diagram);
            ej.datavisualization.Diagram.SvgContext._updateGrid(hOffset, vOffset, diagram._currZoom, diagram);
        },
        _updateRuler: function (diagram, hOffset, vOffset) {
            if (diagram && diagram.model.rulerSettings.showRulers) {
                var rulerSize = this._getRulerSize(diagram);
                var rulerGeometry = ej.datavisualization.Diagram.ScrollUtil._getRulerGeometry(diagram, true);

                if (hOffset != undefined && diagram._hRuler) {
                    ej.datavisualization.Diagram.SvgContext._updateRulerSpace(diagram, rulerGeometry, true);
                    $("#" + diagram._hRuler[0].id).ejRuler({ offset: hOffset, scale: diagram._currZoom, length: rulerGeometry.width + 100 });
                    diagram._hRuler[0].style.marginLeft = (rulerSize.left - diagram._hRulerInstance._hRulerDiff) + "px";
                }
                if (vOffset != undefined && diagram._vRuler) {
                    ej.datavisualization.Diagram.SvgContext._updateRulerSpace(diagram, rulerGeometry, false);
                    $("#" + diagram._vRuler[0].id).ejRuler({ offset: vOffset, scale: diagram._currZoom, length: rulerGeometry.height + 100 });
                    diagram._vRuler[0].style.marginTop = (-diagram._vRulerInstance._vRulerDiff) + "px";
                }


            }
        },
        _viewPort: function (diagram, update) {
            if (diagram._viewPort && !update) return diagram._viewPort;
            var element = diagram.element[0];
            var bRect = diagram.element[0].getBoundingClientRect();
            var eWidth = bRect.width;
            //var vScrollHeight = diagram._vScrollbar && diagram._vScrollbar.model.height ? diagram._vScrollbar.model.height : null;
            //var eHeight = vScrollHeight ? (bRect.height === vScrollHeight) ? vScrollHeight + 18 : bRect.height : bRect.height;
            var eHeight = bRect.height;
            var screenX = (window.screenX < 0) ? window.screenX * -1 : window.screenX;
            if (eWidth === 0) {
                eWidth = Math.floor(((window.innerWidth - screenX) - Math.floor(bRect.left)));
            }
            var screenY = (window.screenY < 0) ? window.screenY * -1 : window.screenY;
            if (eHeight === 0) {
                eHeight = Math.floor(((window.innerHeight - screenY) - Math.floor(bRect.window)));
            }
            var rulerSize = this._getRulerSize(diagram);
            return ej.datavisualization.Diagram.Size(eWidth - rulerSize.left, eHeight - rulerSize.top);
        },
        _getRulerSize: function (diagram) {
            var left = 0, top = 0;
            if (diagram.model.rulerSettings.showRulers) {
                if (diagram.model.rulerSettings.horizontalRuler.thickness)
                    top = diagram.model.rulerSettings.horizontalRuler.thickness
                if (diagram.model.rulerSettings.verticalRuler.thickness)
                    left = diagram.model.rulerSettings.verticalRuler.thickness
            }
            return { left: left, top: top };
        },
        _getRulerGeometry: function (diagram) {
            var rulerSize = this._getRulerSize(diagram);
            var height = diagram._viewPort.height;
            var width = diagram._viewPort.width;
            if (width < (diagram._canvas.clientWidth - rulerSize.left))
                width = diagram._canvas.clientWidth - rulerSize.left;
            if (height < (diagram._canvas.clientHeight - rulerSize.top))
                height = diagram._canvas.clientHeight - rulerSize.top;
            if (diagram.model.rulerSettings.horizontalRuler.length)
                width = diagram.model.rulerSettings.horizontalRuler.length;
            if (diagram.model.rulerSettings.verticalRuler.length)
                height = diagram.model.rulerSettings.verticalRuler.length;
            return { width: width, height: height }
        },
        _union: function (rect, rect1) {
            if (rect.width <= 0) {
                rect = rect1;
                return rect;
            }
            if (rect.width > 0) {
                var num = Math.min(rect.x, rect1.x);
                var num2 = Math.min(rect.y, rect1.y);
                if (rect1.width === Infinity || rect.width === Infinity) {
                    rect.width = Infinity;
                }
                else {
                    var num3 = Math.max(rect.x + rect.width, rect1.x + rect1.width);
                    rect.width = Math.max(num3 - num, 0);
                }
                if (rect1.height === Infinity || rect.height === Infinity) {
                    rect.height = Infinity;
                }
                else {
                    var num4 = Math.max(rect.y + rect.height, rect1.y + rect1.height);
                    rect.height = Math.max(num4 - num2, 0);
                }
                rect.x = num;
                rect.y = num2;
                return rect;
            }
        },

        _setScrollContentSize: function (diagram) {
            var scale = diagram._currZoom;
            var viewPort = this._viewPort(diagram);
            viewPort = ej.datavisualization.Diagram.Rectangle(diagram._hScrollOffset, diagram._vScrollOffset, viewPort.width, viewPort.height);
            var scrollPadding = diagram.model.scrollSettings.padding;
            var left = diagram._spatialSearch.pageLeft;
            var right = diagram._spatialSearch.pageRight;
            var top = diagram._spatialSearch.pageTop;
            var bottom = diagram._spatialSearch.pageBottom;
            var left1 = left;
            var top1 = top;
            if (left > right) {
                left = right = 0;
            }
            if (top > bottom) {
                top = bottom = 0;
            }

            if (diagram.model.pageSettings) {
                var pageWidth = Number(diagram._pageWidth());
                var pageHeight = Number(diagram._pageHeight());

                if (pageWidth > 0 && pageHeight > 0) {
                    if (diagram._multiplePage()) {
                        left = Math.floor(left / pageWidth) * pageWidth;
                        top = Math.floor(top / pageHeight) * pageHeight;
                        right = Math.ceil(right / pageWidth) * pageWidth;
                        bottom = Math.ceil(bottom / pageHeight) * pageHeight;
                    }
                    else {
                        left = 0;
                        top = 0;
                        right = pageWidth;
                        bottom = pageHeight;
                    }
                    left -= scrollPadding.left;
                    right += scrollPadding.right;
                    top -= scrollPadding.top;
                    bottom += scrollPadding.bottom;
                    left1 = left;
                    top1 = top;
                }
                else {
                    left = left < 0 ? left : 0;
                    top = top < 0 ? top : 0;
                    if ((diagram._spatialSearch.pageLeft - left) < scrollPadding.left)
                        left += diagram._spatialSearch.pageLeft - left - scrollPadding.left;

                    if ((diagram._spatialSearch.pageTop - top) < scrollPadding.top)
                        top += diagram._spatialSearch.pageTop - top - scrollPadding.top;

                    if (diagram._spatialSearch.pageRight + scrollPadding.right > viewPort.width && diagram._spatialSearch.pageRight < viewPort.width)
                        right += scrollPadding.right + diagram._spatialSearch.pageRight - viewPort.width;

                    else if (diagram._spatialSearch.pageRight > viewPort.width)
                        right += scrollPadding.right;

                    if (diagram._spatialSearch.pageBottom + scrollPadding.bottom > viewPort.height && diagram._spatialSearch.pageBottom < viewPort.height)
                        bottom += scrollPadding.bottom + diagram._spatialSearch.pageBottom - viewPort.height;

                    else if (diagram._spatialSearch.pageBottom > viewPort.height)
                        bottom += scrollPadding.bottom;

                    left1 -= scrollPadding.left;
                    top1 -= scrollPadding.top;
                }
            }
            left = left * scale;
            top = top * scale;
            right = right * scale;
            bottom = bottom * scale;

            var diagramArea = ej.datavisualization.Diagram.Rectangle(0, 0, 0, 0);
            diagramArea = this._union(diagramArea, ej.datavisualization.Diagram.Rectangle(0, 0, viewPort.width, viewPort.height));
            diagramArea = this._union(diagramArea, ej.datavisualization.Diagram.Geometry.rect([{ x: left, y: top }, { x: right, y: bottom }]));
            diagramArea.width -= (viewPort.width - 18);
            diagramArea.height -= (viewPort.height - 18);

            if (diagramArea.x > diagram._hScrollOffset) {
                var diff = diagramArea.x - diagram._hScrollOffset;
                diagramArea.x -= diff;
                diagramArea.width += diff;
            }
            if (diagram._hScrollOffset > diagramArea.x + diagramArea.width) {
                diagramArea.width = diagram._hScrollOffset - diagramArea.x;
            }

            var minimumX = diagramArea.x;
            var maximumX = Math.max(0, diagramArea.x + diagramArea.width);

            if (diagramArea.y > diagram._vScrollOffset) {
                var diff = diagramArea.y - diagram._vScrollOffset;
                diagramArea.y -= diff;
                diagramArea.height += diff;
            }
            if (diagram._vScrollOffset > diagramArea.y + diagramArea.height) {
                diagramArea.height = diagram._vScrollOffset - diagramArea.y;
            }
            var minimumY = diagramArea.y;
            var maximumY = Math.max(0, diagramArea.y + diagramArea.height);

            diagramArea.width = viewPort.width;
            diagramArea.height = viewPort.height;

            if (diagram._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Limited) {
                var scrollableArea = diagram.model.pageSettings.scrollableArea;
                minimumX = scrollableArea.x * scale;
                minimumY = scrollableArea.y * scale;
                maximumX = (scrollableArea.x + scrollableArea.width) * scale - viewPort.width;
                maximumY = (scrollableArea.y + scrollableArea.height) * scale - viewPort.height;
                bottom = (scrollableArea.y + scrollableArea.height) * scale;
                right = (scrollableArea.x + scrollableArea.width) * scale;
                top = scrollableArea.y * scale;
                left = scrollableArea.x * scale;
            }

            var executeHorizontal = true, executeVertical = true;
            if (left >= diagram._hScrollOffset && right <= viewPort.width + diagram._hScrollOffset) {
                executeHorizontal = false;
                diagram._hScrollbar._remove();
                diagram._hScrollbar.model.width = 0;
                if (diagram._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Limited) diagram._hScrollbar.model.minimum = Math.min(0, minimumX);
                else diagram._hScrollbar.model.minimum = 0;
                diagram._hScrollbar.model.maximum = 0;
            }  
            if (top >= diagram._vScrollOffset && bottom <= viewPort.height + diagram._vScrollOffset) {
                executeVertical = false;
                diagram._vScrollbar._remove();
                diagram._vScrollbar.model.height = 0;
                if (diagram._scrollLimit() === ej.datavisualization.Diagram.ScrollLimit.Limited) diagram._vScrollbar.model.minimum = Math.min(0, minimumY);
                else diagram._vScrollbar.model.minimum = 0;
                diagram._vScrollbar.model.maximum = 0;
            }  

            if (executeHorizontal) {
                var viewPortWidth = executeVertical ? viewPort.width - 18 : viewPort.width;
                maximumX = !executeVertical ? maximumX - 18 : maximumX;
                if (!diagram._preventScrollerUpdate) {
                    $("#" + diagram._canvas.id + "_hScrollbar").ejScrollBar({ width: viewPortWidth, viewportSize: viewPortWidth, maximum: maximumX, minimum: minimumX });
                    $("#" + diagram._canvas.id + "_hScrollbar").ejScrollBar("scroll", diagram._hScrollOffset);
                }
                else {
                    diagram._hScrollbar.model.minimum = minimumX;
                    diagram._hScrollbar.model.maximum = maximumX;
                }
                var hScroll = document.getElementById(diagram._canvas.id + "_hScrollbar");
                hScroll.style.marginTop = viewPort.height - 18 + "px";
                if (Math.round(left1 * scale) >= Math.round(diagram._hScrollOffset) && Math.round(right) <= Math.round(viewPort.width + diagram._hScrollOffset))
                    hScroll.style.visibility = "hidden";
                else {
                    hScroll.style.visibility = "visible";
                    if (diagramArea.height >= 18)
                        diagramArea.height -= 18;
                }
            }

            if (executeVertical) {
                var viewPortHeight = executeHorizontal ? viewPort.height - 18 : viewPort.height;
                maximumY = !executeHorizontal ? maximumY - 18 : maximumY;
                if (!diagram._preventScrollerUpdate) {
                    $("#" + diagram._canvas.id + "_vScrollbar").ejScrollBar({ height: viewPortHeight, viewportSize: viewPortHeight, maximum: maximumY, minimum: minimumY });
                    $("#" + diagram._canvas.id + "_vScrollbar").ejScrollBar("scroll", diagram._vScrollOffset);
                }
                else {
                    diagram._vScrollbar.model.minimum = minimumY;
                    diagram._vScrollbar.model.maximum = maximumY;
                }
                var vScroll = document.getElementById(diagram._canvas.id + "_vScrollbar");
                if (Math.round(top1 * scale) >= Math.round(diagram._vScrollOffset) && Math.round(bottom) <= Math.round(viewPort.height + diagram._vScrollOffset)) {
                    vScroll.style.visibility = "hidden";
                }
                else {
                    vScroll.style.visibility = "visible";
                    if (diagramArea.width >= 18)
                        diagramArea.width -= 18;
                }
            }
            if (diagram._isMobile) diagram._disableScrollbar();
            ej.datavisualization.Diagram.SvgContext.setSize(diagram, diagramArea.width, diagramArea.height);
        },

        _setMinMaxValues: function (diagram, minX, minY, maxX, maxY, viewPort, scale) {
            var scrollableArea = diagram.model.pageSettings.scrollableArea;
            minX = Math.max(minX, scrollableArea.x * scale);
            minY = Math.max(minY, scrollableArea.y * scale);
            maxX = Math.min((scrollableArea.x + scrollableArea.width) * scale - viewPort.width, maxX);
            maxY = Math.min((scrollableArea.y + scrollableArea.height) * scale - viewPort.height, maxY);
            maxX = maxX > 0 ? maxX : 0;
            maxY = maxY > 0 ? maxY : 0;
            return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };
        },

        _initScrollbar: function (diagram) {
            var canvas = diagram._canvas;
            var hScrollbar = document.getElementById(canvas.id + "_hScrollbar");
            var vScrollbar = document.getElementById(canvas.id + "_vScrollbar");
            var viewPort = this._viewPort(diagram);
            $(hScrollbar).ejScrollBar({
                orientation: ej.ScrollBar.Orientation.Horizontal,
                width: viewPort.width - 18,
                viewportSize: viewPort.width - 18,
                scroll: function (e) {
                    if (e.source != null) {
                        if (e.source == "thumb" || e.source == "button" || e.source == "key") {
                            if (e.scrollData != null) {
                                var oVal = {
                                    zoom: diagram._getCurrentZoom(), horizontalOffset: diagram._hScrollOffset,
                                    verticalOffset: diagram._vScrollOffset, viewPort: diagram._viewPort
                                };
                                diagram._updateScrollOffset(e.scrollLeft, diagram._vScrollOffset);
                                var nVal = {
                                    zoom: diagram._getCurrentZoom(), horizontalOffset: diagram._hScrollOffset,
                                    verticalOffset: diagram._vScrollOffset, viewPort: diagram._viewPort
                                };
                                diagram._compareModelProperty("scrollSettings", true);
                                diagram._eventCause["scrollChange"] = ej.datavisualization.Diagram.ScrollChangeCause.Pan;
                                diagram._raiseEvent("scrollChange", { newValues: nVal, oldValues: oVal });
                            }
                        }
                    }
                }
            });
            diagram._hScrollbar = $(hScrollbar).ejScrollBar("instance");

            $(vScrollbar).ejScrollBar({
                orientation: ej.ScrollBar.Orientation.Vertical,
                height: viewPort.height - 18,
                viewportSize: viewPort.height - 18,
                scroll: function (e) {
                    if (e.source != null) {
                        if (e.source == "thumb" || e.source == "button" || e.source == "key") {
                            if (e.scrollData != null) {
                                var oVal = {
                                    zoom: diagram._getCurrentZoom(), horizontalOffset: diagram._hScrollOffset,
                                    verticalOffset: diagram._vScrollOffset, viewPort: diagram._viewPort
                                };
                                diagram._updateScrollOffset(diagram._hScrollOffset, e.scrollTop);
                                var nVal = {
                                    zoom: diagram._getCurrentZoom(), horizontalOffset: diagram._hScrollOffset,
                                    verticalOffset: diagram._vScrollOffset, viewPort: diagram._viewPort
                                };
                                diagram._compareModelProperty("scrollSettings", true);
                                diagram._eventCause["scrollChange"] = ej.datavisualization.Diagram.ScrollChangeCause.Pan;
                                diagram._raiseEvent("scrollChange", { newValues: nVal, oldValues: oVal });
                            }
                        }
                    }
                }
            });
            diagram._vScrollbar = $(vScrollbar).ejScrollBar("instance");

        },
    };
    //#endregion

    //#region Snapping
    ej.datavisualization.Diagram.SnapUtil = {
        _canConsider: function (nameTable, selectedObject, target) {
            var consider = false;
            if (selectedObject != target) {
                if (selectedObject._type == "group" || selectedObject._type == "pseudoGroup") {
                    consider = (target.isSwimlane && !selectedObject.isSwimlane) ? false : !this._contains(nameTable, selectedObject, target);
                }
                else if ((target._type == "group" && target.type != "bpmn") || target.type == "pseudoGroup")
                    consider = (target.isSwimlane && !selectedObject.isSwimlane) ? false : !this._contains(nameTable, target, selectedObject);
                else if (!selectedObject.segments) {
                    consider = !(selectedObject == target);
                }
            }
            return consider;
        },
        _contains: function (nameTable, group, target) {
            var name = target.name;
            var node = null;
            if (group.children.indexOf(name) >= 0) {
                node = nameTable[name];
                if (node == target)
                    return true;
            }
            else if (group.children.indexOf(target) >= 0) {
                return true;
            }
            if (group._type == "group" || group._type == "pseudoGroup") {
                var contains = false;
                for (var i = 0; i < group.children.length; i++) {
                    if (this.diagram) {
                        var child = typeof group.children[i] == "string" ? nameTable[group.children[i]] : nameTable[group.children[i].name];
                        if (child) {
                            if (typeof child == "string") child = nameTable[child];
                            if (child._type == "group")
                                contains = this._contains(nameTable, child, target);
                            if (contains) return contains;
                        }
                    }
                }
                return contains;
            }
            //return this._contains(nameTable, node, child);
            return false;
        },
        _getSnapIntervals:function(diagram, isVertical){
            var snapInterval = [];
            if (diagram.model.rulerSettings.showRulers) {
                var ruler = isVertical ? diagram.model.rulerSettings.horizontalRuler : diagram.model.rulerSettings.verticalRuler;
                var interval = (ruler.segmentWidth / ruler.interval);
                snapInterval.push(Math.round(interval * 100) / 100);
            }
            else
            {
                var snapSettings = diagram.model.snapSettings;
                if (isVertical)
                    snapInterval = snapSettings.verticalGridLines.snapInterval;
                else
                    snapInterval = snapSettings.horizontalGridLines.snapInterval;
            }
            return snapInterval;
        },
        _round: function (value, snapintervals, scale) {
            if (scale > 1) scale = Math.pow(2, Math.floor(Math.log(scale) / Math.log(2)));
            else scale = Math.pow(2, Math.ceil(Math.log(scale) / Math.log(2)));
            var cutoff = 0, i;
            for (i = 0; i < snapintervals.length; i++) {
                cutoff += snapintervals[i];
            }
            cutoff /= scale;
            var quotient = Math.floor(Math.abs(value) / cutoff);
            var bal = value % cutoff;
            var prev = quotient * cutoff;
            if (prev != value) {
                if (value >= 0) {
                    for (i = 0; i < snapintervals.length ; i++) {
                        if (bal <= snapintervals[i] / scale) {
                            return prev + (bal < (snapintervals[i] / (2 * scale)) ? 0 : snapintervals[i] / scale);
                        }
                        else {
                            prev += snapintervals[i] / scale;
                            bal -= snapintervals[i] / scale;
                        }
                    }
                }
                else {
                    prev = prev * -1;
                    for (i = snapintervals.length - 1; i >= 0; i--) {
                        if (Math.abs(bal) <= snapintervals[i] / scale) {
                            return prev - (Math.abs(bal) < (snapintervals[i] / (2 * scale)) ? 0 : snapintervals[i] / scale);
                        }
                        else {
                            prev -= snapintervals[i] / scale;
                            bal += snapintervals[i] / scale;
                        }
                    }
                }
            }
            return value;
        },
        _findNodes: function (spatialSearch, node, child, viewPort, nodesInView) {
            var nodes = [], quad, nd, bounds;
            var quads;
            quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(spatialSearch, nodesInView ? viewPort : child);
            for (var i = 0; i < quads.length; i++) {
                quad = quads[i];
                if (quad.objects.length > 0) {
                    for (var j = 0; j < quad.objects.length; j++) {
                        nd = quad.objects[j];
                        if (!nd.segments && nd.visible) {
                            bounds = ej.datavisualization.Diagram.Util.bounds(nd);
                            if (nodes.indexOf(nd) == -1 && ej.datavisualization.Diagram.Geometry.intersectsRect(child, bounds))
                                nodes.push(nd);
                            if (nodesInView && nodesInView.indexOf(nd) && ej.datavisualization.Diagram.Geometry.intersectsRect(viewPort, bounds)) {
                                nodesInView.push(nd);
                            }
                        }
                    }
                }
            }
            return nodes;
        },
        _snapAngle: function (diagram, angle) {
            var snapAngle = diagram._snapAngle();
            var width = angle % snapAngle;
            if (width >= (snapAngle / 2)) {
                return angle + snapAngle - width;
            }
            else {
                return angle - width;
            }
        },
        _snapPoint: function (diagram, selectedObject, towardsLeft, towardsTop, del, endPoint, startPoint) {
            var snapSettings = diagram.model.snapSettings;
            var zoomFactor = diagram._currZoom;
            var offset = ej.datavisualization.Diagram.Point();
            var bounds = ej.datavisualization.Diagram.Util.bounds(selectedObject);
            var horizontallysnapped = { snapped: false, offset: 0 };
            var verticallysnapped = { snapped: false, offset: 0 };
            this.diagram = diagram;
            if (diagram._enableSnapToObject())
                this._snapObject(diagram, selectedObject, horizontallysnapped,
                    verticallysnapped, del, startPoint == endPoint);
            //original position
            var left = bounds.x + del.x;
            var top = bounds.y + del.y;
            var right = bounds.x + bounds.width + del.x;
            var bottom = bounds.y + bounds.height + del.y;
            //snapped positions
            var roundedRight = this._round(right, this._getSnapIntervals(diagram,true), zoomFactor);
            var roundedLeft = this._round(left, this._getSnapIntervals(diagram, true), zoomFactor);
            var roundedTop = this._round(top, this._getSnapIntervals(diagram, false), zoomFactor);
            var roundedBottom = this._round(bottom, this._getSnapIntervals(diagram, false), zoomFactor);
            //currentposition
            var currentright = bounds.x + bounds.width;
            var currentbottom = bounds.y + bounds.height;
            if (!horizontallysnapped.snapped) {
                if (diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.SnapToVerticalLines) {
                    if (Math.abs(del.x) >= 1) {
                        if (towardsLeft) {
                            if (Math.abs(roundedRight - currentright) > Math.abs(roundedLeft - bounds.x)) {
                                offset.x += roundedLeft - bounds.x;
                            } else
                                offset.x += roundedRight - currentright;
                        } else {
                            if (Math.abs(roundedRight - currentright) < Math.abs(roundedLeft - bounds.x)) {
                                offset.x += roundedRight - currentright;
                            } else
                                offset.x += roundedLeft - bounds.x;
                        }
                    }
                } else {
                    offset.x = endPoint.x - startPoint.x;
                }
            } else {
                if (diagram._enableSnapToObject())
                    offset.x = horizontallysnapped.offset;
                else
                    offset.x = endPoint.x - startPoint.x;
            }
            if (!verticallysnapped.snapped) {
                if (diagram._snapConstraints() & ej.datavisualization.Diagram.SnapConstraints.SnapToHorizontalLines) {
                    if (Math.abs(del.y) >= 1) {
                        if (towardsTop) {
                            if (Math.abs(roundedBottom - currentbottom) > Math.abs(roundedTop - bounds.y)) {
                                offset.y += roundedTop - bounds.y;
                            }
                            else
                                offset.y += roundedBottom - currentbottom;
                        }
                        else {
                            if (Math.abs(roundedBottom - currentbottom) < Math.abs(roundedTop - bounds.y)) {
                                offset.y += roundedBottom - currentbottom;
                            }
                            else
                                offset.y += roundedTop - bounds.y;
                        }
                    }
                }
                else
                    offset.y = endPoint.y - startPoint.y;
            }
            else
                offset.y = verticallysnapped.offset;

            return offset;
        },
        _snapObject: function (diagram, selectedObject, hSnap, vSnap, del, ended) {
            var lengthX = null, lengthY = null;
            var hTarget, vTarget;
            var objectsAtLeft = [], objectsAtRight = [], objectsAtTop = [], objectsAtBottom = [];
            var bounds = ej.datavisualization.Diagram.Util.bounds(selectedObject);
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            var snapObjDistance = diagram._snapObjectDistance();
            var viewPort = diagram._viewPort;
            var hIntersectRect = ej.datavisualization.Diagram.Rectangle(hoffset / scale, (bounds.y - snapObjDistance - 5), viewPort.width / scale,
                (bounds.height + 2 * snapObjDistance + 10));
            var vIntersectRect = ej.datavisualization.Diagram.Rectangle((bounds.x - snapObjDistance - 5), voffset / scale,
                (bounds.width + 2 * snapObjDistance + 10), viewPort.height / scale);
            viewPort = ej.datavisualization.Diagram.Rectangle(hoffset / scale, voffset / scale, viewPort.width / scale,
                viewPort.height / scale);
            var nodes = this._findNodes(diagram._spatialSearch, selectedObject, vIntersectRect, viewPort);
            var i, target, targetBounds;
            var nameTable = diagram.nameTable;
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (ej.datavisualization.Diagram.Util._canBeTarget(diagram, target)) {
                    if (!target.segments && this._canConsider(nameTable, selectedObject, target)) {
                        targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                        if (targetBounds.y + targetBounds.height < bounds.y + del.y) {
                            objectsAtTop.push({ object: target, distance: Math.abs(bounds.y + del.y - targetBounds.y - targetBounds.height) });
                        }
                        else if (targetBounds.y > bounds.y + del.y + bounds.height) {
                            objectsAtBottom.push({ object: target, distance: Math.abs(bounds.y + del.y + bounds.height - targetBounds.y) });
                        }
                        if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y - del.y)) {
                            if (Math.abs(targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2 + del.x)) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "centerX");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            } else if (Math.abs(targetBounds.x - (bounds.x + del.x)) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "left");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            } else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + bounds.width + del.x)) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "right");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            } else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + del.x)) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "leftRight");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            } else if (Math.abs(targetBounds.x - (bounds.x + bounds.width + del.x)) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "rightLeft");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                        }
                    }
                }
            }
            nodes = this._findNodes(diagram._spatialSearch, selectedObject, hIntersectRect, viewPort);
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (ej.datavisualization.Diagram.Util._canBeTarget(diagram, target)) {
                    if (!target.segments && this._canConsider(nameTable, selectedObject, target)) {
                        targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                        if (targetBounds.x + targetBounds.width < bounds.x + del.x) {
                            objectsAtLeft[objectsAtLeft.length] = { object: target, distance: Math.abs((bounds.x + del.x) - targetBounds.x - targetBounds.width) };
                        }
                        if (targetBounds.x > bounds.x + del.x + bounds.width) {
                            objectsAtRight[objectsAtRight.length] = { object: target, distance: Math.abs(bounds.x + del.x + bounds.width - targetBounds.x) };
                        }
                        if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x - del.x)) {
                            if (Math.abs(targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2 + del.y)) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "centerY");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            } else if (Math.abs(targetBounds.y - bounds.y - del.y) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "top");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            } else if (Math.abs(targetBounds.y + targetBounds.height - (bounds.y + bounds.height + del.y)) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "bottom");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            } else if (Math.abs(targetBounds.y + targetBounds.height - bounds.y - del.y) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "topBottom");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            } else if (Math.abs(targetBounds.y - (bounds.y + bounds.height + del.y)) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "bottomTop");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                        }
                    }
                }
            }
            var g = this._createGuidelines(diagram, hTarget, vTarget, hSnap, vSnap, ended);
            if (!hSnap.snapped) {
                this._createHSpacingLines(diagram, selectedObject, objectsAtLeft, objectsAtRight, hSnap, vSnap, ended, g, del, snapObjDistance);
            }
            if (!vSnap.snapped) {
                this._createVSpacingLines(diagram, selectedObject, objectsAtTop, objectsAtBottom, hSnap, vSnap, ended, g, del, snapObjDistance);
            }
        },

        _snapSize: function (diagram, hSnap, vSnap, delx, dely, selectedObject, ended) {
            var lengthX = null, lengthY = null;
            var hTarget;
            var vTarget;
            var bounds = ej.datavisualization.Diagram.Util.bounds(selectedObject);
            var nameTable = diagram.nameTable;
            var sameWidth = [];
            var sameHeight = [];
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            var snapObjDistance = diagram._snapObjectDistance();
            var viewPort = diagram._viewPort;
            var hintersectedrect = ej.datavisualization.Diagram.Rectangle(hoffset / scale, (bounds.y - 5) / scale,
                viewPort.width / scale, (bounds.height + 10) / scale);
            var vintersectedrect = ej.datavisualization.Diagram.Rectangle((bounds.x - 5) / scale, voffset / scale,
                (bounds.width + 10) / scale, viewPort.height / scale);
            viewPort = ej.datavisualization.Diagram.Rectangle(hoffset / scale, voffset / scale, viewPort.width / scale,
               viewPort.height / scale);
            var nodesInView = [];
            var nodes = this._findNodes(diagram._spatialSearch, selectedObject, vintersectedrect, viewPort, nodesInView);
            var i, target, targetBounds;
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (this._canConsider(nameTable, selectedObject, target) && !target.segments) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y)) {
                        if (hSnap.left) {
                            if (Math.abs(bounds.x + delx - targetBounds.x) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "left");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                            else if (Math.abs(bounds.x + delx - targetBounds.x - targetBounds.width) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "leftRight");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                        }
                        else if (hSnap.right) {
                            if (Math.abs(bounds.x + delx + bounds.width - targetBounds.x - targetBounds.width) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "right");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                            else if (Math.abs(bounds.x + delx + bounds.width - targetBounds.x) <= snapObjDistance) {
                                hTarget = this._createSnapObject(targetBounds, bounds, "rightLeft");
                                lengthX = Math.abs(targetBounds.y - bounds.y);
                            }
                        }
                    }
                }
            }
            nodes = this._findNodes(diagram._spatialSearch, selectedObject, hintersectedrect, viewPort);
            for (i = 0; i < nodes.length; i++) {
                target = nodes[i];
                if (this._canConsider(nameTable, selectedObject, target) && !target.segments) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x)) {
                        if (vSnap.top) {
                            if (Math.abs(bounds.y + dely - targetBounds.y) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "top");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                            else if (Math.abs(bounds.y + dely - targetBounds.y - targetBounds.height) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "topBottom");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                        }
                        else if (vSnap.bottom) {
                            if (Math.abs(bounds.y + bounds.height + dely - targetBounds.y - targetBounds.height) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "bottom");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                            else if (Math.abs(bounds.y + bounds.height + dely - targetBounds.y) <= snapObjDistance) {
                                vTarget = this._createSnapObject(targetBounds, bounds, "bottomTop");
                                lengthY = Math.abs(targetBounds.x - bounds.x);
                            }
                        }
                    }
                }
            }
            for (i = 0; i < nodesInView.length; i++) {
                target = nodesInView[i];
                if (this._canConsider(nameTable, selectedObject, target)) {
                    var targetbounds = ej.datavisualization.Diagram.Util.bounds(target);
                    var del = hSnap.left ? -delx : delx;
                    var diff = Math.abs(bounds.width + del - targetbounds.width);
                    var actualDiff;
                    if (diff <= snapObjDistance) {
                        actualDiff = hSnap.left ? -targetbounds.width + bounds.width : targetbounds.width - bounds.width;
                        sameWidth[sameWidth.length] = { source: target, diff: diff, offset: actualDiff };
                    }
                    del = vSnap.top ? -dely : dely;
                    var dify = Math.abs(bounds.height + del - targetbounds.height);
                    if (dify <= snapObjDistance) {
                        actualDiff = vSnap.top ? -targetbounds.height + bounds.height : targetbounds.height - bounds.height;
                        sameHeight[sameHeight.length] = { source: target, diff: dify, offset: actualDiff };
                    }
                }
            }
            if (!diagram.activeTool.selectedSeperator)
                var g = this._createGuidelines(diagram, hTarget, vTarget, hSnap, vSnap, ended);
            if (!hSnap.snapped && sameWidth.length > 0 && (hSnap.left || hSnap.right)) {
                this._addSameWidthLines(diagram, sameWidth, hSnap, ended, g, selectedObject);
            }
            if (!vSnap.snapped && sameHeight.length > 0 && (vSnap.top || vSnap.bottom)) {
                this._addSameHeightLines(diagram, sameHeight, vSnap, ended, g, selectedObject);
            }
        },
        _createSnapObject: function (targetbounds, bounds, snap) {
            var snapObject;
            switch (snap) {
                case "left":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x - bounds.x, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "right":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x + targetbounds.width - bounds.x - bounds.width, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "top":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y),
                        offsetY: targetbounds.y - bounds.y, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "bottom":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y + targetbounds.height),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y + targetbounds.height),
                        offsetY: targetbounds.y + targetbounds.height - bounds.y - bounds.height, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "topBottom":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y + targetbounds.height),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y + targetbounds.height),
                        offsetY: targetbounds.y + targetbounds.height - bounds.y, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "bottomTop":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y),
                        offsetY: targetbounds.y - bounds.y - bounds.height, offsetX: 0, type: "sideAlign"
                    };
                    break;
                case "leftRight":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x + targetbounds.width - bounds.x, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "rightLeft":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x - bounds.x - bounds.width, offsetY: 0, type: "sideAlign"
                    };
                    break;
                case "centerX":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width / 2, Math.min(targetbounds.y, bounds.y)),
                        end: ej.datavisualization.Diagram.Point(targetbounds.x + targetbounds.width / 2, Math.max(targetbounds.y + targetbounds.height, bounds.y + bounds.height)),
                        offsetX: targetbounds.x + targetbounds.width / 2 - (bounds.x + bounds.width / 2), offsetY: 0, type: "centerAlign"
                    };
                    break;
                case "centerY":
                    snapObject = {
                        start: ej.datavisualization.Diagram.Point(Math.min(targetbounds.x, bounds.x), targetbounds.y + targetbounds.height / 2),
                        end: ej.datavisualization.Diagram.Point(Math.max(targetbounds.x + targetbounds.width, bounds.x + bounds.width), targetbounds.y + targetbounds.height / 2),
                        offsetY: targetbounds.y + targetbounds.height / 2 - (bounds.y + bounds.height / 2), offsetX: 0, type: "centerAlign"
                    };
                    break;
            }
            return snapObject;
        },
        _createGuidelines: function (diagram, hTarget, vTarget, hsnap, vsnap, ended) {
            var attr = { id: diagram._canvas.id + "guideline", "style": "pointer-events:none;" };
            var g = ej.datavisualization.Diagram.SvgContext._initializeGuidelines(diagram._adornerSvg, attr, diagram._adornerLayer);
            var scale = diagram._currZoom;
            var hOffset = diagram._hScrollOffset;
            var vOffset = diagram._vScrollOffset;
            if (hTarget) {
                hsnap.offset = hTarget.offsetX;
                hsnap.snapped = true;
                if (!ended) {
                    if (hTarget.type == "sideAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderSideAlignmentLines(hTarget.start, hTarget.end, g, diagram._adornerSvg, scale, hOffset, vOffset);
                    }
                    else if (hTarget.type == "centerAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderCenterAlignmentLines(hTarget.start, hTarget.end, g, diagram._adornerSvg, scale, hOffset, vOffset);
                    }
                }
            }
            if (vTarget) {
                vsnap.offset = vTarget.offsetY;
                vsnap.snapped = true;
                if (!ended) {
                    if (vTarget.type == "sideAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderSideAlignmentLines(vTarget.start, vTarget.end, g, diagram._adornerSvg, scale, hOffset, vOffset);
                    }
                    else if (vTarget.type == "centerAlign") {
                        ej.datavisualization.Diagram.SvgContext._renderCenterAlignmentLines(vTarget.start, vTarget.end, g, diagram._adornerSvg, scale, hOffset, vOffset);
                    }
                }
            }
            diagram._guideline = g;
            return g;
        },
        _removeGuidelines: function (diagram) {
            var g = diagram._guideline ? diagram._guideline : diagram._adornerSvg.getElementById(diagram._canvas.id + "guideline");
            if (g != null) {
                ej.datavisualization.Diagram.SvgContext._removeGuidelines(diagram._adornerLayer, g);
                delete diagram._guideline;
            }
        },
        _sortByDistance: function (obj, value, asc) {
            var i, j, temp;
            if (asc) {
                for (i = 0; i < obj.length; i++) {
                    for (j = i + 1; j < obj.length; j++) {
                        if (obj[i][value] > obj[j][value]) {
                            temp = obj[i];
                            obj[i] = obj[j];
                            obj[j] = temp;
                        }
                    }
                }
            }
            else {
                for (i = 0; i < obj.length; i++) {
                    for (j = i + 1; j < obj.length; j++) {
                        if (obj[i][value] < obj[j][value]) {
                            temp = obj[i];
                            obj[i] = obj[j];
                            obj[j] = temp;
                        }
                    }
                }
            }
        },
        _createHSpacingLines: function (diagram, shape, objectsAtLeft, objectsAtRight, hSnap, vSnap, ended, g, del, snapObjDistance) {
            var top = null;
            this._sortByDistance(objectsAtLeft, "distance", true);
            this._sortByDistance(objectsAtRight, "distance", true);
            var equallySpaced = [];
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var nearestleft, nearestright;
            var targetBounds;
            if (objectsAtLeft.length > 0) {
                equallySpaced[equallySpaced.length] = objectsAtLeft[0];
                nearestleft = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[0].object);
                top = nearestleft.y;
                if (objectsAtLeft.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[1].object);
                    var equaldistance = nearestleft.x - targetBounds.x - targetBounds.width;
                    if (Math.abs(equaldistance - objectsAtLeft[0].distance) <= snapObjDistance) {
                        top = this._findEquallySpacedNodesAtLeft(objectsAtLeft, equaldistance, top, equallySpaced);

                    } else equaldistance = objectsAtLeft[0].distance;
                } else equaldistance = objectsAtLeft[0].distance;
            }
            this._sortByDistance(equallySpaced, "distance");
            equallySpaced[equallySpaced.length] = { object: shape, distance: 0 };
            top = bounds.y < top || !top ? bounds.y : top;
            if (objectsAtRight.length > 0) {
                var dist;
                nearestright = ej.datavisualization.Diagram.Util.bounds(objectsAtRight[0].object);
                top = nearestright.y < top ? nearestright.y : top;
                if (objectsAtRight.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtRight[1].object);
                    dist = targetBounds.x - nearestright.x - nearestright.width;
                }
                if (objectsAtLeft.length > 0) {
                    if (Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) <= snapObjDistance) {
                        var adjustablevalue = Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) / 2;
                        (objectsAtRight[0].distance < objectsAtLeft[0].distance) ?
                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;
                        equallySpaced[equallySpaced.length] = objectsAtRight[0];
                    }
                    else if (objectsAtLeft.length == 1) {
                        nearestleft = undefined;
                        equallySpaced.splice(0, 1);
                        equallySpaced[equallySpaced.length] = objectsAtRight[0];
                        equaldistance = dist;
                    }
                }
                else {
                    equaldistance = dist;
                    equallySpaced[equallySpaced.length] = objectsAtRight[0];
                }
                if (objectsAtRight.length > 1 && nearestright.x + nearestright.width < targetBounds.x) {
                    top = this._findEquallySpacedNodesAtRight(objectsAtRight, dist, top, equallySpaced, snapObjDistance);
                }
            }
            if (equallySpaced.length > 2) {
                this._addHSpacingLines(diagram, equallySpaced, ended, g, top);
                var delta = 0;
                if (ended)
                    delta = del.x;
                if (nearestleft)
                    hSnap.offset = equaldistance - Math.abs(bounds.x + delta - nearestleft.x - nearestleft.width) + delta;
                else if (nearestright)
                    hSnap.offset = Math.abs(bounds.x + bounds.width + delta - nearestright.x) - equaldistance + delta;
                hSnap.snapped = true;
            }
        },
        _createVSpacingLines: function (diagram, shape, objectsAtTop, objectsAtBottom, hSnap, vSnap, ended, g, del, snapObjDistance) {
            var right = null;
            this._sortByDistance(objectsAtTop, "distance", true);
            this._sortByDistance(objectsAtBottom, "distance", true);
            var equallySpaced = [];
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var nearesttop, nearestbottom;
            var targetBounds;
            if (objectsAtTop.length > 0) {
                equallySpaced[equallySpaced.length] = objectsAtTop[0];
                nearesttop = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[0].object);
                right = nearesttop.x + nearesttop.width;
                if (objectsAtTop.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[1].object);
                    var equaldistance = nearesttop.y - targetBounds.y - targetBounds.height;
                    if (Math.abs(equaldistance - objectsAtTop[0].distance) <= snapObjDistance) {
                        right = this._findEquallySpacedNodesAtTop(objectsAtTop, equaldistance, right, equallySpaced);
                    } else equaldistance = objectsAtTop[0].distance;
                } else equaldistance = objectsAtTop[0].distance;
            }
            this._sortByDistance(equallySpaced, "distance");
            equallySpaced[equallySpaced.length] = { object: shape, distance: 0 };
            right = bounds.x + bounds.width > right || !right ? bounds.x + bounds.width : right;
            var dist;
            if (objectsAtBottom.length > 0) {
                nearestbottom = ej.datavisualization.Diagram.Util.bounds(objectsAtBottom[0].object);
                right = nearestbottom.x + nearestbottom.width > right ? nearestbottom.x + nearestbottom.width : right;
                if (objectsAtBottom.length > 1) {
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtBottom[1].object);
                    dist = targetBounds.y - nearestbottom.y - nearestbottom.height;
                }

                if (objectsAtTop.length > 0) {
                    if (Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) <= snapObjDistance) {
                        var adjustablevalue = Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) / 2;
                        (objectsAtBottom[0].distance < objectsAtTop[0].distance) ?
                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;
                        equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                    }
                    else if (objectsAtTop.length == 1) {
                        nearesttop = undefined;
                        equallySpaced.splice(0, 1);
                        equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                        equaldistance = dist;
                    }
                }
                else {
                    equaldistance = dist;
                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                }
                if (objectsAtBottom.length > 1 && targetBounds.y > nearestbottom.y + nearestbottom.height) {
                    right = this._findEquallySpacedNodesAtBottom(objectsAtBottom, dist, right, equallySpaced, snapObjDistance);
                }

            }
            if (equallySpaced.length > 2) {
                this._addVSpacingLine(diagram, equallySpaced, ended, g, right);
                var delta = 0;
                if (ended)
                    delta = del.y;
                if (nearesttop)
                    vSnap.offset = equaldistance - Math.abs(bounds.y + delta - nearesttop.y - nearesttop.height) + delta;
                else if (nearestbottom)
                    vSnap.offset = Math.abs(bounds.y + bounds.height + delta - nearestbottom.y) - equaldistance + delta;
                vSnap.snapped = true;
            }
        },
        _addHSpacingLines: function (diagram, equallySpaced, ended, g, top) {
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            if (equallySpaced.length > 2) {
                if (!ended) {
                    for (var i = 0; i < equallySpaced.length - 1; i++) {
                        var crnt = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i].object);
                        var next = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i + 1].object);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(crnt.x + crnt.width, top - 15),
                       ej.datavisualization.Diagram.Point(next.x, top - 15), g, diagram._adornerSvg, scale, hoffset, voffset);
                    }
                }

            }
        },
        _addVSpacingLine: function (diagram, equallySpaced, ended, g, right) {
            var scale = diagram._currZoom;
            var hoffset = diagram._hScrollOffset;
            var voffset = diagram._vScrollOffset;
            if (equallySpaced.length > 2) {
                if (!ended) {
                    var crnt, next;
                    for (var i = 0; i < equallySpaced.length - 1; i++) {
                        crnt = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i].object);
                        next = ej.datavisualization.Diagram.Util.bounds(equallySpaced[i + 1].object);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(right + 15, crnt.y + crnt.height),
                      ej.datavisualization.Diagram.Point(right + 15, next.y), g, diagram._adornerSvg, scale, hoffset, voffset);
                    }
                }

            }
        },
        _addSameWidthLines: function (diagram, sameWidths, hSnap, ended, g, shape) {
            var scale = diagram._currZoom;
            var hOffset = diagram._hScrollOffset;
            var vOffset = diagram._vScrollOffset;
            this._sortByDistance(sameWidths, "offset");
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var target = sameWidths[0];
            var targetBounds = ej.datavisualization.Diagram.Util.bounds(target.source);
            var sameSizes = [];
            sameSizes.push(sameWidths[0]);
            var i, crntbounds;
            for (i = 1; i < sameWidths.length; i++) {
                crntbounds = ej.datavisualization.Diagram.Util.bounds(sameWidths[i].source);
                if (crntbounds.width == targetBounds.width)
                    sameSizes.push(sameWidths[i]);
            }
            if (sameSizes.length > 0) {
                if (!ended) {
                    ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x + target.offset, bounds.y - 15),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width + target.offset, bounds.y - 15), g, diagram._adornerSvg, scale, hOffset, vOffset);
                    for (i = 0; i < sameSizes.length; i++) {
                        bounds = ej.datavisualization.Diagram.Util.bounds(sameSizes[i].source);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x, bounds.y - 15),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width, bounds.y - 15), g, diagram._adornerSvg, scale, hOffset, vOffset);
                    }
                }
            }
            hSnap.offset = target.offset;
            hSnap.snapped = true;
        },
        _addSameHeightLines: function (diagram, sameHeights, vSnap, ended, g, shape) {
            var scale = diagram._currZoom;
            var hOffset = diagram._hScrollOffset;
            var vOffset = diagram._vScrollOffset;
            this._sortByDistance(sameHeights, "offset");
            var bounds = ej.datavisualization.Diagram.Util.bounds(shape);
            var target = sameHeights[0];
            var targetBounds = ej.datavisualization.Diagram.Util.bounds(target.source);
            var sameSizes = [];
            sameSizes.push(sameHeights[0]);
            var i, crntBounds;
            for (i = 0; i < sameHeights.length; i++) {
                crntBounds = ej.datavisualization.Diagram.Util.bounds(sameHeights[i].source);
                if (crntBounds.height == targetBounds.height)
                    sameSizes.push(sameHeights[i]);
            }
            if (sameSizes.length > 0) {
                if (!ended) {
                    ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y + target.offset),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y + bounds.height + target.offset), g, diagram._adornerSvg, scale, hOffset, vOffset);
                    for (i = 0; i < sameSizes.length; i++) {
                        bounds = ej.datavisualization.Diagram.Util.bounds(sameSizes[i].source);
                        ej.datavisualization.Diagram.SvgContext._renderSpacingLines(ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y),
                        ej.datavisualization.Diagram.Point(bounds.x + bounds.width + 15, bounds.y + bounds.height), g, diagram._adornerSvg, scale, hOffset, vOffset);

                    }
                }
                vSnap.offset = target.offset;
                vSnap.snapped = true;
            }
        },
        _findEquallySpacedNodesAtLeft: function (objectsAtLeft, equalDistance, top, equallySpaced) {
            var prevBounds, targetBounds, dist;
            for (var i = 1; i < objectsAtLeft.length; i++) {
                prevBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[i - 1].object);
                targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtLeft[i].object);
                dist = prevBounds.x - targetBounds.x - targetBounds.width;
                if (Math.abs(dist - equalDistance) <= 1) {
                    equallySpaced[equallySpaced.length] = objectsAtLeft[i];
                    if (targetBounds.y < top)
                        top = targetBounds.y;
                }
                else
                    break;
            }
            return top;
        },
        _findEquallySpacedNodesAtRight: function (objectsAtRight, equalDistance, top, equallySpaced, snapObjDistance) {
            var actualDistance = objectsAtRight[0].distance;
            var target, targetBounds, prevBounds, dist;
            if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {
                for (var i = 0; i < objectsAtRight.length - 1; i++) {
                    target = objectsAtRight[i].object;
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtRight[i + 1].object);
                    prevBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    dist = targetBounds.x - prevBounds.x - prevBounds.width;
                    if (Math.abs(dist - equalDistance) <= 1) {
                        equallySpaced[equallySpaced.length] = objectsAtRight[i + 1];
                        if (prevBounds.y < top) {
                            top = prevBounds.y;
                        }
                    }
                    else
                        break;
                }
            }
            return top;
        },
        _findEquallySpacedNodesAtTop: function (objectsAtTop, equalDistance, right, equallySpaced) {
            var prevBounds, targetBounds, dist;
            for (var i = 1; i < objectsAtTop.length; i++) {
                prevBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[i - 1].object);
                targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtTop[i].object);
                dist = prevBounds.y - targetBounds.y - targetBounds.height;
                if (Math.abs(dist - equalDistance) <= 1) {
                    equallySpaced[equallySpaced.length] = objectsAtTop[i];
                    if (targetBounds.x + targetBounds.width > right)
                        right = targetBounds.x + targetBounds.width;
                }
                else
                    break;
            }
            return right;
        },
        _findEquallySpacedNodesAtBottom: function (objectsAtBottom, equalDistance, right, equallySpaced, snapObjDistance) {
            var actualDistance = objectsAtBottom[0].distance;
            var target, targetBounds, prevBounds, dist;
            if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {
                for (var i = 0; i < objectsAtBottom.length - 1; i++) {
                    target = objectsAtBottom[i].object;
                    targetBounds = ej.datavisualization.Diagram.Util.bounds(objectsAtBottom[i + 1].object);
                    prevBounds = ej.datavisualization.Diagram.Util.bounds(target);
                    dist = targetBounds.y - prevBounds.y - prevBounds.height;
                    if (Math.abs(dist - equalDistance) <= 1) {
                        equallySpaced[equallySpaced.length] = objectsAtBottom[i + 1];
                        if (prevBounds.x + prevBounds.width > right)
                            right = prevBounds.x + prevBounds.width;
                    }
                    else
                        break;
                }
            }
            return right;
        },

    };
    //#endregion

    //#region SpatialSearch
    ej.datavisualization.Diagram.SpatialUtil = {
        findQuads: function (spatialSearch, viewPort) {
            spatialSearch.quads = [];
            var quad = spatialSearch.parentQuad;
            this._findQuads(spatialSearch, quad, viewPort);
            return spatialSearch.quads;
        },
        _addIntoAQuad: function (spatialSearch) {
            var isAdded = false;
            while (!isAdded) {
                isAdded = this._add(spatialSearch, spatialSearch.parentQuad);
            }
        },
        _setCurrentNode: function (spatialSearch, node, diagram) {
            spatialSearch.childnode = node;
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            spatialSearch.childLeft = bounds.left;
            spatialSearch.childTop = bounds.top;
            spatialSearch.childRight = bounds.right;
            spatialSearch.childBottom = bounds.bottom;
            if (diagram) {
                var labels = node.labels;
                for (var j = 0; j < labels.length; j++) {
                    var label = labels[j];

                    if (label && label.visible && !diagram.activeTool.inAction && !diagram._isLayoutExecute) {
                        var labelbounds = ej.datavisualization.Diagram.Util.getLabelbounds(diagram, node, label);

                        if (labelbounds) {
                            bounds = diagram._union(labelbounds, bounds);
                            bounds = ej.datavisualization.Diagram.Util.bounds(bounds);
                            spatialSearch.childLeft = bounds.left;
                            spatialSearch.childTop = bounds.top;
                            spatialSearch.childRight = bounds.right;
                            spatialSearch.childBottom = bounds.bottom;
                        }
                    }
                }
            }
        },
        _add: function (spatialSearch, quad) {
            if (this._isContained(spatialSearch, quad)) {
                this._selectQuad(spatialSearch, quad);
                return true;
            } else {
                var newParent;
                var isEmpty = !quad.objects.length && quad.first == null && quad.second == null && quad.third == null && quad.fourth == null;
                if (spatialSearch.childLeft < quad.left) {
                    if (spatialSearch.childTop < quad.top) {
                        newParent = ej.datavisualization.Diagram.Quad(quad.left - quad.width, quad.top - quad.height, quad.width * 2, quad.height * 2);
                        if (!isEmpty)
                            newParent.fourth = quad;
                    }
                    else {
                        newParent = ej.datavisualization.Diagram.Quad(quad.left - quad.width, quad.top, quad.width * 2, quad.height * 2);
                        if (!isEmpty)
                            newParent.second = quad;
                    }
                }
                else if (spatialSearch.childTop < quad.top) {
                    newParent = ej.datavisualization.Diagram.Quad(quad.left, quad.top - quad.height, quad.width * 2, quad.height * 2);
                    if (!isEmpty)
                        newParent.third = quad;
                }
                else {
                    newParent = ej.datavisualization.Diagram.Quad(quad.left, quad.top, quad.width * 2, quad.height * 2);
                    if (!isEmpty)
                        newParent.first = quad;
                }
                quad.parent = newParent;
                spatialSearch.parentQuad = newParent;
                return false;
            }
        },
        _isContained: function (spatialSearch, quad) {
            if (spatialSearch.childLeft >= quad.left && spatialSearch.childRight <= quad.left + quad.width &&
                spatialSearch.childTop >= quad.top && spatialSearch.childBottom <= quad.top + quad.height) {
                return true;
            }
            return false;
        },
        _selectQuad: function (spatialSearch, quad) {
            var current = quad;
            while (current !== null) {
                current = this._getQuad(spatialSearch, current);
            }
        },
        _getQuad: function (spatialSearch, quad) {
            var halfWidth = quad.width / 2;
            var halfHeight = quad.height / 2;
            var height = spatialSearch._isRouting && spatialSearch._viewPortHeight > 0 ? spatialSearch._viewPortHeight : 100;
            var width = spatialSearch._isRouting && spatialSearch._viewPortWidth > 0 ? spatialSearch._viewPortWidth : 100;
            if (halfWidth >= width && halfHeight >= height) {
                var xCenter = quad.left + halfWidth;
                var yCenter = quad.top + halfHeight;
                if (spatialSearch.childRight <= xCenter) {
                    if (spatialSearch.childBottom <= yCenter) {
                        return quad.first ? quad.first :
                               quad.first = ej.datavisualization.Diagram.Quad(quad.left, quad.top, halfWidth, halfHeight, quad);
                    }
                    else if (spatialSearch.childTop >= yCenter) {
                        return quad.third ? quad.third :
                                quad.third = ej.datavisualization.Diagram.Quad(quad.left, yCenter, halfWidth, halfHeight, quad);
                    }
                }
                else if (spatialSearch.childLeft >= xCenter) {
                    if (spatialSearch.childBottom <= yCenter) {
                        return quad.second ? quad.second :
                               quad.second = ej.datavisualization.Diagram.Quad(xCenter, quad.top, halfWidth, halfHeight, quad);
                    }
                    else if (spatialSearch.childTop >= yCenter) {
                        return quad.fourth ? quad.fourth :
                                quad.fourth = ej.datavisualization.Diagram.Quad(xCenter, yCenter, halfWidth, halfHeight, quad);
                    }
                }
            }
            quad.objects.push(spatialSearch.childnode);
            spatialSearch.quadTable[spatialSearch.childnode.name] = quad;
            return null;
        },
        _findQuads: function (spatialSearch, quad, viewPort) {
            if (quad.first && this._isIntersect(quad.first, viewPort)) {
                this._findQuads(spatialSearch, quad.first, viewPort);
            }
            if (quad.second && this._isIntersect(quad.second, viewPort)) {
                this._findQuads(spatialSearch, quad.second, viewPort);
            }
            if (quad.third && this._isIntersect(quad.third, viewPort)) {
                this._findQuads(spatialSearch, quad.third, viewPort);
            }
            if (quad.fourth && this._isIntersect(quad.fourth, viewPort)) {
                this._findQuads(spatialSearch, quad.fourth, viewPort);
            }
            if (quad.objects.length > 0)
                spatialSearch.quads.push(quad);
        },
        _isIntersect: function (quad, viewPort) {
            if (quad.left + quad.width < viewPort.x || quad.top + quad.height < viewPort.y || quad.left > viewPort.x + viewPort.width || quad.top > viewPort.y + viewPort.height) {
                return false;
            }
            return true;
        },
        _update: function (quad) {
            if (quad.parent != null && quad.objects.length == 0 && quad.first == null &&
                quad.second == null && quad.third == null && quad.fourth == null) {
                var parent = quad.parent;
                if (parent.first == quad) {
                    parent.first = null;
                }
                else if (parent.second == quad) {
                    parent.second = null;
                }
                else if (parent.third == quad) {
                    parent.third = null;
                }
                else if (parent.fourth == quad) {
                    parent.fourth = null;
                }
                this._update(quad.parent);
            }
            else
                return;
        },
        _isWithinPageBounds: function (spatialSearch, bounds) {
            if (bounds.left >= spatialSearch.pageLeft && bounds.right <= spatialSearch.pageRight &&
                bounds.top >= spatialSearch.pageTop && bounds.bottom <= spatialSearch.pageBottom)
                return true;
            else
                return false;
        },
        _updateBounds: function (diagram, spatialSearch, node, update) {
            var modified = false;
            if (spatialSearch.topElement && node.name == spatialSearch.topElement.name) {
                modified = true;
                spatialSearch.pageTop = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "top");
            }
            if (spatialSearch.leftElement && node.name == spatialSearch.leftElement.name) {
                modified = true;
                spatialSearch.pageLeft = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "left");
            }
            if (spatialSearch.rightElement && node.name == spatialSearch.rightElement.name) {
                modified = true;
                spatialSearch.pageRight = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "right");
            }
            if (spatialSearch.bottomElement && node.name == spatialSearch.bottomElement.name) {
                modified = true;
                spatialSearch.pageBottom = null;
                this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "bottom");
            }
            if (modified) {
                if (diagram._pageBackgroundLayer) {
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram, (update !== undefined) ? update : true);
                }
            }
        },
        _findQuadElement: function (spatialSearch, quad, direction) {
            switch (direction) {
                case "bottom":
                    if (quad.third != null || quad.fourth != null) {
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    else {
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                    }
                    break;
                case "top":
                    if (quad.first != null || quad.second != null) {
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                    }
                    else {
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    break;
                case "left":
                    if (quad.first != null || quad.third != null) {
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                    }
                    else {
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    break;
                case "right":
                    if (quad.second != null || quad.fourth != null) {
                        if (quad.second != null) {
                            this._findQuadElement(spatialSearch, quad.second, direction);
                        }
                        if (quad.fourth != null) {
                            this._findQuadElement(spatialSearch, quad.fourth, direction);
                        }
                    }
                    else {
                        if (quad.third != null) {
                            this._findQuadElement(spatialSearch, quad.third, direction);
                        }
                        if (quad.first != null) {
                            this._findQuadElement(spatialSearch, quad.first, direction);
                        }
                    }

                    break;
            }

            var bounds, type;
            for (var i = 0; i < quad.objects.length; i++) {
                bounds = ej.datavisualization.Diagram.Util.bounds(quad.objects[i]);
                if (direction === "bottom" && (spatialSearch.pageBottom <= bounds.bottom || spatialSearch.pageBottom == null)) {
                    spatialSearch.pageBottom = bounds.bottom;
                    spatialSearch.bottomElement = quad.objects[i];
                }
                else if (direction === "top" && (spatialSearch.pageTop >= bounds.top || spatialSearch.pageTop == null)) {
                    spatialSearch.pageTop = bounds.top;
                    spatialSearch.topElement = quad.objects[i];
                }
                else if (direction === "left" && (spatialSearch.pageLeft >= bounds.left || spatialSearch.pageLeft == null)) {
                    spatialSearch.pageLeft = bounds.left;
                    spatialSearch.leftElement = quad.objects[i];
                }
                else if (direction === "right" && (spatialSearch.pageRight <= bounds.right || spatialSearch.pageRight == null)) {
                    spatialSearch.pageRight = bounds.right;
                    spatialSearch.rightElement = quad.objects[i];
                }
            }
        },
        _initializeNodes: function (diagram, spatialSearch) {
            var nodes = diagram.nodes();
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var type = this.getObjectType(node);
                if (type != "group") {
                    this._updateQuad(diagram, spatialSearch, node);
                }
            }
        },

        _initializeConnectors: function (diagram, spatialSearch) {
            var connectors = diagram.connectors();
            for (var i = 0; i < connectors.length; i++) {
                this._updateQuad(diagram, spatialSearch, connectors[i]);
            }
        },

        _updateQuad: function (diagram, spatialSearch, node, layoutinAction) {
            this._setCurrentNode(spatialSearch, node, diagram);
            var bounds = ej.datavisualization.Diagram.Util.bounds(node);
            var quad = spatialSearch.quadTable[node.name];
            if (quad) {
                if (!this._isContained(spatialSearch, quad)) {
                    this._removeFromaQuad(spatialSearch, quad, node);
                    this._addIntoAQuad(spatialSearch);
                }
            }
            else {
                if (!spatialSearch.parentQuad)
                    spatialSearch.parentQuad = ej.datavisualization.Diagram.Quad(0, 0, 200, 200);
                this._addIntoAQuad(spatialSearch);
            }
            if (!(this._isWithinPageBounds(spatialSearch, bounds) && spatialSearch.leftElement != node &&
                spatialSearch.topElement != node && spatialSearch.rightElement != node && spatialSearch.bottomElement != node)) {
                var modified = false, endElement = false;
                if (spatialSearch.pageLeft >= spatialSearch.childLeft || spatialSearch.pageLeft == null) {
                    spatialSearch.pageLeft = spatialSearch.childLeft;
                    spatialSearch.leftElement = node;
                    modified = true;
                }
                else if (node == spatialSearch.leftElement) {
                    spatialSearch.pageLeft = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "left");
                    endElement = modified = true;
                }

                if (spatialSearch.pageTop >= spatialSearch.childTop || spatialSearch.pageTop == null) {
                    spatialSearch.pageTop = spatialSearch.childTop;
                    spatialSearch.topElement = node;
                    modified = true;
                }
                else if (node == spatialSearch.topElement) {
                    spatialSearch.pageTop = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "top");
                    endElement = modified = true;
                }

                if (spatialSearch.pageBottom <= spatialSearch.childBottom || spatialSearch.pageBottom == null) {
                    modified = true;
                    spatialSearch.pageBottom = spatialSearch.childBottom;
                    spatialSearch.bottomElement = node;
                }
                else if (node == spatialSearch.bottomElement) {
                    spatialSearch.pageBottom = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "bottom");
                    endElement = modified = true;
                }

                if (spatialSearch.pageRight <= spatialSearch.childRight || spatialSearch.pageRight == null) {
                    spatialSearch.pageRight = spatialSearch.childRight;
                    spatialSearch.rightElement = node;
                    modified = true;
                }
                else if (node == spatialSearch.rightElement) {
                    spatialSearch.pageRight = null;
                    this._findQuadElement(spatialSearch, spatialSearch.parentQuad, "right");
                    endElement = modified = true;
                }
            }
            var pageBounds = diagram.activeTool.diagramBounds;
            if (modified && diagram.model.pageSettings.multiplePage &&
                (diagram.model.pageSettings.pageWidth || diagram.model.pageSettings.pageHeight) && pageBounds) {
                modified = false;
                if (endElement || spatialSearch.pageLeft < pageBounds.x || spatialSearch.pageTop < pageBounds.y ||
                    spatialSearch.pageRight > pageBounds.x + pageBounds.width || spatialSearch.pageBottom > pageBounds.y + pageBounds.height) {
                    modified = true;
                    diagram.activeTool.diagramBounds = diagram._getDigramBounds();
                }
            }
            if (modified) {
                diagram._views.forEach(function (viewid) {
                    var view = diagram._views[viewid];
                    if (view.type == "overview") {
                        var ovw = $("#" + viewid).ejOverview("instance");
                        if (ovw)
                            ovw._updateOverview(view);
                    }
                });
                if (!diagram._layoutInAction && diagram._pageBackgroundLayer) {
                    ej.datavisualization.Diagram.PageUtil._updatePageSize(diagram, diagram.activeTool.inAction || diagram._selectedSymbol);
                }
            }
        },
        _removeFromaQuad: function (spatialSearch, quad, node) {
            if (quad) {
                var index = quad.objects.indexOf(node);
                quad.objects.splice(index, 1);
                this._update(quad);
                delete spatialSearch.quadTable[node.name];
            }
        }

    };

    ej.datavisualization.Diagram.Quad = function (left, top, width, height, parent) {
        return {
            left: left, top: top, width: width, height: height, parent: parent,
            first: null, second: null, third: null, fourth: null, objects: []
        };
    }
    ej.datavisualization.Diagram.SpatialSearch = function (diagram) {       
        var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(diagram);
        var x = 0;
        var y = 0;
        var height = 200;
        var width = 200;
        if (ej.datavisualization.Diagram.Util.canRouteDiagram(diagram)) {
            x = -100; y = -100;
            height = viewPort.height > 0 ? viewPort.height : 1000;
            width = viewPort.width > 0 ? viewPort.width : 1000;
        }
        return {
            pageLeft: null, pageRight: null, pageTop: null, pageBottom: null,
            topElement: null, bottomElement: null, rightElement: null, leftElement: null,
            childLeft: null, childTop: null, childRight: null, childBottom: null, childNode: null,
            quads: null, parentQuad: ej.datavisualization.Diagram.Quad(x, y, width, height), quadTable: {}
        };
    };
    //#endregion
    ej.datavisualization.Diagram.ClassifierHelper = {
        getEditableElementUnderMouse: function (evt, diagram) {
            var element = diagram._findNodeUnderMouse(evt);
            if (element) {
                var type = element.name.match("_attribute") ? "attribute" : (element.name.match("_method") ? "method" : (element.name.match("_member") ? "member" : "header"));
                if (type && element.parent)
                    element = diagram.nameTable[element.parent];
            }
            return element;
        },
        getMovableElementUnderMouse: function (evt, diagram, defult) {
            var element = diagram._findNodeUnderMouse(evt);
            var className = evt.target.className;
            if (element && element.parent && !(element.type == "umlclassifier"))
                element = diagram.nameTable[element.parent]
            return element;
        },
        getSelectableElementUnderMouse: function (evt, diagram, skip) {
            var node = diagram._findNodeUnderMouse(evt);
            if (node && node.parent && !(node.type == "umlclassifier"))
                node = diagram.nameTable[node.parent];
            return node;
        },
        getDropableElementUnderMouse: function (evt, diagram) {
            var element = diagram._findNodeUnderMouse(evt);
            if (!diagram._nodeUnderMouse)
                diagram._nodeUnderMouse = element;
            if (element && ej.datavisualization.Diagram.Util.canAllowDrop(element))
                return element;
            else
                return true;
        },
        renderResizeBorder: function (id, node, svg, scale) {
            var width = node.width ? node.width : node._width;
            var height = node.height ? node.height : node._height;
            var rect = svg.rect({
                "id": id, "width": (width * scale) + node.borderWidth + 4, "height": height * scale + node.borderWidth + 4, x: -(node.borderWidth / 2 + 2), y: -(node.borderWidth / 2 + 2), "stroke": "#f93732", "stroke-width": 2, "stroke-dasharray": "0", "fill": "none", "pointer-events": "none"
            });
            return rect;
        },
        getEditboxValue: function (editBoxValue, shape, diagram) {
            for (var i = 0; i < shape.children.length; i++) {
                if (typeof shape.children[i] == "string")
                    shape.children[i] = diagram.nameTable[diagram._getChild(shape.children[i])];
                var type = shape.children[i].name.match("_attribute") ? "attribute" : (shape.children[i].name.match("_method") ? "method" : (shape.children[i].name.match("_member") ? "member" : "header"));
            }
            var text = editBoxValue.split("\n");
            for (var j = 0; j < text.length; j++) {
                text[j] = text[j].trim().replace(/\s+/g, " ");
                if (!text[j].indexOf("---") > -1 && text[j].charAt(0) == "+" || text[j].charAt(0) == "-" || text[j].charAt(0) == "#" || text[j].charAt(0) == "~")
                    text[j] = text[j];
                else if (j != text[j].length - text[j].length && !text[j].indexOf("---") > -1 && text[j].length > 0 && type != "member" && !shape.enumeration) {
                    text[j] = "+" + " " + text[j];
                }
                if (text[j].indexOf("---") > -1 && text[j].match(/\w|\d|\D|\s/g)) {
                    var spliter = text[j].match(/---/g);
                    text[j] = spliter[0];
                }
            }
            editBoxValue = text.join("\n");
            var editLabel = editBoxValue.split("\n---\n");
            for (var j = 0; j < editLabel.length; j++)
                editLabel[j] = editLabel[j].replace(/^\n+/g, "");
            if (editLabel[0].indexOf("+") > -1)
                editLabel[0] = editLabel[0].replace(/[+]/g, "");
            if (editLabel[0].length > 0)
                shape.children[0].labels[0].text = editLabel[0];
            if (shape.children[1] && !editLabel[2])
                shape.children[1].labels[0].text = editLabel[1];
            else if (shape.children[1] && editLabel[2]) {
                if (shape.children[1].name.indexOf("method") > -1) {
                    if (shape.children[1].labels[0].text.indexOf(editLabel[1]) > -1) {
                        shape.children[1].labels[0].text = editLabel[1];
                        editLabel.pop()
                    }
                    else
                        shape.children[1].labels[0].text = editLabel[2];
                }
                else {
                    var value = shape.children[1].name.indexOf("attribute") > -1 ? editLabel[1] : (shape.children[1].name.indexOf("member") > -1 ? editLabel[1] : editLabel[2]);
                    shape.children[1].labels[0].text = value;
                }
            }
            if (shape.children[2])
                shape.children[2].labels[0].text = editLabel[2];
            for (var i = 0; i < shape.children.length; i++) {
                var textEdit = shape.children[i].labels[0].text;
                if (textEdit && textEdit.indexOf("--") > -1) {
                    textEdit = textEdit.replace(/---\n*/g, "");
                    shape.children[i].labels[0].text = textEdit;
                }
                if (textEdit && textEdit.endsWith("\n")) {
                    var newText = textEdit.replace(/\n+$/g, "");
                    shape.children[i].labels[0].text = newText;
                }
                var labelLength = shape.children[i].labels[0].text ? shape.children[i].labels[0].text.length : null;
                if (!labelLength && labelLength <= 0) {
                    diagram._remove(shape.children[i]);
                    i--;
                }
                diagram.nameTable[shape.children[i].name] = shape.children[i];
            }
            if ((editLabel[2] && !shape.children[2]) || (editLabel[1] && !shape.children[1])) {
                var nodes = [];
                var constraints = ej.datavisualization.Diagram.NodeConstraints.Default & ~(ej.datavisualization.Diagram.NodeConstraints.Select | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeWest | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthEast | ej.datavisualization.Diagram.NodeConstraints.ResizeNorthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeSouthWest | ej.datavisualization.Diagram.NodeConstraints.ResizeNorth | ej.datavisualization.Diagram.NodeConstraints.ResizeSouth | ej.datavisualization.Diagram.NodeConstraints.Connect | ej.datavisualization.Diagram.NodeConstraints.Rotate | ej.datavisualization.Diagram.NodeConstraints.ResizeEast);
                var defaultProperty = { width: shape.width, offsetX: shape.offsetX, parent: shape.name, ports: [], fillColor: "transparent", borderColor: shape.borderColor, type: "node", labels: [{ margin: { left: 5, right: 5, top: 5, bottom: 5 } }], _isClassMember: true };
                for (var i = 0; i < shape.children.length; i++) {
                    if (i != 0 && shape.children[i].name.indexOf("_attribute") > -1 && editLabel[2].length > 0)
                        nodes.push({ name: shape.name + "_method" + "_classifier", labels: [{ text: editLabel[2], horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 } }], constraints: constraints });
                    else if (i != 0 && shape.children[i].name.indexOf("_method") > -1 && editLabel[1].length > 0)
                        nodes.push({ name: shape.name + "_attribute" + "_classifier", labels: [{ text: editLabel[1], horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 } }], constraints: constraints });
                }
                if (shape.children.length < 2) {
                    if (editLabel[1])
                        nodes.push({ name: shape.name + "_attribute" + "_classifier", labels: [{ text: editLabel[1], horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 } }], constraints: constraints });
                    if (editLabel[2])
                        nodes.push({ name: shape.name + "_method" + "_classifier", labels: [{ text: editLabel[2], horizontalAlignment: "left", textAlign: "left", offset: { x: 0, y: 0.5 } }], constraints: constraints });
                }
                for (var j = 0; j < nodes.length; j++) {
                    nodes[j].labels[0] = $.extend(true, {}, shape.labels[0], nodes[j].labels[0]);
                    nodes[j] = ej.datavisualization.Diagram.Node($.extend(true, {}, defaultProperty, nodes[j]));
                    diagram._getNodeDimension(nodes[j], nodes[j].labels[0]);
                    nodes[j].offsetY += (shape.offsetY - shape.height / 2);
                    diagram.add(nodes[j]);
                    diagram.nameTable[nodes[j].name] = nodes[j];
                }
                if (shape.children[2] && shape.children[2].match("_attribute")) {
                    shape.children.splice(1, 0, shape.children[2]);
                    shape.children.pop();
                }
                if (typeof shape.children[1] == "string")
                    shape.children[1] = diagram.nameTable[shape.children[1]];
                if (typeof shape.children[2] == "string")
                    shape.children[2] = diagram.nameTable[shape.children[2]];
            }
            for (var i = 0; i < shape.children.length; i++) {
                if (shape.children.length == 1) {
                    if (shape["class"]) {
                        delete shape["class"].attributes;
                        delete shape["class"].methods;
                    }
                    if (shape["interface"]) {
                        delete shape["interface"].attributes;
                        delete shape["interface"].methods;
                    }
                    if (shape.enumeration)
                        delete shape.enumeration.members;
                }
                if (shape.children.length == 2) {
                    if (shape["class"]) {
                        if (shape.children[i].name.match("attribute"))
                            delete shape["class"].methods;
                        if (shape.children[i].name.match("method"))
                            delete shape["class"].attributes;
                    }
                    if (shape["interface"]) {
                        if (shape.children[i].name.match("attribute"))
                            delete shape["interface"].methods;
                        if (shape.children[i].name.match("method"))
                            delete shape["interface"].attributes;
                    }
                }
                this._updateClassNode(shape.children[i], shape);
            }
            return editBoxValue;
        },
        getUMLConnectorValue: function (shape, editBoxValue, label) {
            var available, option;
            if (label.name === shape.name + "_sourcelabel" || label.name === shape.name + "_targetlabel") {
                if (shape.shape.multiplicity.type == "onetoone" || shape.shape.multiplicity.type == "manytoone" || shape.shape.multiplicity.type == "onetomany") {
                    if (editBoxValue.length == 1 && (editBoxValue.indexOf("1") > -1 || editBoxValue.indexOf("*") > -1))
                        available = true;
                    option = false;
                    if ((label.name === shape.name + "_sourcelabel") && (shape.shape.multiplicity.type == "onetoone" || shape.shape.multiplicity.type == "onetomany")) {
                        editBoxValue = "1";
                        shape.shape.multiplicity = $.extend(true, {}, shape.shape.multiplicity, { source: { optional: option, lowerBounds: null, upperBounds: null } });
                    }
                    else if ((label.name === shape.name + "_targetlabel") && (shape.shape.multiplicity.type == "manytoone" || shape.shape.multiplicity.type == "onetoone")) {
                        editBoxValue = "1";
                        shape.shape.multiplicity = $.extend(true, {}, shape.shape.multiplicity, { target: { optional: option, lowerBounds: null, upperBounds: null } });
                    }
                }
                editBoxValue = this.umlConnectorEditBox(editBoxValue);
                if (editBoxValue.match(/\d\.{3}\d/g))
                    var text = editBoxValue.split("...");
                else if (!available) {
                    var labels = this.umlConnectorMultiplicity(shape);
                    if (label.name == shape.name + "_sourcelabel") {
                        var text = labels[0].text.split("...");
                        editBoxValue = labels[0].text;
                    }
                    else {
                        var text = labels[1].text.split("...");
                        editBoxValue = labels[1].text;
                    }
                }
                if (text) {
                    if (label.name == shape.name + "_sourcelabel")
                        shape.shape.multiplicity = $.extend(true, {}, shape.shape.multiplicity, { source: { optional: option, lowerBounds: text[0], upperBounds: text[1] } });
                    else
                        shape.shape.multiplicity = $.extend(true, {}, shape.shape.multiplicity, { target: { optional: option, lowerBounds: text[0], upperBounds: text[1] } });
                }
            }
            label.text = editBoxValue;
            return shape;
        },
        umlConnectorMultiplicity: function (options) {
            var labels = [], text, text1, sourceText, targetText, lower, upper;
            if (options.shape.multiplicity.source) {
                options.shape.multiplicity.source.lowerBounds = this.umlConnectorEditBox(options.shape.multiplicity.source.lowerBounds);
                options.shape.multiplicity.source.upperBounds = this.umlConnectorEditBox(options.shape.multiplicity.source.upperBounds);
            }
            if (options.shape.multiplicity.target) {
                options.shape.multiplicity.target.lowerBounds = this.umlConnectorEditBox(options.shape.multiplicity.target.lowerBounds);
                options.shape.multiplicity.target.upperBounds = this.umlConnectorEditBox(options.shape.multiplicity.target.upperBounds);
            }
            lower = options.shape.multiplicity.source;
            upper = options.shape.multiplicity.target;
            text = lower.upperBounds ? lower.lowerBounds + "..." + lower.upperBounds : lower.lowerBounds;
            text1 = upper.upperBounds ? upper.lowerBounds + "..." + upper.upperBounds : upper.lowerBounds;
            if (options.shape.multiplicity.type == "manytoone") {
                options.shape.multiplicity.target.optional = false;
                sourceText = text ? text : "*"; targetText = "1";
            }
            if (options.shape.multiplicity.type == "onetomany") {
                options.shape.multiplicity.source.optional = false;
                targetText = text1 ? text1 : "*"; sourceText = "1";
            }
            if (options.shape.multiplicity.type == "manytomany") {
                sourceText = text ? text : "*"; targetText = text1 ? text1 : "*";
            }
            if (options.shape.multiplicity.type == "onetoone") {
                options.shape.multiplicity.target.optional = false;
                options.shape.multiplicity.source.optional = false;
                sourceText = "1"; targetText = "1"
            }
            labels.push({ name: options.name + "_sourcelabel", text: sourceText, segmentOffset: 0, alignment: "before", margin: { left: 5, top: 5 } }, { name: options.name + "_targetlabel", text: targetText, segmentOffset: 1, alignment: "before", margin: { right: 5, bottom: 5 } });
            return labels;
        },
        umlConnectorEditBox: function (text) {
            if (typeof text == "string") {
                if (text.match(/[a-zA-Z]/g))
                    text = text.replace(/[a-zA-Z]/g, "");
            }
            return text;
        },
        EnableorDisableConnection: function (child, node, connector, diagram) {
            if (connector.shape) {
                if (connector.shape.type == "umlclassifier" && connector.shape.relationship != "association") {
                    if (connector.shape.relationship != "dependency" && connector.shape.relationship != "inheritance" && connector.shape.relationship != "realization") {
                        if (node && child) {
                            if (child["interface"] && node["class"])
                                child = null;
                        }
                    }
                    if (connector.shape.relationship == "dependency") {
                        if (node && child) {
                            if (child["class"] && node["interface"])
                                child = null;
                        }
                    }
                }
            }
            return child;
        },
        getClassifierNodeDimension: function (shape, diagram) {
            for (var i = 0; i < shape.children.length; i++)
                diagram._getNodeDimension(shape.children[i]);
            shape._height = 0;
            for (var i = 0; i < shape.children.length; i++) {
                var height = shape.children[i].height ? shape.children[i].height : shape.children[i]._height;
                shape.children[i].offsetY = shape._height + height / 2;
                shape._height += height;
                shape.height = shape._height;
            }
            var width = shape.children[0]._width;
            if (shape.children[1])
                var width = shape.children[0]._width > shape.children[1]._width ? shape.children[0]._width : shape.children[1]._width
            if (shape.children[2])
                width = shape.children[2]._width > width ? shape.children[2]._width : width;
            shape.children[0].width = width;
            if (shape.children[1])
                shape.children[1].width = width;
            if (shape.children[2])
                shape.children[2].width = width;
            shape.width = width;
            for (var j = 0; j < shape.children.length; j++)
                shape.children[j].offsetY += (shape.offsetY - shape.height / 2);
            diagram._updateAssociatedConnectorEnds(shape, diagram.nameTable);
            return shape;
        },
        _updateClassNode: function (node, parent) {
            if (node.name.match("_header")) {
                if (parent["class"]) parent["class"].name = node.labels[0].text;
                else if (parent["interface"]) parent["interface"].name = node.labels[0].text;
                else parent.enumeration.name = node.labels[0].text;
            }
            else {
                var type = node.name.match("_attribute") ? "attribute" : (node.name.match("_method") ? "method" : "member");
                var label = node.labels[0];
                var scopeValue, argument, classArgument = [], argumentText;
                var str = label.text.split("\n");
                var classMember = [], data, i;
                for (i = 0; i < str.length; i++) {
                    if (str[i].indexOf("+") > -1)
                        scopeValue = "public";
                    else if (str[i].indexOf("-") > -1)
                        scopeValue = "private";
                    else if (str[i].indexOf("#") > -1)
                        scopeValue = "protected";
                    else if (str[i].indexOf("~") > -1)
                        scopeValue = "package";
                    if (str[i].indexOf("+") > -1 || str[i].indexOf("-") > -1 || str[i].indexOf("#") > -1 || str[i].indexOf("~") > -1)
                        str[i] = str[i].replace(/[+|~|#|-]\s/g, "");
                    switch (type) {
                        case "attribute":
                            data = str[i].split(/:[ ]*/g);
                            classMember.push(ej.datavisualization.Diagram.ClassAttribute({ name: data[0], type: data[1], scope: scopeValue }));
                            break;
                        case "method":
                            argument = str[i].split(/["("|")"]/g);
                            for (var k = 0; k < argument.length; k++) {
                                if (argument[k].indexOf(",") > -1)
                                    data = argument[k].split(",");
                                if (k == argument.length - 1)
                                    argument[k] = argument[k].replace(/[:\s]|:/g, "");
                            }
                            if (data) {
                                for (var j = 0; j < data.length; j++) {
                                    argumentText = data[j].split(":");
                                    classArgument.push(ej.datavisualization.Diagram.ClassmethodArguments({ name: argumentText[0], type: argumentText[1] }))
                                }
                            }
                            if (argument.length == 3 && !data) {
                                if (argument[1].indexOf(":") > -1) {
                                    argumentText = argument[1].split(":");
                                    classArgument.push(ej.datavisualization.Diagram.ClassmethodArguments({ name: argumentText[0], type: argumentText[1] }))
                                }
                                else
                                    classArgument.push(ej.datavisualization.Diagram.ClassmethodArguments({ name: argument[1] }))
                            }
                            classMember.push(ej.datavisualization.Diagram.ClassMethod({ name: argument[0], arguments: classArgument, type: argument[argument.length - 1], scope: scopeValue }));
                            break;
                        case "member":
                            classMember.push(ej.datavisualization.Diagram.ClassMember({ name: str[i] }));
                            break;
                    }
                }
                if (type == "attribute") {
                    if (parent["class"])
                        parent["class"].attributes = classMember;
                    else if (parent["interface"])
                        parent["interface"].attributes = classMember;
                }
                else if (type == "method") {
                    if (parent["class"])
                        parent["class"].methods = classMember;
                    else if (parent["interface"])
                        parent["interface"].methods = classMember;
                }
                else parent.enumeration.members = classMember;
            }

        },

    }
    //#region Swimlane 
    ej.datavisualization.Diagram.SwimLaneContainerHelper = {
        //#region initDefaults
        _initSwimLane: function (diagram, node) {
            var node = ej.datavisualization.Diagram.SwimLane(node);
            node = this._initLaneCollection(diagram, node);
            this._swapPhaseSize(node);
            node = this._setPhaseMinValues(diagram, node);
            node = this._initPhaseCollection(diagram, node);

            return node;
        },
        _initLaneCollection: function (diagram, node) {
            if (node.lanes.length === 0)
                node.lanes = [ej.datavisualization.Diagram.Lane({ orientation: node.orientation })];
            for (var i = 0; i < node.lanes.length; i++) {
                node.lanes[i] = ej.datavisualization.Diagram.Lane(node.lanes[i]);
                node.lanes[i].container = { type: "canvas", orientation: node.orientation }
                node.lanes[i].borderColor = node.lanes[i].borderColor ? node.lanes[i].borderColor : "black",
                node.lanes[i].orientation = node.orientation ? node.orientation : "horizontal",
                node.lanes[i].horizontalAlign = node.orientation === "horizontal" ? "stretch" : "left",
                node.lanes[i].verticalAlign = node.orientation === "vertical" ? "stretch" : "top",
                node.lanes[i].addInfo = node.lanes[i].addInfo ? node.lanes[i].addInfo : {},
                node.lanes[i].fillColor = node.lanes[i].fillColor,
                node.lanes[i].paddingTop = 20,
                node.lanes[i].paddingRight = 20,
                node.lanes[i].paddingBottom = 20,
                node.lanes[i].paddingLeft = 20,
                node.lanes[i].constraints = node.lanes[i].constraints ? node.lanes[i].constraints | ej.datavisualization.Diagram.NodeConstraints.AllowDrop : (ej.datavisualization.Diagram.NodeConstraints.Default | ej.datavisualization.Diagram.NodeConstraints.AllowDrop & ~ej.datavisualization.Diagram.NodeConstraints.Connect),
                node.lanes[i].cssClass = node.lanes[i].cssClass,
                node.lanes[i]._laneHeader = node.lanes[i]._laneHeader ? node.lanes[i]._laneHeader : null

                if (node.lanes[i].labels && node.lanes[i].labels.length > 0) {
                    for (var h = 0; h < node.lanes[i].labels.length; h++) {
                        node.lanes[i].labels[h] = ej.datavisualization.Diagram.Label(node.lanes[i].labels[h]);
                    }
                }
                var laneHeader = node.lanes[i]._laneHeader = node.lanes[i]._laneHeader ? node.lanes[i]._laneHeader : node.lanes[i].header
                var header = this._initLaneHeader(diagram, node.lanes[i], laneHeader, node);
                node.lanes[i].children.splice(0, 0, header);

            }
            return node;
        },
        _initLaneHeader: function (diagram, lane, laneHeader, node) {
            var headObj = lane.header;
            var nodeOrientation = node.orientation;
            if (nodeOrientation === "horizontal") {
                var hAlign = "left";
                var vAlign = "stretch";
                headObj.rotateAngle = 270;
            }
            else {
                hAlign = "stretch";
                vAlign = "top";
                headObj.rotateAngle = 0;
            }

            var node = ej.datavisualization.Diagram.Node({
                _hidePorts: true,
                _isHeader: true,
                name: (diagram._isUndo && laneHeader.name) ? laneHeader.name : lane.name + "_Headerr_",
                type: "node",
                labels: [headObj],
                height: laneHeader.height ? laneHeader.height : 50,
                width: laneHeader.width ? laneHeader.width : 50,
                fillColor: headObj.fillColor ? headObj.fillColor : "white",
                rotateAngle: 0,
                horizontalAlign: hAlign,
                verticalAlign: vAlign,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
                marginLeft: -20,
                marginTop: -20,
                marginRight: -20,
                marginBottom: -20,
            });
            if (headObj && headObj._labelName && diagram._isUndo)
                node.labels[0].name = headObj._labelName;
            else
                node.labels[0].name = node.name + "_label";
            return node;
        },
        _initPhaseCollection: function (diagram, node) {
            var offY = 0, offX = 0;
            if (node.phases.length === 0)
                node.phases = [ej.datavisualization.Diagram.Phase({ orientation: node.orientation })];
            for (var i = 0; i < node.phases.length; i++) {
                node.phases[i]._UndoRedo = diagram._UndoRedo;
                node.phases[i]._isUndo = diagram._isUndo;
                node.phases[i] = ej.datavisualization.Diagram.Phase(node.phases[i]);
                node.phases[i].isPhase = true;
                node.phases[i]._hidePorts = true,
                node.phases[i].constraints = ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
                node.phases[i].parent = "";
                node.phases[i]._isHeader = true;
                node.phases[i]._type = "node";
                //node.phases[i].fillColor = 'blue';
                node.phases[i].orientation = node.orientation;
                if (!diagram._isLoad) {
                    if (node.phases[i].label && node.phaseSize != 0) {
                        node.phases[i].label.rotateAngle = node.orientation === "vertical" ? 270 : 0;
                        node.phases[i].labels = [node.phases[i].label];
                    }
                }
                else {
                    if (node.phases[i].labels && node.phases[i].labels.length > 0) {
                        node.phases[i].label = [node.phases[i].labels[0]]
                    }
                }
                if (node.orientation === "horizontal") {
                    //node.phases[i].verticalAlign = "stretch";
                    node.phases[i].width = node.phases[i].offset - offX;
                    node.phases[i].height = node.phaseSize;
                    offX = node.phases[i].offset;
                }
                else {
                    //node.phases[i].horizontalAlign = "stretch";
                    node.phases[i].height = node.phases[i].offset - offY;
                    node.phases[i].width = node.phaseSize;
                    offY = node.phases[i].offset;
                }
            }

            return node;
        },
        _setPhaseMinValues: function (diagram, node) {
            var cphase, fphase;
            fphase = node.phases[0];
            if (fphase) {
                if (fphase.offset < 70)
                    fphase.offset = 70;
                for (var i = 1; i < node.phases.length; i++) {
                    cphase = node.phases[i];
                    fphase = node.phases[i - 1];
                    if (fphase.offset + 20 >= cphase.offset)
                        cphase.offset = fphase.offset + 20;
                }
            }
            return node;
        },
        _swapPhaseSize: function (obj) {
            if (obj.phases.length > 0) {
                var phases = obj.phases, i, j, temp;
                for (i = 0; i < phases.length; i++) {
                    for (j = 0; j < (phases.length - i - 1) ; j++) {
                        if (phases[j].offset > phases[j + 1].offset) {
                            temp = phases[j];
                            phases[j] = phases[j + 1];
                            phases[j + 1] = temp;
                        }
                    }
                }
            }
        },
        _setLastPhaseSize: function (obj) {
            if (obj.phases.length > 0) {
                var lastPhase = obj.phases[obj.phases.length - 1];
                if (obj.orientation === "horizontal")
                    lastPhase.offset = obj.width;
                else
                    lastPhase.offset = obj.height;
            }
        },
        //#endregion

        //#region create
        _createSwimlane: function (diagram, node) {
            var header = this._createSwimlaneHeader(diagram, node);

            var stackOrientation = (node.orientation === "horizontal") ? "vertical" : "horizontal";
            var nodeOrientation = node.orientation;

            if (nodeOrientation === "horizontal") {
                var marginTop = Math.round(header.height + node.phaseSize);
                var marginLeft = 0;
            }
            else {
                marginTop = header.height;
                marginLeft = Math.round(node.phaseSize);
            }


            var phaseStack = {
                name: node.name + "phaseStack",
                isPhaseStack: true,
                container: { type: "stack", orientation: nodeOrientation },
                minHeight: 10,
                minWidth: 10,
                children: node.phases,
                marginTop: header.height,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect & ~ej.datavisualization.Diagram.NodeConstraints.AllowDrop
                //verticalAlign: nodeOrientation === "vertical" ? "stretch" : "top",
                //horizontalAlign: nodeOrientation === "horizontal" ? "stretch" : "left",
            };
            var laneStack = {
                name: node.name + "laneStack",
                isLaneStack: true,
                container: { type: "stack", orientation: stackOrientation },
                children: node.lanes,
                marginTop: marginTop,
                marginLeft: marginLeft,
                verticalAlign: "stretch",
                horizontalAlign: "stretch",
                constraints: (ej.datavisualization.Diagram.NodeConstraints.Default | ej.datavisualization.Diagram.NodeConstraints.AllowDrop) & ~ej.datavisualization.Diagram.NodeConstraints.Connect
            };
            var swimlane = {
                _hidePorts: true,
                name: node.name,
                container: { type: "canvas" },
                children: [
                    header,
                    //phaseStack,
                    laneStack
                ],
                addInfo: node.addInfo ? node.addInfo : null,
                paletteItem: node.paletteItem ? node.paletteItem : null,
                constraints: node.constraints,
                cssClass: node.cssClass,
                offsetX: node.offsetX ? node.offsetX : 100,
                offsetY: node.offsetY ? node.offsetY : 100,
                orientation: node.orientation,
                phaseSize: node.phaseSize,
                isSwimlane: true,
                height: node.height ? node.height : 100,
                width: node.width ? node.width : 100,
            };

            swimlane.offsetX = node.offsetX ? node.offsetX : 100;
            swimlane.offsetY = node.offsetY ? node.offsetY : 100;
            //#region temp
            var cloneObj = ej.datavisualization.Diagram.containerCommon._cloneObject(diagram, swimlane, ej.datavisualization.Diagram.Util.randomId());
            cloneObj = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, cloneObj);
            var cloneObjBounds = ej.datavisualization.Diagram.Util.bounds(cloneObj);

            cloneObjBounds = this._setSwimlaneSize(diagram, swimlane, cloneObjBounds);

            ej.datavisualization.Diagram.containerCommon._removeObject(diagram, cloneObj);
            //#endregion

            if (nodeOrientation === "horizontal") {
                phaseStack.maxHeight = node.phaseSize;
                phaseStack.minWidth = 10;
            }
            else {
                phaseStack.minHeight = 10;
                phaseStack.maxWidth = node.phaseSize;
            }
            swimlane.children.splice(1, 0, phaseStack);
            this._setPhaseValues(diagram, swimlane, cloneObjBounds);
            var canvas = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, swimlane);
            return canvas;
        },
        _setSwimlaneSize: function (diagram, swimlane, cloneBounds) {
            if (swimlane.orientation === "horizontal") {
                if (swimlane.width > cloneBounds.width) {
                    var lanes = swimlane.children[1].children;
                    for (var i = 0; i < lanes.length; i++) {
                        lanes[i].minWidth = swimlane.width;
                    }
                    cloneBounds.width = swimlane.width;
                }

                if (swimlane.height > cloneBounds.height) {
                    var lanes = swimlane.children[1].children;
                    var lastLane = lanes[lanes.length - 1];
                    lastLane.minHeight += swimlane.height - cloneBounds.height;
                    cloneBounds.height = swimlane.height;
                }
            }
            else {
                if (swimlane.width > cloneBounds.width) {
                    var lanes = swimlane.children[1].children;
                    var lastLane = lanes[lanes.length - 1];
                    lastLane.minWidth += swimlane.width - cloneBounds.width;
                    cloneBounds.height = swimlane.height;
                }


                if (swimlane.height > cloneBounds.height) {
                    var lanes = swimlane.children[1].children;
                    for (var i = 0; i < lanes.length; i++) {
                        lanes[i].minHeight = swimlane.height - (2 * swimlane.children[0].height);
                    }
                    cloneBounds.height = swimlane.height;
                }
            }
            return cloneBounds;
        },
        _setPhaseValues: function (diagram, swimlane, bounds) {
            var phases = swimlane.children[1].children;
            var lastPhase = phases[phases.length - 1];
            var orientation = swimlane.orientation;
            if (orientation === "horizontal") {
                if (lastPhase.offset <= bounds.width) {
                    if (phases.length == 1) {
                        lastPhase.offset = bounds.width;
                        lastPhase.width = bounds.width;
                    }
                    else {
                        var prevPhase = phases[phases.indexOf(lastPhase) - 1];
                        lastPhase.offset = bounds.width;
                        lastPhase.width = bounds.width - prevPhase.offset;
                    }

                    var lanes = swimlane.children[2].children;
                    for (var i = 0; i < lanes.length; i++) {
                        lanes[i].minWidth = lastPhase.offset;
                    }
                }
                else {
                    var maxOffset = 0;
                    for (var i = 0; i < phases.length; i++) {
                        if (phases[i].offset >= maxOffset) {
                            maxOffset = phases[i].offset;
                        }
                    }
                    var lanes = swimlane.children[2].children;
                    for (var i = 0; i < lanes.length; i++) {
                        lanes[i].minWidth = maxOffset;
                    }
                }
            }
            else {
                var header = swimlane.children[0];
                if (lastPhase.offset <= bounds.height - header.height) {
                    if (phases.length == 1) {
                        lastPhase.offset = bounds.height - header.height;
                        lastPhase.height = lastPhase.offset;
                    }
                    else {
                        var prevPhase = phases[phases.indexOf(lastPhase) - 1];
                        lastPhase.offset = bounds.height - header.height;
                        lastPhase.height = bounds.height - prevPhase.offset - header.height;
                    }

                    var lanes = swimlane.children[2].children;
                    for (var i = 0; i < lanes.length; i++) {
                        lanes[i].minHeight = lastPhase.offset;
                    }
                }
                else {
                    var maxOffset = 0;
                    for (var i = 0; i < phases.length; i++) {
                        if (phases[i].offset >= maxOffset) {
                            maxOffset = phases[i].offset;
                        }
                    }
                    var lanes = swimlane.children[2].children;
                    for (var i = 0; i < lanes.length; i++) {
                        lanes[i].minHeight = maxOffset;
                    }
                }
            }

        },
        _createSwimlaneHeader: function (diagram, node) {
            var headObj = node.header;
            var laneHeader = node.lanes[0]._laneHeader ? node.lanes[0]._laneHeader : null;
            headObj.name = node.name + "_header_swimlane" + "_label"
            var header = ej.datavisualization.Diagram.Node({
                _type: "node",
                _hidePorts: true,
                _isHeader: true,
                name: node.name + "_header_swimlane",
                labels: [headObj],
                height: headObj.height != undefined ? headObj.height : 50,
                width: headObj.width != undefined ? headObj.width : 50,
                fillColor: node.header.fillColor ? node.header.fillColor : (laneHeader ? laneHeader.fillColor : "white"), // laneHeader ? laneHeader.fillColor : node.header.fillColor ? node.header.fillColor : "white",
                rotateAngle: 0,
                constraints: ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect,
                horizontalAlign: "stretch",
                parent: node.name,
            });
            header.labels[0].fillColor = "transparent";
            if (diagram._isLoad) {
                header.fillColor = node.header.fillColor;
            }
            return header;
        },
        //#endregion

        //#region update
        _updateSwimlane: function (diagram, node) {
            this._updateLaneStack(diagram, node);
            this._updatePhaseStack(diagram, node);
            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, node);
        },
        _updateLaneStack: function (diagram, swimlane) {
            var lanes = this.getLanes(diagram, swimlane), lane;
            for (var i = 0; i < lanes.length; i++) {
                lane = diagram.nameTable[diagram._getChild(lanes[i])];
                if (lane) {
                    for (var j = 1; j < lane.children.length; j++) {
                        var child = typeof lane.children[j] == "string" ? diagram.nameTable[lane.children[j]] : lane.children[j];
                        child.marginBottom = child.marginRight = 0;
                    }
                    this._updateLane(diagram, lane);
                }
            }
        },
        _updatePhaseStack: function (diagram, swimlane) {
            var PhaseStack = diagram.nameTable[diagram._getChild(swimlane.children[1])];
            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, PhaseStack);
        },
        _updateLane: function (diagram, node) {
            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, node);
        },

        //#endregion 

        //#region helper
        getPhases: function (diagram, swimlane, childTable) {
            if (swimlane) {
                if (swimlane.children[1])
                    var phaseStack = childTable ? childTable[diagram._getChild(swimlane.children[1])] : diagram.nameTable[diagram._getChild(swimlane.children[1])];
                if (phaseStack) {
                    var phases = diagram._getChildren(phaseStack.children);
                    if (phases && phases.length > 0) {
                        return phases;
                    }
                }

            }
        },
        getLanes: function (diagram, swimlane) {
            if (swimlane && swimlane.isSwimlane && swimlane.children[2])
                var laneStack = diagram.nameTable[diagram._getChild(swimlane.children[2])];
            if (laneStack) {
                var lanes = laneStack.children;
                if (lanes && lanes.length > 0) {
                    return lanes;
                }
            }


        },

        _updateLanesMinValue: function (diagram, swimlane, prop, value) {
            var lanes = this.getLanes(diagram, swimlane), lane;
            for (var i = 0; i < lanes.length; i++) {
                lane = diagram.nameTable[diagram._getChild(lanes[i])];
                if (lane) {
                    lane[prop] = value;
                }
            }
        },
        _resizeLastPhase: function (diagram, swimlane) {
        },
        _getPhaseBounds: function (diagram, phase) {
            var bounds = null, group, phaseBounds, prevOffset, left = 0, right = 0, top = 0, bottom = 0;
            if (phase && phase.type == "phase" && phase.parent) {
                var prevPhase = this._getPrevPhase(diagram, phase);
                var nextPhase = this._getNextPhase(diagram, phase)
                group = diagram.nameTable[phase.parent.split("phaseStack")[0]];
                if (group && group.orientation) {
                    bounds = ej.datavisualization.Diagram.Util.bounds(group)
                    if (group.orientation == "horizontal") {
                        prevOffset = this._getPrevOffset(diagram, phase, prevPhase, nextPhase, group, bounds);
                        if (prevPhase && prevPhase.name === phase.name) {
                            left = prevOffset.left + bounds.left;
                            right = left + (phase.offset - left - prevOffset.left);
                        }
                        else {
                            if (prevPhase)
                                left = bounds.left + prevPhase.offset;
                            right = (phase.offset - left + bounds.left);
                        }
                        top = prevOffset.top + bounds.top;
                        bottom = bounds.bottom - top;
                        phaseBounds = ej.datavisualization.Diagram.Rectangle(left, top, right, bottom);
                    }
                    else {
                        prevOffset = this._getPrevOffset(diagram, phase, prevPhase, nextPhase, group, bounds);
                        if (prevPhase === phase) {

                            left = prevOffset.left + bounds.left;
                            bottom = phase.offset + top;

                            top = prevOffset.top + bounds.top;
                        }
                        else {
                            var head = diagram.nameTable[diagram._getChild(group.children[0])];

                            var headHeight = head ? head.height : 0;
                            left = prevOffset.left + bounds.left;
                            if (prevPhase)
                                top = (prevPhase.offset + bounds.top) + headHeight;
                            bottom = bounds.top + phase.offset - top + headHeight;
                        }
                        right = bounds.right - left;
                        phaseBounds = ej.datavisualization.Diagram.Rectangle(left, top, right, bottom);
                    }
                }
            }
            return phaseBounds;
        },
        _getPrevPhase: function (diagram, phase) {
            var prevPhase = null, index;
            var group = diagram.nameTable[phase.parent.split("phaseStack")[0]];
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, group);
            if (group && phases && phases.length > 0) {
                index = this._getPhaseIndex(diagram, phase.name);
                if (index === 0)
                    prevPhase = diagram.nameTable[diagram._getChild(phases[0])];
                else
                    prevPhase = diagram.nameTable[diagram._getChild(phases[index - 1])];
            }
            return prevPhase;
        },
        _getPrevOffset: function (diagram, phase, prevPhase, nextPhase, parent, parentBounds) {
            var stckHeadWidth = 50, stack, firstCanvas, dleft = 0, dtop = 0;
            if (parent.children[0]) {
                var head = diagram.nameTable[diagram._getChild(parent.children[0])];
                if (head) {
                    dtop = head.height;
                }
            }
            if (parent.orientation == "horizontal") {
                if (parent.children[2])
                    stack = diagram.nameTable[diagram._getChild(parent.children[2])];
                if (stack && stack.children && stack.children.length > 0) {
                    firstCanvas = diagram.nameTable[diagram._getChild(stack.children[0])];
                    if (firstCanvas && firstCanvas.children && firstCanvas.children.length > 0) {
                        var _firstchild = diagram.nameTable[diagram._getChild(firstCanvas.children[0])]
                        if (_firstchild && _firstchild.name.indexOf("_Headerr") != -1) {
                            dleft = _firstchild.width;
                        }
                    }
                }
            }
            return { left: dleft, top: dtop };
        },
        _getNextPhase: function (diagram, phase) {
            var nxtPhase = null, index;
            var group = diagram.nameTable[phase.parent.split("phaseStack")[0]];
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, group);
            if (group && phases && phases.length > 0) {
                index = diagram._getPhaseIndex(phase.name);
                if (index === phases.length - 1)
                    nxtPhase = diagram.nameTable[diagram._getChild(phases[index])];
                else
                    nxtPhase = diagram.nameTable[diagram._getChild(phases[index + 1])];
            }
            return nxtPhase;
        },
        _getPhaseIndex: function (diagram, name) {
            var phase, group, index = -1;
            phase = diagram.nameTable[name];
            if (phase && phase.parent) {
                group = diagram.nameTable[phase.parent.split("phaseStack")[0]];
                var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, group);
                if (phases && phases.length > 0) {
                    index = phases.indexOf(name);
                }
            }
            return index;
        },
        _cloneLaneObj: function (diagram, obj, name, childTable) {
            var nameTable = childTable ? childTable : diagram.nameTable;
            obj = $.extend(true, {}, obj);
            var children = obj.children;
            if (children && children.length > 0) {
                for (var m = 0; m < children.length; m++) {
                    var child = nameTable[diagram._getChild(children[m])];
                    if (child) {
                        child = jQuery.extend(true, {}, child);
                        if (child && child.children && child.children.length) {
                            child = diagram._cloneLaneObj(child, name, childTable);
                        }
                        child.name += name;
                        child.parent = name;
                        obj.children[m] = child;
                        if (childTable)
                            diagram._preserveConnection(childTable, child);
                    }
                }
            }
            if (obj && obj.header) {
                obj.header.name += name;
            }
            obj.name += name;
            return obj;
        },
        _cloneSwimlaneObj: function (diagram, obj, name, data) {
            obj = $.extend(true, {}, obj);
            if (obj && obj.isSwimlane) {
                obj = jQuery.extend(true, {}, obj);
                obj.name += name;
                //update lanes
                if (obj.lanes && obj.lanes.length > 0) {
                    for (var i = 0; i < obj.lanes.length; i++) {
                        if (obj.lanes[i]) {
                            obj.lanes[i] = diagram._cloneLaneObj(obj.lanes[i], name, (data && data.childTable) ? data.childTable : null);
                        }
                    }
                }
                //update phases
                if (obj.phases && obj.phases.length > 0) {
                    for (var i = 0; i < obj.phases.length; i++) {
                        if (obj.phases[i]) {
                            obj.phases[i].name += name;
                            obj.phases[i].parent = "";
                        }
                    }
                }
            }
            return obj;
        },
        _pasteSwimlaneObj: function (diagram, node, data) {
            node = diagram._pasteSwimlane(node, data);
            if (node) {
                var dx = diagram._isUndo ? 0 : (diagram._pasteIndex * 10);
                diagram._translate(node, dx, dx, diagram.nameTable);
                ej.datavisualization.Diagram.DiagramContext.update(node, diagram);
            }
            return node;
        },
        _pasteSwimlane: function (diagram, node, data, mSelection, x) {
            diagram._pasteObj = true;
            if (node && node.isSwimlane) {
                var dx = diagram._isUndo ? 0 : diagram._pasteIndex * 10;
                var cloneObj = diagram._cloneSwimlaneObj(diagram._getNode(node.name, data ? data.childTable : null), diagram._swimlanePaste ? "" : ej.datavisualization.Diagram.Util.randomId(), data);
                cloneObj = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, cloneObj, data);
                if (diagram._outOfBoundsOnNudge(cloneObj, dx, dx)) {
                    diagram.add(cloneObj);
                }
                else {
                    ej.datavisualization.Diagram.containerCommon._removeObject(diagram, cloneObj);
                    return null
                };
                diagram._pasteObj = false;
                return cloneObj;
            }
        },
        _updateNextPhase: function (diagram, swimlane, dif, index) {
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, swimlane), phase;
            for (var i = index + 1; i < phases.length; i++) {
                phase = diagram.nameTable[diagram._getChild(phases[i])];
                if (phase) {
                    phase.offset += dif;
                }
            }
        },
        _getOuterNodes: function (diagram, swimlane, x, y) {
            var outerNodes = [];
            var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(diagram, swimlane);
            var prop = swimlane.orientation === "horizontal" ? "left" : "top";
            var value = swimlane.orientation === "horizontal" ? x : y;
            for (var i = 0; i < lanes.length; i++) {
                var lane = diagram.nameTable[diagram._getChild(lanes[i])];
                if (lane && lane.children.length > 1) {
                    for (var j = 0; j < lane.children.length; j++) {
                        var child = diagram.nameTable[diagram._getChild(lane.children[j])];
                        if (child) {
                            var childBounds = ej.datavisualization.Diagram.Util.bounds(child);
                            if (childBounds[prop] > value)
                                outerNodes.push(child);
                        }
                    }
                }
            }
            return outerNodes;
        },
        _getInnerNodes: function (diagram, swimlane, value1, value2) {
            var innerNodes = [];
            var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(diagram, swimlane);
            var prop1 = swimlane.orientation === "horizontal" ? "left" : "top";
            var prop2 = swimlane.orientation === "horizontal" ? "right" : "bottom";
            for (var i = 0; i < lanes.length; i++) {
                var lane = diagram.nameTable[diagram._getChild(lanes[i])];
                if (lane && lane.children.length > 1) {
                    for (var j = 0; j < lane.children.length; j++) {
                        var child = diagram.nameTable[diagram._getChild(lane.children[j])];
                        if (child) {
                            var bounds = ej.datavisualization.Diagram.Util.bounds(child);
                            if (bounds[prop1] >= value1 && bounds[prop2] <= value2)
                                innerNodes.push(child);
                        }
                    }
                }
            }
            return innerNodes;
        },
        _moveOuterNodes: function (diagram, swimlane, dif, index) {
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, swimlane);
            var phase = diagram.nameTable[diagram._getChild(phases[index])];
            var bounds = ej.datavisualization.Diagram.Util.bounds(swimlane);
            var swimlaneHeader = diagram.nameTable[diagram._getChild(swimlane.children[0])];
            var x = bounds.left + phase.offset;
            var y = bounds.top + phase.offset + swimlaneHeader.height;

            var prop = swimlane.orientation === "horizontal" ? "offsetX" : "offsetY";
            var value = swimlane.orientation === "horizontal" ? x : y;
            var margin = swimlane.orientation === "horizontal" ? "marginLeft" : "marginTop";
            var nodes = diagram._getOuterNodes(swimlane, x, y);

            if (nodes && nodes.length > 0) {
                for (var i = 0; i < nodes.length; i++) {
                    var child = diagram.nameTable[diagram._getChild(nodes[i])];
                    //child[prop] += dif;
                    diagram._translate(child, (prop === "offsetX" ? dif : 0), (prop === "offsetY" ? dif : 0), diagram.nameTable);
                    child[margin] += dif;
                }
            }
        },
        _moveOnPhaseChange: function (diagram, phase, dif, index) {
            var lane;
            var swimlaneName = phase.parent.split('phaseStack')[0];
            if (swimlaneName)
                var swimlane = diagram.nameTable[swimlaneName];
            if (swimlane) {
                var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(diagram, swimlane);
                var swimlaneHeader = diagram.nameTable[diagram._getChild(swimlane.children[0])];
                for (var i = 0; i < lanes.length; i++) {
                    lane = diagram.nameTable[diagram._getChild(lanes[i])];
                    if (lane) {
                        if (phase.orientation === "horizontal") {
                            lane.width += dif;
                            lane.minWidth = lane.width;
                        }
                        else {
                            lane.height += dif;
                            lane.minHeight = lane.height
                        }
                    }
                }
                if (phase.orientation === "horizontal") {
                    swimlane.minWidth += dif;
                }
                else {
                    swimlane.minHeight = lane.height
                }
                //diagram._updateNextPhase(swimlane, dif, index);
                //diagram._moveOuterNoder(swimlane, dif, index);
                ej.datavisualization.Diagram.SwimLaneContainerHelper._updateSwimlane(diagram, swimlane);
            }
        },
        _getPhaseDifferece: function (diagram, swimlane, index, difference) {
            var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, swimlane);
            var phase = diagram.nameTable[diagram._getChild(phases[index])];
            var swimlaneBounds = ej.datavisualization.Diagram.Util.bounds(swimlane);
            var prop = swimlane.orientation === "horizontal" ? "left" : "top";
            var swimlaneHeader = diagram.nameTable[diagram._getChild(swimlane.children[0])], head = 0;
            if (swimlane.orientation === "vertical")
                head = swimlaneHeader.height;
            if (index === 0) {
                var innerNodes = diagram._getInnerNodes(swimlane, swimlaneBounds[prop] + head, swimlaneBounds[prop] + phase.offset + head)
                if (innerNodes && innerNodes.length > 0) {
                    var pseudoGroup = ej.datavisualization.Diagram.Group({ "name": "multipleSelection", type: "pseudoGroup", children: innerNodes });
                    ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                    var bounds = ej.datavisualization.Diagram.Util.bounds(pseudoGroup);
                }
                else {
                    var bounds = ej.datavisualization.Diagram.Util.bounds();
                    bounds.right = swimlaneBounds.left + 50;
                }
                if (swimlane.orientation === "horizontal") {
                    if (swimlaneBounds.left + (phase.offset + difference) >= bounds.right + 20) {
                    }
                    else {
                        var temp = (bounds.right + 20) - (swimlaneBounds.left + (phase.offset + difference));
                        difference = difference + temp;
                    }
                    if (phase.offset + difference < 100)
                        difference = 0;
                }
                else {
                    if (swimlaneBounds.top + swimlaneHeader.height + (phase.offset + difference) >= bounds.bottom + 20) {
                    }
                    else {
                        var temp = (bounds.bottom + 20) - (swimlaneBounds.top + head + (phase.offset + difference));
                        difference = difference + temp;
                    }
                    if (phase.offset + difference < 100)
                        difference = 0;
                }
            }
            else {
                var prevPhase = diagram.nameTable[diagram._getChild(phases[index - 1])];
                var innerNodes = diagram._getInnerNodes(swimlane, swimlaneBounds[prop] + prevPhase.offset + head, swimlaneBounds[prop] + phase.offset + head)
                if (innerNodes && innerNodes.length > 0) {
                    var pseudoGroup = ej.datavisualization.Diagram.Group({ "name": "multipleSelection", type: "pseudoGroup", children: innerNodes });
                    ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                    var bounds = ej.datavisualization.Diagram.Util.bounds(pseudoGroup);
                }
                else {
                    bounds = ej.datavisualization.Diagram.Util.bounds();
                    bounds.bottom = swimlaneBounds.top + swimlaneHeader.height + prevPhase.offset;
                }
                if (swimlane.orientation === "horizontal") {
                    if (swimlaneBounds.left + (phase.offset + difference) >= bounds.right + 20) {
                    }
                    else {
                        var temp = (bounds.right + 20) - (swimlaneBounds.left + (phase.offset + difference));
                        difference = difference + temp;
                    }
                }
                else {
                    if (swimlaneBounds.top + swimlaneHeader.height + (phase.offset + difference) >= bounds.bottom + 20) {
                    }
                    else {
                        var temp = (bounds.bottom + 20) - (swimlaneBounds.top + swimlaneHeader.height + (phase.offset + difference));
                        difference = difference + temp;
                    }
                }
            }
            if (prevPhase && phase.offset - prevPhase.offset + difference < 20) {
                difference -= (phase.offset - prevPhase.offset + difference - 20);
            }
            return difference;
        },
        //#endregion
    };

    ej.datavisualization.Diagram.ContainerHelper = {
        _initContainer: function (diagram, node, data) {
            if (node.container) {
                switch (node.container.type) {
                    default:
                    case "canvas":
                        node = ej.datavisualization.Diagram.canvasHelper._initCanvas(diagram, node);
                        if (node.type == "bpmn") {
                            var parent = ej.datavisualization.Diagram.ContainerHelper.updateparent(node, diagram);
                            if (!parent)
                                ej.datavisualization.Diagram.bpmnHelper.updateCanvas(node, diagram);
                        }
                        break;
                    case "stack":
                        node = ej.datavisualization.Diagram.stackHelper._initStack(diagram, node);
                        break;
                }
            }
            else if (node.type === "swimlane" || node.isSwimlane) {
                node = ej.datavisualization.Diagram.SwimLaneContainerHelper._initSwimLane(diagram, node);
                node = ej.datavisualization.Diagram.SwimLaneContainerHelper._createSwimlane(diagram, node);
            }
            return node;
        },
        _add: function (diagram, node) {
            var parent;
            if (diagram.getObjectType(node) !== "connector") {
                parent = (node.parent) ? diagram.nameTable[node.parent] : null;
                if (parent && parent.container) {
                    for (var i = parent.children.length - 1; i >= 0; i--) {
                        var child = diagram.nameTable[diagram._getChild(parent.children[i])];
                        if (child.name === node.name)
                            ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, parent.children[i]);
                    }
                    var cause = diagram._isUndo ? ej.datavisualization.Diagram.GroupChangeCause.HistoryChange : ej.datavisualization.Diagram.GroupChangeCause.Drop;
                    if (diagram._isLaneApi)
                        cause = ej.datavisualization.Diagram.GroupChangeCause.Unknown;

                    diagram._raiseGroupChangeEvent(node, null, parent, cause);
                    parent.children.push(node);
                    diagram._disableSwimlaneUptate = true;
                    ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(diagram);
                    var prevObj = $.extend(true, {}, parent)
                    this._updateCollectionChange(diagram, parent, true);
                    ej.datavisualization.Diagram.canvasHelper._updateAddRemoveNodeConnectors(diagram, parent, prevObj);
                    delete diagram._disableSwimlaneUptate
                    ej.datavisualization.Diagram.canvasHelper._updateLastSwimlanePhase(diagram, node);
                    var parentObj = diagram._svg.document.getElementById(node.parent);
                    if (node._type === "group")
                        ej.datavisualization.Diagram.DiagramContext.renderGroup(node, diagram, parentObj);
                    else
                        ej.datavisualization.Diagram.DiagramContext.renderNode(node, diagram, parentObj);
                    ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdateNode(diagram, node);
                }
            }
        },
        updateparent: function (node, diagram) {
            var temp = node;
            if (diagram) {
                while (temp && temp.parent) {
                    temp = diagram.nameTable[temp.parent]
                    if (temp && temp.isLane)
                        return temp;
                }
            }
            return false;
        },
        _updateCollectionChange: function (diagram, node, updateOffset, parent) {
            if (!diagram._diagramClear) {
                var oldXY, currXY, update = true;
                if (node) {
                    var oldBounds = ej.datavisualization.Diagram.Util.bounds(node);
                    oldXY = { x: oldBounds.x, y: oldBounds.y };
                    if (node.container) {
                        if (node.container.type === "canvas") {
                            if (node._isBpmn) {
                                var parent = this.updateparent(node, diagram);
                                if (!parent) ej.datavisualization.Diagram.bpmnHelper.updateCanvas(node, diagram);
                                else ej.datavisualization.Diagram.canvasHelper._updateCollectionChange(diagram, node);
                            }
                            else ej.datavisualization.Diagram.canvasHelper._updateCollectionChange(diagram, node);
                        }
                        else
                            ej.datavisualization.Diagram.stackHelper._updateCollectionChange(diagram, node, null, parent);
                    }
                    if ((updateOffset && !node.isLane && !node._isBpmn) || node.isSwimlane) {
                        if (diagram._disableSwimlaneUptate)
                            update = false;
                        var currBounds = ej.datavisualization.Diagram.Util.bounds(node);
                        currXY = { x: currBounds.x, y: currBounds.y };
                        diagram._translate(node, oldXY.x - currXY.x, oldXY.y - currXY.y, diagram.nameTable)
                        if (update) {
                            ej.datavisualization.Diagram.DiagramContext.update(node, diagram);
                        }
                    }
                }
                if (node && node.container && !node.isLane && !node.isSwimlane && !node.isLaneStack && !node.isPhaseStack)
                    ej.datavisualization.Diagram.DiagramContext.update(node, diagram);
            }
        },
    };

    ej.datavisualization.Diagram.stackHelper = {
        _initStack: function (diagram, node) {
            node = ej.datavisualization.Diagram.Group(node);
            node = this._initGroupNode(diagram, node);
            node = this._initChildren(diagram, node);
            this._setSize(diagram, node);
            this._alignChildren(diagram, node);
            return node;
        },
        _initGroupNode: function (diagram, node) {
            return ej.datavisualization.Diagram.containerCommon._initGroupNode(diagram, node);
        },
        _initChildren: function (diagram, node) {
            return ej.datavisualization.Diagram.containerCommon._initChildren(diagram, node);
        },
        _setSize: function (diagram, node) {
            var pBounds = this._getStackBoundsBounds(diagram, node);
            if (pBounds.width >= node.minWidth && pBounds.width <= node.maxWidth)
                node.width = pBounds.width
            else if (pBounds.width <= node.minWidth)
                node.width = node.minWidth
            else if (pBounds.width >= node.maxWidth)
                node.width = node.maxWidth


            if (pBounds.height >= node.minHeight && pBounds.height <= node.maxHeight)
                node.height = pBounds.height
            else if (pBounds.height <= node.minHeight)
                node.height = node.minHeight
            else if (pBounds.height >= node.maxHeight)
                node.height = node.maxHeight
        },
        _getStackBoundsBounds: function (diagram, node) {
            var fRect = ej.datavisualization.Diagram.Rectangle(), i, child, cRect, height = 0, width = 0, maxWidth = 0, maxHeight = 0;
            var orientation = node.container.orientation ? node.container.orientation : "vertical";
            if (node.children && node.children.length > 0) {
                var children = node.children;
                for (i = 0; i < children.length; i++) {
                    child = typeof (children[i]) === "string" ? diagram.nameTable[children[i]] : children[i];
                    if (child) {
                        cRect = ej.datavisualization.Diagram.Util.bounds(child);
                        cRect = ej.datavisualization.Diagram.Geometry.rect([cRect.topLeft, cRect.topRight, cRect.bottomRight, cRect.bottomLeft]);
                        if (cRect) {
                            if (orientation === "vertical") {
                                width = cRect.width += child.marginLeft + child.marginRight;
                                if (width > maxWidth) {
                                    maxWidth = cRect.width = width;
                                }
                                cRect.width = (child.horizontalAlign === "stretch") ? (cRect.width > child.minWidth ? cRect.width : maxWidth) : maxWidth;
                                cRect.height += child.marginTop + child.marginBottom;
                                cRect.height += fRect.height;
                            }
                            else {
                                height = cRect.height += child.marginTop + child.marginBottom;
                                if (height > maxHeight) {
                                    maxHeight = cRect.height = height;
                                }

                                cRect.height = (child.verticalAlign === "stretch") ? (cRect.height > child.minHeight ? cRect.height : maxHeight) : maxHeight;
                                cRect.width += child.marginLeft + child.marginRight;
                                cRect.width += fRect.width;
                            }
                            cRect.x = 0; cRect.y = 0;
                        }
                        fRect = diagram._union(fRect, cRect);
                    }
                }
            }
            fRect.width += node.paddingLeft + node.paddingRight;
            fRect.height += node.paddingTop + node.paddingBottom;
            return fRect;
        },
        _alignChildren: function (diagram, node) {
            var child, transX = 0, transY = 0;;
            var children = node.children;
            for (var i = 0; i < children.length; i++) {
                child = typeof (children[i]) === "string" ? diagram.nameTable[children[i]] : children[i];
                if (child) {
                    var pos = this._getStackPosition(diagram, child, node, transX, transY);
                    this._translate(diagram, child, pos.x, pos.y);

                    if (node.container.orientation == "vertical")
                        transY += (child.height ? child.height : child._height) + child.marginTop + child.marginBottom;
                    else
                        transX += (child.width ? child.width : child._width) + child.marginLeft + child.marginRight;
                }
            }
        },
        _getStackPosition: function (diagram, child, parent, transX, transY) {
            var dx = 0, dy = 0;
            var groupBounds = ej.datavisualization.Diagram.Util.bounds(parent);
            var bounds = ej.datavisualization.Diagram.Util.bounds(child);
            var orientation = parent.container.orientation ? parent.container.orientation : "vertical";
            var width = child.width ? child.width : child._width;
            var height = child.height ? child.height : child._height;
            if (parent.container.orientation == "vertical") {
                dy = groupBounds.y - bounds.y + transY + child.marginTop + parent.paddingTop;
                switch (child.horizontalAlign) {
                    case "left":
                        dx = groupBounds.x - bounds.x + child.marginLeft + parent.paddingLeft;
                        break;
                    case "center":
                        dx = groupBounds.center.x - bounds.center.x;
                        break;
                    case "right":
                        dx = (groupBounds.x + groupBounds.width) - (bounds.x + bounds.width + parent.paddingRight);
                        break;
                    case "stretch":
                        var deltaWidth = (parent.width - (parent.paddingLeft + parent.paddingRight) - (child.marginLeft + child.marginRight)) / width;
                        diagram.scale(child, deltaWidth, 1, parent.pivot, diagram.nameTable);
                        groupBounds = ej.datavisualization.Diagram.Util.bounds(parent);
                        bounds = ej.datavisualization.Diagram.Util.bounds(child, diagram);
                        dx = (groupBounds.x + parent.paddingLeft + child.marginLeft) - (bounds.x);
                        break;
                }
            }
            else {
                dx = groupBounds.x - bounds.x + transX + child.marginLeft + parent.paddingLeft;
                switch (child.verticalAlign) {
                    case "top":
                        dy = groupBounds.y - bounds.y + child.marginTop + parent.paddingTop;
                        break;
                    case "center":
                        dy = groupBounds.center.y - bounds.center.y;
                        break;
                    case "bottom":
                        dy = (groupBounds.y + groupBounds.height) - (bounds.y + bounds.height + parent.paddingBottom);
                        break;
                    case "stretch":
                        var deltaHeight = (parent.height - (parent.paddingTop + parent.paddingBottom) - (child.marginTop + child.marginBottom)) / height;
                        diagram.scale(child, 1, deltaHeight, parent.pivot, diagram.nameTable);
                        groupBounds = ej.datavisualization.Diagram.Util.bounds(parent);
                        bounds = ej.datavisualization.Diagram.Util.bounds(child, diagram);
                        dy = (groupBounds.y + parent.paddingTop + child.marginTop) - (bounds.y);
                        break;
                }
            }
            return { x: dx, y: dy }
        },
        _translate: function (diagram, node, dx, dy) {
            if (dx || dy) {
                if (!node.segments) {
                    node.offsetX += dx;
                    node.offsetY += dy;
                    if ((node._type === "group" || node.type === "pseudoGroup" || node.type == "umlclassifier")) {
                        var nodes = node.children;
                        var child;
                        for (var i = 0; nodes && i < nodes.length; i++) {
                            child = diagram.nameTable[diagram._getChild(nodes[i])];
                            if (child) {
                                this._translate(diagram, child, dx, dy);
                            }
                        }
                    }
                    ej.datavisualization.Diagram.DefautShapes.translateBPMNAnnotationShape(node, dx, dy, null, diagram);
                } else {
                    ej.datavisualization.Diagram.Util._translateLine(node, dx, dy, node);
                }
            }
        },

        //#region update
        _updateCollectionChange: function (diagram, node, updateParent, parentObj) {
            this._setSize(diagram, node);
            this._alignChildren(diagram, node);
            if (node.parent) {
                var parent = diagram.nameTable[node.parent];
                if (!parent) {
                    if (parentObj && node.isPhaseStack) {
                        parent = parentObj;
                    }
                }
                if (parent && parent.container && !updateParent) {
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent);
                }
            }
            //ej.datavisualization.Diagram.DiagramContext.update(node, diagram);
        }
        //#endregion
    };

    ej.datavisualization.Diagram.canvasHelper = {

        //#region helpers

        _initCanvas: function (diagram, node) {
            node._type = "group";
            if (!node.type) node.type = "group";
            node = ej.datavisualization.Diagram.Group(node);
            node = this._initGroupNode(diagram, node);
            node = this._initChildren(diagram, node);
            this._setSize(diagram, node);
            this._alignChildren(diagram, node);
            //this._setSize(diagram, node);
            return node;
        },
        _initGroupNode: function (diagram, node) {
            return ej.datavisualization.Diagram.containerCommon._initGroupNode(diagram, node);
        },
        _initChildren: function (diagram, node) {
            return ej.datavisualization.Diagram.containerCommon._initChildren(diagram, node);
        },
        _setSize: function (diagram, node, updatePosition, useBottomRight) {
            var pBounds = this._getCanvasBounds(diagram, node, useBottomRight);
            var pervBounds = ej.datavisualization.Diagram.Util.bounds(node);
            pervBounds = ej.datavisualization.Diagram.Geometry.rect([pervBounds.topLeft, pervBounds.topRight, pervBounds.bottomRight, pervBounds.bottomLeft]);
            if (pBounds.width >= node.minWidth && pBounds.width <= node.maxWidth)
                pBounds.width = pBounds.width
            else if (pBounds.width <= node.minWidth)
                pBounds.width = node.minWidth
            else if (pBounds.width >= node.maxWidth)
                pBounds.width = node.maxWidth


            if (pBounds.height >= node.minHeight && pBounds.height <= node.maxHeight)
                pBounds.height = pBounds.height
            else if (pBounds.height <= node.minHeight)
                pBounds.height = node.minHeight
            else if (pBounds.height >= node.maxHeight)
                pBounds.height = node.maxHeight

            if (updatePosition) {
                var scaleX = pBounds.width / pervBounds.width, scaleY = pBounds.height / pervBounds.height;
                var dx = (pBounds.x + pBounds.width / 2) - (pervBounds.x + pervBounds.width / 2);
                var dy = (pBounds.y + pBounds.height / 2) - (pervBounds.y + pervBounds.height / 2);
                var offset = ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY)
                diagram._translate(node, dx, dy, diagram.nameTable, true);
                diagram.scale(node, scaleX, scaleY, ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), diagram.nameTable);
                if (node._isBpmn) {
                    var children = diagram._getChildren(node.children);
                    for (var i = 0; i < children.length; i++) {
                        var child = diagram.nameTable[children[i]];
                        if (child && child._isInternalShape && ej.datavisualization.Diagram.Util.canResize(child))
                            child = $.extend(true, child, { offsetX: node.offsetX, offsetY: node.offsetY, width: node.width, height: node.height });
                    }
                    ej.datavisualization.Diagram.Util._updateBPMNProperties(node, diagram, diagram.nameTable, true);
                }
                ej.datavisualization.Diagram.DefautShapes.translateBPMNAnnotationShape(node, 1 / scaleX, 1 / scaleY, offset, diagram);
            } else {
                node.width = pBounds.width;
                node.height = pBounds.height;
            }
        },
        _alignChildren: function (diagram, node) {
            var child, update = true;
            var children = node.children;
            for (var i = 0; i < children.length; i++) {
                child = typeof (children[i]) === "string" ? diagram.nameTable[children[i]] : children[i];
                if (child && !child._isInternalShape) {
                    if (diagram._disablePhaseUpdate && child.isPhaseStack)
                        update = false;
                    if (update) {
                        var pos = this._getCanvasPosition(diagram, child, node);
                        this._translate(diagram, child, pos.x, pos.y);
                    }
                }
                if (child && child._isInternalShape && ej.datavisualization.Diagram.Util.canResize(child)) {
                    child = $.extend(true, child, { offsetX: node.offsetX, offsetY: node.offsetY, width: node.width, height: node.height });
                    ej.datavisualization.Diagram.Util._updateBPMNProperties(node, diagram, diagram.nameTable, true);
                }
            }
        },
        _translate: function (diagram, node, dx, dy) {
            if (dx || dy) {
                if (!node.segments) {
                    node.offsetX += dx;
                    node.offsetY += dy;
                    if ((node._type === "group" || node.type === "pseudoGroup")) {
                        var nodes = node.children;
                        var child;
                        for (var i = 0; i < nodes.length; i++) {
                            child = diagram.nameTable[diagram._getChild(nodes[i])];
                            if (child) {
                                this._translate(diagram, child, dx, dy);
                                diagram._updateQuad(child);
                            }
                        }
                    }
                    ej.datavisualization.Diagram.DefautShapes.translateBPMNAnnotationShape(node, dx, dy, null, diagram);
                } else {
                    ej.datavisualization.Diagram.Util._translateLine(node, dx, dy, node);
                }
            }
        },
        _getCanvasPosition: function (diagram, child, parent) {
            var dx = 0, dy = 0;
            var groupBounds = ej.datavisualization.Diagram.Util.bounds(parent);
            var bounds = ej.datavisualization.Diagram.Util.bounds(child);
            switch (child.horizontalAlign) {
                case "left":
                    dx = groupBounds.x - bounds.x + child.marginLeft + parent.paddingLeft;
                    break;
                case "center":
                    dx = (groupBounds.x + groupBounds.width / 2) - (bounds.x + bounds.width / 2) + child.marginLeft + parent.paddingLeft;
                    break;
                case "right":
                    dx = (groupBounds.x + groupBounds.width - child.marginRight) - (bounds.x + bounds.width + parent.paddingRight);
                    break;
                case "stretch":
                    var deltaWidth = (groupBounds.width - parent.paddingLeft - parent.paddingRight - child.marginLeft - child.marginRight) / child.width;
                    diagram.scale(child, deltaWidth, 0, parent.pivot, diagram.nameTable);
                    bounds = ej.datavisualization.Diagram.Util.bounds(child, diagram);
                    dx = (groupBounds.x + parent.paddingLeft) - (bounds.x) + child.marginLeft;
                    break;
            }
            switch (child.verticalAlign) {
                case "top":
                    dy = groupBounds.y - bounds.y + child.marginTop + parent.paddingTop;
                    break;
                case "center":
                    dy = (groupBounds.y + groupBounds.height / 2) - (bounds.y + bounds.height / 2) + child.marginTop + parent.paddingTop;
                    break;
                case "bottom":
                    dy = (groupBounds.y + groupBounds.height - child.marginBottom) - (bounds.y + bounds.height + parent.paddingBottom);
                    break;
                case "stretch":
                    var deltaHeight = (groupBounds.height - parent.paddingTop - parent.paddingBottom - child.marginTop - child.marginBottom) / child.height;
                    diagram.scale(child, 0, deltaHeight, parent.pivot, diagram.nameTable);
                    bounds = ej.datavisualization.Diagram.Util.bounds(child, diagram);
                    dy = (groupBounds.y + parent.paddingTop) - (bounds.y) + child.marginTop;
                    break;

            }
            return { x: dx, y: dy };
        },
        _getCanvasBounds: function (diagram, node, useBottomRight) {
            var fRect = ej.datavisualization.Diagram.Rectangle(), i = 0, child, cRect;
            var x, y, diffx, diffy;
            if (node.children && node.children.length > 0) {
                var children = node.children;
                for (; i < children.length; i++) {
                    child = typeof (children[i]) === "string" ? diagram.nameTable[children[i]] : children[i];
                    if (child && !child._isInternalShape) {
                        cRect = ej.datavisualization.Diagram.Util.bounds(child);
                        cRect = ej.datavisualization.Diagram.Geometry.rect([cRect.topLeft, cRect.topRight, cRect.bottomRight, cRect.bottomLeft]);
                        if (child.horizontalAlign === "stretch") {
                            cRect.width = cRect.width >= node.minWidth ? cRect.width : 1;
                            if ((node.isLane || node.isSwimlane) && i == 0)
                                cRect.width = 1;
                        }
                        if (child.verticalAlign === "stretch") {
                            cRect.height = cRect.height >= node.minHeight ? cRect.height : 1;
                            if (node.isLane && i == 0)
                                cRect.height = 1;
                        }
                        if (cRect) {
                            diffx = child.marginLeft > 0 ? cRect.x - child.marginLeft : cRect.x;
                            diffy = child.marginTop > 0 ? cRect.y - child.marginTop : cRect.y;
                            x = x == undefined ? diffx : Math.min(x, diffx);
                            y = y == undefined ? diffy : Math.min(y, diffy);
                            cRect.width += child.marginLeft + (useBottomRight ? 0 : child.marginRight);
                            cRect.height += child.marginTop + (useBottomRight ? 0 : child.marginBottom);
                            cRect.x = 0; cRect.y = 0;
                            if (node.type == "bpmn") {
                                if (child.marginLeft < 0) cRect.width -= child.marginLeft;
                                if (child.marginTop < 0) cRect.height -= child.marginTop;
                            }
                        }
                        fRect = ej.datavisualization.Diagram.Geometry.union(fRect, cRect);
                    }
                }
            }
            if (node.type == "bpmn" && ej.datavisualization.Diagram.Geometry.isEmptyRect(fRect)) {
                fRect = ej.datavisualization.Diagram.Util.bounds(node);
                fRect = ej.datavisualization.Diagram.Geometry.rect([fRect.topLeft, fRect.topRight, fRect.bottomRight, fRect.bottomLeft]);
            }
            else {
                fRect.width += node.paddingLeft + node.paddingRight;
                fRect.height += node.paddingTop + node.paddingBottom;
                fRect.x = x - node.paddingLeft;
                fRect.y = y - node.paddingTop;
            }
            return fRect;
        },

        //#endregion 

        //#region update
        _updateCollectionChange: function (diagram, node) {
            var useBottomRight = false;
            if (diagram.activeTool.name === "resize" && node.container) {
                useBottomRight = true;
            }
            this._setSize(diagram, node, null, useBottomRight);
            this._alignChildren(diagram, node);
            if (node.parent) {
                var parent = diagram.nameTable[node.parent];
                if (parent && parent.container) {
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent);
                }
            }
            //ej.datavisualization.Diagram.DiagramContext.update(node, diagram);
        },
        //#endregion

        _getSwimlane: function (diagram, laneName) {
            var lane = diagram.nameTable[diagram._getChild(laneName)];
            if (lane && lane.isLane) {
                var laneStack = diagram.nameTable[lane.parent];
                if (laneStack) {
                    var swimlane = diagram.nameTable[laneStack.parent];
                    if (swimlane)
                        return diagram.getNode(swimlane.name);
                }
            }

        },
        //#region swapping lane
        _laneConnectors: function (diagram, lane, connectors) {
            var m, i, j, k, lane, child, lanes;
            if (lane && lane.isLane) {
                for (j = 0; j < lane.children.length; j++) {
                    child = diagram.nameTable[diagram._getChild(lane.children[j])];
                    if (child) {
                        if (child.inEdges && child.inEdges.length > 0) {
                            for (m = 0; m < lane.children.length; m++) {
                                if (!diagram._collectionContains(child.inEdges[m], connectors))
                                    connectors.push(child.inEdges[m])
                            }
                        }
                        if (child.outEdges && child.outEdges.length > 0) {
                            for (m = 0; m < lane.children.length; m++) {
                                if (!diagram._collectionContains(child.outEdges[m], connectors))
                                    connectors.push(child.outEdges[m])
                            }
                        }
                    }
                }
            }
        },
        _connectorRelateTolaneCollection: function (diagram, connector, interLanes) {
            if (connector) {
                var swimlane, lIndex, sparent, tparent, tnode, snode, i;
                snode = connector.sourceNode ? diagram.nameTable[connector.sourceNode] : null;
                tnode = connector.targetNode ? diagram.nameTable[connector.targetNode] : null;
                if (snode && snode.parent) {
                    sparent = diagram.nameTable[snode.parent];
                }
                if (tnode && tnode.parent) {
                    tparent = diagram.nameTable[tnode.parent];
                }
                if (sparent && tparent && tparent.name === sparent.name)
                    return false;
                for (i = 0; i < interLanes.length; i++) {
                    if (sparent && sparent.name === interLanes[i])
                        return true;
                    if (tparent && tparent.name === interLanes[i])
                        return true;
                }

            }
            return false;
        },

        _recreateConnectorSegments: function (diagram, node, list, name1, name2) {
            if (diagram && node) {
                var connectors = [], swimConnectors = [], swimlane, connector, m, i, j, k, lane, child, lanes, interLanes;
                node = diagram.nameTable[diagram._getChild(node)];
                if (node && node.isLane || node.isSwimlane) {
                    if (node.isLane) {
                        if (Array.isArray(list)) {
                            interLanes = this._getIntermediateLanes(diagram, list, name1, name2);
                            for (i = 0 ; i < interLanes.length ; i++) {
                                lane = diagram.nameTable[diagram._getChild(interLanes[i])];
                                this._laneConnectors(diagram, lane, connectors)
                            }

                            swimlane = this._getSwimlane(diagram, node.name);
                            lanes = swimlane.lanes;
                            for (i = 0 ; i < lanes.length ; i++) {
                                lane = diagram.nameTable[diagram._getChild(lanes[i])];
                                this._laneConnectors(diagram, lane, swimConnectors)
                            }

                            for (i = 0 ; i < connectors.length ; i++) {
                                connector = diagram.nameTable[diagram._getChild(connectors[i])];
                                if (connector) {
                                    if (this._connectorRelateTolaneCollection(diagram, connector, [name1, name2])) {
                                        connector.segments = [];
                                        ej.datavisualization.Diagram.Util._initializeSegments(connector, "orthogonal");
                                    }
                                }
                            }
                            for (i = 0 ; i < swimConnectors.length ; i++) {
                                connector = diagram.nameTable[diagram._getChild(swimConnectors[i])];
                                if (connector) {
                                    this._updateConnectorEndPoints(diagram, connector);
                                }
                            }
                        }
                    }
                }
            }
        },

        _isLineInterSectingNode: function (diagram, connector, node) {
            var isInterSecting = false;
            if (connector && node) {
                var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
                var nodePoints = [
                        { x: nodeBounds.topLeft.x, y: nodeBounds.topLeft.y },
                        { x: nodeBounds.topRight.x, y: nodeBounds.topRight.y },
                        { x: nodeBounds.bottomRight.x, y: nodeBounds.bottomRight.y },
                        { x: nodeBounds.bottomLeft.x, y: nodeBounds.bottomLeft.y },
                        { x: nodeBounds.topLeft.x, y: nodeBounds.topLeft.y }
                ];
            }
            var segments = connector.segments;
            if (segments && segments.length > 0) {
                for (var i = 0; !isInterSecting && i < segments.length; i++) {
                    var segment = segments[i];
                    if (segment && segment.points.length > 0) {
                        var points = segment.points, point1, point2, point3, point4;
                        for (var j = 0; !isInterSecting && j < points.length - 1; j++) {
                            point1 = points[j];
                            point2 = points[j + 1];
                            for (var m = 0; !isInterSecting && m < nodePoints.length - 1; m++) {
                                point3 = nodePoints[m];
                                point4 = nodePoints[m + 1];
                                if (this._isInterSecting(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y, point4.x, point4.y, true)) {
                                    isInterSecting = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            return isInterSecting;
        },

        _updateConnectorEndPoints: function (diagram, connector) {

            if (diagram && connector) {
                var reset = false;
                connector.sourcePoint = ej.datavisualization.Diagram.Point();
                connector.targetPoint = ej.datavisualization.Diagram.Point();
                ej.datavisualization.Diagram.Util._initConnectionEnds(connector, diagram);
                ej.datavisualization.Diagram.Util._initializeSegments(connector, "orthogonal");
                diagram._dock(connector, diagram.nameTable);
                if (connector.sourceNode)
                    var sourceNode = diagram.nameTable[connector.sourceNode];
                if (sourceNode && this._isLineInterSectingNode(diagram, connector, sourceNode))
                    reset = true;
                if (connector.targetNode)
                    var targetNode = diagram.nameTable[connector.targetNode];
                if (targetNode && this._isLineInterSectingNode(diagram, connector, targetNode)) {
                    if (this._anySegmentOrtho(connector)) {
                        reset = false;
                    }
                    else reset = true;
                }
                if (reset) {
                    connector.segments = [];
                    ej.datavisualization.Diagram.Util._initializeSegments(connector, "orthogonal");
                    diagram._dock(connector, diagram.nameTable);
                }
                ej.datavisualization.Diagram.Util._initializeSegments(connector, "orthogonal");
                diagram._dock(connector, diagram.nameTable);
            }
        },

        _anySegmentOrtho: function (connector) {
            var state = false;
            if (connector) {
                if (connector.segments && connector.segments.length > 0) {
                    for (var segment, i = 0; i < connector.segments.length; i++) {
                        segment = connector.segments[i];
                        if (segment && segment.type !== "orthogonal") {
                            state = true;
                            break;
                        }
                    }
                }
            }
            return state
        },

        _getIntermediateLanes: function (diagram, list, name1, name2) {
            var rlist = [], i;
            if (list) {
                var index1 = list.indexOf(name1);
                var index2 = list.indexOf(name2);
                var start = Math.min(index1, index2);
                var end = Math.max(index1, index2);
                for (i = start; i <= end; i++) {
                    rlist.push(list[i])
                }
            }
            return rlist;
        },
        _swapLane: function (diagram, list, name1, name2, isVertical, parent) {
            var btNode = diagram.nameTable[name2];
            var tList = list.slice();
            var tool = diagram.tools["move"];
            var prevSwimlane = this._getSwimlane(diagram, name1);
            tool._undoObject = $.extend(true, {}, { name1: name1, name2: name2 });
            if (btNode) {
                var bounds = ej.datavisualization.Diagram.Util.bounds(btNode);
                //btNode.height += 10;
                var currentIndex = list.indexOf(name1);
                var moveIndex = list.indexOf(name2);
                list.splice(list.indexOf(name1), 1);
                moveIndex += currentIndex > moveIndex ? 0 : -1;
                moveIndex += isVertical ? tool.currentPoint.y >= bounds.y && tool.currentPoint.y < bounds.center.y ? 0 : 1 :
                     tool.currentPoint.x >= bounds.x && tool.currentPoint.x < bounds.center.x ? 0 : 1;
                list.splice(moveIndex, 0, name1);
            }
            tool._redoObject = $.extend(true, {}, { name1: name2, name2: name1 });
            var entry = {
                type: "swapLane", undoObject: jQuery.extend(true, {}, tool._undoObject), redoObject: jQuery.extend(true, {}, tool._redoObject), currentIndex: currentIndex, moveIndex: moveIndex, category: "internal"
            };
            var currLaneSwimlane = this._getSwimlane(diagram, name1);
            if (prevSwimlane)
                diagram._comparePropertyValues(currLaneSwimlane, "lanes", { lanes: prevSwimlane.lanes }, true);
            diagram.addHistoryEntry(entry);
            tool._multipleUndo = true;
            if (parent)
                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, false);
            if (diagram.activeTool.selectedObject) {
                ej.datavisualization.Diagram.canvasHelper._recreateConnectorSegments(diagram, diagram.activeTool.selectedObject.name, tList, name1, name2);
                ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdateLane(diagram, diagram.activeTool.selectedObject)
            }
        },
        //#endregion

        //#region dragging singleNode
        _updateHelper: function (diagram) {
            if (!diagram.activeTool.helper) {
                this._initHelper(diagram);
            } else {
                this._updateHelperXY(diagram, diagram.activeTool.helper, diagram.activeTool.previousPoint, diagram.activeTool.currentPoint);
                ej.datavisualization.Diagram.SvgContext._updateContainerHelper(diagram);
            }
        },
        _updateHelperXY: function (diagram, shape, startPoint, endPoint) {
            var towardsLeft = endPoint.x < startPoint.x;
            var towardsTop = endPoint.y < startPoint.y;
            var difx = diagram.activeTool.diffx + (endPoint.x - startPoint.x);
            var dify = diagram.activeTool.diffy + (endPoint.y - startPoint.y);
            var offset;
            var enableSnapToObject = diagram.activeTool.diagram._enableSnapToObject();
            diagram.activeTool.diagram._enableSnapToObject(true);
            offset = ej.datavisualization.Diagram.SnapUtil._snapPoint(diagram, diagram.activeTool.helper, towardsLeft, towardsTop, ej.datavisualization.Diagram.Point(difx, dify),
        endPoint, startPoint);
            diagram.activeTool.diagram._enableSnapToObject(enableSnapToObject);
            if (!offset)
                offset = ej.datavisualization.Diagram.Point(difx, dify);
            diagram.activeTool.diffx = difx - offset.x;
            diagram.activeTool.diffy = dify - offset.y;
            if (!ej.datavisualization.Diagram.Geometry.isEmptyPoint(offset)) {
                var args = diagram.activeTool._raiseDragEvent({ element: diagram.getNode(diagram.activeTool.helper), offset: offset, cancel: false });
                if (args && !args.cancel) {
                    if (diagram.activeTool._outOfBoundsDrag(shape, offset.x, offset.y))
                        diagram._translate(shape, offset.x, offset.y, diagram.nameTable);
                    if (shape._type === "group") {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(shape, diagram);
                    }
                }
            }
        },
        _initHelper: function (diagram) {
            diagram.activeTool.helper = this._getCloneNode(diagram.activeTool.selectedObject);
            diagram.activeTool.helper._name = diagram.activeTool.selectedObject.name;
            diagram.activeTool.helper.name = "helper";
            diagram.activeTool.startPoint = diagram.activeTool.currentPoint;
            ej.datavisualization.Diagram.SvgContext._drawContainerHelper(diagram);
        },
        _getCloneNode: function (node) {
            var obj = null;
            obj = jQuery.extend(true, {}, node);
            obj.children = [];
            obj.minHeight = 0;
            obj.minWidth = 0;
            obj.maxHeight = 0;
            obj.maxWidth = 0;
            return obj;
        },
        _updateHighlighter: function (diagram, evt) {
            var overNode = diagram.activeTool._getMouseOverElement(evt);
            if (overNode && !overNode.segments && (!diagram.activeTool.selectedObject.isLane || overNode.isLane)) {
                diagram.activeTool._nodeHighLighter(overNode, evt);
            } else {
                diagram.activeTool._removeHighLighter();
            }
        },
        _updateNodeMargin: function (diagram, node, overNode) {
            if (node._type == "group") {
                for (var i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    this._updateNodeMargin(diagram, typeof child == "string" ? diagram.nameTable[child] : child, node);
                }
            }
            if (node && overNode) {
                var prevNode = $.extend(true, {}, node);
                var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
                var groupBounds = ej.datavisualization.Diagram.Util.bounds(overNode);
                var isStack = (overNode.container && overNode.container.type && overNode.container.type == "stack") ? true : false
                if (isStack) {
                    if (overNode.container.orientation === "horizontal")
                        node.marginTop = nodeBounds.top - groupBounds.top - overNode.paddingTop;
                    else node.marginLeft = nodeBounds.left - groupBounds.left - overNode.paddingLeft;
                }
                else {
                    node.marginLeft = nodeBounds.left - groupBounds.left - overNode.paddingLeft;
                    node.marginTop = nodeBounds.top - groupBounds.top - overNode.paddingTop;
                }
                var nodeWidth = nodeBounds.right - nodeBounds.left, nodeHeight = nodeBounds.bottom - nodeBounds.top;
                var canUpdate = true;
                if (isStack && overNode.container.orientation === "vertical") {
                    canUpdate = false;
                }
                if (canUpdate) {
                    var right = (groupBounds.x + groupBounds.width) - (nodeBounds.x + nodeWidth) - overNode.paddingRight;
                    (right < 0) ? node.marginRight = 0 : node.marginRight = right;
                }
                canUpdate = true;
                if (isStack && overNode.container.orientation === "vertical") {
                    canUpdate = false;
                }
                if (canUpdate) {
                    var bottom = (groupBounds.y + groupBounds.height) - (nodeBounds.y + nodeHeight) - overNode.paddingBottom;
                    (bottom < 0) ? node.marginBottom = 0 : node.marginBottom = bottom;
                }
                if (overNode.isLane) {
                    var left = 0, top = 0;
                    if (overNode.orientation === "horizontal") {
                        left = 50, top = 0;
                        if (overNode.children.length > 1) {
                            var firstChild = diagram.nameTable[diagram._getChild(overNode.children[0])]
                            if (firstChild && firstChild._isHeader) {
                                left = firstChild.width;
                            }
                        }
                    }
                    else {
                        left = 0, top = 50;
                        if (overNode.children.length > 1) {
                            var firstChild = diagram.nameTable[diagram._getChild(overNode.children[0])]
                            if (firstChild && firstChild._isHeader) {
                                top = firstChild.height;
                            }
                        }
                    }
                    node.marginLeft = node.marginLeft >= left ? node.marginLeft : left;
                    node.marginTop = node.marginTop >= top ? node.marginTop : top;
                    diagram._comparePropertyValues(node, "marginLeft", { marginLeft: prevNode.marginLeft }, true);
                    diagram._comparePropertyValues(node, "marginRight", { marginLeft: prevNode.marginRight }, true);
                    diagram._comparePropertyValues(node, "marginBottom", { marginLeft: prevNode.marginBottom }, true);
                    diagram._comparePropertyValues(node, "marginRight", { marginLeft: prevNode.marginRight }, true);
                }
            }
        },
        _singleNodedrag: function (diagram, evt, overNode) {
            var checkDrop = !diagram.activeTool._checkForDropEvent(overNode);
            if (checkDrop) {
                if (overNode) {
                    if (ej.datavisualization.Diagram.Util.canAllowDrop(overNode) || (overNode.name == diagram.activeTool.selectedObject.parent)) {
                        if (overNode.container && overNode.container.type == "canvas") {
                            var newParent, oldParent;
                            var addToContainer = !overNode._isBpmn || (overNode._isBpmn && diagram.activeTool.selectedObject.parent != overNode.name) ? true : false;
                            if (ej.datavisualization.Diagram.canvasHelper._outOfBoundaryNodeDrop(diagram, diagram.activeTool.helper, overNode) && addToContainer) {
                                if (overNode.isLane || overNode.container.type == "canvas")
                                    this._disableConnectorUpdate(diagram);
                                diagram.activeTool.seletedObject = diagram.nameTable[diagram.activeTool.selectedObject.name];
                                if (diagram.activeTool.selectedObject.parent)
                                    oldParent = diagram.nameTable[diagram.activeTool.selectedObject.parent];
                                diagram._disablePhaseUpdate = true;
                                diagram._disableSwimlaneUptate = true;
                                this._removeNodeFromContainer(diagram, diagram.activeTool.selectedObject);
                                this._addNodeToContainer(diagram, diagram.activeTool.selectedObject, overNode, null, true);
                                var cause1 = diagram._isUndo ? ej.datavisualization.Diagram.GroupChangeCause.HistoryChange : ej.datavisualization.Diagram.GroupChangeCause.Drop;
                                diagram._raiseGroupChangeEvent(diagram.activeTool.selectedObject, oldParent, overNode, cause1);
                                diagram._comparePropertyValues(diagram.activeTool.selectedObject, "parent", { parent: oldParent.name }, true);
                                delete diagram._disablePhaseUpdate;
                                delete diagram._disableSwimlaneUptate;
                                this._updateLastSwimlanePhase(diagram, diagram.activeTool.selectedObject);
                                if (overNode.isLane || overNode.container.type == "canvas")
                                    this._enableConnectorUpdateNode(diagram, diagram.activeTool.selectedObject);
                            }
                            else if (overNode._isBpmn) {
                                var canvasContainer = diagram.nameTable[diagram.activeTool.selectedObject.parent];
                                var prevWidth = canvasContainer.width, prevHeight = canvasContainer.height, offset = { x: canvasContainer.offsetX, y: canvasContainer.offsetY };
                                diagram._translate(diagram.activeTool.selectedObject, (diagram.activeTool.helper.offsetX - diagram.activeTool.selectedObject.offsetX), (diagram.activeTool.helper.offsetY - diagram.activeTool.selectedObject.offsetY), diagram.nameTable);
                                diagram._updateAssociatedConnectorEnds(diagram.activeTool.selectedObject, diagram.nameTable);
                                var parent = ej.datavisualization.Diagram.ContainerHelper.updateparent(overNode, diagram);
                                if (!parent)
                                    ej.datavisualization.Diagram.bpmnHelper.updateCanvas(canvasContainer, diagram);
                                else {
                                    this._removeNodeFromContainer(diagram, diagram.activeTool.selectedObject);
                                    this._addNodeToContainer(diagram, diagram.activeTool.selectedObject, overNode, null, true);
                                }

                            }
                            else {
                                diagram._translate(diagram.activeTool.selectedObject, (diagram.activeTool.undoObject.node.offsetX - diagram.activeTool.selectedObject.offsetX), (diagram.activeTool.undoObject.node.offsetY - diagram.activeTool.selectedObject.offsetY), diagram.nameTable);
                                diagram._updateAssociatedConnectorEnds(diagram.activeTool.selectedObject, diagram.nameTable);
                                this._updateLastSwimlanePhase(diagram, overNode);
                            }
                        }
                    }
                }
                else {
                    var selectedNode = $.extend(true, {}, diagram.activeTool.selectedObject);
                    if (diagram.activeTool.selectedObject.type != "pseudoGroup")
                        this._disableConnectorUpdate(diagram);
                    if (diagram.activeTool.selectedObject.parent)
                        oldParent = diagram.nameTable[diagram.activeTool.selectedObject.parent];
                    this._removeNodeFromContainer(diagram, diagram.activeTool.selectedObject);
                    diagram._raiseGroupChangeEvent(diagram.activeTool.selectedObject, oldParent, null, "group");
                    this._addMultiNodeToDiagram(diagram, diagram.activeTool.selectedObject);
                    this._enableConnectorUpdateNode(diagram, selectedNode);
                    diagram._updateAssociatedConnectorEnds(selectedNode, diagram.nameTable);
                }
            }
            return true;
        },

        _updateLastSwimlanePhase: function (diagram, node) {
            var lane = ej.datavisualization.Diagram.ContainerHelper.updateparent(node, diagram);
            if (lane && lane.isLane) {
                var laneStack = diagram.nameTable[lane.parent];
                if (laneStack) {
                    var swimlane = diagram.nameTable[laneStack.parent];
                    if (swimlane) {
                        this._updateLastPhase(diagram, swimlane);
                    }
                }
            }

        },
        _updateLastPhase: function (diagram, swimlane) {
            if (swimlane && swimlane.isSwimlane) {
                var laneStack = diagram.nameTable[diagram._getChild(swimlane.children[2])];
                var phaseStack = diagram.nameTable[diagram._getChild(swimlane.children[1])];
                var lBounds = ej.datavisualization.Diagram.stackHelper._getStackBoundsBounds(diagram, laneStack);
                var pBounds = ej.datavisualization.Diagram.stackHelper._getStackBoundsBounds(diagram, phaseStack);
                var phases = ej.datavisualization.Diagram.SwimLaneContainerHelper.getPhases(diagram, swimlane);
                var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(diagram, swimlane), lane;
                lane = diagram.nameTable[diagram._getChild(lanes[0])];
                if (phases.length > 0) {
                    var lastPhase = diagram.nameTable[phases[phases.length - 1]];
                    if (lastPhase) {
                        if (swimlane.orientation === "horizontal") {
                            var d = lBounds.width - pBounds.width;
                            lastPhase.width += d;
                            lastPhase.offset += d;
                            if (lane && lane.isLane)
                                lane.minWidth += d;
                        }
                        else {
                            d = lBounds.height - pBounds.height;
                            lastPhase.height += d;
                            lastPhase.offset += d;
                            if (lane && lane.isLane)
                                lane.minHeight += d;
                        }
                    }
                    ej.datavisualization.Diagram.SwimLaneContainerHelper._updatePhaseStack(diagram, swimlane);
                }
            }
        },

        //#endregion

        //#region connector update
        _disableConnectorUpdate: function (diagram) {
            diagram._disableSegmentChange = true;
        },

        _enableConnectorUpdate: function (diagram, swimlane, fromNudge) {
            delete diagram._disableSegmentChange;
            if (swimlane) {
                diagram._updateChildAdjacentConnectors(swimlane, true)
                if (!fromNudge) {
                    diagram._disableSegmentChange = true;
                    this._updateSwimalneAssociatedConnectors(diagram, swimlane, diagram._svg);
                    delete diagram._disableSegmentChange;
                }
                this._updateChildAdjacentConnectors(diagram, swimlane);
            }
        },
        _updateChildAdjacentConnectors: function (diagram, swimlane) {
            var childTable = diagram._getChildTable(swimlane, {});
            for (var child in childTable) {
                var childNode = diagram.nameTable[diagram._getChild(child)];
                if (childNode && childNode.segments && swimlane.children.indexOf(child) == -1) {
                    ej.datavisualization.Diagram.DiagramContext.update(childNode, diagram);
                }
            }
        },
        _updateSwimalneAssociatedConnectors: function (diagram, group, svg, layout) {
            var children = diagram._getChildren(group.children);
            if (children && children.length > 0) {
                for (var i = 0, len = children.length; i < len; i++) {
                    var child = diagram.nameTable[children[i]];
                    if (child) {
                        if (child._type === "group")
                            this._updateSwimalneAssociatedConnectors(diagram, child, svg, layout);
                        else
                            this._updateSwimalneAssociatedConnectors(diagram, child, svg, layout);
                    }
                }
            }
            if (group.type != "group") {
                ej.datavisualization.Diagram.SvgContext._updateAssociatedConnector(group, svg, diagram);
            }
        },

        _enableConnectorUpdateNode: function (diagram, node) {
            var parent = null;
            if (node && node.parent) {
                parent = diagram.nameTable[node.parent];
            }
            if (parent) {
                if (parent.isLane) {
                    var swimlane = diagram.nameTable[parent.parent.split("laneStack")[0]];
                    if (swimlane && swimlane.isSwimlane) {
                        this._enableConnectorUpdate(diagram, swimlane);
                    }
                }
                else if (parent.type == "bpmn") {
                    this._enableConnectorUpdate(diagram, parent);
                }
                else if (parent.container && parent.container.type === "canvas") {
                    this._enableConnectorUpdate(diagram, parent);
                }
            }
        },
        _enableConnectorUpdatePhase: function (diagram, phase) {
            if (phase && (phase.isPhase || phase.type === "phase")) {
                var swimlane = diagram.nameTable[phase.parent.split("phaseStack")[0]];
                if (swimlane && swimlane.isSwimlane) {
                    this._enableConnectorUpdate(diagram, swimlane);
                }
            }
        },
        _enableConnectorUpdateLane: function (diagram, lane) {
            if (lane && lane.isLane) {
                var swimlane = diagram.nameTable[lane.parent.split("laneStack")[0]];
                if (swimlane && swimlane.isSwimlane) {
                    this._enableConnectorUpdate(diagram, swimlane);
                }
            }
        },
        //#endregion

        //#region dragging multiNode

        _outOfBoundaryMultiNodeDrop: function (diagram, pseudoGroup) {
            var state = true;
            if (ej.datavisualization.Diagram.Util.canMoveOutofBoundary(diagram)) {
                if (pseudoGroup && pseudoGroup.type === "pseudoGroup") {
                    var child, targets, container;
                    var children = pseudoGroup.children;
                    for (var i = 0; i < children.length; i++) {
                        child = diagram.nameTable[diagram._getChild(children[i])];
                        targets = this._getTargets(diagram, child);
                        if (targets && targets.length > 0 && !child.segments) {
                            container = this._getContainerFromTarget(diagram, targets, child);
                            if (container) {
                                if (!this._isExeedBounds(diagram, child, container))
                                    return false
                            }
                        }
                    }
                }
            }
            return state;
        },

        _multiNodedrag: function (diagram, evt, pseudoGroup) {
            if (this._outOfBoundaryMultiNodeDrop(diagram, pseudoGroup)) {
                if (pseudoGroup) {
                    diagram._disableSwimlaneUptate = true;
                    this._disableConnectorUpdate(diagram);
                    if (pseudoGroup.children.length > 0) {
                        var child, targets, container;
                        var children = pseudoGroup.children;
                        for (var i = 0; i < children.length; i++) {
                            child = diagram.nameTable[diagram._getChild(children[i])];
                            if (child && !(child.type === "connector" || child.segments)) {
                                targets = this._getTargets(diagram, child);
                                if (targets && targets.length > 0) {
                                    container = this._getContainerFromTarget(diagram, targets, child);
                                    if (container) {
                                        this._addNodeToContainer(diagram, child, container);
                                    }
                                    else
                                        this._addMultiNodeToDiagram(diagram, child);
                                }
                                else
                                    this._addMultiNodeToDiagram(diagram, child);
                            }
                            if (child.parent) {
                                var lane = diagram.nameTable[child.parent];
                                if (lane && lane.isLane) {
                                    var swimlane = diagram.nameTable[lane.parent.split("laneStack")[0]];
                                    if (swimlane) {
                                        if (!diagram._updateSwimlanes) {
                                            diagram._updateSwimlanes = [];
                                        }
                                        if (!diagram._collectionContains(swimlane.name, diagram._updateSwimlanes))
                                            diagram._updateSwimlanes.push(swimlane.name)
                                    }
                                }
                            }
                        }
                    }
                    delete diagram._disableSwimlaneUptate;
                    if (diagram._updateSwimlanes && diagram._updateSwimlanes.length > 0) {
                        for (var m = 0; m < diagram._updateSwimlanes.length; m++) {
                            ej.datavisualization.Diagram.DiagramContext.update(diagram.nameTable[diagram._updateSwimlanes[m]], diagram);
                            ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(diagram, diagram.nameTable[diagram._updateSwimlanes[m]]);
                        }
                    }
                    else delete diagram._disableSegmentChange;
                    delete diagram._updateSwimlanes;
                    this._getRedoObject(diagram, pseudoGroup);
                    var entry = { type: "positionchanged", node: jQuery.extend(true, {}, pseudoGroup), undoObject: jQuery.extend(true, {}, diagram.activeTool._undoObject), redoObject: jQuery.extend(true, {}, diagram.activeTool._redoObject), category: "internal", swimlaneMultiSelection: true };
                    diagram.addHistoryEntry(entry);
                    diagram.activeTool._multipleUndo = true;
                    ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                    diagram.updateSelection();
                }
            }
            else {
                this._updateBoundsExceedNodes(diagram, pseudoGroup, "move");
            }
        },

        _updateBoundsExceedNodes: function (diagram, pseudoGroup, tool) {
            var undoObj = diagram.tools[tool].undoObject;
            var children = pseudoGroup.children;
            pseudoGroup.rotateAngle = undoObj.node.rotateAngle;
            for (var i = 0; i < children.length; i++) {
                var child = undoObj.childTable[children[i]];
                var orgChild = diagram.nameTable[diagram._getChild(children[i])];
                if (child && orgChild) {
                    if (tool === "move") {
                        diagram._translate(orgChild, (child.offsetX - orgChild.offsetX), (child.offsetY - orgChild.offsetY), diagram.nameTable);
                    }
                    else if (tool === "resize") {
                        diagram._translate(orgChild, child.offsetX - orgChild.offsetX, child.offsetY - orgChild.offsetY, diagram.nameTable);
                        diagram.scale(orgChild, (child.width / orgChild.width), (child.height / orgChild.height), ej.datavisualization.Diagram.Point(orgChild.offsetX, orgChild.offsetY), diagram.nameTable);
                    }
                    else if (tool === "rotate") {
                        diagram._translate(orgChild, (child.offsetX - orgChild.offsetX), (child.offsetY - orgChild.offsetY), diagram.nameTable);
                        var newangle = child.rotateAngle - orgChild.rotateAngle;
                        orgChild.rotateAngle += newangle;
                    }
                    if (orgChild._type === "group") {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(orgChild, diagram);
                    }
                    diagram._updateAssociatedConnectorEnds(child, diagram.nameTable);
                    if (child.parent) {
                        var parent = diagram.nameTable[child.parent];
                        if (parent && parent.children.length > 0) {
                            parent.children.push(child.name);
                            orgChild.parent = child.parent;
                        }
                    }
                    ej.datavisualization.Diagram.DiagramContext.update(child, diagram);
                }
            }
            ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
            diagram.updateSelection();
        },
        _getContainerFromTarget: function (diagram, collection, child) {
            var childBounds, tarBounds;
            for (var i = 0; i < collection.length; i++) {
                if (collection[i].container && collection[i].container.type === "canvas") {
                    childBounds = ej.datavisualization.Diagram.Util.bounds(child);
                    tarBounds = ej.datavisualization.Diagram.Util.bounds(collection[i]);
                    if (childBounds.center.x > tarBounds.left && childBounds.center.x < tarBounds.right &&
                        childBounds.center.y > tarBounds.top && childBounds.center.y < tarBounds.bottom
                        ) {
                        return collection[i];
                    }
                }
            }
        },
        _getTargets: function (diagram, child) {
            var bounds = null, childBounds, nodes = [], lane;
            if (child) {
                childBounds = ej.datavisualization.Diagram.Util.bounds(child);
                var quads = ej.datavisualization.Diagram.SpatialUtil.findQuads(diagram._spatialSearch, childBounds);
                for (var i = 0; i < quads.length; i++) {
                    var quad = quads[i];
                    if (quad.objects.length > 0) {
                        for (var j = 0; j < quad.objects.length; j++) {
                            var nd = quad.objects[j];
                            if (!nd.segments && nd.visible) {
                                bounds = ej.datavisualization.Diagram.Util.bounds(nd);
                                if (nodes.indexOf(nd) == -1 && ej.datavisualization.Diagram.Geometry.intersectsRect(childBounds, bounds)) {
                                    if (nd.isSwimlane) {
                                        var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(diagram, nd);
                                        for (var k in lanes) {
                                            lane = diagram.nameTable[diagram._getChild(lanes[k])];
                                            if (lane)
                                                nodes.splice(0, 0, lane);
                                        }
                                    }
                                    else
                                        nodes.push(nd);
                                }
                            }
                        }
                    }
                }
            }
            return nodes;
        },
        _removeFromParentContainer: function (diagram, pseudoGroup) {
            this._removeNodeFromContainer(diagram, pseudoGroup);
        },
        _removeNodeFromContainer: function (diagram, node, updateParent) {
            diagram._removedFromContiner = true;
            if (node.type !== "pseudoGroup") {
                var parent = diagram.nameTable[node.parent], child;
                if (parent) {
                    var children = parent.children;
                    var prevChildren = children;
                    prevChildren = prevChildren.slice(0);
                    for (var i = 0; i < children.length; i++) {
                        child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child.name === node.name)
                            ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, children[i]);
                    }
                    ej.datavisualization.Diagram.SpatialUtil._removeFromaQuad(diagram._spatialSearch, diagram._spatialSearch.quadTable[child.name], child);
                    var resource = { element: parent, cause: diagram.activeTool.inAction ? ej.datavisualization.Diagram.ActionType.Mouse : ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "children", oldValue: prevChildren, newValue: children };
                    diagram._raisePropertyChange(resource);
                    diagram._comparePropertyValues(node, "parent", { parent: "" }, resource.cause);
                    node.parent = "";
                    if (child._type === "group") {
                        ej.datavisualization.Diagram.SvgContext.renderGroup(child, diagram._svg, diagram._diagramLayer, diagram.nameTable, diagram);
                    } else if (child.segments) {
                        ej.datavisualization.Diagram.SvgContext.renderConnector(child, diagram._svg, diagram._diagramLayer);
                    } else {
                        ej.datavisualization.Diagram.SvgContext.renderNode(child, diagram._svg, diagram._diagramLayer, undefined, diagram);
                    }
                    if (!updateParent)
                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
            }
            else {
                var children = node.children;
                if (children.length > 0) {
                    this._getUndoObject(diagram, node);
                    for (var i = 0; i < children.length; i++) {
                        var child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child) {
                            this._removeNodeFromContainer(diagram, child, true);
                        }
                    }
                    if (child.parent)
                        var parent = diagram.nameTable[child.parent];
                    if (parent)
                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
            }
        },
        _addDrgaHistoryEntry: function (diagram, node) {
            var childTable = {};
            var childTable = diagram._getChildTable(node, childTable);
            diagram.activeTool._multipleUndo = true;
            var entry = { type: "positionchanged", node: jQuery.extend(true, {}, node), childTable: childTable, category: "internal", swimlaneMultiSelection: true };
            diagram.addHistoryEntry(entry);
        },

        _cloneNode: function (diagram, node, name) {
            if (node) {
                node = $.extend(true, {}, node);
                node.name += name;
                node.parent += name;
                if (node.children && node.children.length > 0) {
                    var child;
                    var children = node.children;
                    for (var i = 0; i < children.length; i++) {
                        child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child) {
                            node.children[i] = this._cloneNode(diagram, child, name)
                        }
                    }
                }
                return node;
            }
        },

        _isExeedBounds: function (diagram, node, overNode) {
            diagram._disableUpdateQuad = true;
            if (node && overNode && overNode.isLane) {
                var swimlane = diagram.nameTable[overNode.parent.split("laneStack")[0]];
                if (swimlane) {
                    var randomId = ej.datavisualization.Diagram.Util.randomId();
                    var clSwimlane = diagram._cloneSwimlaneObj(diagram._getNode(swimlane.name), randomId);
                    clSwimlane = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, clSwimlane);
                    var clNode = this._cloneNode(diagram, node, randomId)
                    diagram.nameTable[clNode.name] = clNode;
                    var clLane = diagram.nameTable[overNode.name + randomId];
                    if (clLane) {
                        clLane.children.push(clNode.name);
                        this._updateNodeMargin(diagram, clNode, diagram.nameTable[overNode.name + randomId]);
                        diagram._disableSwimlaneUptate = true;
                        this._disableConnectorUpdate(diagram);
                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, clLane);
                        ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, clSwimlane);
                        delete diagram._disableSegmentChange;
                        delete diagram._disableSwimlaneUptate
                        var clSwimlaneBounds = ej.datavisualization.Diagram.Util.bounds(clSwimlane);
                        ej.datavisualization.Diagram.containerCommon._removeObject(diagram, clLane);
                        ej.datavisualization.Diagram.containerCommon._removeObject(diagram, clSwimlane);
                        delete diagram._disableUpdateQuad;
                        var size = diagram.activeTool._getPageBounds();
                        if (clSwimlaneBounds.bottom > size.height)
                            return false
                        if (clSwimlaneBounds.right > size.width)
                            return false
                        clLane.children.pop(clNode.name);
                    }
                    diagram.nameTable[clNode.name]
                }
            }
            delete diagram._disableUpdateQuad;
            return true;
        },

        _outOfBoundaryNodeDrop: function (diagram, node, overNode) {
            if (ej.datavisualization.Diagram.Util.canMoveOutofBoundary(diagram)) {
                return this._isExeedBounds(diagram, node, overNode);
            }
            return true;
        },
        _getAssociatedConnectors: function (diagram, node, list) {
            var list = list || [], i = 0, connector;
            if (node && !node.segments) {
                if (node.children && node.children.length > 0) {
                    for (i = 0; i < node.children.length; i++) {
                        this._getAssociatedConnectors(diagram, diagram.nameTable[diagram._getChild(node.children[i])], list);
                    }
                }
                for (i = 0; i < node.inEdges.length; i++) {
                    connector = diagram.nameTable[diagram._getChild(node.inEdges[i])];
                    if (connector)
                        list.push($.extend(true, {}, connector));
                }
                for (i = 0; i < node.outEdges.length; i++) {
                    connector = diagram.nameTable[diagram._getChild(node.outEdges[i])];
                    if (connector)
                        list.push($.extend(true, {}, connector));
                }
            }
            return list;
        },
        _addNodeToContainer: function (diagram, node, overNode, updateParent, enableConnectorUpdate) {
            if (diagram.getObjectType(node) !== "connector") {
                if (node && overNode && !node.isPhase) {
                    if (node.parent) {
                        var oGroup = diagram.nameTable[node.parent];
                        if (!oGroup.container) {
                            var oChjildren = oGroup.children;
                            ej.datavisualization.Diagram.Util.removeFromCollection(diagram, oChjildren, node);
                            ej.datavisualization.Diagram.Util._updateGroupBounds(oGroup, diagram);
                        }
                    }
                    if (node.type !== "pseudoGroup") {
                        var nodeBounds = ej.datavisualization.Diagram.Util.bounds(diagram.activeTool.helper);
                        var selObjBounds = ej.datavisualization.Diagram.Util.bounds(diagram.activeTool.selectedObject);
                        var diffX = diagram.activeTool.helper ? nodeBounds.x - selObjBounds.x : 0;
                        var diffY = diagram.activeTool.helper ? nodeBounds.y - selObjBounds.y : 0;
                        diagram._raiseOffsetPropertyChange(node, node.offsetX + diffX, node.offsetY + diffY, true);
                        diagram._translate(node, diffX, diffY, diagram.activeTool.diagram.nameTable);
                        var prevChildren = overNode.children;
                        prevChildren = prevChildren.slice(0);
                        overNode.children.push(node);
                        ej.datavisualization.Diagram.Util.removeItem(diagram.nodes(), node);
                        var resource = { element: overNode, cause: diagram.activeTool.inAction ? ej.datavisualization.Diagram.ActionType.Mouse : ej.datavisualization.Diagram.ActionType.Unknown, propertyName: "children", oldValue: prevChildren, newValue: overNode.children };
                        diagram._raisePropertyChange(resource);
                        diagram._comparePropertyValues(node, "parent", { parent: overNode.name }, resource.cause);
                        node.parent = overNode.name;
                        this._updateNodeMargin(diagram, node, overNode);
                        if (diagram._isDragg) {
                            var historyList = diagram._historyList;
                            if (historyList) {
                                if (historyList.currentEntry && historyList.currentEntry.object && historyList.currentEntry.object.parent === "")
                                    historyList.currentEntry.object = $.extend(true, {}, node);
                            }
                        }
                        var parentElement = diagram._svg.getElementById(overNode.name);
                        if (node._type === "group") {
                            ej.datavisualization.Diagram.DiagramContext.renderGroup(node, diagram, parentElement);
                        } else if (node.segments) {
                            //ej.datavisualization.Diagram.DiagramContext.renderConnector(node, diagram, parentElement);
                        } else {
                            ej.datavisualization.Diagram.DiagramContext.renderNode(node, diagram, parentElement);
                        }
                        this._disableConnectorUpdate(diagram);
                        if (!updateParent) {
                            var undoObject;
                            if (overNode.type == "bpmn") undoObject = $.extend(true, {}, { node: overNode });
                            var prevObj = jQuery.extend(true, {}, overNode)
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, overNode, true);
                            this._updateAddRemoveNodeConnectors(diagram, overNode, prevObj);
                            if (overNode.type == "bpmn") {
                                diagram._isGroupActionEnabled = true;
                                diagram._startGroupAction();
                                var entry = { type: "sizechanged", node: jQuery.extend(true, {}, overNode), undoObject: undoObject, redoObject: $.extend(true, {}, { node: overNode }), category: "internal" };
                                diagram.addHistoryEntry(entry);
                            }
                        }
                        var connectors = this._getAssociatedConnectors(diagram, node);
                        if (connectors.length > 0) {
                            for (i = 0; i < connectors.length; i++) {
                                var removeConnector = connectors[i];
                                var element = diagram._svg.getElementById(removeConnector.name);
                                diagram._removeElement(removeConnector);
                                diagram._zOrder++;
                                if (diagram.nameTable[removeConnector.name])
                                    diagram.nameTable[removeConnector.name].zOrder = diagram._zOrder;
                                ej.datavisualization.Diagram.DiagramContext.renderConnector(removeConnector, diagram);
                            }
                        }
                        this._updateLastSwimlanePhase(diagram, node);
                        if (!enableConnectorUpdate)
                            this._enableConnectorUpdateNode(diagram, node);
                        if (diagram._findLabelEditing)
                            overNode.children.splice(overNode.children.indexOf(node.name), 1);
                    }
                    else {
                        var children = node.children;
                        if (children.length > 0) {
                            for (var i = 0; i < children.length; i++) {
                                var child = diagram.nameTable[diagram._getChild(children[i])];
                                if (child) {
                                    this._addNodeToContainer(diagram, child, overNode, true)
                                }
                            }
                            if (child && child.parent)
                                var parent = diagram.nameTable[child.parent];
                            if (parent) {
                                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                                ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                                ej.datavisualization.Diagram.SvgContext.updateSelector(node, diagram._adornerSvg, diagram._currZoom, diagram, diagram.model.selectedItems.constraints);
                            }
                        }
                    }
                }
            }
        },
        _addMultiNodeToDiagram: function (diagram, child) {
            if (diagram.activeTool.helper) {
                var nodeBounds = ej.datavisualization.Diagram.Util.bounds(diagram.activeTool.helper);
                var selObjBounds = ej.datavisualization.Diagram.Util.bounds(child);
                var diffX = diagram.activeTool.helper ? nodeBounds.x - selObjBounds.x : 0;
                var diffY = diagram.activeTool.helper ? nodeBounds.y - selObjBounds.y : 0;
                diagram._translate(child, diffX, diffY, diagram.nameTable);
            }
            var nodes = diagram.nodes();
            for (var i = nodes.length - 1; i >= 0; i--) {
                var node = diagram.nameTable[diagram._getChild(nodes[i])];
                if (child.name === node.name)
                    ej.datavisualization.Diagram.Util.removeItem(nodes, nodes[i]);
            }
            diagram.nodes().push(child);
            if (diagram._removedFromContiner) {
                if (child._type === "group") {
                    ej.datavisualization.Diagram.SvgContext.renderGroup(child, diagram._svg, diagram._diagramLayer, diagram.nameTable, diagram);
                } else if (child.segments) {
                    ej.datavisualization.Diagram.SvgContext.renderConnector(child, diagram._svg, diagram._diagramLayer);
                } else {
                    ej.datavisualization.Diagram.SvgContext.renderNode(child, diagram._svg, diagram._diagramLayer, undefined, diagram);
                }
            }
            delete diagram._removedFromContiner;
            if (diagram.activeTool.helper) {
                this._updateLastSwimlanePhase(diagram, diagram.activeTool.helper);
            }
        },
        //#endregion

        //#region resizing singleNode
        _singleNodeResize: function (diagram, evt, node) {
            if (diagram.activeTool.selectedObject) {
                this._resizeNode(diagram, node);
            }
        },
        _resizeNode: function (diagram, node) {
            if (node) {
                var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
                var helperBounds = ej.datavisualization.Diagram.Util.bounds(diagram.activeTool.helper);
                var updateChild = true;
                if ((!node.isLane)) {
                    if (node.parent == "") {
                        if (node._parent) {
                            node.parent = node._parent;
                            delete node._parent;
                            updateChild = false;
                        }
                    }
                    if (!node.segments) {
                        if (node.parent)
                            var parent = diagram.nameTable[node.parent];
                        if (parent && parent.isLane) {
                            this._disableConnectorUpdate(diagram);
                        }
                        if (updateChild)
                            diagram.activeTool._updateSize(node, diagram.activeTool.startPoint, diagram.activeTool.currentPoint);
                        if (parent) {
                            this._updateNodeMargin(diagram, node, parent);
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                            this._updateLastSwimlanePhase(diagram, node);
                        }
                        this._enableConnectorUpdateNode(diagram, node);
                    }
                }
            }
        },
        _updateResizeHelper: function (diagram) {
            if (!diagram.activeTool.helper) {
                diagram.activeTool.helper = diagram.activeTool._getCloneNode(diagram.activeTool.selectedObject);
                diagram.activeTool.helper.inEdges = diagram.activeTool.helper.outEdges = [];
                diagram.activeTool.helper.type = null;
                diagram.activeTool.helper.name = "helper";
                ej.datavisualization.Diagram.SvgContext._drawContainerHelper(diagram);
                diagram.activeTool._startPoint = diagram.activeTool.currentPoint;
                diagram._resizeStack = true;
                diagram.activeTool._updateSize(diagram.activeTool.helper, diagram.activeTool.previousPoint, diagram.activeTool.currentPoint, null, null, null, true);
                delete diagram._resizeStack;
            } else {
                var groupBounds123 = ej.datavisualization.Diagram.Util.bounds(diagram.activeTool.helper);
                diagram._resizeStack = true;
                diagram.activeTool._updateSize(diagram.activeTool.helper, diagram.activeTool.previousPoint, diagram.activeTool.currentPoint, null, null, null, true);
                delete diagram._resizeStack;
                var groupBounds1231 = ej.datavisualization.Diagram.Util.bounds(diagram.activeTool.helper);
                if (diagram.activeTool.selectedObject.container && !diagram.activeTool.helper._isBpmn)
                    diagram._translate(diagram.activeTool.helper, groupBounds123.topLeft.x - groupBounds1231.topLeft.x, groupBounds123.topLeft.y - groupBounds1231.topLeft.y, diagram.nameTable);
                ej.datavisualization.Diagram.SvgContext._updateContainerHelper(diagram);
            }
        },
        //#endregion

        //#region resizing multiNode

        _multiNodeResize: function (diagram, evt, pseudoGroup) {
            if (pseudoGroup) {
                if (this._outOfBoundaryMultiNodeDrop(diagram, pseudoGroup)) {
                    if (pseudoGroup.children.length > 0) {
                        var child, targets, container;
                        var children = pseudoGroup.children;
                        for (var i = 0; i < children.length; i++) {
                            child = diagram.nameTable[diagram._getChild(children[i])];
                            targets = this._getTargets(diagram, child);
                            if (targets && targets.length > 0) {
                                container = this._getContainerFromTarget(diagram, targets, child);
                                if (container) {
                                    this._addNodeToContainer(diagram, child, container);
                                }
                                else this._addMultiNodeToDiagram(diagram, child);
                            }
                            else this._addMultiNodeToDiagram(diagram, child);
                        }
                    }
                    this._getRedoObject(diagram, pseudoGroup);
                    var entry = { type: "sizechanged", node: jQuery.extend(true, {}, pseudoGroup), undoObject: jQuery.extend(true, {}, diagram.activeTool._undoObject), redoObject: jQuery.extend(true, {}, diagram.activeTool._redoObject), category: "internal", swimlaneMultiSelection: true };
                    diagram.addHistoryEntry(entry);
                    diagram.activeTool._multipleUndo = true;
                    ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                    diagram.updateSelection();
                }
                else {
                    this._updateBoundsExceedNodes(diagram, pseudoGroup, "resize");
                }
            }
        },
        //#endregion

        //#region rotate singleNode
        _singleNodeRotate: function (diagram, evt, node) {
            if (diagram.activeTool.selectedObject) {
                this._rotateNode(diagram, node);
            }
        },
        _rotateNode: function (diagram, node) {
            if (node) {
                var updateChild = true;
                if ((!node.container)) {
                    if (node.parent == "") {
                        if (node._parent) {
                            node.parent = node._parent;
                            delete node._parent;
                            updateChild = false;
                        }
                    }
                    if (node.parent)
                        var parent = diagram.nameTable[node.parent];
                    if (parent && parent.isLane) {
                        this._disableConnectorUpdate(diagram);
                    }
                    if (!node.segments) {
                        if (updateChild) {
                            var object = diagram.nameTable[diagram.activeTool.selectedObject.name];
                            if (diagram.activeTool.helper) {
                                var difAngle = diagram.activeTool.helper.rotateAngle - diagram.nameTable[diagram.activeTool.selectedObject.name].rotateAngle;
                                diagram._comparePropertyValues(node, "rotateAngle", { rotateAngle: diagram.activeTool.helper.rotateAngle }, true);
                                diagram._rotate(diagram.activeTool.selectedObject, difAngle, diagram.nameTable);
                            }
                        }

                        if (parent) {
                            this._updateNodeMargin(diagram, node, parent);
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                            this._updateLastSwimlanePhase(diagram, node);
                        }
                        this._enableConnectorUpdateNode(diagram, node);
                    }
                }
            }
        },
        //#endregion

        //#region rotate multiNode
        _multiNodeRotate: function (diagram, evt, pseudoGroup) {
            if (pseudoGroup) {
                if (this._outOfBoundaryMultiNodeDrop(diagram, pseudoGroup)) {
                    if (pseudoGroup.children.length > 0) {
                        var child, targets, container;
                        var children = pseudoGroup.children;
                        for (var i = 0; i < children.length; i++) {
                            child = diagram.nameTable[diagram._getChild(children[i])];
                            targets = this._getTargets(diagram, child);
                            if (targets && targets.length > 0) {
                                container = this._getContainerFromTarget(diagram, targets, child);
                                if (container) {
                                    this._addNodeToContainer(diagram, child, container);
                                }
                                else this._addMultiNodeToDiagram(diagram, child);
                            }
                            else this._addMultiNodeToDiagram(diagram, child);
                        }
                    }
                    this._getRedoObject(diagram, pseudoGroup);
                    var entry = { type: "rotationchanged", node: jQuery.extend(true, {}, pseudoGroup), undoObject: jQuery.extend(true, {}, diagram.activeTool._undoObject), redoObject: jQuery.extend(true, {}, diagram.activeTool._redoObject), category: "internal", swimlaneMultiSelection: true };
                    diagram.addHistoryEntry(entry);
                    diagram.activeTool._multipleUndo = true;
                    ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                    diagram.updateSelection();
                }
                else {
                    this._updateBoundsExceedNodes(diagram, pseudoGroup, "rotate");
                }
            }
        },
        //#endregion

        //#region add New Lane
        _updateDropLaneProperties: function (diagram, lane, swimlane) {
            if (lane && swimlane) {
                lane.orientation = swimlane.orientation;
                lane.horizontalAlign = swimlane.orientation === "horizontal" ? "stretch" : "left";
                lane.verticalAlign = swimlane.orientation === "vertical" ? "stretch" : "top";
                lane.paddingBottom = 20;
                lane.paddingTop = 20;
                lane.paddingLeft = 20;
                lane.paddingRight = 20;
                var header = diagram.nameTable[diagram._getChild(lane.children[0])];
                if (header) {
                    header.marginLeft = -20;
                    header.marginTop = -20;
                    header.marginRight = -20;
                    header.marginBottom = -20;
                    header.constraints = ej.datavisualization.Diagram.NodeConstraints.Default ^ ej.datavisualization.Diagram.NodeConstraints.Select ^ ej.datavisualization.Diagram.NodeConstraints.Connect;
                    header._isHeader = true;
                }
            }
            return lane;
        },
        _updateAddRemoveNodeConnectors: function (diagram, orgNode, dupNode) {
            if (orgNode && orgNode.isLane && dupNode && dupNode.isLane) {
                var xdiff = 0, ydiff = 0;
                xdiff = orgNode.width - dupNode.width;
                ydiff = orgNode.height - dupNode.height;
                if (xdiff || ydiff)
                    this._updateOverlappedConnectorSegment(diagram, dupNode, xdiff, ydiff);
            }
        },

        _updateAddRemoveLaneConnectors: function (diagram, lane) {
            if (lane && lane.isLane) {
                var swimConnectors = [], connector, swimlane, lanes, i, lane;
                swimlane = this._getSwimlane(diagram, lane.name);
                lanes = swimlane.lanes;
                for (i = 0 ; i < lanes.length ; i++) {
                    lane = diagram.nameTable[diagram._getChild(lanes[i])];
                    this._laneConnectors(diagram, lane, swimConnectors)
                }
                for (i = 0 ; i < swimConnectors.length ; i++) {
                    connector = diagram.nameTable[diagram._getChild(swimConnectors[i])];
                    if (connector) {
                        this._updateConnectorEndPoints(diagram, connector);
                    }
                }
            }
        },
        _outOfBoundaryAddLane: function (diagram, swimlane, lane, index) {

            if (ej.datavisualization.Diagram.Util.canMoveOutofBoundary(diagram)) {
                var clSwimlane = diagram._cloneSwimlaneObj(diagram._getNode(swimlane.name), ej.datavisualization.Diagram.Util.randomId());
                clSwimlane = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, clSwimlane);
                var clLane = diagram.activeTool._cloneGroupNode($.extend(true, {}, lane), ej.datavisualization.Diagram.Util.randomId());
                //clLane.children = [];
                diagram.nameTable[clLane.name] = clLane;
                var stack = diagram.nameTable[diagram._getChild(clSwimlane.children[2])];
                if (index || index === 0) {
                    stack.children.splice(index, 0, clLane.name);
                }
                else
                    stack.children.push(clLane.name);
                clLane.parent = stack.name;
                diagram._disableSwimlaneUptate = true;
                this._disableConnectorUpdate(diagram);
                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, clLane);
                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, clSwimlane);
                this._enableConnectorUpdate(diagram, clSwimlane);


                delete diagram._disableSwimlaneUptate

                var clSwimlaneBounds = ej.datavisualization.Diagram.Util.bounds(clSwimlane);
                ej.datavisualization.Diagram.containerCommon._removeObject(diagram, clLane);
                ej.datavisualization.Diagram.containerCommon._removeObject(diagram, clSwimlane);

                var size = diagram.activeTool._getPageBounds();
                if (clSwimlaneBounds.bottom > size.height)
                    return false
                if (clSwimlaneBounds.right > size.width)
                    return false
            }
            return true;
        },

        _addNewLane: function (diagram, overNode, swimlane, updateName, index) {
            diagram.activeTool._removeHelpers();
            var addSelection;
            var stack = diagram.nameTable[diagram._getChild(swimlane.children[2])];
            if (stack) {
                var selctObject = diagram.activeTool._cloneGroupNode(diagram.activeTool.selectedObject, updateName ? "" : ej.datavisualization.Diagram.Util.randomId());
                selctObject = this._updateDropLaneProperties(diagram, selctObject, swimlane);
                var _undo = diagram._isUndo; diagram._isUndo = true;
                diagram.activeTool.selectedObject = null;
                diagram.remove(diagram.activeTool.selectedObject);
                //ej.datavisualization.Diagram.containerCommon._removeObject(diagram, diagram.activeTool.selectedObject);
                diagram._isUndo = _undo;
                if (diagram._isUndo || this._outOfBoundaryAddLane(diagram, swimlane, selctObject, index)) {
                    var isLaneAdded = false;
                    var args = { element: diagram.getNode(selctObject), cancel: false, target: overNode };
                    if (overNode)
                        var index = index !== undefined ? index : diagram.activeTool._getSwimLaneStackIndex(overNode);
                    if (index || index === 0) {
                        stack.children.splice(index, 0, selctObject);
                    }
                    else
                        stack.children.push(selctObject);
                    selctObject.parent = stack.name;
                    if (!diagram._isUndo)
                        diagram._raiseDropEvent(args);
                    diagram.remove(selctObject);
                    if (!args.cancel) {
                        diagram.activeTool._isLane = true;
                        if (selctObject.isLane) {
                            var header = diagram.nameTable[diagram._getChild(selctObject.children[0])];
                            if (header && selctObject.labels && header.labels.length > 0) {
                                for (var j = 0; j < header.labels.length; j++)
                                    header.labels[j].visible = true;
                            }
                        }
                        if (!diagram._isUndo) {
                            var childTable = diagram._getChildTable(selctObject, {});
                            var entry = { type: "collectionchanged", object: jQuery.extend(true, {}, selctObject), childTable: jQuery.extend(true, {}, childTable), index: index, changeType: "insert", category: "internal" };
                            diagram.addHistoryEntry(entry);
                        }
                        diagram._preventHistoryEntry = true;
                        if (diagram.add(selctObject)) {
                            isLaneAdded = true;
                            diagram._updateDroppedSymbol(selctObject);
                        }
                        delete diagram._preventHistoryEntry;
                    }
                    this._disableConnectorUpdate(diagram);
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, stack);
                    this._updateAddRemoveLaneConnectors(diagram, selctObject)
                    ej.datavisualization.Diagram.canvasHelper._updateLastPhase(diagram, swimlane);
                    this._enableConnectorUpdateLane(diagram, selctObject);
                    if (isLaneAdded) {
                        var cause = diagram._isUndo ? ej.datavisualization.Diagram.GroupChangeCause.HistoryChange : ej.datavisualization.Diagram.GroupChangeCause.Drop;
                        var args = { changeType: "insert", element: diagram.getNode(selctObject), state: "changed", cause: cause };
                        diagram._raiseEvent("nodeCollectionChange", args);
                    }
                    addSelection = true;
                }
                diagram._clearSelection(true);
                if (addSelection)
                    diagram._addSelection(swimlane, true);
                diagram.activeTool.selectedObject = null;
                //diagram.selectionList = [];
                //diagram.selectionList.push(swimlane);
            }
        },
        //#endregion

        //#region resize lane

        _outOfBoundsOnLaneResize: function (diagram, node, isLane) {
            if (ej.datavisualization.Diagram.Util.canMoveOutofBoundary(diagram)) {
                if (isLane) {
                    var swimlane = diagram.nameTable[node.parent.split("laneStack")[0]];
                }
                else
                    swimlane = node;
                var randomId = ej.datavisualization.Diagram.Util.randomId();
                if (swimlane) {
                    var clSwimlaneBounds = ej.datavisualization.Diagram.Util.bounds(swimlane);
                    var widthDx = 0, heightDx = 0;
                    if (node.height != diagram.activeTool.helper.height)
                        heightDx = diagram.activeTool.helper.height - node.height
                    if (node.width != diagram.activeTool.helper.width)
                        widthDx = diagram.activeTool.helper.width - node.width
                    var size = diagram.activeTool._getPageBounds();
                    if ((clSwimlaneBounds.bottom + heightDx) > size.height)
                        return false
                    if ((clSwimlaneBounds.right + widthDx) > size.width)
                        return false
                }
            }
            return true;
        },
        _getLaneIndex: function (swimlane, lane) {
            var lanes = swimlane.lanes, i;
            for (i = 0; i < lanes.length; i++) {
                if (lane.name === lanes[i].name)
                    return i;
            }
            return null;
        },

        _isCanAddNodeToSegmentUpdate: function (diagram, index, node) {
            if (node) {
                if (node && node.parent) {
                    var lane = diagram.nameTable[node.parent], swimlane, lIndex;
                    if (lane && lane.isLane) {
                        swimlane = this._getSwimlane(diagram, lane.name);
                        lIndex = this._getLaneIndex(swimlane, lane);
                        if (lIndex > index) {
                            return true;
                        }
                    }
                    else return false;
                }
                else return false;
            }
            return false;
        },
        _getUpdateConnectorByEdges: function (diagram, node, index, connectors) {
            if (node) {
                this._getUpdateSegmentConnectors(diagram, node, index, connectors, node.inEdges)
                this._getUpdateSegmentConnectors(diagram, node, index, connectors, node.outEdges)
            }
        },
        _getUpdateSegmentConnectors: function (diagram, node, index, connectors, edges) {
            if (edges && edges.length > 0) {
                var line, sNode, tNode;
                for (var i = 0; i < edges.length; i++) {
                    line = diagram.nameTable[edges[i]];
                    if (line.sourceNode)
                        sNode = diagram.nameTable[line.sourceNode];
                    if (line.targetNode)
                        tNode = diagram.nameTable[line.targetNode];
                    if (sNode && tNode) {
                        if (this._isCanAddNodeToSegmentUpdate(diagram, index, sNode) && this._isCanAddNodeToSegmentUpdate(diagram, index, tNode) && !diagram._collectionContains(line.name, connectors))
                            connectors.push(line);
                    }
                }
            }
        },
        _updateConnectorSegments: function (diagram, node, dx, dy) {
            var swimlane = this._getSwimlane(diagram, node.name), index, connectors, lanes, i, children, j;
            index = this._getLaneIndex(swimlane, node);
            if (index != null) {
                connectors = [];
                lanes = swimlane.lanes;
                for (i = index + 1; i < lanes.length; i++) {
                    children = lanes[i].children;
                    for (j = 0; j < children.length; j++) {
                        this._getUpdateConnectorByEdges(diagram, children[j], index, connectors);
                    }
                }
            }
            if (connectors && connectors.length > 0 && dx != null && dy != null) {
                for (i = 0; i < connectors.length; i++) {
                    ej.datavisualization.Diagram.Util._translateLine(connectors[i], dx, dy, connectors[i]);

                }
            }
        },
        _resizeLane: function (diagram, node) {
            var object = diagram.nameTable[node.name];
            var needUpdate = true;
            if (object) {
                if (object.isLane || object._isBpmn) {
                    if (this._outOfBoundsOnLaneResize(diagram, object, true)) {
                        if (object.type == "bpmn" && object.container) {
                            var helper = diagram.activeTool.helper;
                            var scaleX = helper.width / node.width, scaleY = helper.height / node.height, offset = { x: node.offsetX, y: node.offsetY };
                            diagram._raiseSizePropertyChange(node, helper.width / node.width, helper.height / node.height, true);
                            diagram.activeTool._undoObject = $.extend(true, {}, { node: object });
                            object = $.extend(true, object, { width: helper.width, height: helper.height, offsetX: helper.offsetX, offsetY: helper.offsetY, minWidth: helper.width, minHeight: helper.height });
                            if (object.parent) {
                                var parent = ej.datavisualization.Diagram.ContainerHelper.updateparent(object, diagram);
                                if (parent) {
                                    object.minWidth = diagram.activeTool.helper.width;
                                    object.minHeight = diagram.activeTool.helper.height;
                                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, object, true);
                                    this._updateLastSwimlanePhase(diagram, object);
                                }
                                else
                                    ej.datavisualization.Diagram.bpmnHelper.updateCanvas(object, diagram);
                            }
                            else
                                ej.datavisualization.Diagram.bpmnHelper.updateCanvas(object, diagram);
                            ej.datavisualization.Diagram.DefautShapes.translateBPMNAnnotationShape(object, 1 / scaleX, 1 / scaleY, offset, diagram);
                            diagram.activeTool._redoObject = $.extend(true, {}, { node: object });
                        }
                        else if (object.container) {
                            diagram._raiseSizePropertyChange(node, diagram.activeTool.helper.width / node.width, diagram.activeTool.helper.height / node.height, true);
                            diagram.activeTool._undoObject = $.extend(true, {}, { node: object });
                            diagram._comparePropertyValues(node, "minWidth", { minWidth: diagram.activeTool.helper.width }, true);
                            diagram._comparePropertyValues(node, "offsetX", { offsetX: node.offsetX + diagram.activeTool.helper.width / 2 }, true);
                            object.minWidth = diagram.activeTool.helper.width <= 100 ? 100 : diagram.activeTool.helper.width;
                            diagram._comparePropertyValues(node, "minHeight", { minHeight: diagram.activeTool.helper.height }, true);
                            diagram._comparePropertyValues(node, "offsetY", { offsetY: node.offsetY + diagram.activeTool.helper.height / 2 }, true);
                            object.minHeight = diagram.activeTool.helper.height <= 100 ? 100 : diagram.activeTool.helper.height;
                            diagram.activeTool._redoObject = $.extend(true, {}, { node: object });
                        }
                        var entry = { type: "sizechanged", node: jQuery.extend(true, {}, object), undoObject: jQuery.extend(true, {}, diagram.activeTool._undoObject), redoObject: jQuery.extend(true, {}, diagram.activeTool._redoObject), category: "internal" };
                        diagram.addHistoryEntry(entry);
                        diagram.activeTool._multipleUndo = true;
                        if (object.isLane) {
                            this._disableConnectorUpdate(diagram);
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, object, true);
                            var xdiff = object.width - diagram.activeTool._undoObject.node.width, ydiff = object.height - diagram.activeTool._undoObject.node.height, _preventDocking, _disableSegmentChange;
                            _preventDocking = diagram._preventDocking;
                            _disableSegmentChange = diagram._disableSegmentChange
                            delete diagram._preventDocking;
                            delete diagram._disableSegmentChange
                            this._updateOverlappedConnectorSegment(diagram, diagram.activeTool._undoObject.node, xdiff, ydiff);
                            diagram._preventDocking = _preventDocking;
                            diagram._disableSegmentChange = _disableSegmentChange;
                            this._updateConnectorSegments(diagram, object, xdiff, ydiff);
                            this._enableConnectorUpdateLane(diagram, object);
                        }
                    }
                }
                else if (object.isSwimlane) {
                    var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(diagram, object), minLaneSize;
                    if (lanes.length > 0) {
                        var lastLane = diagram.nameTable[diagram._getChild(lanes[lanes.length - 1])];
                        if (lastLane) {
                            diagram.activeTool._undoObject = $.extend(true, {}, { node: lastLane });
                            diagram._raiseSizePropertyChange(object, diagram.activeTool.helper.width / object.width, diagram.activeTool.helper.height / object.height, true);
                            if (object.orientation === "vertical") {
                                minLaneSize = lastLane.width + diagram.activeTool.helper.width - object.width;
                                diagram._comparePropertyValues(lastLane, "minWidth", { minWidth: minLaneSize }, true);
                                diagram._comparePropertyValues(lastLane, "offsetX", { offsetX: node.offsetX + minLaneSize / 2 }, true);
                                lastLane.minWidth = minLaneSize <= 100 ? 100 : minLaneSize;
                            }
                            else {
                                minLaneSize = lastLane.height + diagram.activeTool.helper.height - object.height
                                if (minLaneSize == lastLane.minHeight) {
                                    needUpdate = false;
                                }
                                else {
                                    diagram._comparePropertyValues(lastLane, "minHeight", { minHeight: minLaneSize }, true);
                                    diagram._comparePropertyValues(lastLane, "offsetY", { offsetY: node.offsetY + minLaneSize / 2 }, true);
                                    lastLane.minHeight = minLaneSize <= 100 ? 100 : minLaneSize;
                                }
                            }
                            if (needUpdate) {
                                this._disableConnectorUpdate(diagram);
                                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, lastLane, true);
                                this._enableConnectorUpdateLane(diagram, object);
                                diagram.activeTool._redoObject = $.extend(true, {}, { node: lastLane });

                                var entry = { type: "sizechanged", node: jQuery.extend(true, {}, object), undoObject: jQuery.extend(true, {}, diagram.activeTool._undoObject), redoObject: jQuery.extend(true, {}, diagram.activeTool._redoObject), category: "internal" };
                                diagram.addHistoryEntry(entry);
                                diagram.activeTool._multipleUndo = true;
                                this._disableConnectorUpdate(diagram);
                                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, object, true);
                                this._enableConnectorUpdateLane(diagram, object);
                            }
                        }
                    }
                }
                else if (object.container) {
                    object.minWidth = diagram.activeTool.helper.width;
                    object.minHeight = diagram.activeTool.helper.height;
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, object, true);
                }
            }
        },

        _updateOverlappedConnectorSegment: function (diagram, lane, xdiff, ydiff) {
            if (lane) {
                var start, end, interSectors, i, interSectSegments, j, connectorName, segmentindex, connector, length;
                if (xdiff != undefined && ydiff != undefined)
                    var ovrConncts = this._overLappedConnectros(diagram, lane);
                if (ovrConncts && ovrConncts.length > 0) {
                    var bounds = ej.datavisualization.Diagram.Util.bounds(lane);
                    if (lane.orientation === "horizontal") {
                        start = bounds.bottomLeft;
                        end = bounds.bottomRight;
                    }
                    else {
                        start = bounds.topRight;
                        end = bounds.bottomRight;
                    }
                    interSectors = [];
                    for (i = 0; i < ovrConncts.length; i++) {
                        interSectSegments = this._lineSegmentsIntersect(diagram, lane, ovrConncts[i], { start: start, end: end });
                        if (interSectSegments && interSectSegments.length > 0) {
                            for (j = 0; j < interSectSegments.length; j++) {
                                connectorName = Object.keys(interSectSegments[j])[0];
                                segmentindex = interSectSegments[j][connectorName]["index"];
                                var point = interSectSegments[j][connectorName]["point"];
                                connector = diagram.nameTable[diagram._getChild(connectorName)]
                                if (connector && connector.segments && connector.segments.length > 0) {
                                    if (lane.orientation === "horizontal") {
                                        if (connector.segments[segmentindex])
                                            length = connector.segments[segmentindex].length;
                                        if (length) {
                                            connector.segments[segmentindex].length += ydiff
                                        }
                                    }
                                    else {
                                        length = connector.segments[segmentindex].length;
                                        if (length) { connector.segments[segmentindex].length += xdiff }
                                    }
                                    this._updateConnectorEndPoints(diagram, connector);
                                }
                            }
                        }
                    }
                }
            }
        },

        _lineSegmentsIntersect: function (diagram, lane, connector, line1, interSectors) {
            var x1, y1, x2, y2, i, segment, j, point1, point2, x3, y3, x4, y4, data, interSectSegments;
            x1 = line1.start.x;
            y1 = line1.start.y;
            x2 = line1.end.x;
            y2 = line1.end.y;
            interSectSegments = [];
            var orientation = (lane && lane.orientation) ? lane.orientation : "horizontal";
            connector = diagram.nameTable[diagram._getChild(connector)];
            if (connector && connector.segments && connector.segments.length > 0) {
                if (connector.segments.length === 1) {
                }
                else {
                    for (i = 0; i < connector.segments.length; i++) {
                        segment = connector.segments[i];
                        if (segment && segment.points.length > 0) {
                            for (j = 0; j < segment.points.length - 1; j++) {
                                point1 = segment.points[j];
                                point2 = segment.points[j + 1];
                                if (point1 && point2) {
                                    x3 = point1.x;
                                    y3 = point1.y;
                                    x4 = point2.x;
                                    y4 = point2.y;
                                    if (this._isInterSecting(x1, y1, x2, y2, x3, y3, x4, y4)) {
                                        data = {
                                        };
                                        var pointindex = j;
                                        if (orientation === "horizontal") {
                                            if (point1.y > y1)
                                                pointindex = -1;
                                        }
                                        else {
                                            if (point1.x > x1)
                                                pointindex = -1;
                                        }
                                        data[connector.name] = {
                                            index: i, point: pointindex
                                        };
                                        interSectSegments.push(data);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return interSectSegments;
        },

        _isInterSecting: function (x1, y1, x2, y2, x3, y3, x4, y4, isCrossing) {
            var a_dx = x2 - x1;
            var a_dy = y2 - y1;
            var b_dx = x4 - x3;
            var b_dy = y4 - y3;
            var s = (-a_dy * (x1 - x3) + a_dx * (y1 - y3)) / (-b_dx * a_dy + a_dx * b_dy);
            var t = (+b_dx * (y1 - y3) - b_dy * (x1 - x3)) / (-b_dx * a_dy + a_dx * b_dy);
            if (isCrossing)
                return (s > 0 && s < 1 && t > 0 && t < 1);
            else
                return (s >= 0 && s <= 1 && t >= 0 && t <= 1);

        },
        _overLappedConnectros: function (diagram, lane) {
            var swimlane = this._getSwimlane(diagram, lane.name);
            var lIndex, lanes, connectors, i, prevLane, j, child, m;
            if (swimlane && swimlane.isSwimlane) {
                lIndex = this._getLaneIndex(swimlane, lane);
                lanes = diagram.nameTable[lane.parent];
                connectors = [];
                if (lanes && lanes.isLaneStack) {
                    if (lanes && lanes.children.length > 0) {
                        for (i = lIndex ; i >= 0; i--) {
                            prevLane = diagram.nameTable[diagram._getChild(lanes.children[i])];
                            if (prevLane && prevLane.isLane) {
                                this._laneConnectors(diagram, prevLane, connectors);
                            }
                        }
                    }
                }
            }
            return connectors;
        },
        //#endregion

        //#region undo dragNode
        _getUndoObject: function (diagram, node) {
            var childTable = {};
            var childTable = diagram._getChildTable(node, childTable);
            diagram.activeTool._undoObject = $.extend(true, {}, { node: node, childTable: childTable });
        },
        _getRedoObject: function (diagram, node) {
            var childTable = {};
            var childTable = diagram._getChildTable(node, childTable);
            diagram.activeTool._redoObject = $.extend(true, {}, { node: node, childTable: childTable });
        },
        _undoRemoveNodeFromContainer: function (diagram, node) {
            if (node.type !== "pseudoGroup") {
                var parent = diagram.nameTable[node.parent], child;
                if (parent) {
                    node.parent = "";
                    var children = parent.children, child;
                    for (var i = 0; i < children.length; i++) {
                        child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child) {
                            if (child.name === node.name) {
                                diagram.nodes().push(children[i]);
                                ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, children[i]);
                            }
                        }
                    }
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
            }
        },
        _undoAddNodeToContainer: function (diagram, node, object) {
            if (node && node.type !== "pseudoGroup") {
                var parent = diagram.nameTable[object.parent], child, parentElement;
                if (!object.segments)
                    diagram._translate(node, object.offsetX - node.offsetX, object.offsetY - node.offsetY, diagram.nameTable);
                else if (!node.sourceNode && !node.targetNode) {
                    var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node, true);
                    var objectBounds = ej.datavisualization.Diagram.Util.bounds(object, true);
                    ej.datavisualization.Diagram.Util._translateLine(node, objectBounds.center.x - nodeBounds.center.x, objectBounds.center.y - nodeBounds.center.y);
                }
                if (parent) {
                    node.parent = parent.name;
                    parent.children.push(node);
                    ej.datavisualization.Diagram.Util.removeItem(diagram.nodes(), node);
                    parentElement = diagram._svg.getElementById(parent.name);
                    if (parent._isBpmn) {
                        ej.datavisualization.Diagram.bpmnHelper.resetNodeMargin(node, parent, diagram);
                        node = $.extend(true, node, { marginLeft: object.marginLeft, marginRight: object.marginRight, marginTop: object.marginTop, marginBottom: object.marginBottom });
                    }
                    else
                        this._updateNodeMargin(diagram, node, parent);
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
                else {
                    if (!diagram._swimlaneOuterNodes)
                        diagram._swimlaneOuterNodes = [];
                    diagram._swimlaneOuterNodes.push(node);
                }
                if (node._type === "group") {
                    ej.datavisualization.Diagram.DiagramContext.renderGroup(node, diagram, parentElement);
                } else if (node.segments) {
                    ej.datavisualization.Diagram.DiagramContext.renderConnector(node, diagram, parentElement);
                } else {
                    ej.datavisualization.Diagram.DiagramContext.renderNode(node, diagram, parentElement);
                }
            }
        },
        _undoDragNode: function (diagram, node, object, pseudoGroup) {
            object = $.extend(true, {}, object);
            if (node && object) {
                if (node.type !== "pseudoGroup") {
                    var tempObj = $.extend(true, {}, object);
                    var tempNode = $.extend(true, {}, node);
                    if (!pseudoGroup) {
                        this._disableConnectorUpdate(diagram);
                        diagram._disableSwimlaneUptate = true;
                    }
                    this._undoRemoveNodeFromContainer(diagram, node);
                    this._undoAddNodeToContainer(diagram, node, object);
                    if (!pseudoGroup)
                        delete diagram._disableSwimlaneUptate
                    diagram._clearSelection(true);
                    diagram._addSelection(node, true);
                    //diagram.activeTool.selectedObject = node;
                    this._updateLastSwimlanePhase(diagram, node);
                    if (!pseudoGroup) {
                        if (tempNode.parent) {
                            this._enableConnectorUpdateNode(diagram, tempNode);
                            if (node.parent && node.parent !== tempNode.parent) {
                                this._enableConnectorUpdateNode(diagram, node);
                                this._updateLastSwimlanePhase(diagram, tempNode);
                            }
                        }
                        else
                            this._enableConnectorUpdateNode(diagram, tempObj);
                    }
                    if (!node.parent) {
                        this._updateAssociatedConnectorEnds(diagram, node, diagram.nameTable);
                    }
                }
            }
        },
        _undoMultiDragNode: function (diagram, args) {
            var pseudoGroup = $.extend(true, {}, args.node), obj;
            if (pseudoGroup && (pseudoGroup.type === "pseudoGroup")) {
                var children = pseudoGroup.children;
                diagram._disableSwimlaneUptate = true;
                for (var i = 0; i < children.length; i++) {
                    this._disableConnectorUpdate(diagram);
                    var node = diagram.nameTable[diagram._getChild(children[i])];
                    var parent = node.parent;
                    if (args.undo && node)
                        obj = args.undoObject.childTable ? args.undoObject.childTable[node.name] : null;
                    else
                        obj = args.redoObject.childTable ? args.redoObject.childTable[node.name] : null;
                    this._undoDragNode(diagram, node, obj, true);
                    if (!parent) {
                        if (obj.parent) {
                            parent = obj.parent;
                        }
                    }
                    if (parent) {
                        var lane = diagram.nameTable[parent];
                        if (lane && lane.isLane) {
                            var swimlane = diagram.nameTable[lane.parent.split("laneStack")[0]];
                            if (swimlane) {
                                if (!diagram._updateSwimlanes) {
                                    diagram._updateSwimlanes = [];
                                }
                                if (!diagram._collectionContains(swimlane.name, diagram._updateSwimlanes))
                                    diagram._updateSwimlanes.push(swimlane.name)
                            }
                        }
                    }
                    else {
                        delete diagram._disableSegmentChange;
                        this._updateAssociatedConnectorEnds(diagram, node, diagram.nameTable);
                    }
                    delete diagram._disableSegmentChange;
                    this._updateAssociatedConnectorEnds(diagram, node, diagram.nameTable);
                }

                delete diagram._disableSwimlaneUptate;
                if (diagram._updateSwimlanes && diagram._updateSwimlanes.length > 0) {
                    for (var m = 0; m < diagram._updateSwimlanes.length; m++) {
                        ej.datavisualization.Diagram.DiagramContext.update(diagram.nameTable[diagram._updateSwimlanes[m]], diagram);
                        ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdate(diagram, diagram.nameTable[diagram._updateSwimlanes[m]]);
                    }
                }
                if (diagram._swimlaneOuterNodes && diagram._swimlaneOuterNodes.length > 0) {
                    for (var m = 0; m < diagram._swimlaneOuterNodes.length; m++) {
                        var updateNode = diagram._swimlaneOuterNodes[m];
                        if (updateNode && updateNode.type !== "connector") {
                            for (var i = 0, len = updateNode.inEdges.length; i < len; i++) {
                                var connector = diagram.nameTable[updateNode.inEdges[i]];
                                if (connector) {
                                    diagram._dock(connector, diagram.nameTable);
                                    ej.datavisualization.Diagram.DiagramContext.update(connector, diagram);
                                }
                            }
                            for (i = 0, len = updateNode.outEdges.length; i < len; i++) {
                                connector = diagram.nameTable[updateNode.outEdges[i]];
                                if (connector) {
                                    diagram._dock(connector, diagram.nameTable);
                                    ej.datavisualization.Diagram.DiagramContext.update(connector, diagram);
                                }
                            }
                        }
                    }
                    delete diagram._swimlaneOuterNodes
                }
                delete diagram._updateSwimlanes;
                diagram._clearSelection(true);
                ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                diagram._addSelection(pseudoGroup, true);
                delete diagram.nameTable[pseudoGroup.name];
                diagram.nameTable[pseudoGroup.name] = pseudoGroup;
                //diagram.activeTool.selectedObject = pseudoGroup;
            }
        },


        _updateAssociatedConnectorEnds: function (diagram, node, nameTable) {
            var i, len;
            var connector;
            if (diagram.getObjectType(node) !== "connector") {
                if (node.inEdges.length || node.outEdges.length) {
                    //Finding the segment points to avoid calculating path points multiple times to dock every edge
                    var nodeToNode = diagram._isNodeToNodeConnection(node);
                    var nodeToDock = node;
                    if (node.type == "bpmn" && node._type == "group") {
                        nodeToDock = typeof node.children[0] == "object" ? node.children[0] : diagram.nameTable[node.children[0]];
                    }
                    if (nodeToNode) {
                        var segmentPoints = ej.datavisualization.Diagram.Util._findSegmentPoints(nodeToDock);
                    }
                    var childTable = {};
                    if (diagram._parentNode) {
                        childTable = diagram._getChildTable(diagram._parentNode, {});
                    }
                    for (i = 0, len = node.inEdges.length; i < len; i++) {
                        connector = nameTable[node.inEdges[i]];
                        if (connector && !(diagram._parentNode && childTable[connector.sourceNode])) {
                            if (!connector.targetPadding) {
                                nodeToDock._segmentPoints = segmentPoints;
                            }
                            else delete nodeToDock._segmentPoints;
                            diagram._dock(connector, nameTable);
                            ej.datavisualization.Diagram.DiagramContext.update(connector, diagram);
                        }
                    }
                    for (i = 0, len = node.outEdges.length; i < len; i++) {
                        connector = nameTable[node.outEdges[i]];
                        if (connector && !(diagram._parentNode && childTable[connector.targetNode])) {
                            if (!connector.sourcePadding) { nodeToDock._segmentPoints = segmentPoints; }
                            else delete nodeToDock._segmentPoints;
                            diagram._dock(connector, nameTable);
                            //ej.datavisualization.Diagram.DiagramContext.update(connector, diagram);
                        }
                    }
                    delete nodeToDock._segmentPoints;
                }
            }
        },
        //#endregion

        //#region undo resizeNode
        _undoRemoveResizeNodeFromContainer: function (diagram, node) {
            if (node.type !== "pseudoGroup") {
                var parent = diagram.nameTable[node.parent], child;
                if (parent) {
                    node.parent = "";
                    var children = parent.children, child;
                    for (var i = 0; i < children.length; i++) {
                        child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child) {
                            if (child.name === node.name)
                                ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, children[i]);
                        }
                    }
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
            }
        },
        _undoAddResizeNodeToContainer: function (diagram, node, object) {
            if (node.type !== "pseudoGroup") {
                var parent = diagram.nameTable[object.parent], child, parentElement;
                if (!node.segments) {
                    diagram._translate(node, object.offsetX - node.offsetX, object.offsetY - node.offsetY, diagram.nameTable);
                    diagram.scale(node, (object.width / node.width), (object.height / node.height), ej.datavisualization.Diagram.Point(node.offsetX, node.offsetY), diagram.nameTable);
                    if (node._type === "group") ej.datavisualization.Diagram.Util._updateGroupBounds(node, diagram);
                    if (node.container) ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, node, true);
                }
                if (parent) {
                    node.parent = parent.name;
                    parent.children.push(node.name);
                    parentElement = diagram._svg.getElementById(parent.name);
                    if (parent._isBpmn) {
                        ej.datavisualization.Diagram.bpmnHelper.resetNodeMargin(node, parent, diagram);
                        node = $.extend(true, node, { marginLeft: object.marginLeft, marginRight: object.marginRight, marginTop: object.marginTop, marginBottom: object.marginBottom });
                    }
                    else
                        this._updateNodeMargin(diagram, node, parent);
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
                if (node._type === "group") {
                    ej.datavisualization.Diagram.DiagramContext.renderGroup(node, diagram, parentElement);
                } else if (node.segments) {
                    ej.datavisualization.Diagram.DiagramContext.renderConnector(node, diagram, parentElement);
                } else {
                    ej.datavisualization.Diagram.DiagramContext.renderNode(node, diagram, parentElement);
                }
            }
        },
        _undoResizeNode: function (diagram, node, object, pseudoGroup) {
            object = $.extend(true, {}, object);
            if (node && object) {
                if (node.type !== "pseudoGroup") {
                    if (!pseudoGroup)
                        this._disableConnectorUpdate(diagram);
                    this._undoRemoveResizeNodeFromContainer(diagram, node);
                    this._undoAddResizeNodeToContainer(diagram, node, object);
                    diagram._clearSelection(true);
                    diagram._addSelection(node, true);
                    this._updateLastSwimlanePhase(diagram, node);
                    if (!pseudoGroup)
                        this._enableConnectorUpdateNode(diagram, node);
                }
            }
        },
        _undoMultiResizeNode: function (diagram, args) {
            var pseudoGroup = $.extend(true, {}, args.node), obj;
            if (pseudoGroup && (pseudoGroup.type === "pseudoGroup")) {
                var children = pseudoGroup.children;
                for (var i = 0; i < children.length; i++) {
                    var node = diagram.nameTable[diagram._getChild(children[i])];
                    if (args.undo && node)
                        obj = args.undoObject.childTable ? args.undoObject.childTable[node.name] : null;
                    else
                        obj = args.redoObject.childTable ? args.redoObject.childTable[node.name] : null;
                    this._undoResizeNode(diagram, node, obj);
                }
                diagram._clearSelection(true);
                ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                diagram._addSelection(pseudoGroup, true);
                delete diagram.nameTable[pseudoGroup.name];
                diagram.nameTable[pseudoGroup.name] = pseudoGroup;
            }
        },
        _undoResizeLane: function (diagram, object, args) {
            var node = diagram.nameTable[object.name];
            if (node) {
                if (args && args.node && args.node.isSwimlane) {
                    var lanes = ej.datavisualization.Diagram.SwimLaneContainerHelper.getLanes(diagram, args.node);
                    if (lanes.length > 0) {
                        var lastLane = diagram.nameTable[diagram._getChild(lanes[lanes.length - 1])];
                        if (lastLane) {
                            if (args.undo) {
                                object = (args.undoObject && args.undoObject.node) ? args.undoObject.node : lastLane;
                            }
                            else {
                                object = (args.undoObject && args.redoObject.node) ? args.redoObject.node : lastLane;
                            }
                            diagram._comparePropertyValues(lastLane, "minWidth", { minWidth: object.minWidth });
                            lastLane.minWidth = object.minWidth;
                            diagram._comparePropertyValues(lastLane, "minHeight", { minHeight: object.minHeight });
                            lastLane.minHeight = object.minHeight;
                            this._disableConnectorUpdate(diagram);
                            ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, node, true);
                            this._enableConnectorUpdateLane(diagram, node);
                        }
                    }
                }
                else if (node.isLane) {
                    if (node.container) {
                        diagram.activeTool._undonode = $.extend(true, {}, { node: node });
                        diagram._comparePropertyValues(node, "minWidth", { minWidth: object.minWidth });
                        node.minWidth = object.minWidth;
                        diagram._comparePropertyValues(node, "minHeight", { minHeight: object.minHeight });
                        node.minHeight = object.minHeight;
                    }
                    this._disableConnectorUpdate(diagram);
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, node, true);
                    var xdiff = node.width - diagram.activeTool._undonode.node.width, ydiff = node.height - diagram.activeTool._undonode.node.height, _preventDocking, _disableSegmentChange;
                    _preventDocking = diagram._preventDocking;
                    _disableSegmentChange = diagram._disableSegmentChange
                    delete diagram._preventDocking;
                    delete diagram._disableSegmentChange
                    this._updateOverlappedConnectorSegment(diagram, diagram.activeTool._undonode.node, xdiff, ydiff);
                    diagram._preventDocking = _preventDocking;
                    diagram._disableSegmentChange = _disableSegmentChange;
                    this._updateConnectorSegments(diagram, node, xdiff, ydiff);
                    this._enableConnectorUpdateLane(diagram, node);
                }
            }
        },
        //#endregion

        //#region undo rotateNode
        _undoRemoveRotateNodeFromContainer: function (diagram, node) {
            if (node.type !== "pseudoGroup") {
                var parent = diagram.nameTable[node.parent], child;
                if (parent) {
                    node.parent = "";
                    var children = parent.children, child;
                    for (var i = 0; i < children.length; i++) {
                        child = diagram.nameTable[diagram._getChild(children[i])];
                        if (child) {
                            if (child.name === node.name)
                                ej.datavisualization.Diagram.Util.removeChildFromGroup(parent.children, children[i]);
                        }
                    }
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
            }
        },
        _undoAddRotateNodeToContainer: function (diagram, node, object) {
            if (node.type !== "pseudoGroup") {
                var parent = diagram.nameTable[object.parent], child, parentElement;
                if (!node.segments) {
                    var newangle = object.rotateAngle - node.rotateAngle;
                    diagram._rotate(node, newangle, diagram.nameTable);
                }
                if (parent) {
                    node.parent = parent.name;
                    parent.children.push(node.name);
                    parentElement = diagram._svg.getElementById(parent.name);
                    if (parent._isBpmn) {
                        ej.datavisualization.Diagram.bpmnHelper.resetNodeMargin(node, parent, diagram);
                        node = $.extend(true, node, { marginLeft: object.marginLeft, marginRight: object.marginRight, marginTop: object.marginTop, marginBottom: object.marginBottom });
                    }
                    else
                        this._updateNodeMargin(diagram, node, parent);
                    ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, true);
                }
                if (node._type === "group") {
                    ej.datavisualization.Diagram.DiagramContext.renderGroup(node, diagram, parentElement);
                } else if (node.segments) {
                    ej.datavisualization.Diagram.DiagramContext.renderConnector(node, diagram, parentElement);
                } else {
                    ej.datavisualization.Diagram.DiagramContext.renderNode(node, diagram, parentElement);
                }
            }
        },
        _undoRotateNode: function (diagram, node, object, pseudoGroup) {
            object = $.extend(true, {}, object);
            if (node && object) {
                if (node.type !== "pseudoGroup") {
                    if (!pseudoGroup)
                        this._disableConnectorUpdate(diagram);
                    this._undoRemoveRotateNodeFromContainer(diagram, node);
                    this._undoAddRotateNodeToContainer(diagram, node, object);
                    diagram._clearSelection(true);
                    diagram._addSelection(node, true);
                    this._updateLastSwimlanePhase(diagram, node);
                    if (!pseudoGroup)
                        this._enableConnectorUpdateNode(diagram, node);
                }
            }
        },
        _undoMultiRotateNode: function (diagram, args) {
            var pseudoGroup = $.extend(true, {}, args.node), obj;
            if (pseudoGroup && (pseudoGroup.type === "pseudoGroup")) {
                var children = pseudoGroup.children;
                for (var i = 0; i < children.length; i++) {
                    var node = diagram.nameTable[diagram._getChild(children[i])];
                    if (args.undo && node)
                        obj = args.undoObject.childTable ? args.undoObject.childTable[node.name] : null;
                    else
                        obj = args.redoObject.childTable ? args.redoObject.childTable[node.name] : null;
                    this._undoRotateNode(diagram, node, obj, true);
                }
                diagram._clearSelection(true);
                pseudoGroup.rotateAngle = obj.rotateAngle;
                ej.datavisualization.Diagram.Util._updateGroupBounds(pseudoGroup, diagram);
                diagram._addSelection(pseudoGroup, true);
                delete diagram.nameTable[pseudoGroup.name];
                diagram.nameTable[pseudoGroup.name] = pseudoGroup;
            }
        },
        //#endregion

        //#region swapping lane
        _undoSwap: function (diagram, args) {
            diagram.activeTool._removeHelpers();
            diagram._clearSelection(true);
            var index = args.undo ? args.insertIndex : args.moveIndex;
            var node = diagram.nameTable[args.undoObject.name1];
            var parent = node && node.parent ? diagram.nameTable[node.parent] : null;
            if (parent && parent.children.length > 0)
                var list = parent.children;
            var tList = list.slice();
            var prevSwimlane = this._getSwimlane(diagram, list[0]);
            if (list && list.length > 0) {
                ej.datavisualization.Diagram.canvasHelper._disableConnectorUpdate(diagram);
                this._undoSwapLane(diagram, list, index, node, null);
                ej.datavisualization.Diagram.ContainerHelper._updateCollectionChange(diagram, parent, false);
                ej.datavisualization.Diagram.canvasHelper._recreateConnectorSegments(diagram, node.name, tList, args.undoObject.name2, args.undoObject.name1);
                ej.datavisualization.Diagram.canvasHelper._enableConnectorUpdateLane(diagram, node);
            }
            var currLaneSwimlane = this._getSwimlane(diagram, list[0]);
            diagram._comparePropertyValues(currLaneSwimlane, "lanes", { lanes: prevSwimlane.lanes });
        },
        _undoSwapLane: function (diagram, list, index, node, isVertical) {
            if (list && list.length > 0) {
                list.splice(list.indexOf(node), 1);
                list.splice(index, 0, node);
            }
        },
        //#endregion
    };

    ej.datavisualization.Diagram.containerCommon = {
        _initGroupNode: function (diagram, group) {
            var child = null;
            group = diagram._getNewGroup(group);
            for (var i = 0; i < group.children.length; i++) {
                child = group.children[i];
                if (child && typeof (child) == "object") {
                    if (typeof child.shape !== "object")
                        child = ej.datavisualization.Diagram.NodeType(child, diagram);
                    //if (child.type === "bpmn")
                    //    child._type = "node";
                    if (child._type != "group" && !child.children && !child.segments && child.type != "connector") {
                        if (group.type != "bpmn") child = diagram._getNewNode(child);
                        if (child.name == "")
                            child.name = ej.datavisualization.Diagram.Util.randomId();
                        if (child._type == "node" && child.labels.length && (child.width == 0 || child.height == 0))
                            diagram._getNodeDimension(child);
                    }
                    else if (child.segments || child.type == "connector") {
                        child = diagram._getNewConnector(child);
                        if (child.name == "") {
                            child.name = ej.datavisualization.Diagram.Util.randomId();
                        }
                    }
                    else {
                        child = diagram._getNewGroup(child);
                        if (child.name == "") {
                            child.name = ej.datavisualization.Diagram.Util.randomId();
                        }
                        child = this._initGroupNode(diagram, child);
                    }
                    group.children[i] = child;
                    child.parent = group.name;
                }
            }
            return group;
        },
        _initChildren: function (diagram, node) {
            if (node.children && node.children.length > 0) {
                var children = node.children;
                for (var i = 0; i < children.length; i++) {
                    var child = typeof (children[i]) === "string" ? diagram.nameTable[children[i]] : children[i];
                    if (child) {
                        if (!child._isInternalShape
                            || (child._isInternalShape && child.type === "group")
                            ) {

                            if (child.container) {
                                child = ej.datavisualization.Diagram.ContainerHelper._initContainer(diagram, child);
                            }
                            else if (child.children) {
                                child = ej.datavisualization.Diagram.Group(child);
                                child = this._initGroupNode(diagram, children[i]);
                                child = diagram._getNewGroup(children[i]);
                                child = this._initChildren(diagram, children[i]);
                                if (diagram._isLoad && children[i].type !== "bpmn")
                                    this._updateGroupBounds(diagram, children[i]);
                            }
                            else if (child.segments) {
                                child = ej.datavisualization.Diagram.Connector(child);
                                child = diagram._getNewConnector(child);
                            }
                            else {
                                child = ej.datavisualization.Diagram.NodeType(child, diagram);
                                child = diagram._getNewNode(child);
                            }

                            if (node.container) {
                                if (child.type === "bpmn" && node.shape !== "group")
                                    diagram._translate(child, 0 - child.offsetX, 0 - child.offsetY, diagram.nameTable)
                                //else
                                    //child.offsetX = 0; child.offsetY = 0;
                            }
                        }
                        diagram.nameTable[child.name] = child;
                        node.children[i] = child;
                        if (diagram._spatialSearch) diagram._updateQuad(child);
                    }
                }
            }
            return node;
        },
        _getChildrenBounds: function (diagram, group) {
            var children = group.children, rect,
                bounds = ej.datavisualization.Diagram.Rectangle(), child;
            if (children.length > 0) {
                child = diagram.nameTable[diagram._getChild(children[0])];
                if (child)
                    bounds = ej.datavisualization.Diagram.Util._rotateChildBounds(child, group, diagram);
            }
            for (var i = 0, len = children.length; i < len; i++) {
                child = diagram.nameTable[diagram._getChild(children[i])];
                if (child) {
                    if (child._type === "group") {
                        ej.datavisualization.Diagram.Util._updateGroupBounds(child, diagram);
                        rect = ej.datavisualization.Diagram.Util._rotateChildBounds(child, group, diagram);
                    } else
                        rect = ej.datavisualization.Diagram.Util._rotateChildBounds(child, group, diagram);
                }
                if (rect)
                    bounds = ej.datavisualization.Diagram.Geometry.union(bounds, rect);
            }
            return bounds;
        },
        _updateGroupBounds: function (diagram, node, angleChange) {
            var exWidth, exHeight, exOffX, exOffY;
            if (node && !node.container) {
                if (node && ((node.type === "pseudoGroup") || (node.children && node.children.length > 0))) {
                    exWidth = node.width;
                    exHeight = node.height;
                    exOffX = node.offsetX;
                    exOffY = node.offsetY;
                    if (angleChange)
                        ej.datavisualization.Diagram.Util._updateRotateAngle(node, diagram.nameTable);
                    var bounds = this._getChildrenBounds(diagram, node);
                    var x = bounds.x + bounds.width * node.pivot.x;
                    var y = bounds.y + bounds.height * node.pivot.y;
                    var newposition = { x: x, y: y };
                    if (node.rotateAngle) {
                        var matrix = ej.Matrix.identity();
                        ej.Matrix.rotate(matrix, node.rotateAngle);
                        newposition = ej.Matrix.transform(matrix, newposition);
                    }
                    if (bounds) {
                        node.offsetX = newposition.x;
                        node.offsetY = newposition.y;
                        node.width = bounds.width;
                        node.height = bounds.height;
                    }
                }
            }
        },
        _cloneObject: function (diagram, node, id) {
            if (node) {
                var obj = $.extend(true, {}, node);
                var child;
                if (obj.children && obj.children.length > 0) {
                    for (var i = 0; i < obj.children.length; i++) {
                        obj.children[i] = this._cloneObject(diagram, obj.children[i], id);
                    }
                }
                obj.name += id;
            }
            return obj;
        },
        _removeObject: function (diagram, node) {
            if (node) {
                if (typeof (node) === "string")
                    node = diagram.nameTable[node];
                var child;
                if (node && node.children && node.children.length > 0) {
                    for (var i = 0; i < node.children.length; i++) {
                        this._removeObject(diagram, node.children[i]);
                    }
                }
                if (node)
                    delete diagram.nameTable[node.name];
            }
        },
    }
    //#endregion

})(jQuery, Syncfusion);
(function ($, ej, undefined) {
    "use strict";
    //#region ruler widget
    ej.widget("ejRuler", "ej.datavisualization.ejRuler", {
        element: null,
        validTags: ["div"],
        model: null,
        //#region Initialization
        defaults: {
            offset: 0,
            orientation: "horizontal",
            scale: 1,
            interval: 5,
            segmentWidth: 100,
            arrangeTick: null,
            tickAlignment: "rightorbottom",
            markerColor: "red",
            length: null,
            thickness: 25
        },
        _init: function () {
            if (!(ej.browserInfo().name === "msie" && Number(ej.browserInfo().version) < 9)) {
                this._wireEvents();
                this._renderRuler();
            }
        },

        _renderRuler: function () {
            this._updateRulerGeometry();

        },
        _updateRulerGeometry: function () {
            var size = this.model.length;
            if (!size) {
                if (this.orientation === "horizontal")
                    size = $(this.element[0]).width();
                else size = $(this.element[0]).height();
            }
            this.element[0].style.height = (this.model.orientation === "horizontal" ? this.model.thickness : size) + "px";
            this.element[0].style.width = (this.model.orientation === "horizontal" ? size : this.model.thickness) + "px";
            this.element[0].style.textAlign = "left";
            //this.element[0].setAttribute("id", this.element[0].id + (this.model.orientation === "horizontal" ? "_hRuler" : "_vRuler"));
            //this.element[0].setAttribute("class", (this.model.orientation === "horizontal" ? "sf-diagram_hRuler" : "sf-diagram_vRuler"));
            this._renderRulerSpace();
            this._updateRuler();
        },
        _renderRulerSpace: function () {
            var rulerGeometry = this._getRulerGeometry();
            var div = document.getElementById(this.element[0].id + "_ruler_space");
            if (!div) {
                div = document.createElement("div");
                div.setAttribute("id", this.element[0].id + "_ruler_space");
                div.setAttribute("class", "ej-ruler-space");
                div.style.height = rulerGeometry.height + "px";
                div.style.width = rulerGeometry.width + "px";
                div.style.float = "left";
                this.element[0].appendChild(div);
            }
            return div;
        },
        _updateRuler: function () {
            var rulerSize = this._getRulerSize();
            var rulerGeometry = this._getRulerGeometry();
            var length = 0, offset = 0, availableSize = {};
            var svg = this._getRulerSVG(rulerGeometry);
            if (svg) {
                length = this.model.length;
                availableSize.height = rulerSize;
                offset = this.model.offset;
                if (length && length != Infinity) {
                    var unitLength = length + this.model.segmentWidth;
                    var unitOffset = offset;
                    this._updateSegments(unitOffset, (unitLength + Math.abs(unitOffset)), svg, rulerSize);
                }
            }
        },
        _updateSegments: function (start, end, svg, rulerSize) {
            var run = start;
            var trans = { trans: 0 };
            while (run < end) {
                var rulerSegment = this._getNewSegment(run, svg);
                if (rulerSegment) {
                    svg.document.appendChild(rulerSegment.segment)
                    run = this._updateSegment(start, end, rulerSegment, run, trans, svg, rulerSize);
                }
            }
        },
        _updateSegment: function (start, end, rulerSegment, run, trans, svg, rulerSize) {
            var segWidth = this._updateSegmentWidth(this.model.scale)
            if (run == start) {
                this.model.startValue = Math.floor(start / segWidth) * segWidth / this.model.scale;
                this.model.startValue = (this.model.startValue % 1) != 0 ? Number((this.model.startValue).toFixed(1)) : this.model.startValue;
                rulerSegment.label.textContent = this.model.startValue;
                this._starValue = run = this.model.startValue * this.model.scale;
                if (this.model.orientation === "horizontal")
                    this._hRulerDiff = start - run;
                else
                    this._vRulerDiff = start - run;
            }
            else if (run > end) {
            }
            else if (run > end) {
            }
            else {
                this.model.startValue = (run / this.model.scale);
                this.model.startValue = (this.model.startValue % 1) != 0 ? Number((this.model.startValue).toFixed(1)) : this.model.startValue;
                rulerSegment.label.textContent = this.model.startValue;
            }
            this._updateTickLabel(rulerSegment, rulerSize);
            if (this.model.orientation === "horizontal")
                rulerSegment.segment.setAttribute("transform", "translate(" + trans.trans + " 0)");
            else
                rulerSegment.segment.setAttribute("transform", "translate(0 " + trans.trans + ")");
            trans.trans += segWidth;
            run += segWidth;
            return run;
        },
        _updateTickLabel: function (segment, rulerSize) {
            var attr, bbox;
            if (this.model.orientation === "horizontal") {
                if (this.model.tickAlignment === "rightorbottom")
                    attr = { "x": 2, "y": (rulerSize / 2 + (11 / 2) - (11 / 2)) }
                else
                    attr = { "x": 2, "y": (rulerSize / 2 + (11 / 2)), }
            }
            else {
                bbox = segment.segment.lastChild.getBBox();
                if (this.model.tickAlignment === "rightorbottom")
                    attr = { "x": 0, "y": bbox.height, "font-size": "11", "transform": "rotate(270)" + "translate(" + -(bbox.width + 2) + " " + ((rulerSize / 2) - bbox.height) + ")" };
                else
                    attr = { "x": 0, "y": bbox.height, "font-size": "11", "transform": "rotate(270)" + "translate(" + -(bbox.width + 2) + " " + ((rulerSize / 2) - bbox.height / 2) + ")" };
            }
            ej.datavisualization.Diagram.Util.attr(segment.segment.lastChild, attr);
        },
        _getNewSegment: function (run, svg) {
            var segment = this._createNewTicks(run, svg);
            var label = this._createTickLabel(svg, segment);
            return { segment: segment, label: label };
        },
        _createNewTicks: function (run, svg) {
            var tick, i, tickInterval;
            var segmentWidth = this._updateSegmentWidth(this.model.scale)
            var g = svg.g({ "class": "ej-ruler-segment" });
            for (i = 0; i < this.model.interval; i++) {
                tickInterval = segmentWidth / this.model.interval;
                tick = this._createTick(svg, tickInterval, i + 1, run);
                g.appendChild(tick);
            }
            return g;
        },
        _getLinePoint: function (svg, tickInterval, length) {
            var segmentWidth = this._updateSegmentWidth(this.model.scale)
            var rulerSize = this._getRulerSize(), length;
            tickInterval = tickInterval * (length - 1);
            if ((tickInterval % segmentWidth) == 0) {
                length = rulerSize;
            }
            else {
                length = rulerSize * 0.3;
            }
            return length;
        },
        _createTick: function (svg, tickInterval, length, run) {
            var ruler, svg, line;
            var linePoint = this._getLinePoint(svg, tickInterval, length);
            var rulerSize = this._getRulerSize(), args, attr;
            var arrangeTick = this.model.arrangeTick;
            if (typeof arrangeTick == "string") arrangeTick = ej.util.getObject(arrangeTick, window);
            if ($.isFunction(arrangeTick)) {
                args = { ruler: ruler, tickLength: linePoint, tickInterval: Number((run + tickInterval * (length - 1)).toFixed(1)) }
                arrangeTick(args);
                linePoint = args.tickLength;
            }
            if (this.model.orientation === "horizontal") {
                var xPoint = tickInterval * (length - 1);
                if (this.model.tickAlignment === "rightorbottom")
                    attr = { "x1": xPoint, "y1": rulerSize, "x2": xPoint, "y2": rulerSize - linePoint, "stroke-width": "1" };
                else
                    attr = { "x1": xPoint, "y1": rulerSize - (rulerSize - linePoint), "x2": xPoint, "y2": 0, "stroke-width": "1" };
                line = svg.line(attr);
            }
            else {
                var yPoint = tickInterval * (length - 1);
                if (this.model.tickAlignment === "rightorbottom")
                    attr = { "x1": rulerSize, "y1": yPoint, "x2": rulerSize - linePoint, "y2": yPoint, "stroke-width": "1" }
                else
                    attr = { "x1": 0, "y1": yPoint, "x2": rulerSize - (rulerSize - linePoint), "y2": yPoint, "stroke-width": "1" }
                line = svg.line(attr);
            }
            line.setAttribute("class", "ej-ruler-tick")
            return line;
        },
        _createTickLabel: function (svg, segment) {
            if (segment) {
                var attr = { "class": "ej-ruler-tick-label" };
                var text = svg.text(attr);
                segment.appendChild(text);
            }
            return text;
        },
        _updateSegmentWidth: function (scale) {
            if (this.model.segmentWidth != 100)
                return this.model.segmentWidth;
            var five = 25, multiples = 1, div, scaleRound, fifty = 100;
            scaleRound = Math.pow(2, Math.round(Math.log(scale) / Math.log(2)));
            div = fifty;
            //if (Ruler.Scale >= 1)
            {
                div = (fifty / scaleRound);
            }
            while (div > 100) {
                multiples /= 10;
                div /= 10;
            }
            while (div < 25) {
                multiples *= 10;
                div *= 10;
            }
            if (div >= five && div % five != 0) {
                div = Math.round(div / five) * five;
            }
            return div * scale / multiples;
        },

        _getRulerGeometry: function () {
            return {
                width: $(this.element[0]).width(),
                height: $(this.element[0]).height()
            };
        },
        _getRulerSize: function () {
            return this.model.thickness;
        },
        _getRulerSVG: function (rulerGeometry) {
            var rulerSpace, i, rulerSize = this._getRulerSize(), svg;
            rulerSpace = document.getElementById(this.element[0].id + "_ruler_space");
            if (rulerSpace) {
                svg = new ej.datavisualization.Diagram.Svg({
                    "id": this.element[0].id + "_Ruler_svg",
                    width: this.model.orientation === "horizontal" ? rulerGeometry.width : rulerSize,
                    height: this.model.orientation === "horizontal" ? rulerSize : rulerGeometry.height,
                    style: "position:inherit;"
                });
                if (rulerSpace.childNodes.length > 0) {
                    for (i = rulerSpace.childNodes.length - 1; i >= 0 ; i--) {
                        rulerSpace.childNodes[i].parentNode.removeChild(rulerSpace.childNodes[i]);
                    }
                }
                rulerSpace.appendChild(svg.document);
            }
            return svg;
        },
        _setModel: function (options) {
            for (var option in options) {
                switch (option) {
                    case "offset":
                    case "length":
                    case "interval":
                    case "segmentWidth":
                    case "tickAlignment":
                    case "markerColor":
                    case "thickness":
                        this._updateRuler();
                        break;
                    case "arrangeTick":
                        this._updateRuler();
                        this.model.arrangeTick = options.arrangeTick;
                        break;
                }
            }
        },
        _destroy: function () {
            this.element.empty().removeClass(this.model.cssClass);
        },
        //#endregion

        //#region Events
        _wireEvents: function () {

        },
        //#endregion
    });
    //#endregion
})(jQuery, Syncfusion);



;
/**
* @fileOverview Plugin to style the Html Overview elements
* @copyright Copyright Syncfusion Inc. 2001 - 2020. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">Syncfusion Inc</a>
*/
(function ($, ej, undefined) {
    "use strict";
    //#region Overview widget
    ej.widget("ejOverview", "ej.datavisualization.Overview", {
        element: null,
        validTags: ["div"],
        model: null,
        //#region Initialization
        defaults: {
            sourceID: "",
            width: null,
            height: null
        },
        _canvas: null,
        _actionName: "",
        _startPoint: null,
        _currentPoint: null,
        _prevPoint: null,
        _helper: null,
        _viewPortRatio: 1,
        _resizeDirection: "",
        _inAction: false,
        _init: function () {
            if (!(ej.browserInfo().name === "msie" && Number(ej.browserInfo().version) < 9)) {
                this._wireEvents();
                this._renderCanvas();
                this._setParent(this.model.sourceID);
            }
        },
        _renderCanvas: function () {
            var canvas = $("#" + this.element[0].id + "_canvas")[0];
            if (!canvas) {
            var canvas = document.createElement("div");
                this.element.append(canvas);
            }
            canvas.setAttribute("id", this.element[0].id + "_canvas");
            canvas.setAttribute("class", "drawing");
            canvas.setAttribute("style", "position:relative; height:" + this.model.height + "; width:" + this.model.width + ";style:-ms-touch-action: none;touch-action: none;");
            this.element[0].setAttribute("tabindex", "0");
            this.element.css({
                overflow: "hidden", outline: "none", display: "block", height: this.model.height, width: this.model.width
            });
            this._canvas = canvas;
        },
        _renderDocument: function (view) {
            view.canvas = this._canvas;
            if (window.SVGSVGElement) {
                var svg = $("#" + this._canvas.id + "_svg")[0];
                if (svg)
                    svg.parentNode.removeChild(svg);
                var attr = {
                    id: this._canvas.id + "_svg",
                    version: "1.1",
                    xlink: "http://www.w3.org/1999/xlink",
                    "style": view.style,
                    "class": "overview_svg"
                };
                var svg = new ej.datavisualization.Diagram.Svg(attr);
                this._svg = svg;
                view.svg = svg;
                var ovw = document.getElementById(this._id);
                var element = ovw;
                var eWidth = $(element).width();
                var eHeight = $(element).height();
                var bRect = element.getBoundingClientRect();
                var screenX = (window.screenX < 0) ? window.screenX * -1 : window.screenX;
                if (eWidth === 0) {
                    eWidth = Math.floor(((window.innerWidth - screenX) - Math.floor(bRect.left)));
                }
                var screenY = (window.screenY < 0) ? window.screenY * -1 : window.screenY;
                if (eHeight === 0) {
                    eHeight = Math.floor(((window.innerHeight - screenY) - Math.floor(bRect.top)));
                }
                svg.document.setAttribute("width", eWidth);
                svg.document.setAttribute("height", eHeight);
                this.width = eWidth;
                this.height = eHeight;
                view.diagramLayer = ej.datavisualization.Diagram.SvgContext._renderDiagramLayer(view.canvas, view.svg, view.svg);
                var defs = svg.defs({ "id": view.canvas.id + "patterndefinition" });
                svg.appendChild(defs);
                view.canvas.appendChild(svg.document);
                svg._htmlLayer = this._renderHtmlLayer(view.canvas);
                this._addOverviewRectPanel(view);
            }
        },
        _removeDocument: function (view) {
            var svg = document.getElementById(this._canvas.id + "_svg");
            this._canvas.removeChild(svg);
            var htmlLayer = document.getElementById(this._canvas.id + "_htmlLayer");
            this._canvas.removeChild(htmlLayer);
            //var rect = document.getElementById("overview_canvasrect");
            //this._canvas.removeChild(rect);
        },
        _renderHtmlLayer: function (canvas) {
            var div = document.createElement("div");
            var attr = { "id": canvas.id + "_htmlLayer", "class": "htmlLayer" };
            ej.datavisualization.Diagram.Util.attr(div, attr);
            var htmlLayer = div;
            div.style.pointerEvents = "none";
            div.style.position = "absolute";
            div.style.left = "0px";
            div.style.top = "0px";
            canvas.appendChild(htmlLayer);
            return htmlLayer;
        },
        _setModel: function (options) {
            var updateSize = false;
            for (var option in options) {
                switch (option) {
                    case "sourceID":
                        this._setParent(options[option]);
                        break;
                    case "width":
                    case "height":
                        if (!updateSize) {
                            this._renderCanvas();
                            this._setParent(this.model.sourceID);
                }
                        updateSize = true;
                        break;
            }
            }
        },
        _setParent: function (diagram) {
            if (this._parent) {
                var oldparent = $("#" + this._parent._id).ejDiagram("instance");
                this._parent = null;
                oldparent._setOverview(null, this._id);
            }
            if (diagram) {
                this.model.sourceID = diagram;
                this._parent = $("#" + diagram).ejDiagram("instance");
                if (this._parent)
                    this._parent._setOverview(this);
            }
        },
        _destroy: function () {
            this.element.empty().removeClass(this.model.cssClass);
        },
        //#endregion
        //#region Events
        _wireEvents: function () {
            var canvas = $(this._canvas);
            this._on(canvas, ej.eventType.mouseDown, this._mousedown);
            this._on(canvas, ej.eventType.mouseMove, this._mousemove);
            this._on(canvas, ej.eventType.mouseUp, this._mouseup);
            this._on(canvas, ej.eventType.mouseLeave, this._documentmouseup);
            this._on(canvas, "touchstart", this.handleTouchStart);
            this._on(canvas, "touchmove", this.handleTouchMove);
            this._on(canvas, "touchend", this.handleTouchEnd);
        },
        _mouseup: function (evt) {
            this._currentPoint = this._mouseposition(evt);
            var offwidth = this.width;
            var offheight = this.height;
            if (this._actionName)
                if ((this._startPoint.x != this._currentPoint.x || this._startPoint.y != this._currentPoint.y)) {
                    if (this._actionName == "pan") { }
                    else {
                        if (this._helper) {
                            var bounds = this._helper.getBBox();
                            this._resizeDirection = this._resizeDirection || "";
                            var x = bounds.x;
                            var y = bounds.y;
                            var width = bounds.width;
                            var height = bounds.height;
                            var adjust = this._resizeDirection == "topleft" || this._resizeDirection == "topright" || this._resizeDirection == "bottomleft" ||
                                this._resizeDirection == "bottomright";
                            this._renderOverviewRect(x, y, width, height);
                        }
                    }
                }
                else
                    if (evt.target.id == this._canvas.id + "overviewbackrect" || evt.target.id == "helper")
                        if (this._startPoint.x == this._currentPoint.x && this._startPoint.y == this._currentPoint.y) {
                            var g = document.getElementById(this._canvas.id + "overviewrect");
                            var bounds = g.getBBox();
                            var width = bounds.width || 100;
                            var height = bounds.height || 100 / this._viewPortRatio;
                            this.inAction = true;
                            this._actionName = "pan";
                            this._renderOverviewRect(this._currentPoint.x - width / 2, this._currentPoint.y - height / 2, width, height);
                            this.inAction = false;
                        }
            if (this._helper) {
                var g = document.getElementById(this._canvas.id + "overviewhandle");
                g.removeChild(this._helper);
                this._helper = null;
            }
            this._actionName = "";
            this._startPoint = null;
            this._currentPoint = null;
            this._prevPoint = null;
            this._helper = null;
            this._viewPortRatio = 1;
            this._resizeDirection = "";
            this._inAction = false
        },
        _mousedown: function (evt) {
            if (evt.target.className.animVal == "overviewbackrect")
                this._actionName = "draw";
            if (evt.target.id == this._canvas.id + "overviewrect") this._actionName = "pan";
            if (evt.target.className.animVal == "overviewresizer") {
                this._actionName = "scale";
                switch (evt.target.id) {
                    case this._canvas.id + "left":
                        this._resizeDirection = "left";
                        break;
                    case this._canvas.id + "right":
                        this._resizeDirection = "right"; break;
                    case this._canvas.id + "top":
                        this._resizeDirection = "top"; break;
                    case this._canvas.id + "bottom":
                        this._resizeDirection = "bottom"; break;
                    case this._canvas.id + "topleft":
                        this._resizeDirection = "topleft"; break;
                    case this._canvas.id + "topright":
                        this._resizeDirection = "topright"; break;
                    case this._canvas.id + "bottomleft":
                        this._resizeDirection = "bottomleft"; break;
                    case this._canvas.id + "bottomright":
                        this._resizeDirection = "bottomright"; break;
                }
            }
            this._startPoint = this._prevPoint = this._mouseposition(evt);
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            this._viewPortRatio = viewPort.width / viewPort.height;
        },
        _mouseposition: function (evt) {
            var e = this._parent._isTouchEvent(evt);
            if (!e) {
                e = evt;
            }
            var scrollLeft = this._canvas.scrollLeft;
            var scrollTop = this._canvas.scrollTop;
            var controlBBox = this._canvas.getBoundingClientRect();
            var layerx = (e.clientX + scrollLeft) - controlBBox.left;
            var layery = (scrollTop + e.clientY) - controlBBox.top;
            return new ej.datavisualization.Diagram.Point(layerx, layery);
        },
        _updateCursor: function (evt) {
            if (evt.target.className.animVal == "overviewresizer") {
                switch (evt.target.id) {
                    case this._canvas.id + "left":
                        this._canvas.style.cursor = "w-resize";
                        break;
                    case this._canvas.id + "right":
                        this._canvas.style.cursor = "e-resize"; break;
                    case this._canvas.id + "top":
                        this._canvas.style.cursor = "n-resize"; break;
                    case this._canvas.id + "bottom":
                        this._canvas.style.cursor = "s-resize"; break;
                    case this._canvas.id + "topleft":
                        this._canvas.style.cursor = "nw-resize"; break;
                    case this._canvas.id + "topright":
                        this._canvas.style.cursor = "ne-resize"; break;
                    case this._canvas.id + "bottomleft":
                        this._canvas.style.cursor = "sw-resize"; break;
                    case this._canvas.id + "bottomright":
                        this._canvas.style.cursor = "se-resize"; break;
                }
            }
            else this._canvas.style.cursor = "default";
        },
        _mousemove: function (evt) {
            this._updateCursor(evt);
            this._currentPoint = this._mouseposition(evt);
            if (this._actionName)
                switch (this._actionName) {
                    case "draw":
                        if (!this._inAction && (this._startPoint.x != this._currentPoint.x || this._startPoint.y == this._currentPoint.y)) {
                            this._initHelper();
                            this._inAction = true;
                        }
                        if (this._inAction)
                            this._updateHelper();
                        break;
                    case "scale":
                        if (!this._inAction) {
                            this._initHelper();
                            this._inAction = true;
                        }
                        this._updateOverviewRectangle();
                        break;
                    case "pan":
                        if ((this._startPoint.x != this._currentPoint.x || this._startPoint.y == this._currentPoint.y) || this._inAction) {
                            this._inAction = true;
                            this._translateOverviewRectangle();
                        }
                        break;

                }
            this._prevPoint = this._currentPoint;
        },
        _documentmouseup: function (evt) {
            this._inAction = false;
            this._actionName = "";
            if (this._helper) {
                var g = document.getElementById(this._canvas.id + "overviewhandle");
                g.removeChild(this._helper);
                this._helper = null;
            }
        },
        _addOverviewRectPanel: function (view) {
            var svg = $("#" + this._canvas.id + "_overviewsvg")[0];
            if (svg)
                svg.parentNode.removeChild(svg)
            svg = new ej.datavisualization.Diagram.Svg({
                id: this._canvas.id + "_overviewsvg",
                version: "1.1",
                xlink: "http://www.w3.org/1999/xlink",
                "style": "position:absolute;left:0px;top:0px",
                width: this.width,
                height: this.height
            });
            this._canvas.appendChild(svg.document);
            var ovw = svg.g({ "id": this._id + "_overviewlayer" });
            svg.appendChild(ovw);
            var rect = svg.rect({ "fill": "transparent", "width": "100%", "height": "100%", "class": "overviewbackrect", "id": this._canvas.id + "overviewbackrect" });
            ovw.appendChild(rect);
            var svgDocument = $(ovw);
            this._on(svgDocument, ej.eventType.mouseDown, this._mousedown);
            this._on(svgDocument, ej.eventType.mouseMove, this._mousemove);
            this._on(svgDocument, ej.eventType.mouseUp, this._mouseup);
            this._on(svgDocument, ej.eventType.mouseLeave, this._documentmouseup);
            this._on(svgDocument, "touchstart", this.handleTouchStart);
            this._on(svgDocument, "touchmove", this.handleTouchMove);
            this._on(svgDocument, "touchend", this.handleTouchEnd);
            var g = svg.g({ "id": this._canvas.id + "overviewhandle" });
            ovw.appendChild(g);
            var innerrect = svg.rect({ "id": this._canvas.id + "overviewrect", "fill": "transparent" });
            g.appendChild(innerrect);
            this._renderOverviewCorner("left", g);
            this._renderOverviewCorner("right", g);
            this._renderOverviewCorner("top", g);
            this._renderOverviewCorner("bottom", g);
            this._renderOverviewCorner("topleft", g);
            this._renderOverviewCorner("topright", g);
            this._renderOverviewCorner("bottomleft", g);
            this._renderOverviewCorner("bottomright", g);
        },
        _updateOverview: function (view) {
            view = view || this._parent._views[this._id];
            var width, height;
            var bounds = this._parent._getDigramBounds();
            width = bounds.width;
            height = bounds.height;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            var offwidth = this.width;
            var offheight = this.height;
            if (view.context == ej.datavisualization.Diagram.SvgContext) {
                var w = Math.max(width, viewPort.width);
                var h = Math.max(height, viewPort.height);
                this.contentWidth = w = Math.max(w, (offwidth / offheight) * h);
                this.contentHeight = h = Math.max(h, (offheight / offwidth) * w);
                var g = document.getElementById(this._canvas.id + "_diagramLayer");
                var scale = Math.min(offwidth / w, offheight / h);
                this.scale = scale;
                g.setAttribute("transform", "scale(" + scale + "," + scale + "),translate(" + -bounds.x + "," + (-bounds.y) + ")");
                var htmlLayer = document.getElementById(this._canvas.id + "_htmlLayer");
                htmlLayer.style.webkitTransform = "scale(" + scale + ") translate(" + -bounds.x + "px," + (-bounds.y) + "px)";
                htmlLayer.style.MozTransform = "scale(" + scale + ") translate(" + -bounds.x + "px," + (-bounds.y) + "px)";
                htmlLayer.style.OTransform = "scale(" + scale + ") translate(" + -bounds.x + "px," + (-bounds.y) + "px)";
                htmlLayer.style.msTransform = "scale(" + scale + ") translate(" + -bounds.x + "px," + (-bounds.y) + "px)";
                htmlLayer.style.transform = "scale(" + scale + ") translate(" + -bounds.x + "px," + (-bounds.y) + "px)";
                // if (bounds.x < 0 || bounds.y < 0) 
                {
                    var ovw = document.getElementById(this._id + "_overviewlayer");
                    ovw.setAttribute("transform", "translate(" + (-bounds.x * scale) + "," + (-bounds.y * scale) + ")");
                }
            }
            else {
                var context = view._canvas.document.getContext("2d");
                if (view.scale) {
                    context.scale(1 / view.scale.x, 1 / view.scale.y);
                }
                view.scale = { x: scale, y: scale };
                context.scale(scale, scale);
                ej.datavisualization.Diagram.CanvasContext.refreshCanvas(this._parent.model, view);
            }
            this._scrollOverviewRect(this._parent._hScrollOffset, this._parent._vScrollOffset, this._parent._currZoom);
        },
        _updateOverviewRectangle: function () {
            var difx = this._currentPoint.x - this._prevPoint.x;
            var dify = this._currentPoint.y - this._prevPoint.y;
            if (this._actionName == "scale") {
                var size = { "width": 0, "height": 0 };
                var x = 0, y = 0; var w, h;
                switch (this._resizeDirection) {
                    case "left":
                        size.width -= difx;
                        size.height -= difx / this._viewPortRatio;
                        x = difx;
                        y = difx / this._viewPortRatio;
                        y /= 2;
                        break;
                    case "right":
                        size.width += difx;
                        size.height += difx / this._viewPortRatio;
                        y = difx / this._viewPortRatio;
                        y /= -2;
                        break;
                    case "top":
                        size.height -= dify;
                        size.width -= dify * this._viewPortRatio;
                        y = dify;
                        x = dify * this._viewPortRatio;
                        x /= 2;
                        break;
                    case "bottom":
                        size.height += dify;
                        size.width += dify * this._viewPortRatio;
                        x = dify * this._viewPortRatio;
                        x /= -2;
                        break;
                    case "topleft":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = dify * this._viewPortRatio; }
                        else
                            dify = difx / this._viewPortRatio;
                        size.width -= difx;
                        size.height -= dify;
                        x = difx;
                        y = dify;
                        break;
                    case "topright":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = -dify * this._viewPortRatio; }
                        else
                            dify = -(difx / this._viewPortRatio);
                        y = dify;
                        size.width += difx;
                        size.height -= dify;
                        break;
                    case "bottomleft":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = -dify * this._viewPortRatio; }
                        else
                            dify = -difx / this._viewPortRatio;
                        x = difx;
                        size.width -= difx;
                        size.height += dify;
                        break;
                    case "bottomright":
                        if (Math.abs(dify) > Math.abs(difx)) { difx = dify * this._viewPortRatio; }
                        else
                            dify = difx / this._viewPortRatio;
                        size.width += difx;
                        size.height += dify;
                        break;
                }
                this._updateHelper(x, y, size, w, h);
            }
        },
        _initHelper: function () {
            if (!this._helper) {
                var svg = this._svg;
                var g = document.getElementById(this._canvas.id + "overviewhandle");
                var scale = this._parent._currZoom;
                var x = this._startPoint.x;
                var y = this._startPoint.y; var width = 1; var height = 1;
                if (this._actionName == "scale") {
                    var rect = document.getElementById(this._canvas.id + "overviewrect");
                    var bounds = rect.getBBox();
                    x = bounds.x; y = bounds.y; width = bounds.width; height = bounds.height;
                }
                var selectionRect = svg.rect({
                    "id": "helper", x: x, y: y, width: width, height: height,
                    "fill": "transparent", "stroke": "gray", "stroke-dasharray": "2 2", "shape-rendering": "crispEdges"
                });
                g.appendChild(selectionRect);
                this._helper = selectionRect;
            }
        },
        _updateHelper: function (difx, dify, size) {
            if (size) {
                var bounds = this._helper.getBBox();
                var x = bounds.x + difx;
                var y = bounds.y + dify;
                var width = bounds.width + size.width;
                var height = bounds.height + size.height;
            }
            else {
                var difx;
                if (this._currentPoint.x > this._startPoint.x)
                    difx = this._currentPoint.x - this._prevPoint.x;
                else
                    difx = this._prevPoint.x - this._currentPoint.x;
                var dify;
                if (this._currentPoint.y > this._startPoint.y)
                    dify = this._currentPoint.y - this._prevPoint.y;
                else dify = this._prevPoint.y - this._currentPoint.y;
                var w, h;
                if (Math.abs(dify) > Math.abs(difx)) {
                    difx = this._viewPortRatio * dify; h = true; w = false;
                }
                else { dify = difx / this._viewPortRatio; w = true; h = false; }
                var bounds = this._helper.getBBox();
                var x = ((this._startPoint.x > this._currentPoint.x) ?
                    bounds.x - difx : bounds.x);
                var y = ((this._startPoint.y > this._currentPoint.y) ? bounds.y - dify : bounds.y);
                var width = bounds.width + difx;
                var height = bounds.height + dify;
            }
            if (this._helper) {
                ej.datavisualization.Diagram.Util.attr(this._helper, {
                    "id": this._helper.id, "x": x, "y": y,
                    "width": (width < 0) ? 0 : width, "height": (height < 0) ? 0 : height
                });
            }
        },
        _renderOverviewCorner: function (name, parent) {
            var svg = this._svg;
            if (name == "top" || name == "bottom" || name == "right" || name == "left") {
                var innerrect = svg.rect({ "id": this._canvas.id + "visible" + name });
                parent.appendChild(innerrect);
                var transrect = svg.rect({ "id": this._canvas.id + name, "class": "overviewresizer", "fill": "transparent" });
                parent.appendChild(transrect);
            }
            else {
                var innerrect = svg.circle({ "id": this._canvas.id + "visible" + name });
                parent.appendChild(innerrect);
                var transrect = svg.circle({ "id": this._canvas.id + name, "class": "overviewresizer", "fill": "transparent" });
                parent.appendChild(transrect);
            }
        },
        _updateOverviewrect: function (x, y, width, height) {
            if (width && height) {
                var rect = document.getElementById(this._canvas.id + "overviewrect");
                var attr = { x: x, y: y, width: Math.max(1, width), height: Math.max(1, height) };
                ej.datavisualization.Diagram.Util.attr(rect, attr);
                this._updateOverviewCorner("top", x + 8, y - 2, Math.max(0, width - 16), 2);
                this._updateOverviewCorner("bottom", x + 8, y + height, Math.max(0, width - 16), 2);
                this._updateOverviewCorner("left", x - 2, y + 8, 2, Math.max(0, height - 16));
                this._updateOverviewCorner("right", x + width, y + 8, 2, Math.max(0, height - 16));
                this._updateOverviewCorner("topleft", x, y, 5, 5);
                this._updateOverviewCorner("topright", x + width, y, 5, 5);
                this._updateOverviewCorner("bottomleft", x, y + height, 5, 5);
                this._updateOverviewCorner("bottomright", x + width, y + height, 5, 5);
            }
        },
        _scrollOverviewRect: function (hoffset, voffset, currentzoom, isoverviewresize) {
            if (!(this._actionName) || isoverviewresize) {
                var offwidth = this.width;
                var offheight = this.height;
                var scale = Math.min(this.contentWidth / offwidth, this.contentHeight / offheight);
                var bounds = {};
                var x = bounds.x = (hoffset / currentzoom) / scale;
                var y = bounds.y = (voffset / currentzoom) / scale;
                var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
                var width = bounds.width = (viewPort.width / currentzoom) / scale;
                var height = bounds.height = (viewPort.height / currentzoom) / scale;
                var ratio = viewPort.width / viewPort.height;
				if(isoverviewresize)
					return { x:x, y:y, width:width, height:height };
                this._updateOverviewrect(x, y, width, height);
            }
        },
        _updateOverviewCorner: function (name, x, y, width, height) {
            var rectname = "visible" + name;
            var rect = document.getElementById(this._canvas.id + rectname);
            if (name == "top" || name == "bottom" || name == "right" || name == "left") {
                var attr = { x: x, y: y, width: width, height: height, fill: "#ED1C24" };
                var transattr = { x: x - 2, y: y - 2, width: width == 2 ? 4 : width, height: height == 2 ? 4 : height };
            }
            else {
                var attr = { cx: x, cy: y, "r": 4, fill: "#ED1C24" };
                var transattr = { cx: x, cy: y, "r": 6, fill: "transparent" };
            }
            ej.datavisualization.Diagram.Util.attr(rect, attr);
            var transrect = document.getElementById(this._canvas.id + name);
            ej.datavisualization.Diagram.Util.attr(transrect, transattr);
        },
        _translateOverviewRectangle: function () {
            var offwidth = this.width;
            var offheight = this.height;
            var difx = this._currentPoint.x - this._prevPoint.x;
            var dify = this._currentPoint.y - this._prevPoint.y;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            var zoom = Math.min(viewPort.width / offwidth, viewPort.height / offheight);
            var panel = document.getElementById(this._canvas.id + "overviewrect");
            var bounds = panel.getBBox();
            var x = bounds.x + difx;
            var y = bounds.y + dify;
            var width = bounds.width;
            var height = bounds.height;
            this._updateOverviewrect(x, y, width, height);
            this._updateView(this._parent._currZoom, x, y, width, height, null);
        },
        _updateView: function (zoom, x, y, width, height, focuspoint) {
            var offwidth = this.width;
            var offheight = this.height;
            var scalex = this.contentWidth / offwidth;
            var scaley = this.contentHeight / offheight;
            var hoffset = x * scalex * zoom;
            var voffset = y * scaley * zoom;
            var bounds = this._parent._getDigramBounds();
            if (zoom != 1 || this._actionName == "pan") {
                var scrollModel = $("#" + this._parent._canvas.id + "_hScrollbar").ejScrollBar("instance").model;
                var scrollwidth = -hoffset + (scrollModel.maximum);
                var delx = -hoffset + this._parent._hScrollOffset;;
                var dely = -voffset + this._parent._vScrollOffset;
                if (bounds.width * zoom < scrollwidth) {
                    var difwidth = bounds.width * zoom - scrollwidth;
                    if (Math.abs(difwidth) < Math.abs(delx)) {
                        delx = delx - difwidth;
                    }
                    //else delx = 0;
                }
                scrollModel = $("#" + this._parent._canvas.id + "_vScrollbar").ejScrollBar("instance").model;
                var scrollheight = -voffset + (scrollModel.maximum);
                if (bounds.height * zoom < scrollheight) {
                    var difwidth = bounds.height * zoom - scrollheight;
                    if (Math.abs(difwidth) < Math.abs(dely)) {
                        dely = dely - difwidth;
                    }
                    //else dely = 0;
                }
            }
            ej.datavisualization.Diagram.ZoomUtil.zoomPan(this._parent, zoom / this._parent._currZoom, delx, dely, focuspoint, false);
        },
        _renderOverviewRect: function (x, y, width, height) {
            var offwidth = this.width;
            var offheight = this.height;
            var viewPort = ej.datavisualization.Diagram.ScrollUtil._viewPort(this._parent);
            var viewwidth = (width / offwidth) * this.contentWidth;
            var viewheight = (height / offheight) * this.contentHeight;
            var zoom = Math.max(viewPort.width / viewwidth, viewPort.height / viewheight);
            if (zoom >= 0.25 && zoom <= 30) {
                this._updateView(zoom, x, y, width, height, new ej.datavisualization.Diagram.Point(0, 0));
				var bounds = this._scrollOverviewRect( this._parent._hScrollOffset, this._parent._vScrollOffset, this._parent._currZoom, true);
				this._updateOverviewrect(bounds.x, bounds.y, bounds.width, bounds.height);
            }
        },
        handleTouchStart: function (evt) {
            evt.preventDefault();
        },
        handleTouchMove: function (evt) {
            evt.preventDefault();
        },
        handleTouchEnd: function (evt) {
            evt.preventDefault();
        },
        handleTouchLeave: function (evt) {
            evt.preventDefault();
        },
        //#endregion
    });
    //#endregion
})(jQuery, Syncfusion);;

(function ($, ej) {
    "use strict";

    //#region SVG
    var Canvas = (function () {
        function Canvas(attr) {
            this.document = document.createElement("canvas");
            this.id = attr.id;
            this._scaleX = 1;
            this._scaleY = 1;
            if (attr) {
                ej.datavisualization.Diagram.Util.attr(this.document, attr);
            }
            return this;
        }

        //rect
        Canvas.prototype.rect = function (x, y, width, height, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style) {
                this.setStyle(style, ctx);
                if (style.dashArray)
                    this.dashedRectangle(x, y, width, height, style.dashArray);
            }
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }
        //Rounded rect
        Canvas.prototype.roundedRect = function (x, y, width, height, radius, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            var points = [{ x: x + radius, y: y }, { x: x + width - radius, y: y },
                { x: x + width, y: y + radius }, { x: x + width, y: y + height - radius },
                { x: x + width - radius, y: y + height }, { x: x + radius, y: y + height },
                { x: x, y: y + height - radius }, { x: x, y: y + radius }
            ];
            var corners = [{ x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];
            var corner = 0;
            var point2, next;
            if (style)
                this.setStyle(style, ctx);
            //draw
            ctx.moveTo(points[0].x, points[0].y);
            var i;
            for (i = 0; i < points.length; i = i + 2) {
                point2 = points[i + 1];
                ctx.lineTo(point2.x, point2.y);
                next = points[i + 2] || points[0];
                ctx.quadraticCurveTo(corners[corner].x, corners[corner].y, next.x, next.y);
                corner++;
            }
            ctx.fill();
            if (style && style.dashArray) {
                corner = 0;
                for (i = 0; i < points.length; i = i + 2) {
                    this.dashedLine(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, style.dashArray);
                    this.quadraticCurve(points[i + 1], corners[corner], points[i + 2] || points[0], style);
                    corner++;
                }
            }
            ctx.stroke();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }
        //ellipse
        Canvas.prototype.ellipse = function (cx, cy, rx, ry, rotation, style) {
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            var r = 4 * ((Math.sqrt(2) - 1) / 3);
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.moveTo(cx, cy - ry);
            ctx.bezierCurveTo(cx + (r * rx), cy - ry, cx + rx, cy - (r * ry), cx + rx, cy);
            ctx.bezierCurveTo(cx + rx, cy + (r * ry), cx + (r * rx), cy + ry, cx, cy + ry);
            ctx.bezierCurveTo(cx - (r * rx), cy + ry, cx - rx, cy + (r * ry), cx - rx, cy);
            ctx.bezierCurveTo(cx - rx, cy - (r * ry), cx - (r * rx), cy - ry, cx, cy - ry);
            ctx.fill();
            if (style && style.dashArray) {
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx, cy - ry),
                    new ej.datavisualization.Diagram.Point(cx + (r * rx), cy - ry),
                    new ej.datavisualization.Diagram.Point(cx + rx, cy - (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx + rx, cy), style);
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx + rx, cy),
                    new ej.datavisualization.Diagram.Point(cx + rx, cy + (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx + (r * rx), cy + ry),
                    new ej.datavisualization.Diagram.Point(cx, cy + ry), style);
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx, cy + ry),
                    new ej.datavisualization.Diagram.Point(cx - (r * rx), cy + ry),
                    new ej.datavisualization.Diagram.Point(cx - rx, cy + (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx - rx, cy), style);
                this.bezierCurve(ej.datavisualization.Diagram.Point(cx - rx, cy),
                    new ej.datavisualization.Diagram.Point(cx - rx, cy - (r * ry)),
                    new ej.datavisualization.Diagram.Point(cx - (r * rx), cy - ry),
                    new ej.datavisualization.Diagram.Point(cx, cy - ry), style);
            }
            ctx.stroke();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //circle
        Canvas.prototype.circle = function (centerx, centery, radius, rotation, style) {
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style && style.dashArray) {
                ctx.beginPath();
                ctx.arc(centerx, centery, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.closePath();
            }
            else { this.ellipse(centerx, centery, radius * 2, radius * 2, rotation, style); }
            if (rotation && rotation.angle)
                ctx.restore();
        }
        Canvas.prototype.arc = function (centerx, centery, radius, angle, sweep, style) {
            var rotation = { "angle": angle, x: centerx, y: centery };
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.beginPath();
            var stAngle = 0;
            var endAngle = Math.PI;
            if (!sweep) {
                stAngle = Math.PI;
                endAngle = 0;
            }
            if (style && style.dashArray) {
                ctx.arc(centerx, centery, radius, stAngle, endAngle);
            }
            else { ctx.arc(centerx, centery, radius, stAngle, endAngle); }
            //ctx.fill();
            ctx.stroke();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //path
        Canvas.prototype.path = function (path, x, y, width, height, rotation, style) {
            var ctx = this.document.getContext("2d");
            if (style) {
                this.setStyle(style, ctx);
            }
            ctx.beginPath();
            var transX = x, transY = y;
            ctx.translate(transX, transY);
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            var shape = document.createElementNS('http://www.w3.org/2000/svg', "path");
            shape.setAttribute("d", path);
            this.document.appendChild(shape);
            var segments = this.getSegments(shape);
            var offsetX = x;
            var offsetY = y;
            var pathstr = "";
            var x0, y0, x1, y1, x2, y2, segs = segments;
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.command;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
                switch (char) {
                    case 'M':
                        ctx.moveTo(x, y); seg.x = x; seg.y = y;
                        break;
                    case 'L':
                        ctx.lineTo(x, y);
                        seg.x = x; seg.y = y;
                        break;
                    case 'C':
                        ctx.bezierCurveTo(x1, y1, x2, y2, x, y);
                        seg.x = x; seg.y = y; seg.x1 = x1; seg.y1 = y1; seg.x2 = x2; seg.y2 = y2;
                        break;
                    case 'Q':
                        ctx.quadraticCurveTo(x1, y1, x, y);
                        seg.x = x; seg.y = y; seg.x1 = x1; seg.y1 = y1;
                        break;
                    case 'A':
                        var curr = new ej.datavisualization.Diagram.Point(x0, y0);
                        var rx = seg.r1, ry = seg.r2;
                        var xAxisRotation = seg.angle * (Math.PI / 180.0);
                        var largeArcFlag = seg.largeArcFlag;
                        var sweepFlag = seg.sweepFlag;
                        var cp = new ej.datavisualization.Diagram.Point(x, y);

                        var currp = new ej.datavisualization.Diagram.Point(
                            Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                            -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                        );

                        var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                        if (l > 1) {
                            rx *= Math.sqrt(l);
                            ry *= Math.sqrt(l);
                        }

                        var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                            ((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - (Math.pow(ry, 2) * Math.pow(currp.x, 2))) /
                            (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2))
                        );
                        if (isNaN(s)) s = 0;
                        var cpp = new ej.datavisualization.Diagram.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);

                        var centp = new ej.datavisualization.Diagram.Point(
                            (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                            (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                        );
                        // vector magnitude
                        var m = function (v) { return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)); }
                        // ratio between two vectors
                        var r = function (u, v) { return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v)) }
                        // angle between two vectors
                        var a = function (u, v) { return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v)); }
                        // initial angle
                        var a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                        // angle delta
                        var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                        var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                        var ad = a(u, v);
                        if (r(u, v) <= -1) ad = Math.PI;
                        if (r(u, v) >= 1) ad = 0;

                        var dir = 1 - sweepFlag ? 1.0 : -1.0;
                        var ah = a1 + dir * (ad / 2.0);
                        var halfWay = new ej.datavisualization.Diagram.Point(
                            centp.x + rx * Math.cos(ah),
                            centp.y + ry * Math.sin(ah)
                        );
                        seg.centp = centp;
                        seg.xAxisRotation = xAxisRotation;
                        seg.rx = rx;
                        seg.ry = ry;
                        seg.a1 = a1; seg.ad = ad; seg.sweepFlag = sweepFlag;
                        if (ctx != null) {
                            var r = rx > ry ? rx : ry;
                            var sx = rx > ry ? 1 : rx / ry;
                            var sy = rx > ry ? ry / rx : 1;
                            ctx.save();
                            ctx.translate(centp.x, centp.y);
                            ctx.rotate(xAxisRotation);
                            ctx.scale(sx, sy);
                            ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                            ctx.scale(1 / sx, 1 / sy);
                            ctx.rotate(-xAxisRotation);
                            ctx.translate(-centp.x, -centp.y);
                            ctx.restore();
                        }
                        break;
                    case 'Z':
                    case 'z':
                        ctx.closePath();
                        x = x0; y = y0;
                        break;
                }
                // Record the start of a subpath
                x0 = x, y0 = y;
            }
            ctx.fill();
            if (style && style.dashArray)
                this.drawDashedPath(segs, style);
            else
                ctx.stroke();
            ctx.translate(-transY, -transY);
            if (rotation && rotation.angle)
                ctx.restore();
        }

        Canvas.prototype.getSegments = function (shape) {
            var x0, y0, x1, y1, x2, y2, initx, inity, segs = ej.datavisualization.Diagram.Util.convertPathToArray(shape.getAttribute("d"));
            var segments = [];
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.pathSegTypeAsLetter;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
                switch (char) {
                    case 'M':
                        segments.push({ command: "M", x: x, y: y });
                        break;
                    case 'L':
                        segments.push({ command: "L", x0: x0, y0: y0, x: x, y: y });
                        break;
                    case 'H':
                        segments.push({ command: "L", x0: x0, y0: y0, x: x, y: y0 });
                        break;
                    case 'V':
                        segments.push({ command: "L", x0: x0, y0: y0, x: x0, y: y });
                        break;
                    case 'C':
                        segments.push({ command: "C", x0: x0, y0: y0, x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y });
                        break;
                    case 'S':
                        if (prev) {
                            if (prev.command == "C" || prev.command == "S") {
                                var ctrl = { x: prev.x2, y: prev.y2 };
                            }
                            else
                                var ctrl = { x: prev.x0, y: prev.y0 };
                            var cpt2 = new ej.datavisualization.Diagram.Point(2 * x0 - ctrl.x, 2 * y0 - ctrl.y);

                            segments.push({ command: "C", x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x2: x2, y2: y2, x: x, y: y });
                        }
                        break;
                    case 'Q':
                        //ctx.quadraticCurveTo(x1, y1, x, y);
                        segments.push({ command: "Q", x0: x0, y0: y0, x1: x1, y1: y1, x: x, y: y });
                        break;
                    case 'T':
                        if (prev) {
                            if (prev.command == "Q") {
                                var ctrl = { x: prev.x1, y: prev.y1 };
                            }
                            else
                                var ctrl = { x: prev.x0, y: prev.y0 };
                            var cpt2 = new ej.datavisualization.Diagram.Point(2 * x0 - ctrl.x, 2 * y0 - ctrl.y);

                            segments.push({ command: "Q", x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x: x, y: y });
                        }
                        break;
                    case 'A'://need to update for "A"
                        var newSeg = $.extend(true, {}, seg);
                        newSeg.command = "A";
                        segments.push(newSeg);
                        break;
                    case 'Z':
                    case 'z':
                        segments.push({ command: "L", x0: x, y0: y, x: initx, y: inity });
                        x = x0; y = y0;
                        break;
                }
                var prev = segments[segments.length - 1];
                // Record the start of a subpath
                if (char === 'M' || char === 'm') {
                    initx = x, inity = y;
                }
                x0 = x, y0 = y;
            }
            return segments;
        }

        Canvas.prototype.drawDashedPath = function (segs, style) {
            var x1, y1, x2, y2, x0, y0;
            var initial;
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.command;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
                switch (char) {
                    case 'M':
                        initial = { x: x, y: y };
                        break;
                    case 'L':
                        this.dashedLine(x0, y0, x, y, style.dashArray);
                        break;
                    case 'H':
                        this.dashedLine(x0, y0, x, y0, style.dashArray);
                        break;
                    case 'V':
                        this.dashedLine(x0, y0, x0, y, style.dashArray);
                        break;
                    case 'C':
                        this.bezierCurve(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x2, y2), ej.datavisualization.Diagram.Point(x, y), style);
                        break;
                    case 'Q':
                        this.quadraticCurve(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x, y), style);
                        break;
                    case 'A':
                        var ctx = this.document.getContext("2d");
                        if (ctx != null) {
                            var r = seg.rx > seg.ry ? seg.rx : seg.ry;
                            var sx = seg.rx > seg.ry ? 1 : seg.rx / seg.ry;
                            var sy = seg.rx > seg.ry ? seg.ry / seg.rx : 1;
                            ctx.save();
                            ctx.translate(seg.centp.x, seg.centp.y);
                            ctx.rotate(seg.xAxisRotation);
                            ctx.scale(sx, sy);
                            this.dashedArc(r, 0, 0, seg.a1, seg.a1 + seg.ad, 1 - seg.sweepFlag, style.dashArray);
                            ctx.scale(1 / sx, 1 / sy);
                            ctx.rotate(-seg.xAxisRotation);
                            ctx.translate(-seg.centp.x, -seg.centp.y);
                            ctx.restore();
                        }
                        break;
                    case 'Z':
                    case 'z':
                        //ctx.closePath();
                        this.dashedLine(x, y, initial.x, initial.y, style.dashArray);
                        x = x0; y = y0;
                        break;
                }
                // Record the start of a subpath
                //if (char === 'M' || char === 'm') x0 = x, y0 = y;
                x0 = x, y0 = y;
            }
            //ctx.fill();
        }
        Canvas.prototype.calculateCirclePoints = function (radius, cx, cy, stAngle, endAngle, couterClockwise, dashSize) {
            stAngle = stAngle * 180 / Math.PI;
            endAngle = endAngle * 180 / Math.PI;
            var n = (2 * Math.PI * radius) * (Math.abs(stAngle - endAngle) / 360) * 0.7;
            var alpha = Math.abs(stAngle - endAngle) / n;
            alpha = couterClockwise ? alpha * -1 : alpha;
            var i = 0;
            var points = [];
            while (i < n) {
                points.push(ej.datavisualization.Diagram.Geometry.transform({ x: cx, y: cy }, stAngle + alpha * i, radius));
                i++;
            }
            return points;
        }

        //polygon
        Canvas.prototype.polygon = function (points, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style) {
                this.setStyle(style, ctx);
            }
            ctx.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.lineTo(points[0].x, points[0].y);
            ctx.fill();
            if (style && style.dashArray) {
                for (var i = 1; i < points.length; i++) {
                    this.line(points[i - 1], points[i], style);
                }
                this.line(points[i - 1], points[0], style);
            }
            ctx.stroke();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //image
        Canvas.prototype.image = function (image, x, y, width, height, rotation, style, alignOptions) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style) {
                this.setStyle(style, ctx);
            }
            if (width && height) {
                var srcWidth = image.width, srcHeight = image.height, destinationW = width, destinationH = height;
                var resultWidth, resultHeight;

                if (alignOptions && alignOptions.alignment !== "none") {
                    var xalign = alignOptions.alignment.substr(1, 3), yalign = alignOptions.alignment.substr(5, 3);
                    if (alignOptions.scale === "slice") {

                        var a = function () {
                            resultWidth = destinationW;
                            resultHeight = srcHeight * destinationW / srcWidth;
                        };

                        var b = function () {
                            resultWidth = srcWidth * destinationH / srcHeight;
                            resultHeight = destinationH;
                        };

                        if (destinationW > destinationH) {
                            a();
                            if (destinationH > resultHeight) {
                                b();
                            }
                        } else if (destinationW === destinationH) {
                            if (srcWidth > srcHeight) {
                                b();
                            } else {
                                a();
                            }
                        } else {
                            b();
                            if (destinationW > resultWidth) {
                                a();
                            }
                        }

                        var x1 = this.getSliceOffset(xalign, resultWidth, destinationW, srcWidth);
                        var y1 = this.getSliceOffset(yalign, resultHeight, destinationH, srcHeight);

                        var s = {
                            sx: x1, sy: y1, swidth: srcWidth - x1, sheight: srcHeight - y1, dx: 0, dy: 0,
                            dwidth: resultWidth - (x1 * (resultWidth / srcWidth)),
                            dheight: resultHeight - (y1 * (resultHeight / srcHeight)),
                        };

                        var canvas1 = document.createElement("canvas");
                        canvas1.setAttribute("width", width);
                        canvas1.setAttribute("height", height);
                        var ctx1 = canvas1.getContext('2d');
                        ctx1.drawImage(image, s.sx, s.sy, s.swidth, s.sheight, s.dx, s.dy, s.dwidth, s.dheight);
                        ctx.drawImage(canvas1, x, y, width, height);

                    }
                    else if (alignOptions.scale === "meet") {

                        var srcRatio = (srcHeight / srcWidth), destRatio = (destinationH / destinationW),

                        resultWidth = destRatio > srcRatio ? destinationW : destinationH / srcRatio,
                        resultHeight = destRatio > srcRatio ? destinationW * srcRatio : destinationH;

                        x += this.getMeetOffset(xalign, resultWidth, destinationW);
                        y += this.getMeetOffset(yalign, resultHeight, destinationH);

                        ctx.drawImage(image, 0, 0, srcWidth, srcHeight, x, y, resultWidth, resultHeight);
                    }
                    else
                        ctx.drawImage(image, x, y, width, height);
                }
                else
                    ctx.drawImage(image, x, y, width, height);
            }
            else
                ctx.drawImage(image, x, y);
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        Canvas.prototype.getSliceOffset = function (arg, res, dest, src) {
            switch (arg) {
                case 'min': return 0;
                case 'mid': return (res - dest) / 2 * src / res;
                case 'max': return (res - dest) * src / res;
                default: return 'invalid';
            };
        }

        Canvas.prototype.getMeetOffset = function (arg, res, dest) {

            var max = Math.max(res, dest),
              min = Math.min(res, dest);

            switch (arg) {
                case 'min': return 0;
                case 'mid': return (max - min) / 2;
                case 'max': return max - min;
                default: return 'invalid';
            }
        }

        //text
        Canvas.prototype.text = function (text, x, y, rotation, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            if (style)
                this.setStyle(style, ctx);
            ctx.fillText(text.text, x, y);
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //line
        Canvas.prototype.line = function (start, end, style, dontstart, dontclose) {
            var ctx = this.document.getContext("2d");
            if (!dontstart) {
                ctx.beginPath();
                if (style) {
                    this.setStyle(style, ctx);
                }
            }
            if (style && style.dashArray) {
                this.dashedLine(start.x, start.y, end.x, end.y, style.dashArray);
            }
            else {
                if (!dontstart)
                    ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
            if (!dontclose)
                ctx.closePath();
        }

        //polyline
        Canvas.prototype.polyline = function (points, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (style) {
                this.setStyle(style, ctx);
            }
            for (var i = 1; i < points.length; i++) {
                this.line(points[i - 1], points[i], style);
            }
            ctx.stroke();
        }

        //bezier curve
        Canvas.prototype.bezierCurve = function (startPoint, cpt1, cpt2, cpt3, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            if (style) {
                this.setStyle(style, ctx);
            }
            if (style && style.dashArray) {
                var points = [];
                this.flattenCubicBezier(points, startPoint, cpt1, cpt2, cpt3);
                var dashLength = 0;
                for (var i = 0; i < style.dashArray.length; i++) {
                    dashLength += Number(style.dashArray[i]);
                }
                var dashcount = points.length / dashLength;
                var draw = true;
                var drawn = 0;
                for (var i = 0; i < dashcount; i++) {
                    for (var j = 0; j < style.dashArray.length; j++) {
                        drawn += Number(style.dashArray[j]);
                        if (drawn < points.length) {
                            if (draw) {
                                ctx.lineTo(points[drawn].x, points[drawn].y);
                            }
                            else ctx.moveTo(points[drawn].x, points[drawn].y);
                        }
                        draw = !draw;
                    }
                }


            }
            else {
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.bezierCurveTo(cpt1.x, cpt1.y, cpt2.x, cpt2.y, cpt3.x, cpt3.y);
            }
            ctx.stroke();
        }

        Canvas.prototype.quadraticCurve = function (startPoint, cpt1, cpt2, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            if (style) {
                this.setStyle(style, ctx);
            }
            if (style && style.dashArray) {
                var points = [];
                this.flattenQuadraticBezier(points, startPoint, cpt1, cpt2);
                var dashLength = 0;
                for (var i = 0; i < style.dashArray.length; i++) {
                    dashLength += Number(style.dashArray[i]);
                }
                var dashcount = points.length / dashLength;
                var draw = true;
                var drawn = 0;
                for (var i = 0; i < dashcount; i++) {
                    for (var j = 0; j < style.dashArray.length; j++) {
                        drawn += Number(style.dashArray[j]);
                        if (drawn < points.length) {
                            if (draw) {
                                ctx.lineTo(points[drawn].x, points[drawn].y);
                            }
                            else ctx.moveTo(points[drawn].x, points[drawn].y);
                        }
                        draw = !draw;
                    }
                }

            }
            else {
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.quadraticCurveTo(cpt1.x, cpt1.y, cpt2.x, cpt2.y);
            }
            ctx.stroke();
        }

        //arrow
        Canvas.prototype.arrow = function (point, rotation, size, isOpen, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.moveTo(point.x + size.width, point.y + size.height / 2);
            ctx.lineTo(point.x, point.y);
            ctx.lineTo(point.x + size.width, point.y - size.height / 2);
            if (!isOpen) {
                ctx.closePath();
                ctx.fill();
            }
            ctx.stroke();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        //diamond
        Canvas.prototype.diamond = function (point, rotation, size, style) {
            var ctx = this.document.getContext("2d");
            ctx.beginPath();
            if (style) {
                this.setStyle(style, ctx);
            }
            if (rotation && rotation.angle) {
                this.rotateContext(rotation, ctx);
            }
            ctx.moveTo(point.x + size.width, point.y);
            ctx.lineTo(point.x + size.width / 2, point.y + size.height / 2);
            ctx.lineTo(point.x, point.y);
            ctx.lineTo(point.x + size.width / 2, point.y - size.height / 2);
            ctx.lineTo(point.x + size.width, point.y);
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            if (rotation && rotation.angle)
                ctx.restore();
        }

        Canvas.prototype.dashedLine = function (x1, y1, x2, y2, dashArray) {
            var ctx = this.document.getContext("2d");
            ctx.save();
            var dx = (x2 - x1), dy = (y2 - y1);
            var length = Math.sqrt(dx * dx + dy * dy);
            var angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.translate(x1, y1);
            ctx.moveTo(0, 0);
            ctx.rotate(angle);
            var dcount = dashArray.length;
            var dindex = 0, draw = true;
            var x = 0;
            while (length > x) {
                x += Number(dashArray[dindex++ % dcount]);
                if (x > length) x = length;
                draw ? ctx.lineTo(x, 0) : ctx.moveTo(x, 0);
                draw = !draw;
                ctx.stroke();
            }
            ctx.restore();
        }

        Canvas.prototype.dashedRectangle = function (x, y, width, height, dashArray) {
            this.dashedLine(x, y, x + width, y, dashArray);
            this.dashedLine(x + width, y, x + width, y + height, dashArray);
            this.dashedLine(x + width, y + height, x, y + height, dashArray);
            this.dashedLine(x, y + height, x, y, dashArray);
        }

        Canvas.prototype.dashedArc = function (radius, cx, cy, stAngle, endAngle, couterClockwise, dashArray) {
            var dashLength = 0;
            for (var i = 0; i < dashArray.length; i++) {
                dashLength += Number(dashArray[i]);
            }
            var points = this.calculateCirclePoints(radius, cx, cy, stAngle, endAngle, couterClockwise, dashLength);
            var ctx = this.document.getContext("2d");
            ctx.beginPath();

            var dashcount = points.length / dashLength;
            var draw = true;
            var drawn = 0;
            for (var i = 0; i < dashcount; i++) {
                for (var j = 0; j < dashArray.length; j++) {
                    drawn += Number(dashArray[j]);
                    if (drawn < points.length) {
                        if (draw) {
                            ctx.lineTo(points[drawn].x, points[drawn].y);
                            ctx.stroke();
                        }
                        else ctx.moveTo(points[drawn].x, points[drawn].y);
                    }
                    draw = !draw;
                }
            }
            ctx.closePath();
        }
        Canvas.prototype.absolutePath = function (path) {
            var minx, miny, maxx, maxy;
            var x0, y0, x1, y1, x2, y2, segs = ej.datavisualization.Diagram.Util.convertPathToArray(path.getAttribute("d"));
            for (var x = 0, y = 0, i = 0, length = segs.length; i < length; ++i) {
                var seg = segs[i], char = seg.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(char)) {
                    if ('x' in seg) x = seg.x;
                    if ('y' in seg) y = seg.y;
                } else {
                    if ('x1' in seg) x1 = x + seg.x1;
                    if ('x2' in seg) x2 = x + seg.x2;
                    if ('y1' in seg) y1 = y + seg.y1;
                    if ('y2' in seg) y2 = y + seg.y2;
                    if ('x' in seg) x += seg.x;
                    if ('y' in seg) y += seg.y;
                    var newSeg;
                    switch (char) {
                        case 'm':
                            newSeg = { pathSegTypeAsLetter: "M", x: x, y: y };
                            break;
                        case 'l':
                            newSeg = { pathSegTypeAsLetter: "L", x: x, y: y };
                            break;
                        case 'h':
                            newSeg = { pathSegTypeAsLetter: "H", x: x };
                            break;
                        case 'v':
                            newSeg = { pathSegTypeAsLetter: "V", y: y };
                            break;
                        case 'c':
                            newSeg = { pathSegTypeAsLetter: "C", x: x, y: y, x1: x1, y1: y1, x2: x2, y2: y2 };
                            break;
                        case 's':
                            newSeg = { pathSegTypeAsLetter: "S", x: x, y: y, x2: x2, y2: y2 };
                            break;
                        case 'q':
                            newSeg = { pathSegTypeAsLetter: "Q", x: x, y: y, x1: x1, y1: y1 };
                            break;
                        case 't':
                            newSeg = { pathSegTypeAsLetter: "T", x: x, y: y };
                            break;
                        case 'a':
                            newSeg = { pathSegTypeAsLetter: "A", x: x, y: y, r1: r1, r2: r2, angle: angle, largeArcFlag: largeArcFlag, sweepFlag: sweepFlag };
                            break;
                        case 'z':
                        case 'Z':
                            x = x0; y = y0;
                            newSeg = segs[i];
                            break;
                    }
                    if (newSeg)
                        segs[i] = newSeg;
                }
                if (char === 'M' || char === 'm') x0 = x, y0 = y;
            }

            path.setAttribute("d", ej.datavisualization.Diagram.Util.pathSegArrayAsString(segs));

            Canvas.prototype._scalePathData = function (val, scaleFactor, oldOffset, newOffset) {
                if (val !== oldOffset) {
                    if (newOffset !== oldOffset) {
                        val = (((val * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)))
                            + (newOffset - Number(oldOffset)));
                    }
                    else
                        val = ((Number(val) * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)));
                }
                else {
                    if (newOffset !== oldOffset) {
                        val = newOffset;
                    }
                }
                return val;
            }
            return path;
        };

        Canvas.prototype.setStyle = function (style, ctx) {
            if (style.fill)
                ctx.fillStyle = style.fill;
            if (style.stroke)
                ctx.strokeStyle = style.stroke == "none" ? "transparent" : style.stroke;
            if (style.font)
                ctx.font = style.font;
            if (style.lineWidth)
                ctx.lineWidth = style.lineWidth;
        }

        Canvas.prototype.rotateContext = function (rotation, ctx) {
            ctx.save();
            ctx.translate(rotation.x, rotation.y);
            ctx.rotate(rotation.angle * Math.PI / 180);
            ctx.translate(-rotation.x, -rotation.y);
        }

        Canvas.prototype.pathBounds = function (segments) {
            //var segs = shape.pathSegList;
            var x1, y1, x2, y2, x0, y0;
            var minx, miny, maxx, maxy;
            for (var x = 0, y = 0, i = 0, length = segments.length; i < length; ++i) {
                var seg = segments[i], char = seg.command;
                if (i == 0 && seg.x && seg.y) {
                    minx = maxx = seg.x;
                    miny = maxy = seg.y;
                }
                //var seg = segs.getItem(i), char = seg.pathSegTypeAsLetter;
                if ('x1' in seg) x1 = seg.x1;
                if ('x2' in seg) x2 = seg.x2;
                if ('y1' in seg) y1 = seg.y1;
                if ('y2' in seg) y2 = seg.y2;
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;

                switch (char) {
                    case 'M':
                        x0 = x; y0 = y;
                    case 'L':
                    case 'H':
                    case 'V':
                        if (x) {
                            minx = Math.min(x, minx);
                            maxx = Math.max(x, maxx);
                        }
                        if (y) {
                            miny = Math.min(y, miny);
                            maxy = Math.max(y, maxy);
                        }
                        break;
                    case 'C':

                    case 'S':
                        var bounds = this.getBezierBounds(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x2, y2), ej.datavisualization.Diagram.Point(x, y));
                        minx = Math.min(bounds.x, minx);
                        maxx = Math.max(bounds.x + bounds.width, maxx);
                        miny = Math.min(bounds.y, miny);
                        maxy = Math.max(bounds.y + bounds.height, maxy);
                        break;
                    case 'Q':
                    case "q":
                    case 'T':
                        var bounds = this.getQuadraticBounds(ej.datavisualization.Diagram.Point(x0, y0), ej.datavisualization.Diagram.Point(x1, y1), ej.datavisualization.Diagram.Point(x, y));
                        minx = Math.min(bounds.x, minx);
                        maxx = Math.max(bounds.x + bounds.width, maxx);
                        miny = Math.min(bounds.y, miny);
                        maxy = Math.max(bounds.y + bounds.height, maxy);
                        break;
                    case 'A':
                        break;
                    case 'Z':
                    case 'z':
                        //ctx.closePath();
                        x = x0; y = y0;
                        break;
                }
            }
            return { x: minx, y: miny, width: maxx - minx, height: maxy - miny };
        };

        Canvas.prototype.flattenCubicBezier = function (points, ptStart, ptCtrl1, ptCtrl2, ptEnd, tolerance) {
            var tolerance = 1.5;

            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                              ej.datavisualization.Diagram.Geometry.distance(ptCtrl2, ptCtrl1) +
                              ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl2)) / tolerance);

            for (var i = 0; i <= max; i++) {
                var t = i / max;

                var x = (1 - t) * (1 - t) * (1 - t) * ptStart.x +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.x +
                           3 * t * t * (1 - t) * ptCtrl2.x +
                           t * t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * (1 - t) * ptStart.y +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.y +
                           3 * t * t * (1 - t) * ptCtrl2.y +
                           t * t * t * ptEnd.y;

                points.push(new ej.datavisualization.Diagram.Point(x, y));
            }
        }

        Canvas.prototype.flattenQuadraticBezier = function (points, ptStart, ptCtrl1, ptEnd, tolerance) {
            var tolerance = 1.5;

            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                             ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl1)) / tolerance);

            for (var i = 0; i <= max; i++) {
                var t = i / max;

                var x = (1 - t) * (1 - t) * ptStart.x +
                                          2 * t * (1 - t) * ptCtrl1.x +
                                          t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * ptStart.y +
                           2 * t * (1 - t) * ptCtrl1.y +
                           t * t * ptEnd.y;

                points.push(new ej.datavisualization.Diagram.Point(x, y));
            }
        }

        Canvas.prototype.getBezierBounds = function (ptStart, ptCtrl1, ptCtrl2, ptEnd, tolerance) {
            var tolerance = 3;
            var minx, miny, maxx, maxy;
            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                              ej.datavisualization.Diagram.Geometry.distance(ptCtrl2, ptCtrl1) +
                              ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl2)) / tolerance);

            for (var i = 0; i <= max; i++) {

                var t = i / max;

                var x = (1 - t) * (1 - t) * (1 - t) * ptStart.x +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.x +
                           3 * t * t * (1 - t) * ptCtrl2.x +
                           t * t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * (1 - t) * ptStart.y +
                           3 * t * (1 - t) * (1 - t) * ptCtrl1.y +
                           3 * t * t * (1 - t) * ptCtrl2.y +
                           t * t * t * ptEnd.y;
                if (i == 0) {
                    minx = maxx = x;
                    miny = maxy = y;
                }
                else {
                    minx = Math.min(x, minx);
                    miny = Math.min(y, miny);
                    maxx = Math.max(x, maxx);
                    maxy = Math.max(y, maxy);
                }
            }
            return { x: minx, y: miny, width: maxx - minx, height: maxy - miny };
        }

        Canvas.prototype.getQuadraticBounds = function (ptStart, ptCtrl1, ptEnd, tolerance) {
            var tolerance = 3;
            var minx, miny, maxx, maxy;
            var max = Number((ej.datavisualization.Diagram.Geometry.distance(ptCtrl1, ptStart) +
                              ej.datavisualization.Diagram.Geometry.distance(ptEnd, ptCtrl1)) / tolerance);

            for (var i = 0; i <= max; i++) {
                var t = i / max;


                var x = (1 - t) * (1 - t) * ptStart.x +
                           2 * t * (1 - t) * ptCtrl1.x +
                           t * t * ptEnd.x;

                var y = (1 - t) * (1 - t) * ptStart.y +
                           2 * t * (1 - t) * ptCtrl1.y +
                           t * t * ptEnd.y;

                if (i == 0) {
                    minx = maxx = x;
                    miny = maxy = y;
                }
                else {
                    minx = Math.min(x, minx);
                    miny = Math.min(y, miny);
                    maxx = Math.max(x, maxx);
                    maxy = Math.max(y, maxy);
                }
            }
            return { x: minx, y: miny, width: maxx - minx, height: maxy - miny };
        }

        return Canvas;
    })();

    ej.datavisualization.Diagram.Canvas = Canvas;
    //#endregion

    //#region Renderer
    ej.datavisualization.Diagram.CanvasContext = {

        _renderDocument: function (view, diagram) {
            var attr = {
                id: view.canvas.id + "_canvas",
                width: diagram._canvas.clientWidth,
                height: diagram._canvas.clientHeight,
                version: "1.1",
                xlink: "http://www.w3.org/1999/xlink",
                "style": view.style,
                "pointer-events": "none"
            };
            view._canvas = new ej.datavisualization.Diagram.Canvas(attr);
            diagram._view = view.canvas;
            view.canvas.appendChild(view._canvas.document);
            if (view.type == "mainview") {
                this._canvas = view.canvas;
                diagram._svg = this._svg = view._canvas;
            }
        },

        _renderGroupBackground: function (group, canvas, diagram) {
            if (!group.pivot) {
                group.pivot = {};
                group.pivot.x = .5;
                group.pivot.y = .5;
            }

            var ctx = canvas.document.getContext("2d");
            if (group.visible) {
                var rotation = { "angle": group.rotateAngle, x: group.offsetX * canvas._scaleX, y: group.offsetY * canvas._scaleY };
                ctx.save();
                ctx.translate(rotation.x, rotation.y);
                ctx.rotate(rotation.angle * Math.PI / 180);
                ctx.translate(-rotation.x, -rotation.y);
                ctx.fillStyle = group.type != "bpmn" ? group.fillColor : "transparent";
                ctx.strokeStyle = group.type != "bpmn" ? group.borderColor : "transparent";
                ctx.lineWidth = group.borderWidth;
                if (group.borderDashArray) {
                    if (group.borderDashArray.indexOf("[") != -1 || group.borderDashArray instanceof Array) {
                        dashArray = group.borderDashArray;
                    } else if (group.borderDashArray.indexOf(",") != -1) {
                        var dashArray = group.borderDashArray.split(",");
                    } else if (group.borderDashArray.indexOf(" ") != -1) {
                        var dashArray = group.borderDashArray.split(" ");
                    }
                    if (ctx.setLineDash) {
                        ctx.setLineDash(dashArray);
                    } else if (ctx.mozDash) {
                        ctx.mozDash = dashArray;
                    } else {
                        var style = { dashArray: dashArray };
                    }
                }
            }

            var x = (group.offsetX * canvas._scaleX) - (group.width * canvas._scaleX) * group.pivot.x;
            var y = (group.offsetY * canvas._scaleY) - (group.height * canvas._scaleY) * group.pivot.y;
            if (ej.datavisualization.Diagram.Util.canCrispEdges(group, diagram)) {
                x = Math.floor(x) + 0.5;
                y = Math.floor(y) + 0.5;
            }
            canvas.rect(x, y, group.width * canvas._scaleX, group.height * canvas._scaleY, null, style);
            ctx.restore();
        },

        renderGroup: function (group, canvas, diagram) {
            if (group.visible) {
                var ctx = canvas.document.getContext("2d");
                var rotation = { "angle": group.rotateAngle, x: group.offsetX * canvas._scaleX, y: group.offsetY * canvas._scaleY };
                ctx.save();
                this._renderGroupBackground(group, canvas, diagram);
                for (var i = 0; i < group.children.length; i++) {
                    var child = diagram.nameTable[diagram._getChild(group.children[i])];
                    if (child) {
                        if (child._type === "group") {
                            this.renderGroup(child, canvas, diagram);
                        }
                        else if (child._type === "node") {
                            this.renderNode(child, canvas);
                        }
                        else if (child.segments) {
                            this.renderConnector(child, canvas);
                        }
                    }
                }
                ctx.translate(rotation.x, rotation.y);
                ctx.rotate(rotation.angle * Math.PI / 180);
                ctx.translate(-rotation.x, -rotation.y);
                var x = (group.offsetX * canvas._scaleX) - (group.width * canvas._scaleX) * group.pivot.x;
                var y = (group.offsetY * canvas._scaleY) - (group.height * canvas._scaleY) * group.pivot.y;
                if (!group.isLane) {
                    this.renderLabels(group, canvas);
                    this.renderPorts(group, canvas, x, y);
                }
                if (group.isSwimlane) {
                    diagram._renderCanvasPhase(group, canvas);
                }
                if (group.annotation) {
                    if (group._annotation && group._annotation.length) {
                        for (var n = 0; n < group._annotation.length; n++) {
                            if (diagram.nameTable[group._annotation[n]]) {
                                var element = diagram.nameTable[group._annotation[n]];
                                var type = diagram.getObjectType(element);
                                if (type == "node")
                                    this.renderNode(element, canvas);
                                else if (type == "connector")
                                    this.renderConnector(element, canvas);
                            }
                        }
                    }
                }
                ctx.restore();
            }
        },
        _isExportable: function (node, canvas) {
            var state = true, content;
            if (node.type === "image") {
                try {
                    var canvas = new ej.datavisualization.Diagram.Canvas({ "id": "temp_canvas", "width": 100, "height": 100 });
                    var ctx = canvas.document.getContext("2d");
                    ctx.save();
                    canvas.rect(0, 0, (node.width * canvas._scaleX), (node.height * canvas._scaleY));
                    var image = new Image();
                    image.src = node.source;
                    canvas.image(image, 0, 0, (node.width * canvas._scaleX), (node.height * canvas._scaleY), undefined, undefined, { scale: node.scale, alignment:node.contentAlignment });
                    ctx.restore();
                    content = canvas.document.toDataURL();
                }
                catch (e) {
                    state = false;
                }
            }
            return state;
        },

        _isImageExportable: function (backgroundImage) {
            var state = true, content;
            if (backgroundImage.source) {
                try {
                    var canvas = new ej.datavisualization.Diagram.Canvas({ "id": "temp_canvas", "width": 100, "height": 100 });
                    var ctx = canvas.document.getContext("2d");
                    ctx.save();
                    var image = new Image();
                    image.src = backgroundImage.source;
                    canvas.image(image, 0, 0, 100, 100, undefined, undefined, { scale: backgroundImage.scale, alignment: backgroundImage.alignment });
                    ctx.restore();
                    content = canvas.document.toDataURL();
                }
                catch (e) {
                    state = false;
                }
            }
            return state;
        },

        renderNode: function (node, canvas, diagram) {
            var ctx = canvas.document.getContext("2d");
            if (node.visible && this._isExportable(node, canvas)) {
                var nodeWidth = node.width || node._width || 0;
                var nodeHeight = node.height || node._height || 0;
                nodeWidth *= canvas._scaleX;
                nodeHeight *= canvas._scaleY;
                var offsetX = node.offsetX * canvas._scaleX;
                var offsetY = node.offsetY * canvas._scaleY;
                var rotation = { "angle": node.rotateAngle, x: offsetX, y: offsetY };
                ctx.save();
                ctx.translate(rotation.x, rotation.y);
                ctx.rotate(rotation.angle * Math.PI / 180);
                ctx.translate(-rotation.x, -rotation.y);
                var flip = node.flip !== "none" ? node.flip : node._flip;
                if (flip && flip !== ej.datavisualization.Diagram.FlipDirection.None && node.flip !== node._flip) {
                    ctx.translate(rotation.x, rotation.y);
                    if (flip === ej.datavisualization.Diagram.FlipDirection.Horizontal) {
                        ctx.scale(-1, 1);
                    }
                    else if (flip === ej.datavisualization.Diagram.FlipDirection.Vertical) {
                        ctx.scale(1, -1);
                    }
                    else if (flip === ej.datavisualization.Diagram.FlipDirection.Both) {
                        ctx.scale(-1, -1);
                    }
                    ctx.translate(-rotation.x, -rotation.y);
                }
                ctx.save();
                ctx.fillStyle = node.fillColor;
                ctx.strokeStyle = (node.borderColor == "none" || !node.borderWidth) ? "transparent" : node.borderColor;
                ctx.lineWidth = node.borderWidth;
                ctx.globalAlpha = node.opacity;
                var x = offsetX - nodeWidth * node.pivot.x;
                var y = offsetY - nodeHeight * node.pivot.y;
                if (ej.datavisualization.Diagram.Util.canCrispEdges(node, canvas._diagram)) {
                    x = Math.floor(x) + 0.5;
                    y = Math.floor(y) + 0.5
                }
                if (node._shape == "path")
                    this._renderGradient(node, ctx, 0, 0);
                else
                    this._renderGradient(node, ctx, x, y);
                var fill = node.fillColor;
                if (node.constraints & ej.datavisualization.Diagram.NodeConstraints.Shadow) {
                    ctx.save();
                    ctx.strokeStyle = "lightgrey";
                    var t = ej.datavisualization.Diagram.Geometry.transform({ x: 0, y: 0 }, node.shadow.angle, node.shadow.distance);
                    ctx.fillStyle = fill != "none" || fill != "transparent" ? "lightgrey" : "none";
                    switch (node._shape) {
                        case "image":
                        case "rectangle":
                            if (node.cornerRadius)
                                canvas.roundedRect(x + t.x, y + t.y, nodeWidth, nodeHeight, node.cornerRadius, null);
                            else canvas.rect(x + t.x, y + t.y, nodeWidth, nodeHeight, null);
                            break;
                        case "ellipse":
                            canvas.ellipse(x + nodeWidth / 2 + t.x, y + nodeHeight / 2 + t.y, nodeWidth / 2, nodeHeight / 2, null);
                            break;
                        case "path":
                            var absolutePath = node._absolutePath;
                            if (canvas._scaleX !== 1 || canvas._scaleY !== 1)
                                absolutePath = ej.datavisualization.Diagram.Geometry.updatePath(x, y, nodeWidth, nodeHeight, absolutePath, canvas._diagram._svg, null, null);
                            canvas.path(absolutePath, x + t.x, y + t.y, nodeWidth, nodeHeight, null);
                            break;
                        case "polygon":
                            var points = this._updatePolygonPoints(node, canvas);
                            ctx.translate(t.x, t.y);
                            canvas.polygon(points, null, style);
                            break;
                    }
                    ctx.restore();
                }
                if (node.borderDashArray) {
                    if (node.borderDashArray.indexOf("[") != -1 || node.borderDashArray instanceof Array) {
                        dashArray = node.borderDashArray;
                    }
                    else
                        if (node.borderDashArray.indexOf(",") != -1) {
                            var dashArray = node.borderDashArray.split(",");
                        }
                        else if (node.borderDashArray.indexOf(" ") != -1) { var dashArray = node.borderDashArray.split(" "); }
                    if (ctx.setLineDash) {
                        ctx.setLineDash(dashArray);
                    }
                    else if (ctx.mozDash) { ctx.mozDash = dashArray; }
                    else
                    {
                        var style = { dashArray: dashArray };
                    }
                }
                switch (node._shape) {
                    case "rectangle":
                        if (node.cornerRadius)
                            canvas.roundedRect(x, y, nodeWidth, nodeHeight, node.cornerRadius, null, style);
                        else canvas.rect(x, y, nodeWidth, nodeHeight, null, style);
                        break;
                    case "ellipse":
                        canvas.ellipse(x + nodeWidth / 2, y + nodeHeight / 2, nodeWidth / 2, nodeHeight / 2, null, style);
                        break;
                    case "path":
                        var absolutePath = node._absolutePath;
                        if (canvas._scaleX !== 1 || canvas._scaleY !== 1)
                            absolutePath = ej.datavisualization.Diagram.Geometry.updatePath(0, 0, nodeWidth, nodeHeight, absolutePath, canvas._diagram._svg, null, null);
                        canvas.path(absolutePath, x, y, nodeWidth, nodeHeight, null, style);
                        break;
                    case "image":
                        var rotation = { angle: node.rotateAngle, x: offsetX, y: offsetY };
                        canvas.rect(x, y, nodeWidth, nodeHeight, null, style);
                        var image = new Image();
                        image.src = node.source;
                        canvas.image(image, x, y, nodeWidth, nodeHeight, undefined, undefined, { scale: node.scale, alignment: node.contentAlignment });
                        break;
                    case "text":
                        canvas.rect(x, y, nodeWidth, nodeHeight, null, style);
                        if (node.textBlock) {
                            var font = "";
                            if (node.textBlock.italic)
                                font += "italic ";
                            if (node.textBlock.bold)
                                font += "bold ";
                            font += node.textBlock.fontSize + " ";
                            font += node.textBlock.fontFamily;
                            ctx.font = font;
                            this._renderTextElement(node, node.textBlock, canvas);
                        }
                        break;
                    case "polygon":
                        var points = this._updatePolygonPoints(node, canvas);
                        canvas.polygon(points, null, style);
                        break;
                    case "native":
                    case "html":
                        diagram._raiseEvent("templateNodeRendering", { element: node, canvas: canvas });
                        break;
                }
                ctx.restore();
                this.renderPorts(node, canvas, x, y);
                if (node.type != "text")
                    this.renderLabels(node, canvas);
                if (node.annotation) {
                    if (node._annotation && node._annotation.length) {
                        for (var n = 0; n < node._annotation.length; n++) {
                            if (diagram.nameTable[node._annotation[n]]) {
                                var element = diagram.nameTable[node._annotation[n]];
                                var type = diagram.getObjectType(element);
                                if (type == "node")
                                    this.renderNode(element, canvas);
                                else if (type == "connector")
                                    this.renderConnector(element, canvas);
                            }
                        }
                    }
                }
                ctx.restore();
            }
        },

        renderPhases: function (phase, canvas, points) {
            var style;
            if (phase && canvas) {
                var ctx = canvas.document.getContext("2d");
                ctx.save();
                ctx.strokeStyle = phase.lineColor ? phase.lineColor : "black";
                ctx.lineWidth = phase.lineWidth ? phase.lineWidth : 1;
                if (phase.lineDashArray) {
                    if (phase.lineDashArray.indexOf("[") != -1 || phase.lineDashArray instanceof Array) {
                        dashArray = phase.lineDashArray;
                    }
                    else {
                        if (phase.lineDashArray.indexOf(",") != -1) {
                            var dashArray = phase.lineDashArray.split(",");
                        }
                        else if (phase.lineDashArray.indexOf(" ") != -1) { var dashArray = phase.lineDashArray.split(" "); }
                    }

                    if (ctx.setLineDash) { ctx.setLineDash(dashArray); }
                    else if (ctx.mozDash) { ctx.mozDash = dashArray; }
                    else
                        style = { "dashArray": dashArray }
                }
                if (points && points.length > 0) {
                    canvas.line(points[0], points[1], style);
                }
            }
            ctx.restore();
        },

        renderConnector: function (connector, canvas) {
            if (connector.visible) {
                var ctx = canvas.document.getContext("2d");
                ctx.save();
                ctx.strokeStyle = connector.lineColor;
                ctx.lineWidth = connector.lineWidth;
                if (connector.lineDashArray) {
                    if (connector.lineDashArray.indexOf("[") != -1 || connector.lineDashArray instanceof Array) {
                        dashArray = connector.lineDashArray;
                    }
                    else {
                        if (connector.lineDashArray.indexOf(",") != -1) {
                            var dashArray = connector.lineDashArray.split(",");
                        }
                        else if (connector.lineDashArray.indexOf(" ") != -1) { var dashArray = connector.lineDashArray.split(" "); }
                    }
                    if (ctx.setLineDash) { ctx.setLineDash(dashArray); }
                    else if (ctx.mozDash) { ctx.mozDash = dashArray; }
                    else
                        var style = { "dashArray": dashArray }
                }
                if (connector.segments) {
                    this._renderSegments(connector, canvas, style);
                }
                ctx.restore();
                this._renderDecorators(connector, canvas);
                this.renderLabels(connector, canvas);
                if (connector.shape) {
                    for (var i = 0; i < connector._inlineDecorators.length; i++)
                        this.renderNode(connector._inlineDecorators[i], canvas)
                }
            }
        },

        _renderSegments: function (connector, canvas, style) {
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = connector.segments[i];
                if (segment._bridges.length > 0) {
                    for (var n = 0; n < segment._bridges.length; n++) {
                        var bridge = segment._bridges[n];
                        bridge._rendered = false;
                    }
                }
                var points = segment.points;
                var diagram = canvas._diagram;
                if (i == 0) {
                    if (diagram && connector.sourceNode) var node = diagram._findNode(connector.sourceNode);
                    points = ej.datavisualization.Diagram.SvgContext._clipDecorators(connector, segment, true, node);
                    if (segment.type == "bezier" && connector.sourceDecorator && connector.sourceDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                        points[0] = ej.datavisualization.Diagram.Util._adjustPoint(points[0], segment._point1, true, connector.lineWidth);
                    }
                    var startPoint = points[0];
                    var starting = true;
                }
                else starting = false;
                if (i == connector.segments.length - 1) {
                    if (diagram && connector.targetNode) var node = diagram._findNode(connector.targetNode);
                    points = ej.datavisualization.Diagram.SvgContext._clipDecorators(connector, segment, false, node);
                    if (startPoint && connector.segments.length < 2) {
                        points[0] = startPoint; startPoint = null;
                    }
                    var ending = true;
                }
                if (connector.shape && connector.shape.flow == "sequence" && connector.shape.sequence == "default" && i == 0) {
                    var beginningpoint = { x: segment.points[0].x, y: segment.points[0].y };
                    var distance = ej.datavisualization.Diagram.Geometry.distance(segment.points[0], segment.points[1]);
                    distance = Math.min(30, distance / 2);
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(segment.points[0], segment.points[1]);
                    var transferpoint = ej.datavisualization.Diagram.Geometry.transform({ x: beginningpoint.x, y: beginningpoint.y }, angle, distance);
                    var startpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: transferpoint.x, y: transferpoint.y }, angle + 135, -12);
                    var endpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: startpoint1.x, y: startpoint1.y }, angle + 135, 12 * 2);
                }
                if (connector.shape && connector.shape.flow == "sequence" && connector.shape.sequence == "default" && i == 0) {
                    var beginningpoint = { x: segment.points[0].x, y: segment.points[0].y };
                    var distance = ej.datavisualization.Diagram.Geometry.distance(segment.points[0], segment.points[1]);
                    distance = Math.min(30, distance / 2);
                    var angle = ej.datavisualization.Diagram.Geometry.findAngle(segment.points[0], segment.points[1]);
                    var transferpoint = ej.datavisualization.Diagram.Geometry.transform({ x: beginningpoint.x, y: beginningpoint.y }, angle, distance);
                    var startpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: transferpoint.x, y: transferpoint.y }, angle + 135, -12);
                    var endpoint1 = ej.datavisualization.Diagram.Geometry.transform({ x: startpoint1.x, y: startpoint1.y }, angle + 135, 12 * 2);
                }
                if (segment.type == "bezier") {
                    var startPoint = points[0];
                    var endPoint = segment._endPoint;
                    if (connector.targetDecorator && connector.targetDecorator.shape !== ej.datavisualization.Diagram.DecoratorShapes.None) {
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(segment._endPoint, segment._point2, true, connector.lineWidth);
                    }
                    canvas.bezierCurve(startPoint, segment._point1, segment._point2, endPoint, style);
                }
                else {
                    if (connector.cornerRadius > 0) {
                        var st, end;
                        for (var j = 0; j < points.length - 1; j++) {
                            var segLength = ej.datavisualization.Diagram.Geometry.distance(points[j], points[j + 1]);
                            if (segLength > 0) {
                                var endpoint = end || st;
                                if (i < connector.segments.length - 1 || j < points.length - 2) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        end = this._adjustPoint(points[j], points[j + 1], false, segLength / 2);
                                    }
                                    else end = this._adjustPoint(points[j], points[j + 1], false, connector.cornerRadius);
                                }
                                else end = points[j + 1];

                                if (i > 0 || j > 0) {
                                    if (segLength < connector.cornerRadius * 2) {
                                        st = this._adjustPoint(points[j], points[j + 1], true, segLength / 2);
                                        if (i < connector.segments.length - 1 || j < points.length - 2)
                                            end = null;
                                    }
                                    else st = this._adjustPoint(points[j], points[j + 1], true, connector.cornerRadius);
                                }

                                if (endpoint && st) {
                                    canvas.quadraticCurve(endpoint, points[j], st, style);
                                }
                                else st = points[j];
                                if (segment._bridges.length > 0) {
                                    this._updateBridging(segment, canvas, j + 1, st ? st : points[j], end ? end : points[j + 1], connector.bridgeSpace, style,
                                        starting && k == 1 ? true : false, ending && k == points.length - 1 ? true : false);
                                }
                                if (end) {
                                    if (!(segment._bridges.length > 0)) {
                                        canvas.line(st, end, style);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        for (var k = 1; k < points.length; k++) {
                            if (segment._bridges.length > 0) {
                                this._updateBridging(segment, canvas, k, points[k - 1], points[k], connector.bridgeSpace, style,
                                    starting && k == 1 ? true : false, ending && k == points.length - 1 ? true : false);
                            }
                            else {
                                canvas.line(this._scalePointforStretch(points[k - 1], canvas, connector), this._scalePointforStretch(points[k], canvas, connector), style,
                                    starting && k == 1 ? false : true, ending && k == points.length - 1 ? false : true);
                            }
                        }
                    };
                }
            }
            if (connector.shape && connector.shape.flow == "sequence" && connector.shape.sequence == "default") {
                canvas.line(this._scalePointforStretch(startpoint1, canvas, connector), this._scalePointforStretch(endpoint1, canvas, connector), style);
            }
        },

        _scalePointforStretch: function (pt, canvas, connector) {
            var tempPt = { x: pt.x, y: pt.y };
            if (connector && ej.datavisualization.Diagram.Util.canCrispEdges(connector, canvas._diagram)) {
                tempPt.x = Math.floor(tempPt.x);
                tempPt.y = Math.floor(tempPt.y);
            }
            tempPt.x *= canvas._scaleX;
            tempPt.y *= canvas._scaleY;
            return tempPt;
        },

        _updateBridging: function (seg, canvas, pointIndex, startPt, endPt, bridgeSpace, style, start, end) {
            var bridgeSP;
            var angle = this._findAngle(startPt, endPt);
            var bridgeDirection = canvas._diagram.bridgeDirection();
            if (seg._bridges.length > 0) {
                if (seg.type === "straight") {
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (!bridge._rendered) {
                            bridgeSP = seg._bridges[n - 1] != null && seg._bridges[n - 1].segmentPointIndex == bridge.segmentPointIndex ? seg._bridges[n - 1].endPoint : startPt;
                            canvas.line(bridgeSP, bridge.startPoint, style, !(start || n == 0), true);
                            var centerX = bridge.startPoint.x + ((bridge.endPoint.x - bridge.startPoint.x) / 2);
                            var centerY = bridge.startPoint.y + ((bridge.endPoint.y - bridge.startPoint.y) / 2);
                            var sweep = ej.datavisualization.Diagram.Util.sweepDirection(angle, bridgeDirection, null, canvas._diagram);
                            canvas.arc(centerX, centerY, bridgeSpace / 2, angle, sweep, style);
                            if (seg._bridges[n + 1] != null && seg._bridges[n + 1].segmentPointIndex == bridge.segmentPointIndex)
                                canvas.line(bridge.endPoint, seg._bridges[n + 1].startPoint, style, false);
                            else
                                canvas.line(bridge.endPoint, endPt, style, false, !end);
                            bridge._rendered = true;
                        }
                    }
                }
                else if (seg.type === "orthogonal") {
                    var ept = startPt;
                    for (var n = 0; n < seg._bridges.length; n++) {
                        var bridge = seg._bridges[n];
                        if (bridge.segmentPointIndex === pointIndex && !bridge._rendered) {
                            bridgeSP = seg._bridges[n - 1] != null && seg._bridges[n - 1].segmentPointIndex == bridge.segmentPointIndex ? seg._bridges[n - 1].endPoint : startPt;
                            canvas.line(bridgeSP, bridge.startPoint, style, !(start || n == 0), true);
                            var centerX = bridge.startPoint.x + ((bridge.endPoint.x - bridge.startPoint.x) / 2);
                            var centerY = bridge.startPoint.y + ((bridge.endPoint.y - bridge.startPoint.y) / 2);
                            var sweep = ej.datavisualization.Diagram.Util.sweepDirection(angle, bridgeDirection, null, canvas._diagram);
                            canvas.arc(centerX, centerY, bridgeSpace / 2, angle, sweep, style);
                            if (seg._bridges[n + 1] != null && seg._bridges[n + 1].segmentPointIndex == bridge.segmentPointIndex)
                                canvas.line(bridge.endPoint, seg._bridges[n + 1].startPoint, style, false);
                            else
                                ept = bridge.endPoint;
                            bridge._rendered = true;
                        }
                    }
                    canvas.line(ept, endPt, style, false, !end);
                }
            }
        },

        _findAngle: function (startPt, endPt) {
            var xDiff = startPt.x - endPt.x; var yDiff = startPt.y - endPt.y;
            return Math.atan2(yDiff, xDiff) * (180 / Math.PI);
        },

        _adjustPoint: function (source, target, isStart, length) {
            var pt = isStart ? { x: source.x, y: source.y } : { x: target.x, y: target.y };
            if (source.x == target.x) {
                if (source.y < target.y && isStart || source.y > target.y && !isStart)
                    pt.y += length;
                else pt.y -= length;
            }
            else if (source.y == target.y) {
                if (source.x < target.x && isStart || source.x > target.x && !isStart)
                    pt.x += length;
                else pt.x -= length;
            }
            else {
                var angle;
                if (isStart) {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(source, target);
                    pt = ej.datavisualization.Diagram.Geometry.transform(source, angle, length);
                }
                else {
                    angle = ej.datavisualization.Diagram.Geometry.findAngle(target, source);
                    pt = ej.datavisualization.Diagram.Geometry.transform(target, angle, length);
                }
            }
            return pt;
        },

        renderLabels: function (node, canvas) {
            for (var i = 0; i < node.labels.length; i++) {
                var label = node.labels[i];
                var ctx = canvas.document.getContext("2d");
                ctx.save();
                ctx.globalAlpha = label.opacity;
                ctx.lineWidth = label.borderWidth;
                ctx.strokeStyle = label.borderColor;
                if (label.text && label.visible)
                    this._renderTextElement(node, label, canvas);
                ctx.restore();
            }
        },

        renderPorts: function (node, canvas, x, y) {
            var ctx = canvas.document.getContext("2d");
            for (var i = 0; i < node.ports.length; i++) {
                var port = node.ports[i];
                if (!(port.visibility & ej.datavisualization.Diagram.PortVisibility.Hidden || port.visibility & ej.datavisualization.Diagram.PortVisibility.Hover || port.visibility & ej.datavisualization.Diagram.PortVisibility.Connect)) {
                    var point = ej.datavisualization.Diagram.Util._getPortPosition(port, ej.datavisualization.Diagram.Util.bounds(node, true));
                    point = this._scalePointforStretch(point, canvas);
                    var portSize = port.size * canvas._scaleY;
                    ctx.fillStyle = port.fillColor;
                    ctx.strokeStyle = port.borderColor;
                    ctx.lineWidth = port.borderWidth;
                    switch (port.shape) {
                        case "x":
                            ctx.beginPath();
                            ctx.moveTo((point.x - portSize / 2), (point.y - portSize / 2));
                            ctx.lineTo((point.x + portSize / 2), (point.y + portSize / 2));
                            ctx.moveTo((point.x + portSize / 2), (point.y - portSize / 2));
                            ctx.lineTo((point.x - portSize / 2), (point.y + portSize / 2));
                            ctx.stroke();
                            ctx.fill();
                            ctx.closePath();
                            break;
                        case "circle":
                            var rx = portSize / 2;
                            var ry = portSize / 2;
                            canvas.ellipse(point.x, point.y, rx, ry);
                            break;
                        case "square":
                            canvas.rect(point.x - portSize / 2, point.y - portSize / 2, portSize, portSize);
                            break;
                        case "path":
                            ctx.save();
                            if (node._type == "group") {
                                ctx.translate(offsetX, node.offsetY);
                                ctx.rotate(-node.rotateAngle * Math.PI / 180);
                                ctx.translate(-offsetX, -node.offsetY);
                                var rotation;
                                if (node.rotateAngle)
                                    rotation = { angle: node.rotateAngle, x: port._absolutePoint.x, y: port._absolutePoint.y };
                                var absolutePath = port._absolutePath;
                                if (canvas._scaleX !== 1 || canvas._scaleY !== 1)
                                    absolutePath = ej.datavisualization.Diagram.Geometry.updatePath(port._absolutePoint.x, port._absolutePoint.y, portSize, portSize, absolutePath, canvas._diagram._svg, null, null);
                                canvas.path(absolutePath, 0, 0, portSize, portSize, rotation);
                            }
                            else {
                                x = point.x - node.width * port.offset.x;
                                y = point.y - node.height * port.offset.y;
                                var absolutePath = port._absolutePath;
                                if (canvas._scaleX !== 1 || canvas._scaleY !== 1)
                                    absolutePath = ej.datavisualization.Diagram.Geometry.updatePath(x, y, portSize, portSize, absolutePath, canvas._diagram._svg, null, null);
                                canvas.path(absolutePath, x, y, portSize, portSize, rotation);
                            }
                            ctx.restore();
                    }
                }
            }
        },

        _renderTextElement: function (node, textElement, canvas) {
            if (textElement) {
                var text = { childNodes: [] };
                var ctx = canvas.document.getContext("2d");
                ctx.save();
                var font = "";
                if (textElement.italic)
                    font += "italic ";
                if (textElement.bold)
                    font += "bold ";
                font += (textElement.fontSize * canvas._scaleY) + "px ";
                font += textElement.fontFamily;
                ctx.font = font;
                var bounds = this._wrapText(node, text, textElement, canvas);
                this._alignTextOnLabel(textElement, node, text, canvas, bounds);
                ctx.restore();
            }
        },

        _alignTextOnLabel: function (label, node, text, canvas, labelBounds) {
            var nodeWidth = node.width || node._width || 0;
            var nodeHeight = node.height || node._height || 0;
            nodeWidth *= canvas._scaleX;
            nodeHeight *= canvas._scaleY;
            var bounds = { "width": labelBounds && labelBounds.width || label.width, "height": text.childNodes.length * (label.fontSize * canvas._scaleY) };
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            nodeBounds.width *= canvas._scaleX;
            nodeBounds.height *= canvas._scaleY;
            nodeBounds.x *= canvas._scaleX;
            nodeBounds.y *= canvas._scaleY;
            var offset, hAlign, vAlign;
            var diagram = canvas._diagram;
            if (node.segments && label.relativeMode == "segmentpath") {
                var obj = ej.datavisualization.Diagram.SvgContext._getConnectorHandlePosition(label, node, 1, diagram);
                var pt = this._scalePointforStretch(obj.position, canvas);
                offset = {
                    x: (pt.x - nodeBounds.x) / nodeBounds.width,
                    y: (pt.y - nodeBounds.y) / nodeBounds.height
                };
                var alignment = ej.datavisualization.Diagram.Util._alignLabelOnSegments(node, label, diagram, obj);
                vAlign = alignment.vAlign; hAlign = alignment.hAlign;
            }
            else {
                hAlign = label.horizontalAlignment;
                vAlign = label.verticalAlignment;
            }
            offset = ej.datavisualization.Diagram.Util._getLabelPosition(label, nodeBounds, offset);
            var point = { x: 0, y: 0 }, tempPt = { x: offset.x, y: offset.y };
            var y = 0;
            if (vAlign == ej.datavisualization.Diagram.VerticalAlignment.Top)
                y = offset.y + bounds.height / 2;
            else if (vAlign == ej.datavisualization.Diagram.VerticalAlignment.Center || vAlign == ej.datavisualization.Diagram.VerticalAlignment.Stretch)
                y = offset.y;
            else
                y = offset.y - bounds.height / 2;
            point.y = y;
            point.x = offset.x;
            tempPt.y = y;
            var ctx = canvas.document.getContext("2d");
            if (label.textAlign == "justify") {
                if (text.childNodes.length > 1) {
                    ctx.textAlign = "left";
                    bounds.width = nodeWidth - 2 * label.borderWidth;
                }
                else ctx.textAlign = "center";
            } else {
                ctx.textAlign = label.textAlign;
            }
            switch (hAlign) {
                case ej.datavisualization.Diagram.HorizontalAlignment.Left:
                    tempPt.x = offset.x + bounds.width / 2;
                    switch (ctx.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x + bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x + bounds.width;
                            break;
                    }
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Center:
                    tempPt.x = offset.x;
                    switch (ctx.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x - bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x + bounds.width / 2;
                            break;
                    }
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Right:
                    tempPt.x = offset.x - bounds.width / 2;
                    switch (ctx.textAlign) {
                        case ej.datavisualization.Diagram.TextAlign.Left:
                            point.x = offset.x - bounds.width;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Center:
                            point.x = offset.x - bounds.width / 2;
                            break;
                        case ej.datavisualization.Diagram.TextAlign.Right:
                            point.x = offset.x;
                            break;
                    }
                    break;
                case ej.datavisualization.Diagram.HorizontalAlignment.Stretch:
                    tempPt.x = offset.x;
                    point.x = offset.x;
                    break;
            }
            var rotation, labelX = nodeBounds.x, labelY = nodeBounds.y;
            if (!node.segments) {
                labelX = (node.offsetX * canvas._scaleX) - nodeWidth * node.pivot.x;
                labelY = (node.offsetY * canvas._scaleY) - nodeHeight * node.pivot.y;
            }

            var bWidth = label.borderWidth || 0;
            var x = labelX + point.x + (labelBounds ? labelBounds.x : 0) - bWidth / 2;
            var y = labelY + point.y - bounds.height / 2 - bWidth / 2;
            if (label.verticalAlignment == "stretch") {
                canvas.rect(x, nodeBounds.y, bounds.width + bWidth, nodeBounds.height + bWidth, null,
                    { fill: label.fillColor && !node._isHeader ? label.fillColor : "transparent", stroke: (bWidth && !node._isHeader) ? (label.borderColor || "transparent") : "transparent", lineWidth: bWidth });
            }
            else
                canvas.rect(x, y, bounds.width + bWidth, bounds.height + bWidth, null,
                    { fill: label.fillColor ? label.fillColor : "transparent", stroke: bWidth ? (label.borderColor || "transparent") : "transparent", lineWidth: bWidth });

            rotation = { "angle": label.rotateAngle, x: labelX + tempPt.x, y: labelY + tempPt.y };
            if (label.textAlign == "justify") {
                var labelWidth = Math.max(nodeWidth, label.width) - 2 * label.borderWidth;
            }
            ctx.save();
            ctx.translate(rotation.x, rotation.y);
            ctx.rotate(rotation.angle * Math.PI / 180);
            ctx.translate(-rotation.x, -rotation.y);
            var flip = node.flip !== "none" ? node.flip : node._flip;
                if (flip && flip !== ej.datavisualization.Diagram.FlipDirection.None && node.flip !== node._flip) {
                    ctx.translate(rotation.x, rotation.y);
                    if (flip === ej.datavisualization.Diagram.FlipDirection.Horizontal) {
                        ctx.scale(-1, 1);
                    }
                    else if (flip === ej.datavisualization.Diagram.FlipDirection.Vertical) {
                        ctx.scale(1, -1);
                    }
                    else if (flip === ej.datavisualization.Diagram.FlipDirection.Both) {
                        ctx.scale(-1, -1);
                    }
                    ctx.translate(-rotation.x, -rotation.y);
                }
            for (var i = 0; i < text.childNodes.length; i++) {
                var child = text.childNodes[i];
                var text_x = x + child.x - labelBounds.x + bWidth / 2;
                var text_y = y + child.dy * i + ((label.fontSize * canvas._scaleY) * 0.8) + bWidth / 2;
                var width = ctx.measureText(child.text).width;
                if (labelWidth > width && i < text.childNodes.length - 1) {
                    var txt = child.text;
                    if (txt[txt.length - 1] == " ") { txt = txt.slice(0, txt.length - 1); } if (txt[0] == " ") { txt = txt.slice(1, txt.length); }
                    width = ctx.measureText(txt).width;
                    var words = txt.split(" ");
                    if (words.length > 1) {
                        var extra = (((labelWidth - width) / ctx.measureText(" ").width) / (words.length - 1));
                        extra = Math.round(extra);
                        var extText = "";
                        for (var k = 0; k < extra; k++) {
                            extText += " ";
                        }
                        child.text = txt.replace(" ", extText);
                    }
                }
                if (label.horizontalAlignment == "stretch") {
                    switch (label.textAlign) {
                        case "left":
                            child.x = offset.x - bounds.width / 2;
                            break;
                        case "center":
                            child.x = -bounds.width / 2;
                            break;
                        case "right":
                            child.x = -offset.x - bounds.width / 2;
                            break;
                    }
                }
                canvas.text({ text: child.text }, text_x - child.x, text_y, null, { fill: label.fontColor });
                if (label.textDecoration != "none")
                    this._renderTextDecoration(text_x - child.x, text_y, ctx.measureText(child.text).width, label, canvas);
            }
            ctx.restore();
        },

        _wrapText: function (node, text, label, canvas) {
            var str = label.text; var attr = null;
            if (label.rotateAngle != undefined) {
                if (canvas && canvas._diagram) {
                    var lane = canvas._diagram.nameTable[node.parent];
                    if (lane && lane.isLane && label.rotateAngle !== 0) {
                        var textBBox = ej.datavisualization.Diagram.Util.bounds(node);
                        var width = textBBox.width;
                        textBBox.width = textBBox.height;
                        textBBox.height = width;
                    }
                    else
                        var textBBox = ej.datavisualization.Diagram.Util.bounds(node);
                }
                else
                    var textBBox = ej.datavisualization.Diagram.Util.bounds(node);
            }
            else var textBBox = ej.datavisualization.Diagram.Util.bounds(node);
            textBBox.width *= canvas._scaleX;
            textBBox.height *= canvas._scaleY;
            textBBox.x *= canvas._scaleX;
            textBBox.y *= canvas._scaleY;
            var bbWidth, bbHeight;
            if (node.segments) {
                bbWidth = textBBox.width;
                bbHeight = textBBox.height;
            }
            else {
                bbWidth = textBBox.width - label.margin.left - label.margin.right;
                bbHeight = textBBox.height - label.margin.top - label.margin.bottom;
            }
            bbWidth -= 2 * (label.borderWidth ? label.borderWidth : 1);
            bbWidth = bbWidth < label.width ? label.width : bbWidth;
            var eachLine = str.split('\n');
            var x, y, tspan, j, string = "", childNodes, bounds, i;
            var ctx = canvas.document.getContext("2d");
            var wrap = label.wrapping == "wrapwithoverflow" ? true : false;
            for (j = 0; j < eachLine.length; j++) {
                var txt = "", spltWord;
                if (label.wrapping != "nowrap" && !label.textOverflow) {
                    var words = label.wrapping == "wrapwithoverflow" ? eachLine[j].split(" ") : eachLine[j];
                    for (i = 0; i < words.length; i++) {
                        var newword = words[i];
                        if (newword.indexOf('-') >= 0 && wrap) {
                            txt = this._splitHyphenWord(txt, newword, text, label, ctx, bbWidth);
                            if (i == words.length - 1) {
                                text.childNodes[text.childNodes.length] = { text: txt };
                                txt = "";
                            }
                            else {
                                if (ctx.measureText(txt + " " + (words[i + 1] || "")).width > bbWidth) {
                                    text.childNodes[text.childNodes.length] = { text: txt };
                                    txt = "";
                                }
                            }
                        }
                        else {
                            txt += ((txt && wrap) ? " " : "") + words[i];
                            bounds = ctx.measureText(txt).width;
                            if (bounds >= bbWidth) {
                                text.childNodes[text.childNodes.length] = { text: txt };
                                txt = "";
                            }
                            else {
                                if (wrap || (label && label.wrapping === "wrap")) {
                                    var newText = txt;
                                    if (i < words.length - 1) {
                                        if (words[i + 1].indexOf("-") >= 0 && wrap) {
                                            txt = this._splitHyphenWord(txt, words[i + 1], text, label, ctx, bbWidth);
                                            if (ctx.measureText(txt + " " + (words[i + 1] || "")).width > bbWidth) {
                                                text.childNodes[text.childNodes.length] = { text: txt };
                                                txt = "";
                                            }
                                            i++;
                                        }
                                        else {
                                            newText += (wrap ? " " : "") + (words[i + 1] || "");
                                            if (ctx.measureText(newText).width > bbWidth) {
                                                text.childNodes[text.childNodes.length] = { text: txt };
                                                txt = "";
                                            }
                                        }
                                    }
                                }
                                if (i == words.length - 1) {
                                    text.childNodes[text.childNodes.length] = { text: txt };
                                    txt = "";
                                }
                            }
                        }
                    }
                }
                else {
                    if (label.textOverflow) {
                        var width;
                        var laneObject = (diagram && diagram.getNode) ? diagram.getNode(node.parent) : null;
                        if ((node.isPhase && node.orientation === "vertical") || (laneObject && laneObject.isLane && laneObject.orientation === "horizontal" && node._isHeader)) {
                            width = node.height;
                        }
                        else {
                            width = node.width;
                        }
                        txt += this._getOverflowTypeText(ctx, eachLine[j], width, label.overflowType);
                    }
                    else {
                        txt += eachLine[j];                      
                    }
                    text.childNodes[text.childNodes.length] = { text: txt };
                }
            }
            return this._wrapTextAlign(text, text.childNodes, (label.fontSize * canvas._scaleY), label.textAlign, ctx, node, label, canvas);
        },

        _getOverflowTypeText: function (c, str, maxWidth, overflowType) {
            var width = c.measureText(str).width;
            var ellipsis = '…';
            var ellipsisWidth = c.measureText(ellipsis).width;
            if (width <= maxWidth) {
                return str;
            } else {
                var len = str.length;
                var cWidth = overflowType === "ellipsis" ? maxWidth - ellipsisWidth : maxWidth
                while (width >= cWidth && len-- > 0) {
                    str = str.substring(0, len);
                    width = c.measureText(str).width;
                }
                return overflowType === "ellipsis" ? str + ellipsis: str;
            }
        },

        _splitHyphenWord: function (txt, hyphenWord, text, label, ctx, bbWidth) {
            var wrap = label.wrapping == "wrapwithoverflow" ? true : false;
            var newText = txt ? txt + " " : "";
            var splitWords = hyphenWord.split("-");
            for (var i = 0; i < splitWords.length; i++) {
                newText += splitWords[i];
                var bounds = ctx.measureText(newText).width;
                if (bounds >= bbWidth) {
                    text.childNodes[text.childNodes.length] = { text: txt };
                    if (i < splitWords.length - 1) {
                        newText = splitWords[i] + "-";
                    }
                    else
                        newText = splitWords[i]
                    txt = newText;
                }
                else {
                    if (wrap || (label && label.wrapping === "wrap")) {
                        txt = newText;
                        if (i < splitWords.length - 1) {
                            newText += "-";
                            if (ctx.measureText(newText).width > bbWidth) {
                                text.childNodes[text.childNodes.length] = { text: txt };
                                newText = "-";
                            }
                            else {
                                txt = newText;
                            }
                        }
                    }
                }
            }
            return txt;
        },

        _wrapTextAlign: function (text, childNodes, height, textAlign, ctx, node, label, canvas) {
            var width, bounds;
            var nodeBounds = ej.datavisualization.Diagram.Util.bounds(node);
            nodeBounds.width *= canvas._scaleX;
            nodeBounds.height *= canvas._scaleY;
            nodeBounds.x *= canvas._scaleX;
            nodeBounds.y *= canvas._scaleY;
            for (var i = 0; i < childNodes.length; i++) {
                var x = ctx.measureText(childNodes[i].text).width;
                width = x;
                if (label.horizontalAlignment == "stretch") {
                    width = nodeBounds.width;
                    x = -width / 2;
                }
                else
                    switch (textAlign) {
                        case "left":
                            x = 0;
                            break;
                        case "center":
                            x = -x / 2;
                            break;
                        case "right":
                            x = -x;
                            break;
                        case "justify":
                            x = childNodes.length > 1 ? 0 : -x / 2;
                            break;
                    }
                childNodes[i].x = Number(x);
                childNodes[i].dy = height;
                if (!bounds) {
                    bounds = {
                        x: x,
                        width: width
                    };
                } else {
                    bounds.x = Math.min(bounds.x, x);
                    bounds.width = Math.max(bounds.width, width);
                }
            }
            return bounds;
        },

        _renderTextDecoration: function (x, y, width, label, canvas) {
            var ctx = canvas.document.getContext("2d");
            ctx.save();
            ctx.strokeStyle = label.fontColor;
            ctx.lineWidth = 1;
            switch (ctx.textAlign) {
                case "center":
                    x -= (width / 2); break;
                case "right":
                    x -= width; break;
            }
            y += 2;
            switch (label.textDecoration) {
                case "overline":
                    y -= (label.fontSize * canvas._scaleY); break;
                case "line-through":
                    y -= (label.fontSize / 2 * canvas._scaleY); break;
            }
            var stPt = { x: x, y: y };
            var edPt = { x: x + width, y: y };
            canvas.line(stPt, edPt, null);
            ctx.restore();
        },

        _renderGradient: function (node, ctx, x, y) {
            if (node.gradient) {
                var max, min;
                for (var i = 0; i < node.gradient.stops.length; i++) {
                    max = !max ? node.gradient.stops[i].offset : Math.max(max, node.gradient.stops[i].offset);
                    min = !min ? node.gradient.stops[i].offset : Math.min(min, node.gradient.stops[i].offset);
                }
                if (node.gradient.type == "linear") {
                    var grd = ctx.createLinearGradient(x + node.gradient.x1, y + node.gradient.y1, x + node.gradient.x2, y + node.gradient.y2);
                    for (var i = 0; i < node.gradient.stops.length; i++) {
                        var stop = node.gradient.stops[i];
                        var offset = min < 0 ? (max + stop.offset) / (2 * max) : stop.offset / max;
                        grd.addColorStop(offset, stop.color);
                    }
                }
                else if (node.gradient.type == "radial") {
                    var grd = ctx.createRadialGradient(x + node.gradient.fx, y + node.gradient.fy, 0, x + node.gradient.cx, y + node.gradient.cy, node.gradient.r);
                    for (var i = 0; i < node.gradient.stops.length; i++) {
                        var stop = node.gradient.stops[i];
                        var offset = min < 0 ? (max + stop.offset) / (2 * max) : stop.offset / max;
                        grd.addColorStop(offset, stop.color);
                    }
                }
                ctx.fillStyle = grd;
            }
        },

        _renderDecorators: function (connector, canvas) {
            var startPoint;
            var endPoint;
            var diagram = canvas._diagram;
            if (connector.targetDecorator && connector.targetDecorator.shape) {
                var segment = connector.segments[connector.segments.length - 1];
                startPoint = segment.points[segment.points.length - 2];
                endPoint = connector.targetPoint;
                if (segment.type == "bezier") {
                    startPoint = segment._point2;
                }
                if (connector.targetNode && diagram) {
                    var targetNode = diagram._findNode(connector.targetNode);
                    if (targetNode && targetNode.borderColor != "none")
                        endPoint = ej.datavisualization.Diagram.Util._adjustPoint(endPoint, startPoint, true, targetNode.borderWidth / 2);
                }
                this._renderDecorator(connector.name + "_targetDecorator", endPoint,
                    startPoint, connector.targetDecorator, canvas);
            }
            if (connector.sourceDecorator && connector.sourceDecorator.shape) {
                var segment = connector.segments[0];
                startPoint = connector.sourcePoint;
                endPoint = segment.points[1];
                if (segment.type == "bezier") {
                    endPoint = segment._point1;
                }
                if (connector.sourceNode && diagram) {
                    var sourceNode = diagram._findNode(connector.sourceNode);
                    if (sourceNode && sourceNode.borderColor != "none")
                        startPoint = ej.datavisualization.Diagram.Util._adjustPoint(startPoint, endPoint, true, sourceNode.borderWidth / 2);
                }
                this._renderDecorator(connector.name + "_sourceDecorator", startPoint,
                    endPoint, connector.sourceDecorator, canvas);
            }
        },

        _renderDecorator: function (name, point1, point2, decorator, canvas) {
            var shape;
            var attr;
            var d;
            var scalePoint1 = this._scalePointforStretch(point1, canvas);
            var scalePoint2 = this._scalePointforStretch(point2, canvas);
            var size = new ej.datavisualization.Diagram.Size(Number(decorator.width * canvas._scaleY), Number(decorator.height * canvas._scaleY));
            var ctx = canvas.document.getContext("2d");
            ctx.fillStyle = decorator.fillColor;
            ctx.strokeStyle = decorator.borderColor == "none" ? "transparent" : decorator.borderColor;
            ctx.lineWidth = decorator.borderWidth;
            var angle = ej.datavisualization.Diagram.Geometry.findAngle(scalePoint1, scalePoint2);
            var rotation = { angle: angle, x: scalePoint1.x, y: scalePoint1.y };
            switch (decorator.shape) {
                case "arrow":
                    canvas.arrow(scalePoint1, rotation, size);
                    break;
                case "openarrow":
                    canvas.arrow(scalePoint1, rotation, size, true);
                    break;
                case "circle":
                    var rx = size.width / 2;
                    var ry = size.height / 2;
                    canvas.ellipse(scalePoint1.x + size.width / 2, scalePoint1.y, rx, ry, rotation);
                    break;
                case "diamond":
                    canvas.diamond(scalePoint1, rotation, size);
                    break;
                case "path":
                    canvas.path(decorator._absolutePath, 0, 0, size.width, size.height, rotation);
                    break;
            }
            return shape;
        },

        _updatePolygonPoints: function (node, canvas) {
            var points = [];
            if (node.points) {
                var nodeWidth = node.width || node._width || 0;
                var nodeHeight = node.height || node._height || 0;
                nodeWidth *= canvas._scaleX;
                nodeHeight *= canvas._scaleY;
                for (var i = 0; i < node.points.length; i++) {
                    var point1 = node.points[i];
                    points.push({ x: point1.x, y: point1.y });
                }
                if (points.length) {
                    this._scalePoints(points, node, canvas);
                    var bounds = ej.datavisualization.Diagram.Geometry.rect(points);
                    var x = (node.offsetX * canvas._scaleX) - nodeWidth * node.pivot.x - bounds.x;
                    var y = (node.offsetY * canvas._scaleY) - nodeHeight * node.pivot.y - bounds.y;
                    for (var i = 0, len = points.length; i < len; ++i) {
                        var point = ej.datavisualization.Diagram.Geometry.translate(points[i], x, y);
                        points[i] = point;
                    }
                }
            }
            return points;
        },

        _scalePoints: function (points, node, canvas) {
            var bounds = ej.datavisualization.Diagram.Geometry.rect(points);
            if (bounds.width > 0 && bounds.height > 0) {
                var nodeWidth = node.width || node._width || 0;
                var nodeHeight = node.height || node._height || 0;
                nodeWidth *= canvas._scaleX;
                nodeHeight *= canvas._scaleY;
                var scaleX = nodeWidth / bounds.width;
                var scaleY = nodeHeight / bounds.height;
                for (var i = 0, len = points.length; i < len; ++i) {
                    points[i].x = points[i].x * scaleX;
                    points[i].y = points[i].y * scaleY;
                }
            }
        },

        updateNode: function (model, canvas) {
            this.refreshCanvas(model, canvas);
        },

        updateConnector: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateGroup: function (model, canvas) { this.refreshCanvas(model, canvas); },

        refreshCanvas: function (model, canvas) {

            var ctx = canvas.document.getContext("2d");
            ctx.save();
            if (view.scale) {
                ctx.scale(1 / view.scale.x, 1 / view.scale.y);
            }
            var bounds = { x: canvas.document.offsetLeft, y: canvas.document.offsetTop, width: canvas.document.offsetWidth, height: canvas.document.offsetHeight };
            ctx.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
            if (view.scale) {
                ctx.scale(view.scale.x, view.scale.y);
            }
            ctx.restore();
            for (var i = 0; i < model.nodes.length; i++) {
                if (model.nodes[i]._type === "node")
                    this.renderNode(model.nodes[i], canvas);
                else if (model.nodes[i]._type === "group")
                    this.renderGroup(model.nodes[i], canvas);
            }
            for (var i = 0; i < model.connectors.length; i++) {
                this.renderConnector(model.connectors[i], canvas);
            }
        },

        updateViewport: function (diagram) {
            //diagram._scroller._updateViewPort();
            //diagram.model.pageSettings._updatePageSize(diagram, true);
        },

        addNodeLabel: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateLabel: function (model, canvas) { this.refreshCanvas(model, canvas); },

        setNodeShape: function (model, canvas) { this.refreshCanvas(model, canvas); },

        setLine: function (model, canvas) { this.refreshCanvas(model, canvas); },

        renderDecorators: function (model, canvas) { this.refreshCanvas(model, canvas); },

        clearDecorators: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateTargetDecoratorStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateSourceDecoratorStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        _updateNodeStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateLabelStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateConnectorStyle: function (model, canvas) { this.refreshCanvas(model, canvas); },

        updateTextBlock: function (model, label, canvas) { this.refreshCanvas(model, canvas); },

        removeChild: function (element, view, diagram) {
            this.refreshCanvas(model, canvas);
        }
    };
    //#endregion

})(jQuery, Syncfusion);;

});